var Hs=Object.defineProperty;var _s=Yr=>{throw TypeError(Yr)};var Ws=(Yr,ze,Gr)=>ze in Yr?Hs(Yr,ze,{enumerable:!0,configurable:!0,writable:!0,value:Gr}):Yr[ze]=Gr;var Ci=(Yr,ze,Gr)=>Ws(Yr,typeof ze!="symbol"?ze+"":ze,Gr),xs=(Yr,ze,Gr)=>ze.has(Yr)||_s("Cannot "+Gr);var is=(Yr,ze,Gr)=>(xs(Yr,ze,"read from private field"),Gr?Gr.call(Yr):ze.get(Yr)),as=(Yr,ze,Gr)=>ze.has(Yr)?_s("Cannot add the same private member more than once"):ze instanceof WeakSet?ze.add(Yr):ze.set(Yr,Gr),ls=(Yr,ze,Gr,Wr)=>(xs(Yr,ze,"write to private field"),Wr?Wr.call(Yr,Gr):ze.set(Yr,Gr),Gr);function _mergeNamespaces(Yr,ze){for(var Gr=0;Gr<ze.length;Gr++){const Wr=ze[Gr];if(typeof Wr!="string"&&!Array.isArray(Wr)){for(const Kr in Wr)if(Kr!=="default"&&!(Kr in Yr)){const Zr=Object.getOwnPropertyDescriptor(Wr,Kr);Zr&&Object.defineProperty(Yr,Kr,Zr.get?Zr:{enumerable:!0,get:()=>Wr[Kr]})}}}return Object.freeze(Object.defineProperty(Yr,Symbol.toStringTag,{value:"Module"}))}(function(){const ze=document.createElement("link").relList;if(ze&&ze.supports&&ze.supports("modulepreload"))return;for(const Kr of document.querySelectorAll('link[rel="modulepreload"]'))Wr(Kr);new MutationObserver(Kr=>{for(const Zr of Kr)if(Zr.type==="childList")for(const Qr of Zr.addedNodes)Qr.tagName==="LINK"&&Qr.rel==="modulepreload"&&Wr(Qr)}).observe(document,{childList:!0,subtree:!0});function Gr(Kr){const Zr={};return Kr.integrity&&(Zr.integrity=Kr.integrity),Kr.referrerPolicy&&(Zr.referrerPolicy=Kr.referrerPolicy),Kr.crossOrigin==="use-credentials"?Zr.credentials="include":Kr.crossOrigin==="anonymous"?Zr.credentials="omit":Zr.credentials="same-origin",Zr}function Wr(Kr){if(Kr.ep)return;Kr.ep=!0;const Zr=Gr(Kr);fetch(Kr.href,Zr)}})();const scriptRel="modulepreload",assetsURL=function(Yr){return"/"+Yr},seen={},__vitePreload=function(ze,Gr,Wr){let Kr=Promise.resolve();if(Gr&&Gr.length>0){let Qr=function(ti){return Promise.all(ti.map(ri=>Promise.resolve(ri).then(ii=>({status:"fulfilled",value:ii}),ii=>({status:"rejected",reason:ii}))))};document.getElementsByTagName("link");const Jr=document.querySelector("meta[property=csp-nonce]"),ei=(Jr==null?void 0:Jr.nonce)||(Jr==null?void 0:Jr.getAttribute("nonce"));Kr=Qr(Gr.map(ti=>{if(ti=assetsURL(ti),ti in seen)return;seen[ti]=!0;const ri=ti.endsWith(".css"),ii=ri?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${ti}"]${ii}`))return;const si=document.createElement("link");if(si.rel=ri?"stylesheet":scriptRel,ri||(si.as="script"),si.crossOrigin="",si.href=ti,ei&&si.setAttribute("nonce",ei),document.head.appendChild(si),ri)return new Promise((ni,oi)=>{si.addEventListener("load",ni),si.addEventListener("error",()=>oi(new Error(`Unable to preload CSS for ${ti}`)))})}))}function Zr(Qr){const Jr=new Event("vite:preloadError",{cancelable:!0});if(Jr.payload=Qr,window.dispatchEvent(Jr),!Jr.defaultPrevented)throw Qr}return Kr.then(Qr=>{for(const Jr of Qr||[])Jr.status==="rejected"&&Zr(Jr.reason);return ze().catch(Zr)})};var ExtensionType=(Yr=>(Yr.Application="application",Yr.WebGLPipes="webgl-pipes",Yr.WebGLPipesAdaptor="webgl-pipes-adaptor",Yr.WebGLSystem="webgl-system",Yr.WebGPUPipes="webgpu-pipes",Yr.WebGPUPipesAdaptor="webgpu-pipes-adaptor",Yr.WebGPUSystem="webgpu-system",Yr.CanvasSystem="canvas-system",Yr.CanvasPipesAdaptor="canvas-pipes-adaptor",Yr.CanvasPipes="canvas-pipes",Yr.Asset="asset",Yr.LoadParser="load-parser",Yr.ResolveParser="resolve-parser",Yr.CacheParser="cache-parser",Yr.DetectionParser="detection-parser",Yr.MaskEffect="mask-effect",Yr.BlendMode="blend-mode",Yr.TextureSource="texture-source",Yr.Environment="environment",Yr.ShapeBuilder="shape-builder",Yr.Batcher="batcher",Yr))(ExtensionType||{});const normalizeExtension=Yr=>{if(typeof Yr=="function"||typeof Yr=="object"&&Yr.extension){if(!Yr.extension)throw new Error("Extension class must have an extension object");Yr={...typeof Yr.extension!="object"?{type:Yr.extension}:Yr.extension,ref:Yr}}if(typeof Yr=="object")Yr={...Yr};else throw new Error("Invalid extension type");return typeof Yr.type=="string"&&(Yr.type=[Yr.type]),Yr},normalizeExtensionPriority=(Yr,ze)=>normalizeExtension(Yr).priority??ze,extensions={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...Yr){return Yr.map(normalizeExtension).forEach(ze=>{ze.type.forEach(Gr=>{var Wr,Kr;return(Kr=(Wr=this._removeHandlers)[Gr])==null?void 0:Kr.call(Wr,ze)})}),this},add(...Yr){return Yr.map(normalizeExtension).forEach(ze=>{ze.type.forEach(Gr=>{var Zr,Qr;const Wr=this._addHandlers,Kr=this._queue;Wr[Gr]?(Qr=Wr[Gr])==null||Qr.call(Wr,ze):(Kr[Gr]=Kr[Gr]||[],(Zr=Kr[Gr])==null||Zr.push(ze))})}),this},handle(Yr,ze,Gr){var Qr;const Wr=this._addHandlers,Kr=this._removeHandlers;if(Wr[Yr]||Kr[Yr])throw new Error(`Extension type ${Yr} already has a handler`);Wr[Yr]=ze,Kr[Yr]=Gr;const Zr=this._queue;return Zr[Yr]&&((Qr=Zr[Yr])==null||Qr.forEach(Jr=>ze(Jr)),delete Zr[Yr]),this},handleByMap(Yr,ze){return this.handle(Yr,Gr=>{Gr.name&&(ze[Gr.name]=Gr.ref)},Gr=>{Gr.name&&delete ze[Gr.name]})},handleByNamedList(Yr,ze,Gr=-1){return this.handle(Yr,Wr=>{ze.findIndex(Zr=>Zr.name===Wr.name)>=0||(ze.push({name:Wr.name,value:Wr.ref}),ze.sort((Zr,Qr)=>normalizeExtensionPriority(Qr.value,Gr)-normalizeExtensionPriority(Zr.value,Gr)))},Wr=>{const Kr=ze.findIndex(Zr=>Zr.name===Wr.name);Kr!==-1&&ze.splice(Kr,1)})},handleByList(Yr,ze,Gr=-1){return this.handle(Yr,Wr=>{ze.includes(Wr.ref)||(ze.push(Wr.ref),ze.sort((Kr,Zr)=>normalizeExtensionPriority(Zr,Gr)-normalizeExtensionPriority(Kr,Gr)))},Wr=>{const Kr=ze.indexOf(Wr.ref);Kr!==-1&&ze.splice(Kr,1)})},mixin(Yr,...ze){for(const Gr of ze)Object.defineProperties(Yr.prototype,Object.getOwnPropertyDescriptors(Gr))}},browserExt={extension:{type:ExtensionType.Environment,name:"browser",priority:-1},test:()=>!0,load:async()=>{await __vitePreload(()=>Promise.resolve().then(()=>browserAll),void 0)}},webworkerExt={extension:{type:ExtensionType.Environment,name:"webworker",priority:0},test:()=>typeof self<"u"&&self.WorkerGlobalScope!==void 0,load:async()=>{await __vitePreload(()=>Promise.resolve().then(()=>webworkerAll),void 0)}};class ObservablePoint{constructor(ze,Gr,Wr){this._x=Gr||0,this._y=Wr||0,this._observer=ze}clone(ze){return new ObservablePoint(ze??this._observer,this._x,this._y)}set(ze=0,Gr=ze){return(this._x!==ze||this._y!==Gr)&&(this._x=ze,this._y=Gr,this._observer._onUpdate(this)),this}copyFrom(ze){return(this._x!==ze.x||this._y!==ze.y)&&(this._x=ze.x,this._y=ze.y,this._observer._onUpdate(this)),this}copyTo(ze){return ze.set(this._x,this._y),ze}equals(ze){return ze.x===this._x&&ze.y===this._y}toString(){return`[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`}get x(){return this._x}set x(ze){this._x!==ze&&(this._x=ze,this._observer._onUpdate(this))}get y(){return this._y}set y(ze){this._y!==ze&&(this._y=ze,this._observer._onUpdate(this))}}function getDefaultExportFromCjs(Yr){return Yr&&Yr.__esModule&&Object.prototype.hasOwnProperty.call(Yr,"default")?Yr.default:Yr}var eventemitter3={exports:{}},hasRequiredEventemitter3;function requireEventemitter3(){return hasRequiredEventemitter3||(hasRequiredEventemitter3=1,function(Yr){var ze=Object.prototype.hasOwnProperty,Gr="~";function Wr(){}Object.create&&(Wr.prototype=Object.create(null),new Wr().__proto__||(Gr=!1));function Kr(ei,ti,ri){this.fn=ei,this.context=ti,this.once=ri||!1}function Zr(ei,ti,ri,ii,si){if(typeof ri!="function")throw new TypeError("The listener must be a function");var ni=new Kr(ri,ii||ei,si),oi=Gr?Gr+ti:ti;return ei._events[oi]?ei._events[oi].fn?ei._events[oi]=[ei._events[oi],ni]:ei._events[oi].push(ni):(ei._events[oi]=ni,ei._eventsCount++),ei}function Qr(ei,ti){--ei._eventsCount===0?ei._events=new Wr:delete ei._events[ti]}function Jr(){this._events=new Wr,this._eventsCount=0}Jr.prototype.eventNames=function(){var ti=[],ri,ii;if(this._eventsCount===0)return ti;for(ii in ri=this._events)ze.call(ri,ii)&&ti.push(Gr?ii.slice(1):ii);return Object.getOwnPropertySymbols?ti.concat(Object.getOwnPropertySymbols(ri)):ti},Jr.prototype.listeners=function(ti){var ri=Gr?Gr+ti:ti,ii=this._events[ri];if(!ii)return[];if(ii.fn)return[ii.fn];for(var si=0,ni=ii.length,oi=new Array(ni);si<ni;si++)oi[si]=ii[si].fn;return oi},Jr.prototype.listenerCount=function(ti){var ri=Gr?Gr+ti:ti,ii=this._events[ri];return ii?ii.fn?1:ii.length:0},Jr.prototype.emit=function(ti,ri,ii,si,ni,oi){var li=Gr?Gr+ti:ti;if(!this._events[li])return!1;var ai=this._events[li],hi=arguments.length,fi,pi;if(ai.fn){switch(ai.once&&this.removeListener(ti,ai.fn,void 0,!0),hi){case 1:return ai.fn.call(ai.context),!0;case 2:return ai.fn.call(ai.context,ri),!0;case 3:return ai.fn.call(ai.context,ri,ii),!0;case 4:return ai.fn.call(ai.context,ri,ii,si),!0;case 5:return ai.fn.call(ai.context,ri,ii,si,ni),!0;case 6:return ai.fn.call(ai.context,ri,ii,si,ni,oi),!0}for(pi=1,fi=new Array(hi-1);pi<hi;pi++)fi[pi-1]=arguments[pi];ai.fn.apply(ai.context,fi)}else{var mi=ai.length,Ti;for(pi=0;pi<mi;pi++)switch(ai[pi].once&&this.removeListener(ti,ai[pi].fn,void 0,!0),hi){case 1:ai[pi].fn.call(ai[pi].context);break;case 2:ai[pi].fn.call(ai[pi].context,ri);break;case 3:ai[pi].fn.call(ai[pi].context,ri,ii);break;case 4:ai[pi].fn.call(ai[pi].context,ri,ii,si);break;default:if(!fi)for(Ti=1,fi=new Array(hi-1);Ti<hi;Ti++)fi[Ti-1]=arguments[Ti];ai[pi].fn.apply(ai[pi].context,fi)}}return!0},Jr.prototype.on=function(ti,ri,ii){return Zr(this,ti,ri,ii,!1)},Jr.prototype.once=function(ti,ri,ii){return Zr(this,ti,ri,ii,!0)},Jr.prototype.removeListener=function(ti,ri,ii,si){var ni=Gr?Gr+ti:ti;if(!this._events[ni])return this;if(!ri)return Qr(this,ni),this;var oi=this._events[ni];if(oi.fn)oi.fn===ri&&(!si||oi.once)&&(!ii||oi.context===ii)&&Qr(this,ni);else{for(var li=0,ai=[],hi=oi.length;li<hi;li++)(oi[li].fn!==ri||si&&!oi[li].once||ii&&oi[li].context!==ii)&&ai.push(oi[li]);ai.length?this._events[ni]=ai.length===1?ai[0]:ai:Qr(this,ni)}return this},Jr.prototype.removeAllListeners=function(ti){var ri;return ti?(ri=Gr?Gr+ti:ti,this._events[ri]&&Qr(this,ri)):(this._events=new Wr,this._eventsCount=0),this},Jr.prototype.off=Jr.prototype.removeListener,Jr.prototype.addListener=Jr.prototype.on,Jr.prefixed=Gr,Jr.EventEmitter=Jr,Yr.exports=Jr}(eventemitter3)),eventemitter3.exports}var eventemitter3Exports=requireEventemitter3();const EventEmitter=getDefaultExportFromCjs(eventemitter3Exports),PI_2=Math.PI*2,RAD_TO_DEG=180/Math.PI,DEG_TO_RAD=Math.PI/180;let Point$1=class ys{constructor(ze=0,Gr=0){this.x=0,this.y=0,this.x=ze,this.y=Gr}clone(){return new ys(this.x,this.y)}copyFrom(ze){return this.set(ze.x,ze.y),this}copyTo(ze){return ze.set(this.x,this.y),ze}equals(ze){return ze.x===this.x&&ze.y===this.y}set(ze=0,Gr=ze){return this.x=ze,this.y=Gr,this}toString(){return`[pixi.js/math:Point x=${this.x} y=${this.y}]`}static get shared(){return tempPoint.x=0,tempPoint.y=0,tempPoint}};const tempPoint=new Point$1;class Matrix{constructor(ze=1,Gr=0,Wr=0,Kr=1,Zr=0,Qr=0){this.array=null,this.a=ze,this.b=Gr,this.c=Wr,this.d=Kr,this.tx=Zr,this.ty=Qr}fromArray(ze){this.a=ze[0],this.b=ze[1],this.c=ze[3],this.d=ze[4],this.tx=ze[2],this.ty=ze[5]}set(ze,Gr,Wr,Kr,Zr,Qr){return this.a=ze,this.b=Gr,this.c=Wr,this.d=Kr,this.tx=Zr,this.ty=Qr,this}toArray(ze,Gr){this.array||(this.array=new Float32Array(9));const Wr=Gr||this.array;return ze?(Wr[0]=this.a,Wr[1]=this.b,Wr[2]=0,Wr[3]=this.c,Wr[4]=this.d,Wr[5]=0,Wr[6]=this.tx,Wr[7]=this.ty,Wr[8]=1):(Wr[0]=this.a,Wr[1]=this.c,Wr[2]=this.tx,Wr[3]=this.b,Wr[4]=this.d,Wr[5]=this.ty,Wr[6]=0,Wr[7]=0,Wr[8]=1),Wr}apply(ze,Gr){Gr=Gr||new Point$1;const Wr=ze.x,Kr=ze.y;return Gr.x=this.a*Wr+this.c*Kr+this.tx,Gr.y=this.b*Wr+this.d*Kr+this.ty,Gr}applyInverse(ze,Gr){Gr=Gr||new Point$1;const Wr=this.a,Kr=this.b,Zr=this.c,Qr=this.d,Jr=this.tx,ei=this.ty,ti=1/(Wr*Qr+Zr*-Kr),ri=ze.x,ii=ze.y;return Gr.x=Qr*ti*ri+-Zr*ti*ii+(ei*Zr-Jr*Qr)*ti,Gr.y=Wr*ti*ii+-Kr*ti*ri+(-ei*Wr+Jr*Kr)*ti,Gr}translate(ze,Gr){return this.tx+=ze,this.ty+=Gr,this}scale(ze,Gr){return this.a*=ze,this.d*=Gr,this.c*=ze,this.b*=Gr,this.tx*=ze,this.ty*=Gr,this}rotate(ze){const Gr=Math.cos(ze),Wr=Math.sin(ze),Kr=this.a,Zr=this.c,Qr=this.tx;return this.a=Kr*Gr-this.b*Wr,this.b=Kr*Wr+this.b*Gr,this.c=Zr*Gr-this.d*Wr,this.d=Zr*Wr+this.d*Gr,this.tx=Qr*Gr-this.ty*Wr,this.ty=Qr*Wr+this.ty*Gr,this}append(ze){const Gr=this.a,Wr=this.b,Kr=this.c,Zr=this.d;return this.a=ze.a*Gr+ze.b*Kr,this.b=ze.a*Wr+ze.b*Zr,this.c=ze.c*Gr+ze.d*Kr,this.d=ze.c*Wr+ze.d*Zr,this.tx=ze.tx*Gr+ze.ty*Kr+this.tx,this.ty=ze.tx*Wr+ze.ty*Zr+this.ty,this}appendFrom(ze,Gr){const Wr=ze.a,Kr=ze.b,Zr=ze.c,Qr=ze.d,Jr=ze.tx,ei=ze.ty,ti=Gr.a,ri=Gr.b,ii=Gr.c,si=Gr.d;return this.a=Wr*ti+Kr*ii,this.b=Wr*ri+Kr*si,this.c=Zr*ti+Qr*ii,this.d=Zr*ri+Qr*si,this.tx=Jr*ti+ei*ii+Gr.tx,this.ty=Jr*ri+ei*si+Gr.ty,this}setTransform(ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti){return this.a=Math.cos(Jr+ti)*Zr,this.b=Math.sin(Jr+ti)*Zr,this.c=-Math.sin(Jr-ei)*Qr,this.d=Math.cos(Jr-ei)*Qr,this.tx=ze-(Wr*this.a+Kr*this.c),this.ty=Gr-(Wr*this.b+Kr*this.d),this}prepend(ze){const Gr=this.tx;if(ze.a!==1||ze.b!==0||ze.c!==0||ze.d!==1){const Wr=this.a,Kr=this.c;this.a=Wr*ze.a+this.b*ze.c,this.b=Wr*ze.b+this.b*ze.d,this.c=Kr*ze.a+this.d*ze.c,this.d=Kr*ze.b+this.d*ze.d}return this.tx=Gr*ze.a+this.ty*ze.c+ze.tx,this.ty=Gr*ze.b+this.ty*ze.d+ze.ty,this}decompose(ze){const Gr=this.a,Wr=this.b,Kr=this.c,Zr=this.d,Qr=ze.pivot,Jr=-Math.atan2(-Kr,Zr),ei=Math.atan2(Wr,Gr),ti=Math.abs(Jr+ei);return ti<1e-5||Math.abs(PI_2-ti)<1e-5?(ze.rotation=ei,ze.skew.x=ze.skew.y=0):(ze.rotation=0,ze.skew.x=Jr,ze.skew.y=ei),ze.scale.x=Math.sqrt(Gr*Gr+Wr*Wr),ze.scale.y=Math.sqrt(Kr*Kr+Zr*Zr),ze.position.x=this.tx+(Qr.x*Gr+Qr.y*Kr),ze.position.y=this.ty+(Qr.x*Wr+Qr.y*Zr),ze}invert(){const ze=this.a,Gr=this.b,Wr=this.c,Kr=this.d,Zr=this.tx,Qr=ze*Kr-Gr*Wr;return this.a=Kr/Qr,this.b=-Gr/Qr,this.c=-Wr/Qr,this.d=ze/Qr,this.tx=(Wr*this.ty-Kr*Zr)/Qr,this.ty=-(ze*this.ty-Gr*Zr)/Qr,this}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.tx===0&&this.ty===0}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const ze=new Matrix;return ze.a=this.a,ze.b=this.b,ze.c=this.c,ze.d=this.d,ze.tx=this.tx,ze.ty=this.ty,ze}copyTo(ze){return ze.a=this.a,ze.b=this.b,ze.c=this.c,ze.d=this.d,ze.tx=this.tx,ze.ty=this.ty,ze}copyFrom(ze){return this.a=ze.a,this.b=ze.b,this.c=ze.c,this.d=ze.d,this.tx=ze.tx,this.ty=ze.ty,this}equals(ze){return ze.a===this.a&&ze.b===this.b&&ze.c===this.c&&ze.d===this.d&&ze.tx===this.tx&&ze.ty===this.ty}toString(){return`[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`}static get IDENTITY(){return identityMatrix$1.identity()}static get shared(){return tempMatrix$5.identity()}}const tempMatrix$5=new Matrix,identityMatrix$1=new Matrix,ux=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],uy=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],vx=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],vy=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],rotationCayley=[],rotationMatrices=[],signum=Math.sign;function init(){for(let Yr=0;Yr<16;Yr++){const ze=[];rotationCayley.push(ze);for(let Gr=0;Gr<16;Gr++){const Wr=signum(ux[Yr]*ux[Gr]+vx[Yr]*uy[Gr]),Kr=signum(uy[Yr]*ux[Gr]+vy[Yr]*uy[Gr]),Zr=signum(ux[Yr]*vx[Gr]+vx[Yr]*vy[Gr]),Qr=signum(uy[Yr]*vx[Gr]+vy[Yr]*vy[Gr]);for(let Jr=0;Jr<16;Jr++)if(ux[Jr]===Wr&&uy[Jr]===Kr&&vx[Jr]===Zr&&vy[Jr]===Qr){ze.push(Jr);break}}}for(let Yr=0;Yr<16;Yr++){const ze=new Matrix;ze.set(ux[Yr],uy[Yr],vx[Yr],vy[Yr],0,0),rotationMatrices.push(ze)}}init();const groupD8={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:Yr=>ux[Yr],uY:Yr=>uy[Yr],vX:Yr=>vx[Yr],vY:Yr=>vy[Yr],inv:Yr=>Yr&8?Yr&15:-Yr&7,add:(Yr,ze)=>rotationCayley[Yr][ze],sub:(Yr,ze)=>rotationCayley[Yr][groupD8.inv(ze)],rotate180:Yr=>Yr^4,isVertical:Yr=>(Yr&3)===2,byDirection:(Yr,ze)=>Math.abs(Yr)*2<=Math.abs(ze)?ze>=0?groupD8.S:groupD8.N:Math.abs(ze)*2<=Math.abs(Yr)?Yr>0?groupD8.E:groupD8.W:ze>0?Yr>0?groupD8.SE:groupD8.SW:Yr>0?groupD8.NE:groupD8.NW,matrixAppendRotationInv:(Yr,ze,Gr=0,Wr=0)=>{const Kr=rotationMatrices[groupD8.inv(ze)];Kr.tx=Gr,Kr.ty=Wr,Yr.append(Kr)}},tempPoints=[new Point$1,new Point$1,new Point$1,new Point$1];class Rectangle{constructor(ze=0,Gr=0,Wr=0,Kr=0){this.type="rectangle",this.x=Number(ze),this.y=Number(Gr),this.width=Number(Wr),this.height=Number(Kr)}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}isEmpty(){return this.left===this.right||this.top===this.bottom}static get EMPTY(){return new Rectangle(0,0,0,0)}clone(){return new Rectangle(this.x,this.y,this.width,this.height)}copyFromBounds(ze){return this.x=ze.minX,this.y=ze.minY,this.width=ze.maxX-ze.minX,this.height=ze.maxY-ze.minY,this}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.width=ze.width,this.height=ze.height,this}copyTo(ze){return ze.copyFrom(this),ze}contains(ze,Gr){return this.width<=0||this.height<=0?!1:ze>=this.x&&ze<this.x+this.width&&Gr>=this.y&&Gr<this.y+this.height}strokeContains(ze,Gr,Wr,Kr=.5){const{width:Zr,height:Qr}=this;if(Zr<=0||Qr<=0)return!1;const Jr=this.x,ei=this.y,ti=Wr*(1-Kr),ri=Wr-ti,ii=Jr-ti,si=Jr+Zr+ti,ni=ei-ti,oi=ei+Qr+ti,li=Jr+ri,ai=Jr+Zr-ri,hi=ei+ri,fi=ei+Qr-ri;return ze>=ii&&ze<=si&&Gr>=ni&&Gr<=oi&&!(ze>li&&ze<ai&&Gr>hi&&Gr<fi)}intersects(ze,Gr){if(!Gr){const Ai=this.x<ze.x?ze.x:this.x;if((this.right>ze.right?ze.right:this.right)<=Ai)return!1;const Pi=this.y<ze.y?ze.y:this.y;return(this.bottom>ze.bottom?ze.bottom:this.bottom)>Pi}const Wr=this.left,Kr=this.right,Zr=this.top,Qr=this.bottom;if(Kr<=Wr||Qr<=Zr)return!1;const Jr=tempPoints[0].set(ze.left,ze.top),ei=tempPoints[1].set(ze.left,ze.bottom),ti=tempPoints[2].set(ze.right,ze.top),ri=tempPoints[3].set(ze.right,ze.bottom);if(ti.x<=Jr.x||ei.y<=Jr.y)return!1;const ii=Math.sign(Gr.a*Gr.d-Gr.b*Gr.c);if(ii===0||(Gr.apply(Jr,Jr),Gr.apply(ei,ei),Gr.apply(ti,ti),Gr.apply(ri,ri),Math.max(Jr.x,ei.x,ti.x,ri.x)<=Wr||Math.min(Jr.x,ei.x,ti.x,ri.x)>=Kr||Math.max(Jr.y,ei.y,ti.y,ri.y)<=Zr||Math.min(Jr.y,ei.y,ti.y,ri.y)>=Qr))return!1;const si=ii*(ei.y-Jr.y),ni=ii*(Jr.x-ei.x),oi=si*Wr+ni*Zr,li=si*Kr+ni*Zr,ai=si*Wr+ni*Qr,hi=si*Kr+ni*Qr;if(Math.max(oi,li,ai,hi)<=si*Jr.x+ni*Jr.y||Math.min(oi,li,ai,hi)>=si*ri.x+ni*ri.y)return!1;const fi=ii*(Jr.y-ti.y),pi=ii*(ti.x-Jr.x),mi=fi*Wr+pi*Zr,Ti=fi*Kr+pi*Zr,yi=fi*Wr+pi*Qr,_i=fi*Kr+pi*Qr;return!(Math.max(mi,Ti,yi,_i)<=fi*Jr.x+pi*Jr.y||Math.min(mi,Ti,yi,_i)>=fi*ri.x+pi*ri.y)}pad(ze=0,Gr=ze){return this.x-=ze,this.y-=Gr,this.width+=ze*2,this.height+=Gr*2,this}fit(ze){const Gr=Math.max(this.x,ze.x),Wr=Math.min(this.x+this.width,ze.x+ze.width),Kr=Math.max(this.y,ze.y),Zr=Math.min(this.y+this.height,ze.y+ze.height);return this.x=Gr,this.width=Math.max(Wr-Gr,0),this.y=Kr,this.height=Math.max(Zr-Kr,0),this}ceil(ze=1,Gr=.001){const Wr=Math.ceil((this.x+this.width-Gr)*ze)/ze,Kr=Math.ceil((this.y+this.height-Gr)*ze)/ze;return this.x=Math.floor((this.x+Gr)*ze)/ze,this.y=Math.floor((this.y+Gr)*ze)/ze,this.width=Wr-this.x,this.height=Kr-this.y,this}enlarge(ze){const Gr=Math.min(this.x,ze.x),Wr=Math.max(this.x+this.width,ze.x+ze.width),Kr=Math.min(this.y,ze.y),Zr=Math.max(this.y+this.height,ze.y+ze.height);return this.x=Gr,this.width=Wr-Gr,this.y=Kr,this.height=Zr-Kr,this}getBounds(ze){return ze||(ze=new Rectangle),ze.copyFrom(this),ze}containsRect(ze){if(this.width<=0||this.height<=0)return!1;const Gr=ze.x,Wr=ze.y,Kr=ze.x+ze.width,Zr=ze.y+ze.height;return Gr>=this.x&&Gr<this.x+this.width&&Wr>=this.y&&Wr<this.y+this.height&&Kr>=this.x&&Kr<this.x+this.width&&Zr>=this.y&&Zr<this.y+this.height}toString(){return`[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`}}const uidCache={default:-1};function uid$1(Yr="default"){return uidCache[Yr]===void 0&&(uidCache[Yr]=-1),++uidCache[Yr]}const warnings={},v8_0_0="8.0.0",v8_3_4="8.3.4";function deprecation(Yr,ze,Gr=3){if(warnings[ze])return;let Wr=new Error().stack;typeof Wr>"u"?console.warn("PixiJS Deprecation Warning: ",`${ze}
Deprecated since v${Yr}`):(Wr=Wr.split(`
`).splice(Gr).join(`
`),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",`${ze}
Deprecated since v${Yr}`),console.warn(Wr),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",`${ze}
Deprecated since v${Yr}`),console.warn(Wr))),warnings[ze]=!0}const NOOP=()=>{};function nextPow2(Yr){return Yr+=Yr===0?1:0,--Yr,Yr|=Yr>>>1,Yr|=Yr>>>2,Yr|=Yr>>>4,Yr|=Yr>>>8,Yr|=Yr>>>16,Yr+1}function isPow2(Yr){return!(Yr&Yr-1)&&!!Yr}function definedProps(Yr){const ze={};for(const Gr in Yr)Yr[Gr]!==void 0&&(ze[Gr]=Yr[Gr]);return ze}const idHash$1=Object.create(null);function createResourceIdFromString(Yr){const ze=idHash$1[Yr];return ze===void 0&&(idHash$1[Yr]=uid$1("resource")),ze}const _TextureStyle=class bs extends EventEmitter{constructor(ze={}){super(),this._resourceType="textureSampler",this._touched=0,this._maxAnisotropy=1,this.destroyed=!1,ze={...bs.defaultOptions,...ze},this.addressMode=ze.addressMode,this.addressModeU=ze.addressModeU??this.addressModeU,this.addressModeV=ze.addressModeV??this.addressModeV,this.addressModeW=ze.addressModeW??this.addressModeW,this.scaleMode=ze.scaleMode,this.magFilter=ze.magFilter??this.magFilter,this.minFilter=ze.minFilter??this.minFilter,this.mipmapFilter=ze.mipmapFilter??this.mipmapFilter,this.lodMinClamp=ze.lodMinClamp,this.lodMaxClamp=ze.lodMaxClamp,this.compare=ze.compare,this.maxAnisotropy=ze.maxAnisotropy??1}set addressMode(ze){this.addressModeU=ze,this.addressModeV=ze,this.addressModeW=ze}get addressMode(){return this.addressModeU}set wrapMode(ze){deprecation(v8_0_0,"TextureStyle.wrapMode is now TextureStyle.addressMode"),this.addressMode=ze}get wrapMode(){return this.addressMode}set scaleMode(ze){this.magFilter=ze,this.minFilter=ze,this.mipmapFilter=ze}get scaleMode(){return this.magFilter}set maxAnisotropy(ze){this._maxAnisotropy=Math.min(ze,16),this._maxAnisotropy>1&&(this.scaleMode="linear")}get maxAnisotropy(){return this._maxAnisotropy}get _resourceId(){return this._sharedResourceId||this._generateResourceId()}update(){this.emit("change",this),this._sharedResourceId=null}_generateResourceId(){const ze=`${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;return this._sharedResourceId=createResourceIdFromString(ze),this._resourceId}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this.removeAllListeners()}};_TextureStyle.defaultOptions={addressMode:"clamp-to-edge",scaleMode:"linear"};let TextureStyle=_TextureStyle;const _TextureSource=class vs extends EventEmitter{constructor(ze={}){super(),this.options=ze,this.uid=uid$1("textureSource"),this._resourceType="textureSource",this._resourceId=uid$1("resource"),this.uploadMethodId="unknown",this._resolution=1,this.pixelWidth=1,this.pixelHeight=1,this.width=1,this.height=1,this.sampleCount=1,this.mipLevelCount=1,this.autoGenerateMipmaps=!1,this.format="rgba8unorm",this.dimension="2d",this.antialias=!1,this._touched=0,this._batchTick=-1,this._textureBindLocation=-1,ze={...vs.defaultOptions,...ze},this.label=ze.label??"",this.resource=ze.resource,this.autoGarbageCollect=ze.autoGarbageCollect,this._resolution=ze.resolution,ze.width?this.pixelWidth=ze.width*this._resolution:this.pixelWidth=this.resource?this.resourceWidth??1:1,ze.height?this.pixelHeight=ze.height*this._resolution:this.pixelHeight=this.resource?this.resourceHeight??1:1,this.width=this.pixelWidth/this._resolution,this.height=this.pixelHeight/this._resolution,this.format=ze.format,this.dimension=ze.dimensions,this.mipLevelCount=ze.mipLevelCount,this.autoGenerateMipmaps=ze.autoGenerateMipmaps,this.sampleCount=ze.sampleCount,this.antialias=ze.antialias,this.alphaMode=ze.alphaMode,this.style=new TextureStyle(definedProps(ze)),this.destroyed=!1,this._refreshPOT()}get source(){return this}get style(){return this._style}set style(ze){var Gr,Wr;this.style!==ze&&((Gr=this._style)==null||Gr.off("change",this._onStyleChange,this),this._style=ze,(Wr=this._style)==null||Wr.on("change",this._onStyleChange,this),this._onStyleChange())}get addressMode(){return this._style.addressMode}set addressMode(ze){this._style.addressMode=ze}get repeatMode(){return this._style.addressMode}set repeatMode(ze){this._style.addressMode=ze}get magFilter(){return this._style.magFilter}set magFilter(ze){this._style.magFilter=ze}get minFilter(){return this._style.minFilter}set minFilter(ze){this._style.minFilter=ze}get mipmapFilter(){return this._style.mipmapFilter}set mipmapFilter(ze){this._style.mipmapFilter=ze}get lodMinClamp(){return this._style.lodMinClamp}set lodMinClamp(ze){this._style.lodMinClamp=ze}get lodMaxClamp(){return this._style.lodMaxClamp}set lodMaxClamp(ze){this._style.lodMaxClamp=ze}_onStyleChange(){this.emit("styleChange",this)}update(){if(this.resource){const ze=this._resolution;if(this.resize(this.resourceWidth/ze,this.resourceHeight/ze))return}this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._style&&(this._style.destroy(),this._style=null),this.uploadMethodId=null,this.resource=null,this.removeAllListeners()}unload(){this._resourceId=uid$1("resource"),this.emit("change",this),this.emit("unload",this)}get resourceWidth(){const{resource:ze}=this;return ze.naturalWidth||ze.videoWidth||ze.displayWidth||ze.width}get resourceHeight(){const{resource:ze}=this;return ze.naturalHeight||ze.videoHeight||ze.displayHeight||ze.height}get resolution(){return this._resolution}set resolution(ze){this._resolution!==ze&&(this._resolution=ze,this.width=this.pixelWidth/ze,this.height=this.pixelHeight/ze)}resize(ze,Gr,Wr){Wr||(Wr=this._resolution),ze||(ze=this.width),Gr||(Gr=this.height);const Kr=Math.round(ze*Wr),Zr=Math.round(Gr*Wr);return this.width=Kr/Wr,this.height=Zr/Wr,this._resolution=Wr,this.pixelWidth===Kr&&this.pixelHeight===Zr?!1:(this._refreshPOT(),this.pixelWidth=Kr,this.pixelHeight=Zr,this.emit("resize",this),this._resourceId=uid$1("resource"),this.emit("change",this),!0)}updateMipmaps(){this.autoGenerateMipmaps&&this.mipLevelCount>1&&this.emit("updateMipmaps",this)}set wrapMode(ze){this._style.wrapMode=ze}get wrapMode(){return this._style.wrapMode}set scaleMode(ze){this._style.scaleMode=ze}get scaleMode(){return this._style.scaleMode}_refreshPOT(){this.isPowerOfTwo=isPow2(this.pixelWidth)&&isPow2(this.pixelHeight)}static test(ze){throw new Error("Unimplemented")}};_TextureSource.defaultOptions={resolution:1,format:"bgra8unorm",alphaMode:"premultiply-alpha-on-upload",dimensions:"2d",mipLevelCount:1,autoGenerateMipmaps:!1,sampleCount:1,antialias:!1,autoGarbageCollect:!1};let TextureSource=_TextureSource;class BufferImageSource extends TextureSource{constructor(ze){const Gr=ze.resource||new Float32Array(ze.width*ze.height*4);let Wr=ze.format;Wr||(Gr instanceof Float32Array?Wr="rgba32float":Gr instanceof Int32Array||Gr instanceof Uint32Array?Wr="rgba32uint":Gr instanceof Int16Array||Gr instanceof Uint16Array?Wr="rgba16uint":(Gr instanceof Int8Array,Wr="bgra8unorm")),super({...ze,resource:Gr,format:Wr}),this.uploadMethodId="buffer"}static test(ze){return ze instanceof Int8Array||ze instanceof Uint8Array||ze instanceof Uint8ClampedArray||ze instanceof Int16Array||ze instanceof Uint16Array||ze instanceof Int32Array||ze instanceof Uint32Array||ze instanceof Float32Array}}BufferImageSource.extension=ExtensionType.TextureSource;const tempMat=new Matrix;class TextureMatrix{constructor(ze,Gr){this.mapCoord=new Matrix,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,typeof Gr>"u"?this.clampMargin=ze.width<10?0:.5:this.clampMargin=Gr,this.isSimple=!1,this.texture=ze}get texture(){return this._texture}set texture(ze){var Gr;this.texture!==ze&&((Gr=this._texture)==null||Gr.removeListener("update",this.update,this),this._texture=ze,this._texture.addListener("update",this.update,this),this.update())}multiplyUvs(ze,Gr){Gr===void 0&&(Gr=ze);const Wr=this.mapCoord;for(let Kr=0;Kr<ze.length;Kr+=2){const Zr=ze[Kr],Qr=ze[Kr+1];Gr[Kr]=Zr*Wr.a+Qr*Wr.c+Wr.tx,Gr[Kr+1]=Zr*Wr.b+Qr*Wr.d+Wr.ty}return Gr}update(){const ze=this._texture;this._updateID++;const Gr=ze.uvs;this.mapCoord.set(Gr.x1-Gr.x0,Gr.y1-Gr.y0,Gr.x3-Gr.x0,Gr.y3-Gr.y0,Gr.x0,Gr.y0);const Wr=ze.orig,Kr=ze.trim;Kr&&(tempMat.set(Wr.width/Kr.width,0,0,Wr.height/Kr.height,-Kr.x/Kr.width,-Kr.y/Kr.height),this.mapCoord.append(tempMat));const Zr=ze.source,Qr=this.uClampFrame,Jr=this.clampMargin/Zr._resolution,ei=this.clampOffset/Zr._resolution;return Qr[0]=(ze.frame.x+Jr+ei)/Zr.width,Qr[1]=(ze.frame.y+Jr+ei)/Zr.height,Qr[2]=(ze.frame.x+ze.frame.width-Jr+ei)/Zr.width,Qr[3]=(ze.frame.y+ze.frame.height-Jr+ei)/Zr.height,this.uClampOffset[0]=this.clampOffset/Zr.pixelWidth,this.uClampOffset[1]=this.clampOffset/Zr.pixelHeight,this.isSimple=ze.frame.width===Zr.width&&ze.frame.height===Zr.height&&ze.rotate===0,!0}}class Texture extends EventEmitter{constructor({source:ze,label:Gr,frame:Wr,orig:Kr,trim:Zr,defaultAnchor:Qr,defaultBorders:Jr,rotate:ei,dynamic:ti}={}){if(super(),this.uid=uid$1("texture"),this.uvs={x0:0,y0:0,x1:0,y1:0,x2:0,y2:0,x3:0,y3:0},this.frame=new Rectangle,this.noFrame=!1,this.dynamic=!1,this.isTexture=!0,this.label=Gr,this.source=(ze==null?void 0:ze.source)??new TextureSource,this.noFrame=!Wr,Wr)this.frame.copyFrom(Wr);else{const{width:ri,height:ii}=this._source;this.frame.width=ri,this.frame.height=ii}this.orig=Kr||this.frame,this.trim=Zr,this.rotate=ei??0,this.defaultAnchor=Qr,this.defaultBorders=Jr,this.destroyed=!1,this.dynamic=ti||!1,this.updateUvs()}set source(ze){this._source&&this._source.off("resize",this.update,this),this._source=ze,ze.on("resize",this.update,this),this.emit("update",this)}get source(){return this._source}get textureMatrix(){return this._textureMatrix||(this._textureMatrix=new TextureMatrix(this)),this._textureMatrix}get width(){return this.orig.width}get height(){return this.orig.height}updateUvs(){const{uvs:ze,frame:Gr}=this,{width:Wr,height:Kr}=this._source,Zr=Gr.x/Wr,Qr=Gr.y/Kr,Jr=Gr.width/Wr,ei=Gr.height/Kr;let ti=this.rotate;if(ti){const ri=Jr/2,ii=ei/2,si=Zr+ri,ni=Qr+ii;ti=groupD8.add(ti,groupD8.NW),ze.x0=si+ri*groupD8.uX(ti),ze.y0=ni+ii*groupD8.uY(ti),ti=groupD8.add(ti,2),ze.x1=si+ri*groupD8.uX(ti),ze.y1=ni+ii*groupD8.uY(ti),ti=groupD8.add(ti,2),ze.x2=si+ri*groupD8.uX(ti),ze.y2=ni+ii*groupD8.uY(ti),ti=groupD8.add(ti,2),ze.x3=si+ri*groupD8.uX(ti),ze.y3=ni+ii*groupD8.uY(ti)}else ze.x0=Zr,ze.y0=Qr,ze.x1=Zr+Jr,ze.y1=Qr,ze.x2=Zr+Jr,ze.y2=Qr+ei,ze.x3=Zr,ze.y3=Qr+ei}destroy(ze=!1){this._source&&ze&&(this._source.destroy(),this._source=null),this._textureMatrix=null,this.destroyed=!0,this.emit("destroy",this),this.removeAllListeners()}update(){this.noFrame&&(this.frame.width=this._source.width,this.frame.height=this._source.height),this.updateUvs(),this.emit("update",this)}get baseTexture(){return deprecation(v8_0_0,"Texture.baseTexture is now Texture.source"),this._source}}Texture.EMPTY=new Texture({label:"EMPTY",source:new TextureSource({label:"EMPTY"})});Texture.EMPTY.destroy=NOOP;Texture.WHITE=new Texture({source:new BufferImageSource({resource:new Uint8Array([255,255,255,255]),width:1,height:1,alphaMode:"premultiply-alpha-on-upload",label:"WHITE"}),label:"WHITE"});Texture.WHITE.destroy=NOOP;function updateQuadBounds(Yr,ze,Gr){const{width:Wr,height:Kr}=Gr.orig,Zr=Gr.trim;if(Zr){const Qr=Zr.width,Jr=Zr.height;Yr.minX=Zr.x-ze._x*Wr,Yr.maxX=Yr.minX+Qr,Yr.minY=Zr.y-ze._y*Kr,Yr.maxY=Yr.minY+Jr}else Yr.minX=-ze._x*Wr,Yr.maxX=Yr.minX+Wr,Yr.minY=-ze._y*Kr,Yr.maxY=Yr.minY+Kr}const defaultMatrix=new Matrix;class Bounds{constructor(ze=1/0,Gr=1/0,Wr=-1/0,Kr=-1/0){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=defaultMatrix,this.minX=ze,this.minY=Gr,this.maxX=Wr,this.maxY=Kr}isEmpty(){return this.minX>this.maxX||this.minY>this.maxY}get rectangle(){this._rectangle||(this._rectangle=new Rectangle);const ze=this._rectangle;return this.minX>this.maxX||this.minY>this.maxY?(ze.x=0,ze.y=0,ze.width=0,ze.height=0):ze.copyFromBounds(this),ze}clear(){return this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=defaultMatrix,this}set(ze,Gr,Wr,Kr){this.minX=ze,this.minY=Gr,this.maxX=Wr,this.maxY=Kr}addFrame(ze,Gr,Wr,Kr,Zr){Zr||(Zr=this.matrix);const Qr=Zr.a,Jr=Zr.b,ei=Zr.c,ti=Zr.d,ri=Zr.tx,ii=Zr.ty;let si=this.minX,ni=this.minY,oi=this.maxX,li=this.maxY,ai=Qr*ze+ei*Gr+ri,hi=Jr*ze+ti*Gr+ii;ai<si&&(si=ai),hi<ni&&(ni=hi),ai>oi&&(oi=ai),hi>li&&(li=hi),ai=Qr*Wr+ei*Gr+ri,hi=Jr*Wr+ti*Gr+ii,ai<si&&(si=ai),hi<ni&&(ni=hi),ai>oi&&(oi=ai),hi>li&&(li=hi),ai=Qr*ze+ei*Kr+ri,hi=Jr*ze+ti*Kr+ii,ai<si&&(si=ai),hi<ni&&(ni=hi),ai>oi&&(oi=ai),hi>li&&(li=hi),ai=Qr*Wr+ei*Kr+ri,hi=Jr*Wr+ti*Kr+ii,ai<si&&(si=ai),hi<ni&&(ni=hi),ai>oi&&(oi=ai),hi>li&&(li=hi),this.minX=si,this.minY=ni,this.maxX=oi,this.maxY=li}addRect(ze,Gr){this.addFrame(ze.x,ze.y,ze.x+ze.width,ze.y+ze.height,Gr)}addBounds(ze,Gr){this.addFrame(ze.minX,ze.minY,ze.maxX,ze.maxY,Gr)}addBoundsMask(ze){this.minX=this.minX>ze.minX?this.minX:ze.minX,this.minY=this.minY>ze.minY?this.minY:ze.minY,this.maxX=this.maxX<ze.maxX?this.maxX:ze.maxX,this.maxY=this.maxY<ze.maxY?this.maxY:ze.maxY}applyMatrix(ze){const Gr=this.minX,Wr=this.minY,Kr=this.maxX,Zr=this.maxY,{a:Qr,b:Jr,c:ei,d:ti,tx:ri,ty:ii}=ze;let si=Qr*Gr+ei*Wr+ri,ni=Jr*Gr+ti*Wr+ii;this.minX=si,this.minY=ni,this.maxX=si,this.maxY=ni,si=Qr*Kr+ei*Wr+ri,ni=Jr*Kr+ti*Wr+ii,this.minX=si<this.minX?si:this.minX,this.minY=ni<this.minY?ni:this.minY,this.maxX=si>this.maxX?si:this.maxX,this.maxY=ni>this.maxY?ni:this.maxY,si=Qr*Gr+ei*Zr+ri,ni=Jr*Gr+ti*Zr+ii,this.minX=si<this.minX?si:this.minX,this.minY=ni<this.minY?ni:this.minY,this.maxX=si>this.maxX?si:this.maxX,this.maxY=ni>this.maxY?ni:this.maxY,si=Qr*Kr+ei*Zr+ri,ni=Jr*Kr+ti*Zr+ii,this.minX=si<this.minX?si:this.minX,this.minY=ni<this.minY?ni:this.minY,this.maxX=si>this.maxX?si:this.maxX,this.maxY=ni>this.maxY?ni:this.maxY}fit(ze){return this.minX<ze.left&&(this.minX=ze.left),this.maxX>ze.right&&(this.maxX=ze.right),this.minY<ze.top&&(this.minY=ze.top),this.maxY>ze.bottom&&(this.maxY=ze.bottom),this}fitBounds(ze,Gr,Wr,Kr){return this.minX<ze&&(this.minX=ze),this.maxX>Gr&&(this.maxX=Gr),this.minY<Wr&&(this.minY=Wr),this.maxY>Kr&&(this.maxY=Kr),this}pad(ze,Gr=ze){return this.minX-=ze,this.maxX+=ze,this.minY-=Gr,this.maxY+=Gr,this}ceil(){return this.minX=Math.floor(this.minX),this.minY=Math.floor(this.minY),this.maxX=Math.ceil(this.maxX),this.maxY=Math.ceil(this.maxY),this}clone(){return new Bounds(this.minX,this.minY,this.maxX,this.maxY)}scale(ze,Gr=ze){return this.minX*=ze,this.minY*=Gr,this.maxX*=ze,this.maxY*=Gr,this}get x(){return this.minX}set x(ze){const Gr=this.maxX-this.minX;this.minX=ze,this.maxX=ze+Gr}get y(){return this.minY}set y(ze){const Gr=this.maxY-this.minY;this.minY=ze,this.maxY=ze+Gr}get width(){return this.maxX-this.minX}set width(ze){this.maxX=this.minX+ze}get height(){return this.maxY-this.minY}set height(ze){this.maxY=this.minY+ze}get left(){return this.minX}get right(){return this.maxX}get top(){return this.minY}get bottom(){return this.maxY}get isPositive(){return this.maxX-this.minX>0&&this.maxY-this.minY>0}get isValid(){return this.minX+this.minY!==1/0}addVertexData(ze,Gr,Wr,Kr){let Zr=this.minX,Qr=this.minY,Jr=this.maxX,ei=this.maxY;Kr||(Kr=this.matrix);const ti=Kr.a,ri=Kr.b,ii=Kr.c,si=Kr.d,ni=Kr.tx,oi=Kr.ty;for(let li=Gr;li<Wr;li+=2){const ai=ze[li],hi=ze[li+1],fi=ti*ai+ii*hi+ni,pi=ri*ai+si*hi+oi;Zr=fi<Zr?fi:Zr,Qr=pi<Qr?pi:Qr,Jr=fi>Jr?fi:Jr,ei=pi>ei?pi:ei}this.minX=Zr,this.minY=Qr,this.maxX=Jr,this.maxY=ei}containsPoint(ze,Gr){return this.minX<=ze&&this.minY<=Gr&&this.maxX>=ze&&this.maxY>=Gr}toString(){return`[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`}copyFrom(ze){return this.minX=ze.minX,this.minY=ze.minY,this.maxX=ze.maxX,this.maxY=ze.maxY,this}}var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(Yr){return typeof Yr=="string"?Yr.length>0:typeof Yr=="number"},n=function(Yr,ze,Gr){return ze===void 0&&(ze=0),Gr===void 0&&(Gr=Math.pow(10,ze)),Math.round(Gr*Yr)/Gr+0},e=function(Yr,ze,Gr){return ze===void 0&&(ze=0),Gr===void 0&&(Gr=1),Yr>Gr?Gr:Yr>ze?Yr:ze},u=function(Yr){return(Yr=isFinite(Yr)?Yr%360:0)>0?Yr:Yr+360},a=function(Yr){return{r:e(Yr.r,0,255),g:e(Yr.g,0,255),b:e(Yr.b,0,255),a:e(Yr.a)}},o=function(Yr){return{r:n(Yr.r),g:n(Yr.g),b:n(Yr.b),a:n(Yr.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(Yr){var ze=Yr.toString(16);return ze.length<2?"0"+ze:ze},h=function(Yr){var ze=Yr.r,Gr=Yr.g,Wr=Yr.b,Kr=Yr.a,Zr=Math.max(ze,Gr,Wr),Qr=Zr-Math.min(ze,Gr,Wr),Jr=Qr?Zr===ze?(Gr-Wr)/Qr:Zr===Gr?2+(Wr-ze)/Qr:4+(ze-Gr)/Qr:0;return{h:60*(Jr<0?Jr+6:Jr),s:Zr?Qr/Zr*100:0,v:Zr/255*100,a:Kr}},b=function(Yr){var ze=Yr.h,Gr=Yr.s,Wr=Yr.v,Kr=Yr.a;ze=ze/360*6,Gr/=100,Wr/=100;var Zr=Math.floor(ze),Qr=Wr*(1-Gr),Jr=Wr*(1-(ze-Zr)*Gr),ei=Wr*(1-(1-ze+Zr)*Gr),ti=Zr%6;return{r:255*[Wr,Jr,Qr,Qr,ei,Wr][ti],g:255*[ei,Wr,Wr,Jr,Qr,Qr][ti],b:255*[Qr,Qr,ei,Wr,Wr,Jr][ti],a:Kr}},g=function(Yr){return{h:u(Yr.h),s:e(Yr.s,0,100),l:e(Yr.l,0,100),a:e(Yr.a)}},d=function(Yr){return{h:n(Yr.h),s:n(Yr.s),l:n(Yr.l),a:n(Yr.a,3)}},f=function(Yr){return b((Gr=(ze=Yr).s,{h:ze.h,s:(Gr*=((Wr=ze.l)<50?Wr:100-Wr)/100)>0?2*Gr/(Wr+Gr)*100:0,v:Wr+Gr,a:ze.a}));var ze,Gr,Wr},c=function(Yr){return{h:(ze=h(Yr)).h,s:(Kr=(200-(Gr=ze.s))*(Wr=ze.v)/100)>0&&Kr<200?Gr*Wr/100/(Kr<=100?Kr:200-Kr)*100:0,l:Kr/2,a:ze.a};var ze,Gr,Wr,Kr},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(Yr){var ze=i.exec(Yr);return ze?(Yr=ze[1]).length<=4?{r:parseInt(Yr[0]+Yr[0],16),g:parseInt(Yr[1]+Yr[1],16),b:parseInt(Yr[2]+Yr[2],16),a:Yr.length===4?n(parseInt(Yr[3]+Yr[3],16)/255,2):1}:Yr.length===6||Yr.length===8?{r:parseInt(Yr.substr(0,2),16),g:parseInt(Yr.substr(2,2),16),b:parseInt(Yr.substr(4,2),16),a:Yr.length===8?n(parseInt(Yr.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(Yr){var ze=v.exec(Yr)||m.exec(Yr);return ze?ze[2]!==ze[4]||ze[4]!==ze[6]?null:a({r:Number(ze[1])/(ze[2]?100/255:1),g:Number(ze[3])/(ze[4]?100/255:1),b:Number(ze[5])/(ze[6]?100/255:1),a:ze[7]===void 0?1:Number(ze[7])/(ze[8]?100:1)}):null},"rgb"],[function(Yr){var ze=l.exec(Yr)||p.exec(Yr);if(!ze)return null;var Gr,Wr,Kr=g({h:(Gr=ze[1],Wr=ze[2],Wr===void 0&&(Wr="deg"),Number(Gr)*(r[Wr]||1)),s:Number(ze[3]),l:Number(ze[4]),a:ze[5]===void 0?1:Number(ze[5])/(ze[6]?100:1)});return f(Kr)},"hsl"]],object:[[function(Yr){var ze=Yr.r,Gr=Yr.g,Wr=Yr.b,Kr=Yr.a,Zr=Kr===void 0?1:Kr;return t(ze)&&t(Gr)&&t(Wr)?a({r:Number(ze),g:Number(Gr),b:Number(Wr),a:Number(Zr)}):null},"rgb"],[function(Yr){var ze=Yr.h,Gr=Yr.s,Wr=Yr.l,Kr=Yr.a,Zr=Kr===void 0?1:Kr;if(!t(ze)||!t(Gr)||!t(Wr))return null;var Qr=g({h:Number(ze),s:Number(Gr),l:Number(Wr),a:Number(Zr)});return f(Qr)},"hsl"],[function(Yr){var ze=Yr.h,Gr=Yr.s,Wr=Yr.v,Kr=Yr.a,Zr=Kr===void 0?1:Kr;if(!t(ze)||!t(Gr)||!t(Wr))return null;var Qr=function(Jr){return{h:u(Jr.h),s:e(Jr.s,0,100),v:e(Jr.v,0,100),a:e(Jr.a)}}({h:Number(ze),s:Number(Gr),v:Number(Wr),a:Number(Zr)});return b(Qr)},"hsv"]]},N=function(Yr,ze){for(var Gr=0;Gr<ze.length;Gr++){var Wr=ze[Gr][0](Yr);if(Wr)return[Wr,ze[Gr][1]]}return[null,void 0]},x=function(Yr){return typeof Yr=="string"?N(Yr.trim(),y.string):typeof Yr=="object"&&Yr!==null?N(Yr,y.object):[null,void 0]},M=function(Yr,ze){var Gr=c(Yr);return{h:Gr.h,s:e(Gr.s+100*ze,0,100),l:Gr.l,a:Gr.a}},H=function(Yr){return(299*Yr.r+587*Yr.g+114*Yr.b)/1e3/255},$=function(Yr,ze){var Gr=c(Yr);return{h:Gr.h,s:Gr.s,l:e(Gr.l+100*ze,0,100),a:Gr.a}},j=function(){function Yr(ze){this.parsed=x(ze)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return Yr.prototype.isValid=function(){return this.parsed!==null},Yr.prototype.brightness=function(){return n(H(this.rgba),2)},Yr.prototype.isDark=function(){return H(this.rgba)<.5},Yr.prototype.isLight=function(){return H(this.rgba)>=.5},Yr.prototype.toHex=function(){return ze=o(this.rgba),Gr=ze.r,Wr=ze.g,Kr=ze.b,Qr=(Zr=ze.a)<1?s(n(255*Zr)):"","#"+s(Gr)+s(Wr)+s(Kr)+Qr;var ze,Gr,Wr,Kr,Zr,Qr},Yr.prototype.toRgb=function(){return o(this.rgba)},Yr.prototype.toRgbString=function(){return ze=o(this.rgba),Gr=ze.r,Wr=ze.g,Kr=ze.b,(Zr=ze.a)<1?"rgba("+Gr+", "+Wr+", "+Kr+", "+Zr+")":"rgb("+Gr+", "+Wr+", "+Kr+")";var ze,Gr,Wr,Kr,Zr},Yr.prototype.toHsl=function(){return d(c(this.rgba))},Yr.prototype.toHslString=function(){return ze=d(c(this.rgba)),Gr=ze.h,Wr=ze.s,Kr=ze.l,(Zr=ze.a)<1?"hsla("+Gr+", "+Wr+"%, "+Kr+"%, "+Zr+")":"hsl("+Gr+", "+Wr+"%, "+Kr+"%)";var ze,Gr,Wr,Kr,Zr},Yr.prototype.toHsv=function(){return ze=h(this.rgba),{h:n(ze.h),s:n(ze.s),v:n(ze.v),a:n(ze.a,3)};var ze},Yr.prototype.invert=function(){return w({r:255-(ze=this.rgba).r,g:255-ze.g,b:255-ze.b,a:ze.a});var ze},Yr.prototype.saturate=function(ze){return ze===void 0&&(ze=.1),w(M(this.rgba,ze))},Yr.prototype.desaturate=function(ze){return ze===void 0&&(ze=.1),w(M(this.rgba,-ze))},Yr.prototype.grayscale=function(){return w(M(this.rgba,-1))},Yr.prototype.lighten=function(ze){return ze===void 0&&(ze=.1),w($(this.rgba,ze))},Yr.prototype.darken=function(ze){return ze===void 0&&(ze=.1),w($(this.rgba,-ze))},Yr.prototype.rotate=function(ze){return ze===void 0&&(ze=15),this.hue(this.hue()+ze)},Yr.prototype.alpha=function(ze){return typeof ze=="number"?w({r:(Gr=this.rgba).r,g:Gr.g,b:Gr.b,a:ze}):n(this.rgba.a,3);var Gr},Yr.prototype.hue=function(ze){var Gr=c(this.rgba);return typeof ze=="number"?w({h:ze,s:Gr.s,l:Gr.l,a:Gr.a}):n(Gr.h)},Yr.prototype.isEqual=function(ze){return this.toHex()===w(ze).toHex()},Yr}(),w=function(Yr){return Yr instanceof j?Yr:new j(Yr)},S=[],k=function(Yr){Yr.forEach(function(ze){S.indexOf(ze)<0&&(ze(j,y),S.push(ze))})};function namesPlugin(Yr,ze){var Gr={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},Wr={};for(var Kr in Gr)Wr[Gr[Kr]]=Kr;var Zr={};Yr.prototype.toName=function(Qr){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var Jr,ei,ti=Wr[this.toHex()];if(ti)return ti;if(Qr!=null&&Qr.closest){var ri=this.toRgb(),ii=1/0,si="black";if(!Zr.length)for(var ni in Gr)Zr[ni]=new Yr(Gr[ni]).toRgb();for(var oi in Gr){var li=(Jr=ri,ei=Zr[oi],Math.pow(Jr.r-ei.r,2)+Math.pow(Jr.g-ei.g,2)+Math.pow(Jr.b-ei.b,2));li<ii&&(ii=li,si=oi)}return si}},ze.string.push([function(Qr){var Jr=Qr.toLowerCase(),ei=Jr==="transparent"?"#0000":Gr[Jr];return ei?new Yr(ei).toRgb():null},"name"])}k([namesPlugin]);const _Color=class ss{constructor(ze=16777215){this._value=null,this._components=new Float32Array(4),this._components.fill(1),this._int=16777215,this.value=ze}get red(){return this._components[0]}get green(){return this._components[1]}get blue(){return this._components[2]}get alpha(){return this._components[3]}setValue(ze){return this.value=ze,this}set value(ze){if(ze instanceof ss)this._value=this._cloneSource(ze._value),this._int=ze._int,this._components.set(ze._components);else{if(ze===null)throw new Error("Cannot set Color#value to null");(this._value===null||!this._isSourceEqual(this._value,ze))&&(this._value=this._cloneSource(ze),this._normalize(this._value))}}get value(){return this._value}_cloneSource(ze){return typeof ze=="string"||typeof ze=="number"||ze instanceof Number||ze===null?ze:Array.isArray(ze)||ArrayBuffer.isView(ze)?ze.slice(0):typeof ze=="object"&&ze!==null?{...ze}:ze}_isSourceEqual(ze,Gr){const Wr=typeof ze;if(Wr!==typeof Gr)return!1;if(Wr==="number"||Wr==="string"||ze instanceof Number)return ze===Gr;if(Array.isArray(ze)&&Array.isArray(Gr)||ArrayBuffer.isView(ze)&&ArrayBuffer.isView(Gr))return ze.length!==Gr.length?!1:ze.every((Zr,Qr)=>Zr===Gr[Qr]);if(ze!==null&&Gr!==null){const Zr=Object.keys(ze),Qr=Object.keys(Gr);return Zr.length!==Qr.length?!1:Zr.every(Jr=>ze[Jr]===Gr[Jr])}return ze===Gr}toRgba(){const[ze,Gr,Wr,Kr]=this._components;return{r:ze,g:Gr,b:Wr,a:Kr}}toRgb(){const[ze,Gr,Wr]=this._components;return{r:ze,g:Gr,b:Wr}}toRgbaString(){const[ze,Gr,Wr]=this.toUint8RgbArray();return`rgba(${ze},${Gr},${Wr},${this.alpha})`}toUint8RgbArray(ze){const[Gr,Wr,Kr]=this._components;return this._arrayRgb||(this._arrayRgb=[]),ze||(ze=this._arrayRgb),ze[0]=Math.round(Gr*255),ze[1]=Math.round(Wr*255),ze[2]=Math.round(Kr*255),ze}toArray(ze){this._arrayRgba||(this._arrayRgba=[]),ze||(ze=this._arrayRgba);const[Gr,Wr,Kr,Zr]=this._components;return ze[0]=Gr,ze[1]=Wr,ze[2]=Kr,ze[3]=Zr,ze}toRgbArray(ze){this._arrayRgb||(this._arrayRgb=[]),ze||(ze=this._arrayRgb);const[Gr,Wr,Kr]=this._components;return ze[0]=Gr,ze[1]=Wr,ze[2]=Kr,ze}toNumber(){return this._int}toBgrNumber(){const[ze,Gr,Wr]=this.toUint8RgbArray();return(Wr<<16)+(Gr<<8)+ze}toLittleEndianNumber(){const ze=this._int;return(ze>>16)+(ze&65280)+((ze&255)<<16)}multiply(ze){const[Gr,Wr,Kr,Zr]=ss._temp.setValue(ze)._components;return this._components[0]*=Gr,this._components[1]*=Wr,this._components[2]*=Kr,this._components[3]*=Zr,this._refreshInt(),this._value=null,this}premultiply(ze,Gr=!0){return Gr&&(this._components[0]*=ze,this._components[1]*=ze,this._components[2]*=ze),this._components[3]=ze,this._refreshInt(),this._value=null,this}toPremultiplied(ze,Gr=!0){if(ze===1)return(255<<24)+this._int;if(ze===0)return Gr?0:this._int;let Wr=this._int>>16&255,Kr=this._int>>8&255,Zr=this._int&255;return Gr&&(Wr=Wr*ze+.5|0,Kr=Kr*ze+.5|0,Zr=Zr*ze+.5|0),(ze*255<<24)+(Wr<<16)+(Kr<<8)+Zr}toHex(){const ze=this._int.toString(16);return`#${"000000".substring(0,6-ze.length)+ze}`}toHexa(){const Gr=Math.round(this._components[3]*255).toString(16);return this.toHex()+"00".substring(0,2-Gr.length)+Gr}setAlpha(ze){return this._components[3]=this._clamp(ze),this}_normalize(ze){let Gr,Wr,Kr,Zr;if((typeof ze=="number"||ze instanceof Number)&&ze>=0&&ze<=16777215){const Qr=ze;Gr=(Qr>>16&255)/255,Wr=(Qr>>8&255)/255,Kr=(Qr&255)/255,Zr=1}else if((Array.isArray(ze)||ze instanceof Float32Array)&&ze.length>=3&&ze.length<=4)ze=this._clamp(ze),[Gr,Wr,Kr,Zr=1]=ze;else if((ze instanceof Uint8Array||ze instanceof Uint8ClampedArray)&&ze.length>=3&&ze.length<=4)ze=this._clamp(ze,0,255),[Gr,Wr,Kr,Zr=255]=ze,Gr/=255,Wr/=255,Kr/=255,Zr/=255;else if(typeof ze=="string"||typeof ze=="object"){if(typeof ze=="string"){const Jr=ss.HEX_PATTERN.exec(ze);Jr&&(ze=`#${Jr[2]}`)}const Qr=w(ze);Qr.isValid()&&({r:Gr,g:Wr,b:Kr,a:Zr}=Qr.rgba,Gr/=255,Wr/=255,Kr/=255)}if(Gr!==void 0)this._components[0]=Gr,this._components[1]=Wr,this._components[2]=Kr,this._components[3]=Zr,this._refreshInt();else throw new Error(`Unable to convert color ${ze}`)}_refreshInt(){this._clamp(this._components);const[ze,Gr,Wr]=this._components;this._int=(ze*255<<16)+(Gr*255<<8)+(Wr*255|0)}_clamp(ze,Gr=0,Wr=1){return typeof ze=="number"?Math.min(Math.max(ze,Gr),Wr):(ze.forEach((Kr,Zr)=>{ze[Zr]=Math.min(Math.max(Kr,Gr),Wr)}),ze)}static isColorLike(ze){return typeof ze=="number"||typeof ze=="string"||ze instanceof Number||ze instanceof ss||Array.isArray(ze)||ze instanceof Uint8Array||ze instanceof Uint8ClampedArray||ze instanceof Float32Array||ze.r!==void 0&&ze.g!==void 0&&ze.b!==void 0||ze.r!==void 0&&ze.g!==void 0&&ze.b!==void 0&&ze.a!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.l!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.l!==void 0&&ze.a!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.v!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.v!==void 0&&ze.a!==void 0}};_Color.shared=new _Color;_Color._temp=new _Color;_Color.HEX_PATTERN=/^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;let Color=_Color;const cullingMixin={cullArea:null,cullable:!1,cullableChildren:!0};class Pool{constructor(ze,Gr){this._pool=[],this._count=0,this._index=0,this._classType=ze,Gr&&this.prepopulate(Gr)}prepopulate(ze){for(let Gr=0;Gr<ze;Gr++)this._pool[this._index++]=new this._classType;this._count+=ze}get(ze){var Wr;let Gr;return this._index>0?Gr=this._pool[--this._index]:Gr=new this._classType,(Wr=Gr.init)==null||Wr.call(Gr,ze),Gr}return(ze){var Gr;(Gr=ze.reset)==null||Gr.call(ze),this._pool[this._index++]=ze}get totalSize(){return this._count}get totalFree(){return this._index}get totalUsed(){return this._count-this._index}clear(){this._pool.length=0,this._index=0}}class PoolGroupClass{constructor(){this._poolsByClass=new Map}prepopulate(ze,Gr){this.getPool(ze).prepopulate(Gr)}get(ze,Gr){return this.getPool(ze).get(Gr)}return(ze){this.getPool(ze.constructor).return(ze)}getPool(ze){return this._poolsByClass.has(ze)||this._poolsByClass.set(ze,new Pool(ze)),this._poolsByClass.get(ze)}stats(){const ze={};return this._poolsByClass.forEach(Gr=>{const Wr=ze[Gr._classType.name]?Gr._classType.name+Gr._classType.ID:Gr._classType.name;ze[Wr]={free:Gr.totalFree,used:Gr.totalUsed,size:Gr.totalSize}}),ze}}const BigPool=new PoolGroupClass,cacheAsTextureMixin={get isCachedAsTexture(){var Yr;return!!((Yr=this.renderGroup)!=null&&Yr.isCachedAsTexture)},cacheAsTexture(Yr){typeof Yr=="boolean"&&Yr===!1?this.disableRenderGroup():(this.enableRenderGroup(),this.renderGroup.enableCacheAsTexture(Yr===!0?{}:Yr))},updateCacheTexture(){var Yr;(Yr=this.renderGroup)==null||Yr.updateCacheTexture()},get cacheAsBitmap(){return this.isCachedAsTexture},set cacheAsBitmap(Yr){deprecation("v8.6.0","cacheAsBitmap is deprecated, use cacheAsTexture instead."),this.cacheAsTexture(Yr)}};function removeItems(Yr,ze,Gr){const Wr=Yr.length;let Kr;if(ze>=Wr||Gr===0)return;Gr=ze+Gr>Wr?Wr-ze:Gr;const Zr=Wr-Gr;for(Kr=ze;Kr<Zr;++Kr)Yr[Kr]=Yr[Kr+Gr];Yr.length=Zr}const childrenHelperMixin={allowChildren:!0,removeChildren(Yr=0,ze){const Gr=ze??this.children.length,Wr=Gr-Yr,Kr=[];if(Wr>0&&Wr<=Gr){for(let Qr=Gr-1;Qr>=Yr;Qr--){const Jr=this.children[Qr];Jr&&(Kr.push(Jr),Jr.parent=null)}removeItems(this.children,Yr,Gr);const Zr=this.renderGroup||this.parentRenderGroup;Zr&&Zr.removeChildren(Kr);for(let Qr=0;Qr<Kr.length;++Qr)this.emit("childRemoved",Kr[Qr],this,Qr),Kr[Qr].emit("removed",this);return Kr.length>0&&this._didViewChangeTick++,Kr}else if(Wr===0&&this.children.length===0)return Kr;throw new RangeError("removeChildren: numeric values are outside the acceptable range.")},removeChildAt(Yr){const ze=this.getChildAt(Yr);return this.removeChild(ze)},getChildAt(Yr){if(Yr<0||Yr>=this.children.length)throw new Error(`getChildAt: Index (${Yr}) does not exist.`);return this.children[Yr]},setChildIndex(Yr,ze){if(ze<0||ze>=this.children.length)throw new Error(`The index ${ze} supplied is out of bounds ${this.children.length}`);this.getChildIndex(Yr),this.addChildAt(Yr,ze)},getChildIndex(Yr){const ze=this.children.indexOf(Yr);if(ze===-1)throw new Error("The supplied Container must be a child of the caller");return ze},addChildAt(Yr,ze){this.allowChildren||deprecation(v8_0_0,"addChildAt: Only Containers will be allowed to add children in v8.0.0");const{children:Gr}=this;if(ze<0||ze>Gr.length)throw new Error(`${Yr}addChildAt: The index ${ze} supplied is out of bounds ${Gr.length}`);if(Yr.parent){const Kr=Yr.parent.children.indexOf(Yr);if(Yr.parent===this&&Kr===ze)return Yr;Kr!==-1&&Yr.parent.children.splice(Kr,1)}ze===Gr.length?Gr.push(Yr):Gr.splice(ze,0,Yr),Yr.parent=this,Yr.didChange=!0,Yr._updateFlags=15;const Wr=this.renderGroup||this.parentRenderGroup;return Wr&&Wr.addChild(Yr),this.sortableChildren&&(this.sortDirty=!0),this.emit("childAdded",Yr,this,ze),Yr.emit("added",this),Yr},swapChildren(Yr,ze){if(Yr===ze)return;const Gr=this.getChildIndex(Yr),Wr=this.getChildIndex(ze);this.children[Gr]=ze,this.children[Wr]=Yr;const Kr=this.renderGroup||this.parentRenderGroup;Kr&&(Kr.structureDidChange=!0),this._didContainerChangeTick++},removeFromParent(){var Yr;(Yr=this.parent)==null||Yr.removeChild(this)},reparentChild(...Yr){return Yr.length===1?this.reparentChildAt(Yr[0],this.children.length):(Yr.forEach(ze=>this.reparentChildAt(ze,this.children.length)),Yr[0])},reparentChildAt(Yr,ze){if(Yr.parent===this)return this.setChildIndex(Yr,ze),Yr;const Gr=Yr.worldTransform.clone();Yr.removeFromParent(),this.addChildAt(Yr,ze);const Wr=this.worldTransform.clone();return Wr.invert(),Gr.prepend(Wr),Yr.setFromMatrix(Gr),Yr}},collectRenderablesMixin={collectRenderables(Yr,ze,Gr){this.parentRenderLayer&&this.parentRenderLayer!==Gr||this.globalDisplayStatus<7||!this.includeInBuild||(this.sortableChildren&&this.sortChildren(),this.isSimple?this.collectRenderablesSimple(Yr,ze,Gr):this.renderGroup?ze.renderPipes.renderGroup.addRenderGroup(this.renderGroup,Yr):this.collectRenderablesWithEffects(Yr,ze,Gr))},collectRenderablesSimple(Yr,ze,Gr){const Wr=this.children,Kr=Wr.length;for(let Zr=0;Zr<Kr;Zr++)Wr[Zr].collectRenderables(Yr,ze,Gr)},collectRenderablesWithEffects(Yr,ze,Gr){const{renderPipes:Wr}=ze;for(let Kr=0;Kr<this.effects.length;Kr++){const Zr=this.effects[Kr];Wr[Zr.pipe].push(Zr,this,Yr)}this.collectRenderablesSimple(Yr,ze,Gr);for(let Kr=this.effects.length-1;Kr>=0;Kr--){const Zr=this.effects[Kr];Wr[Zr.pipe].pop(Zr,this,Yr)}}};class FilterEffect{constructor(){this.pipe="filter",this.priority=1}destroy(){for(let ze=0;ze<this.filters.length;ze++)this.filters[ze].destroy();this.filters=null,this.filterArea=null}}class MaskEffectManagerClass{constructor(){this._effectClasses=[],this._tests=[],this._initialized=!1}init(){this._initialized||(this._initialized=!0,this._effectClasses.forEach(ze=>{this.add({test:ze.test,maskClass:ze})}))}add(ze){this._tests.push(ze)}getMaskEffect(ze){this._initialized||this.init();for(let Gr=0;Gr<this._tests.length;Gr++){const Wr=this._tests[Gr];if(Wr.test(ze))return BigPool.get(Wr.maskClass,ze)}return ze}returnMaskEffect(ze){BigPool.return(ze)}}const MaskEffectManager=new MaskEffectManagerClass;extensions.handleByList(ExtensionType.MaskEffect,MaskEffectManager._effectClasses);const effectsMixin={_maskEffect:null,_maskOptions:{inverse:!1},_filterEffect:null,effects:[],_markStructureAsChanged(){const Yr=this.renderGroup||this.parentRenderGroup;Yr&&(Yr.structureDidChange=!0)},addEffect(Yr){this.effects.indexOf(Yr)===-1&&(this.effects.push(Yr),this.effects.sort((Gr,Wr)=>Gr.priority-Wr.priority),this._markStructureAsChanged(),this._updateIsSimple())},removeEffect(Yr){const ze=this.effects.indexOf(Yr);ze!==-1&&(this.effects.splice(ze,1),this._markStructureAsChanged(),this._updateIsSimple())},set mask(Yr){const ze=this._maskEffect;(ze==null?void 0:ze.mask)!==Yr&&(ze&&(this.removeEffect(ze),MaskEffectManager.returnMaskEffect(ze),this._maskEffect=null),Yr!=null&&(this._maskEffect=MaskEffectManager.getMaskEffect(Yr),this.addEffect(this._maskEffect)))},setMask(Yr){this._maskOptions={...this._maskOptions,...Yr},Yr.mask&&(this.mask=Yr.mask),this._markStructureAsChanged()},get mask(){var Yr;return(Yr=this._maskEffect)==null?void 0:Yr.mask},set filters(Yr){var Zr;!Array.isArray(Yr)&&Yr&&(Yr=[Yr]);const ze=this._filterEffect||(this._filterEffect=new FilterEffect);Yr=Yr;const Gr=(Yr==null?void 0:Yr.length)>0,Wr=((Zr=ze.filters)==null?void 0:Zr.length)>0,Kr=Gr!==Wr;Yr=Array.isArray(Yr)?Yr.slice(0):Yr,ze.filters=Object.freeze(Yr),Kr&&(Gr?this.addEffect(ze):(this.removeEffect(ze),ze.filters=Yr??null))},get filters(){var Yr;return(Yr=this._filterEffect)==null?void 0:Yr.filters},set filterArea(Yr){this._filterEffect||(this._filterEffect=new FilterEffect),this._filterEffect.filterArea=Yr},get filterArea(){var Yr;return(Yr=this._filterEffect)==null?void 0:Yr.filterArea}},findMixin={label:null,get name(){return deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label},set name(Yr){deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label=Yr},getChildByName(Yr,ze=!1){return this.getChildByLabel(Yr,ze)},getChildByLabel(Yr,ze=!1){const Gr=this.children;for(let Wr=0;Wr<Gr.length;Wr++){const Kr=Gr[Wr];if(Kr.label===Yr||Yr instanceof RegExp&&Yr.test(Kr.label))return Kr}if(ze)for(let Wr=0;Wr<Gr.length;Wr++){const Zr=Gr[Wr].getChildByLabel(Yr,!0);if(Zr)return Zr}return null},getChildrenByLabel(Yr,ze=!1,Gr=[]){const Wr=this.children;for(let Kr=0;Kr<Wr.length;Kr++){const Zr=Wr[Kr];(Zr.label===Yr||Yr instanceof RegExp&&Yr.test(Zr.label))&&Gr.push(Zr)}if(ze)for(let Kr=0;Kr<Wr.length;Kr++)Wr[Kr].getChildrenByLabel(Yr,!0,Gr);return Gr}},matrixPool=new Pool(Matrix),boundsPool=new Pool(Bounds),tempMatrix$4=new Matrix,getFastGlobalBoundsMixin={getFastGlobalBounds(Yr,ze){ze||(ze=new Bounds),ze.clear(),this._getGlobalBoundsRecursive(!!Yr,ze,this.parentRenderLayer),ze.isValid||ze.set(0,0,0,0);const Gr=this.renderGroup||this.parentRenderGroup;return ze.applyMatrix(Gr.worldTransform),ze},_getGlobalBoundsRecursive(Yr,ze,Gr){let Wr=ze;if(Yr&&this.parentRenderLayer&&this.parentRenderLayer!==Gr||this.localDisplayStatus!==7||!this.measurable)return;const Kr=!!this.effects.length;if((this.renderGroup||Kr)&&(Wr=boundsPool.get().clear()),this.boundsArea)ze.addRect(this.boundsArea,this.worldTransform);else{if(this.renderPipeId){const Qr=this.bounds;Wr.addFrame(Qr.minX,Qr.minY,Qr.maxX,Qr.maxY,this.groupTransform)}const Zr=this.children;for(let Qr=0;Qr<Zr.length;Qr++)Zr[Qr]._getGlobalBoundsRecursive(Yr,Wr,Gr)}if(Kr){let Zr=!1;const Qr=this.renderGroup||this.parentRenderGroup;for(let Jr=0;Jr<this.effects.length;Jr++)this.effects[Jr].addBounds&&(Zr||(Zr=!0,Wr.applyMatrix(Qr.worldTransform)),this.effects[Jr].addBounds(Wr,!0));Zr&&(Wr.applyMatrix(Qr.worldTransform.copyTo(tempMatrix$4).invert()),ze.addBounds(Wr,this.relativeGroupTransform)),ze.addBounds(Wr),boundsPool.return(Wr)}else this.renderGroup&&(ze.addBounds(Wr,this.relativeGroupTransform),boundsPool.return(Wr))}};function getGlobalBounds(Yr,ze,Gr){Gr.clear();let Wr,Kr;return Yr.parent?ze?Wr=Yr.parent.worldTransform:(Kr=matrixPool.get().identity(),Wr=updateTransformBackwards(Yr,Kr)):Wr=Matrix.IDENTITY,_getGlobalBounds(Yr,Gr,Wr,ze),Kr&&matrixPool.return(Kr),Gr.isValid||Gr.set(0,0,0,0),Gr}function _getGlobalBounds(Yr,ze,Gr,Wr){var Jr,ei;if(!Yr.visible||!Yr.measurable)return;let Kr;Wr?Kr=Yr.worldTransform:(Yr.updateLocalTransform(),Kr=matrixPool.get(),Kr.appendFrom(Yr.localTransform,Gr));const Zr=ze,Qr=!!Yr.effects.length;if(Qr&&(ze=boundsPool.get().clear()),Yr.boundsArea)ze.addRect(Yr.boundsArea,Kr);else{Yr.bounds&&(ze.matrix=Kr,ze.addBounds(Yr.bounds));for(let ti=0;ti<Yr.children.length;ti++)_getGlobalBounds(Yr.children[ti],ze,Kr,Wr)}if(Qr){for(let ti=0;ti<Yr.effects.length;ti++)(ei=(Jr=Yr.effects[ti]).addBounds)==null||ei.call(Jr,ze);Zr.addBounds(ze,Matrix.IDENTITY),boundsPool.return(ze)}Wr||matrixPool.return(Kr)}function updateTransformBackwards(Yr,ze){const Gr=Yr.parent;return Gr&&(updateTransformBackwards(Gr,ze),Gr.updateLocalTransform(),ze.append(Gr.localTransform)),ze}function multiplyHexColors(Yr,ze){if(Yr===16777215||!ze)return ze;if(ze===16777215||!Yr)return Yr;const Gr=Yr>>16&255,Wr=Yr>>8&255,Kr=Yr&255,Zr=ze>>16&255,Qr=ze>>8&255,Jr=ze&255,ei=Gr*Zr/255|0,ti=Wr*Qr/255|0,ri=Kr*Jr/255|0;return(ei<<16)+(ti<<8)+ri}const WHITE_BGR=16777215;function multiplyColors(Yr,ze){return Yr===WHITE_BGR?ze:ze===WHITE_BGR?Yr:multiplyHexColors(Yr,ze)}function bgr2rgb(Yr){return((Yr&255)<<16)+(Yr&65280)+(Yr>>16&255)}const getGlobalMixin={getGlobalAlpha(Yr){if(Yr)return this.renderGroup?this.renderGroup.worldAlpha:this.parentRenderGroup?this.parentRenderGroup.worldAlpha*this.alpha:this.alpha;let ze=this.alpha,Gr=this.parent;for(;Gr;)ze*=Gr.alpha,Gr=Gr.parent;return ze},getGlobalTransform(Yr,ze){if(ze)return Yr.copyFrom(this.worldTransform);this.updateLocalTransform();const Gr=updateTransformBackwards(this,matrixPool.get().identity());return Yr.appendFrom(this.localTransform,Gr),matrixPool.return(Gr),Yr},getGlobalTint(Yr){if(Yr)return this.renderGroup?bgr2rgb(this.renderGroup.worldColor):this.parentRenderGroup?bgr2rgb(multiplyColors(this.localColor,this.parentRenderGroup.worldColor)):this.tint;let ze=this.localColor,Gr=this.parent;for(;Gr;)ze=multiplyColors(ze,Gr.localColor),Gr=Gr.parent;return bgr2rgb(ze)}};let warnCount=0;const maxWarnings=500;function warn(...Yr){warnCount!==maxWarnings&&(warnCount++,warnCount===maxWarnings?console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."):console.warn("PixiJS Warning: ",...Yr))}function getLocalBounds(Yr,ze,Gr){return ze.clear(),Gr||(Gr=Matrix.IDENTITY),_getLocalBounds(Yr,ze,Gr,Yr,!0),ze.isValid||ze.set(0,0,0,0),ze}function _getLocalBounds(Yr,ze,Gr,Wr,Kr){var ei,ti;let Zr;if(Kr)Zr=matrixPool.get(),Zr=Gr.copyTo(Zr);else{if(!Yr.visible||!Yr.measurable)return;Yr.updateLocalTransform();const ri=Yr.localTransform;Zr=matrixPool.get(),Zr.appendFrom(ri,Gr)}const Qr=ze,Jr=!!Yr.effects.length;if(Jr&&(ze=boundsPool.get().clear()),Yr.boundsArea)ze.addRect(Yr.boundsArea,Zr);else{Yr.renderPipeId&&(ze.matrix=Zr,ze.addBounds(Yr.bounds));const ri=Yr.children;for(let ii=0;ii<ri.length;ii++)_getLocalBounds(ri[ii],ze,Zr,Wr,!1)}if(Jr){for(let ri=0;ri<Yr.effects.length;ri++)(ti=(ei=Yr.effects[ri]).addLocalBounds)==null||ti.call(ei,ze,Wr);Qr.addBounds(ze,Matrix.IDENTITY),boundsPool.return(ze)}matrixPool.return(Zr)}function checkChildrenDidChange(Yr,ze){const Gr=Yr.children;for(let Wr=0;Wr<Gr.length;Wr++){const Kr=Gr[Wr],Zr=Kr.uid,Qr=(Kr._didViewChangeTick&65535)<<16|Kr._didContainerChangeTick&65535,Jr=ze.index;(ze.data[Jr]!==Zr||ze.data[Jr+1]!==Qr)&&(ze.data[ze.index]=Zr,ze.data[ze.index+1]=Qr,ze.didChange=!0),ze.index=Jr+2,Kr.children.length&&checkChildrenDidChange(Kr,ze)}return ze.didChange}const tempMatrix$3=new Matrix,measureMixin={_localBoundsCacheId:-1,_localBoundsCacheData:null,_setWidth(Yr,ze){const Gr=Math.sign(this.scale.x)||1;ze!==0?this.scale.x=Yr/ze*Gr:this.scale.x=Gr},_setHeight(Yr,ze){const Gr=Math.sign(this.scale.y)||1;ze!==0?this.scale.y=Yr/ze*Gr:this.scale.y=Gr},getLocalBounds(){this._localBoundsCacheData||(this._localBoundsCacheData={data:[],index:1,didChange:!1,localBounds:new Bounds});const Yr=this._localBoundsCacheData;return Yr.index=1,Yr.didChange=!1,Yr.data[0]!==this._didViewChangeTick&&(Yr.didChange=!0,Yr.data[0]=this._didViewChangeTick),checkChildrenDidChange(this,Yr),Yr.didChange&&getLocalBounds(this,Yr.localBounds,tempMatrix$3),Yr.localBounds},getBounds(Yr,ze){return getGlobalBounds(this,Yr,ze||new Bounds)}},onRenderMixin={_onRender:null,set onRender(Yr){const ze=this.renderGroup||this.parentRenderGroup;if(!Yr){this._onRender&&(ze==null||ze.removeOnRender(this)),this._onRender=null;return}this._onRender||ze==null||ze.addOnRender(this),this._onRender=Yr},get onRender(){return this._onRender}},sortMixin={_zIndex:0,sortDirty:!1,sortableChildren:!1,get zIndex(){return this._zIndex},set zIndex(Yr){this._zIndex!==Yr&&(this._zIndex=Yr,this.depthOfChildModified())},depthOfChildModified(){this.parent&&(this.parent.sortableChildren=!0,this.parent.sortDirty=!0),this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0)},sortChildren(){this.sortDirty&&(this.sortDirty=!1,this.children.sort(sortChildren))}};function sortChildren(Yr,ze){return Yr._zIndex-ze._zIndex}const toLocalGlobalMixin={getGlobalPosition(Yr=new Point$1,ze=!1){return this.parent?this.parent.toGlobal(this._position,Yr,ze):(Yr.x=this._position.x,Yr.y=this._position.y),Yr},toGlobal(Yr,ze,Gr=!1){const Wr=this.getGlobalTransform(matrixPool.get(),Gr);return ze=Wr.apply(Yr,ze),matrixPool.return(Wr),ze},toLocal(Yr,ze,Gr,Wr){ze&&(Yr=ze.toGlobal(Yr,Gr,Wr));const Kr=this.getGlobalTransform(matrixPool.get(),Wr);return Gr=Kr.applyInverse(Yr,Gr),matrixPool.return(Kr),Gr}};class InstructionSet{constructor(){this.uid=uid$1("instructionSet"),this.instructions=[],this.instructionSize=0,this.renderables=[],this.gcTick=0}reset(){this.instructionSize=0}add(ze){this.instructions[this.instructionSize++]=ze}log(){this.instructions.length=this.instructionSize,console.table(this.instructions,["type","action"])}}let count=0;class TexturePoolClass{constructor(ze){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=ze||{},this.enableFullScreen=!1}createTexture(ze,Gr,Wr){const Kr=new TextureSource({...this.textureOptions,width:ze,height:Gr,resolution:1,antialias:Wr,autoGarbageCollect:!1});return new Texture({source:Kr,label:`texturePool_${count++}`})}getOptimalTexture(ze,Gr,Wr=1,Kr){let Zr=Math.ceil(ze*Wr-1e-6),Qr=Math.ceil(Gr*Wr-1e-6);Zr=nextPow2(Zr),Qr=nextPow2(Qr);const Jr=(Zr<<17)+(Qr<<1)+(Kr?1:0);this._texturePool[Jr]||(this._texturePool[Jr]=[]);let ei=this._texturePool[Jr].pop();return ei||(ei=this.createTexture(Zr,Qr,Kr)),ei.source._resolution=Wr,ei.source.width=Zr/Wr,ei.source.height=Qr/Wr,ei.source.pixelWidth=Zr,ei.source.pixelHeight=Qr,ei.frame.x=0,ei.frame.y=0,ei.frame.width=ze,ei.frame.height=Gr,ei.updateUvs(),this._poolKeyHash[ei.uid]=Jr,ei}getSameSizeTexture(ze,Gr=!1){const Wr=ze.source;return this.getOptimalTexture(ze.width,ze.height,Wr._resolution,Gr)}returnTexture(ze){const Gr=this._poolKeyHash[ze.uid];this._texturePool[Gr].push(ze)}clear(ze){if(ze=ze!==!1,ze)for(const Gr in this._texturePool){const Wr=this._texturePool[Gr];if(Wr)for(let Kr=0;Kr<Wr.length;Kr++)Wr[Kr].destroy(!0)}this._texturePool={}}}const TexturePool=new TexturePoolClass;class RenderGroup{constructor(){this.renderPipeId="renderGroup",this.root=null,this.canBundle=!1,this.renderGroupParent=null,this.renderGroupChildren=[],this.worldTransform=new Matrix,this.worldColorAlpha=4294967295,this.worldColor=16777215,this.worldAlpha=1,this.childrenToUpdate=Object.create(null),this.updateTick=0,this.gcTick=0,this.childrenRenderablesToUpdate={list:[],index:0},this.structureDidChange=!0,this.instructionSet=new InstructionSet,this._onRenderContainers=[],this.textureNeedsUpdate=!0,this.isCachedAsTexture=!1,this._matrixDirty=7}init(ze){this.root=ze,ze._onRender&&this.addOnRender(ze),ze.didChange=!0;const Gr=ze.children;for(let Wr=0;Wr<Gr.length;Wr++){const Kr=Gr[Wr];Kr._updateFlags=15,this.addChild(Kr)}}enableCacheAsTexture(ze={}){this.textureOptions=ze,this.isCachedAsTexture=!0,this.textureNeedsUpdate=!0}disableCacheAsTexture(){this.isCachedAsTexture=!1,this.texture&&(TexturePool.returnTexture(this.texture),this.texture=null)}updateCacheTexture(){this.textureNeedsUpdate=!0}reset(){this.renderGroupChildren.length=0;for(const ze in this.childrenToUpdate){const Gr=this.childrenToUpdate[ze];Gr.list.fill(null),Gr.index=0}this.childrenRenderablesToUpdate.index=0,this.childrenRenderablesToUpdate.list.fill(null),this.root=null,this.updateTick=0,this.structureDidChange=!0,this._onRenderContainers.length=0,this.renderGroupParent=null,this.disableCacheAsTexture()}get localTransform(){return this.root.localTransform}addRenderGroupChild(ze){ze.renderGroupParent&&ze.renderGroupParent._removeRenderGroupChild(ze),ze.renderGroupParent=this,this.renderGroupChildren.push(ze)}_removeRenderGroupChild(ze){const Gr=this.renderGroupChildren.indexOf(ze);Gr>-1&&this.renderGroupChildren.splice(Gr,1),ze.renderGroupParent=null}addChild(ze){if(this.structureDidChange=!0,ze.parentRenderGroup=this,ze.updateTick=-1,ze.parent===this.root?ze.relativeRenderGroupDepth=1:ze.relativeRenderGroupDepth=ze.parent.relativeRenderGroupDepth+1,ze.didChange=!0,this.onChildUpdate(ze),ze.renderGroup){this.addRenderGroupChild(ze.renderGroup);return}ze._onRender&&this.addOnRender(ze);const Gr=ze.children;for(let Wr=0;Wr<Gr.length;Wr++)this.addChild(Gr[Wr])}removeChild(ze){if(this.structureDidChange=!0,ze._onRender&&(ze.renderGroup||this.removeOnRender(ze)),ze.parentRenderGroup=null,ze.renderGroup){this._removeRenderGroupChild(ze.renderGroup);return}const Gr=ze.children;for(let Wr=0;Wr<Gr.length;Wr++)this.removeChild(Gr[Wr])}removeChildren(ze){for(let Gr=0;Gr<ze.length;Gr++)this.removeChild(ze[Gr])}onChildUpdate(ze){let Gr=this.childrenToUpdate[ze.relativeRenderGroupDepth];Gr||(Gr=this.childrenToUpdate[ze.relativeRenderGroupDepth]={index:0,list:[]}),Gr.list[Gr.index++]=ze}updateRenderable(ze){ze.globalDisplayStatus<7||(this.instructionSet.renderPipes[ze.renderPipeId].updateRenderable(ze),ze.didViewUpdate=!1)}onChildViewUpdate(ze){this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++]=ze}get isRenderable(){return this.root.localDisplayStatus===7&&this.worldAlpha>0}addOnRender(ze){this._onRenderContainers.push(ze)}removeOnRender(ze){this._onRenderContainers.splice(this._onRenderContainers.indexOf(ze),1)}runOnRender(ze){for(let Gr=0;Gr<this._onRenderContainers.length;Gr++)this._onRenderContainers[Gr]._onRender(ze)}destroy(){this.disableCacheAsTexture(),this.renderGroupParent=null,this.root=null,this.childrenRenderablesToUpdate=null,this.childrenToUpdate=null,this.renderGroupChildren=null,this._onRenderContainers=null,this.instructionSet=null}getChildren(ze=[]){const Gr=this.root.children;for(let Wr=0;Wr<Gr.length;Wr++)this._getChildren(Gr[Wr],ze);return ze}_getChildren(ze,Gr=[]){if(Gr.push(ze),ze.renderGroup)return Gr;const Wr=ze.children;for(let Kr=0;Kr<Wr.length;Kr++)this._getChildren(Wr[Kr],Gr);return Gr}invalidateMatrices(){this._matrixDirty=7}get inverseWorldTransform(){return(this._matrixDirty&1)===0?this._inverseWorldTransform:(this._matrixDirty&=-2,this._inverseWorldTransform||(this._inverseWorldTransform=new Matrix),this._inverseWorldTransform.copyFrom(this.worldTransform).invert())}get textureOffsetInverseTransform(){return(this._matrixDirty&2)===0?this._textureOffsetInverseTransform:(this._matrixDirty&=-3,this._textureOffsetInverseTransform||(this._textureOffsetInverseTransform=new Matrix),this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x,-this._textureBounds.y))}get inverseParentTextureTransform(){if((this._matrixDirty&4)===0)return this._inverseParentTextureTransform;this._matrixDirty&=-5;const ze=this._parentCacheAsTextureRenderGroup;return ze?(this._inverseParentTextureTransform||(this._inverseParentTextureTransform=new Matrix),this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(ze.inverseWorldTransform).translate(-ze._textureBounds.x,-ze._textureBounds.y)):this.worldTransform}get cacheToLocalTransform(){return this._parentCacheAsTextureRenderGroup?this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform:null}}function assignWithIgnore(Yr,ze,Gr={}){for(const Wr in ze)!Gr[Wr]&&ze[Wr]!==void 0&&(Yr[Wr]=ze[Wr])}const defaultSkew=new ObservablePoint(null),defaultPivot=new ObservablePoint(null),defaultScale=new ObservablePoint(null,1,1),UPDATE_COLOR=1,UPDATE_BLEND=2,UPDATE_VISIBLE=4;class Container extends EventEmitter{constructor(ze={}){var Gr,Wr;super(),this.uid=uid$1("renderable"),this._updateFlags=15,this.renderGroup=null,this.parentRenderGroup=null,this.parentRenderGroupIndex=0,this.didChange=!1,this.didViewUpdate=!1,this.relativeRenderGroupDepth=0,this.children=[],this.parent=null,this.includeInBuild=!0,this.measurable=!0,this.isSimple=!0,this.updateTick=-1,this.localTransform=new Matrix,this.relativeGroupTransform=new Matrix,this.groupTransform=this.relativeGroupTransform,this.destroyed=!1,this._position=new ObservablePoint(this,0,0),this._scale=defaultScale,this._pivot=defaultPivot,this._skew=defaultSkew,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._rotation=0,this.localColor=16777215,this.localAlpha=1,this.groupAlpha=1,this.groupColor=16777215,this.groupColorAlpha=4294967295,this.localBlendMode="inherit",this.groupBlendMode="normal",this.localDisplayStatus=7,this.globalDisplayStatus=7,this._didContainerChangeTick=0,this._didViewChangeTick=0,this._didLocalTransformChangeId=-1,this.effects=[],assignWithIgnore(this,ze,{children:!0,parent:!0,effects:!0}),(Gr=ze.children)==null||Gr.forEach(Kr=>this.addChild(Kr)),(Wr=ze.parent)==null||Wr.addChild(this)}static mixin(ze){deprecation("8.8.0","Container.mixin is deprecated, please use extensions.mixin instead."),extensions.mixin(Container,ze)}set _didChangeId(ze){this._didViewChangeTick=ze>>12&4095,this._didContainerChangeTick=ze&4095}get _didChangeId(){return this._didContainerChangeTick&4095|(this._didViewChangeTick&4095)<<12}addChild(...ze){if(this.allowChildren||deprecation(v8_0_0,"addChild: Only Containers will be allowed to add children in v8.0.0"),ze.length>1){for(let Kr=0;Kr<ze.length;Kr++)this.addChild(ze[Kr]);return ze[0]}const Gr=ze[0],Wr=this.renderGroup||this.parentRenderGroup;return Gr.parent===this?(this.children.splice(this.children.indexOf(Gr),1),this.children.push(Gr),Wr&&(Wr.structureDidChange=!0),Gr):(Gr.parent&&Gr.parent.removeChild(Gr),this.children.push(Gr),this.sortableChildren&&(this.sortDirty=!0),Gr.parent=this,Gr.didChange=!0,Gr._updateFlags=15,Wr&&Wr.addChild(Gr),this.emit("childAdded",Gr,this,this.children.length-1),Gr.emit("added",this),this._didViewChangeTick++,Gr._zIndex!==0&&Gr.depthOfChildModified(),Gr)}removeChild(...ze){if(ze.length>1){for(let Kr=0;Kr<ze.length;Kr++)this.removeChild(ze[Kr]);return ze[0]}const Gr=ze[0],Wr=this.children.indexOf(Gr);return Wr>-1&&(this._didViewChangeTick++,this.children.splice(Wr,1),this.renderGroup?this.renderGroup.removeChild(Gr):this.parentRenderGroup&&this.parentRenderGroup.removeChild(Gr),Gr.parentRenderLayer&&Gr.parentRenderLayer.detach(Gr),Gr.parent=null,this.emit("childRemoved",Gr,this,Wr),Gr.emit("removed",this)),Gr}_onUpdate(ze){ze&&ze===this._skew&&this._updateSkew(),this._didContainerChangeTick++,!this.didChange&&(this.didChange=!0,this.parentRenderGroup&&this.parentRenderGroup.onChildUpdate(this))}set isRenderGroup(ze){!!this.renderGroup!==ze&&(ze?this.enableRenderGroup():this.disableRenderGroup())}get isRenderGroup(){return!!this.renderGroup}enableRenderGroup(){if(this.renderGroup)return;const ze=this.parentRenderGroup;ze==null||ze.removeChild(this),this.renderGroup=BigPool.get(RenderGroup,this),this.groupTransform=Matrix.IDENTITY,ze==null||ze.addChild(this),this._updateIsSimple()}disableRenderGroup(){if(!this.renderGroup)return;const ze=this.parentRenderGroup;ze==null||ze.removeChild(this),BigPool.return(this.renderGroup),this.renderGroup=null,this.groupTransform=this.relativeGroupTransform,ze==null||ze.addChild(this),this._updateIsSimple()}_updateIsSimple(){this.isSimple=!this.renderGroup&&this.effects.length===0}get worldTransform(){return this._worldTransform||(this._worldTransform=new Matrix),this.renderGroup?this._worldTransform.copyFrom(this.renderGroup.worldTransform):this.parentRenderGroup&&this._worldTransform.appendFrom(this.relativeGroupTransform,this.parentRenderGroup.worldTransform),this._worldTransform}get x(){return this._position.x}set x(ze){this._position.x=ze}get y(){return this._position.y}set y(ze){this._position.y=ze}get position(){return this._position}set position(ze){this._position.copyFrom(ze)}get rotation(){return this._rotation}set rotation(ze){this._rotation!==ze&&(this._rotation=ze,this._onUpdate(this._skew))}get angle(){return this.rotation*RAD_TO_DEG}set angle(ze){this.rotation=ze*DEG_TO_RAD}get pivot(){return this._pivot===defaultPivot&&(this._pivot=new ObservablePoint(this,0,0)),this._pivot}set pivot(ze){this._pivot===defaultPivot&&(this._pivot=new ObservablePoint(this,0,0)),typeof ze=="number"?this._pivot.set(ze):this._pivot.copyFrom(ze)}get skew(){return this._skew===defaultSkew&&(this._skew=new ObservablePoint(this,0,0)),this._skew}set skew(ze){this._skew===defaultSkew&&(this._skew=new ObservablePoint(this,0,0)),this._skew.copyFrom(ze)}get scale(){return this._scale===defaultScale&&(this._scale=new ObservablePoint(this,1,1)),this._scale}set scale(ze){this._scale===defaultScale&&(this._scale=new ObservablePoint(this,0,0)),typeof ze=="number"?this._scale.set(ze):this._scale.copyFrom(ze)}get width(){return Math.abs(this.scale.x*this.getLocalBounds().width)}set width(ze){const Gr=this.getLocalBounds().width;this._setWidth(ze,Gr)}get height(){return Math.abs(this.scale.y*this.getLocalBounds().height)}set height(ze){const Gr=this.getLocalBounds().height;this._setHeight(ze,Gr)}getSize(ze){ze||(ze={});const Gr=this.getLocalBounds();return ze.width=Math.abs(this.scale.x*Gr.width),ze.height=Math.abs(this.scale.y*Gr.height),ze}setSize(ze,Gr){const Wr=this.getLocalBounds();typeof ze=="object"?(Gr=ze.height??ze.width,ze=ze.width):Gr??(Gr=ze),ze!==void 0&&this._setWidth(ze,Wr.width),Gr!==void 0&&this._setHeight(Gr,Wr.height)}_updateSkew(){const ze=this._rotation,Gr=this._skew;this._cx=Math.cos(ze+Gr._y),this._sx=Math.sin(ze+Gr._y),this._cy=-Math.sin(ze-Gr._x),this._sy=Math.cos(ze-Gr._x)}updateTransform(ze){return this.position.set(typeof ze.x=="number"?ze.x:this.position.x,typeof ze.y=="number"?ze.y:this.position.y),this.scale.set(typeof ze.scaleX=="number"?ze.scaleX||1:this.scale.x,typeof ze.scaleY=="number"?ze.scaleY||1:this.scale.y),this.rotation=typeof ze.rotation=="number"?ze.rotation:this.rotation,this.skew.set(typeof ze.skewX=="number"?ze.skewX:this.skew.x,typeof ze.skewY=="number"?ze.skewY:this.skew.y),this.pivot.set(typeof ze.pivotX=="number"?ze.pivotX:this.pivot.x,typeof ze.pivotY=="number"?ze.pivotY:this.pivot.y),this}setFromMatrix(ze){ze.decompose(this)}updateLocalTransform(){const ze=this._didContainerChangeTick;if(this._didLocalTransformChangeId===ze)return;this._didLocalTransformChangeId=ze;const Gr=this.localTransform,Wr=this._scale,Kr=this._pivot,Zr=this._position,Qr=Wr._x,Jr=Wr._y,ei=Kr._x,ti=Kr._y;Gr.a=this._cx*Qr,Gr.b=this._sx*Qr,Gr.c=this._cy*Jr,Gr.d=this._sy*Jr,Gr.tx=Zr._x-(ei*Gr.a+ti*Gr.c),Gr.ty=Zr._y-(ei*Gr.b+ti*Gr.d)}set alpha(ze){ze!==this.localAlpha&&(this.localAlpha=ze,this._updateFlags|=UPDATE_COLOR,this._onUpdate())}get alpha(){return this.localAlpha}set tint(ze){const Wr=Color.shared.setValue(ze??16777215).toBgrNumber();Wr!==this.localColor&&(this.localColor=Wr,this._updateFlags|=UPDATE_COLOR,this._onUpdate())}get tint(){return bgr2rgb(this.localColor)}set blendMode(ze){this.localBlendMode!==ze&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_BLEND,this.localBlendMode=ze,this._onUpdate())}get blendMode(){return this.localBlendMode}get visible(){return!!(this.localDisplayStatus&2)}set visible(ze){const Gr=ze?2:0;(this.localDisplayStatus&2)!==Gr&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=2,this._onUpdate())}get culled(){return!(this.localDisplayStatus&4)}set culled(ze){const Gr=ze?0:4;(this.localDisplayStatus&4)!==Gr&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=4,this._onUpdate())}get renderable(){return!!(this.localDisplayStatus&1)}set renderable(ze){const Gr=ze?1:0;(this.localDisplayStatus&1)!==Gr&&(this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=1,this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._onUpdate())}get isRenderable(){return this.localDisplayStatus===7&&this.groupAlpha>0}destroy(ze=!1){var Kr;if(this.destroyed)return;this.destroyed=!0;let Gr;if(this.children.length&&(Gr=this.removeChildren(0,this.children.length)),this.removeFromParent(),this.parent=null,this._maskEffect=null,this._filterEffect=null,this.effects=null,this._position=null,this._scale=null,this._pivot=null,this._skew=null,this.emit("destroyed",this),this.removeAllListeners(),(typeof ze=="boolean"?ze:ze==null?void 0:ze.children)&&Gr)for(let Zr=0;Zr<Gr.length;++Zr)Gr[Zr].destroy(ze);(Kr=this.renderGroup)==null||Kr.destroy(),this.renderGroup=null}}extensions.mixin(Container,childrenHelperMixin,getFastGlobalBoundsMixin,toLocalGlobalMixin,onRenderMixin,measureMixin,effectsMixin,findMixin,sortMixin,cullingMixin,cacheAsTextureMixin,getGlobalMixin,collectRenderablesMixin);class ViewContainer extends Container{constructor(ze){super(ze),this.canBundle=!0,this.allowChildren=!1,this._roundPixels=0,this._lastUsed=-1,this._bounds=new Bounds(0,1,0,0),this._boundsDirty=!0}get bounds(){return this._boundsDirty?(this.updateBounds(),this._boundsDirty=!1,this._bounds):this._bounds}get roundPixels(){return!!this._roundPixels}set roundPixels(ze){this._roundPixels=ze?1:0}containsPoint(ze){const Gr=this.bounds,{x:Wr,y:Kr}=ze;return Wr>=Gr.minX&&Wr<=Gr.maxX&&Kr>=Gr.minY&&Kr<=Gr.maxY}onViewUpdate(){if(this._didViewChangeTick++,this._boundsDirty=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const ze=this.renderGroup||this.parentRenderGroup;ze&&ze.onChildViewUpdate(this)}destroy(ze){super.destroy(ze),this._bounds=null}collectRenderablesSimple(ze,Gr,Wr){const{renderPipes:Kr,renderableGC:Zr}=Gr;Kr.blendMode.setBlendMode(this,this.groupBlendMode,ze),Kr[this.renderPipeId].addRenderable(this,ze),Zr.addRenderable(this),this.didViewUpdate=!1;const Jr=this.children,ei=Jr.length;for(let ti=0;ti<ei;ti++)Jr[ti].collectRenderables(ze,Gr,Wr)}}class Sprite extends ViewContainer{constructor(ze=Texture.EMPTY){ze instanceof Texture&&(ze={texture:ze});const{texture:Gr=Texture.EMPTY,anchor:Wr,roundPixels:Kr,width:Zr,height:Qr,...Jr}=ze;super({label:"Sprite",...Jr}),this.renderPipeId="sprite",this.batched=!0,this._visualBounds={minX:0,maxX:1,minY:0,maxY:0},this._anchor=new ObservablePoint({_onUpdate:()=>{this.onViewUpdate()}}),Wr?this.anchor=Wr:Gr.defaultAnchor&&(this.anchor=Gr.defaultAnchor),this.texture=Gr,this.allowChildren=!1,this.roundPixels=Kr??!1,Zr!==void 0&&(this.width=Zr),Qr!==void 0&&(this.height=Qr)}static from(ze,Gr=!1){return ze instanceof Texture?new Sprite(ze):new Sprite(Texture.from(ze,Gr))}set texture(ze){ze||(ze=Texture.EMPTY);const Gr=this._texture;Gr!==ze&&(Gr&&Gr.dynamic&&Gr.off("update",this.onViewUpdate,this),ze.dynamic&&ze.on("update",this.onViewUpdate,this),this._texture=ze,this._width&&this._setWidth(this._width,this._texture.orig.width),this._height&&this._setHeight(this._height,this._texture.orig.height),this.onViewUpdate())}get texture(){return this._texture}get visualBounds(){return updateQuadBounds(this._visualBounds,this._anchor,this._texture),this._visualBounds}get sourceBounds(){return deprecation("8.6.1","Sprite.sourceBounds is deprecated, use visualBounds instead."),this.visualBounds}updateBounds(){const ze=this._anchor,Gr=this._texture,Wr=this._bounds,{width:Kr,height:Zr}=Gr.orig;Wr.minX=-ze._x*Kr,Wr.maxX=Wr.minX+Kr,Wr.minY=-ze._y*Zr,Wr.maxY=Wr.minY+Zr}destroy(ze=!1){if(super.destroy(ze),typeof ze=="boolean"?ze:ze==null?void 0:ze.texture){const Wr=typeof ze=="boolean"?ze:ze==null?void 0:ze.textureSource;this._texture.destroy(Wr)}this._texture=null,this._visualBounds=null,this._bounds=null,this._anchor=null}get anchor(){return this._anchor}set anchor(ze){typeof ze=="number"?this._anchor.set(ze):this._anchor.copyFrom(ze)}get width(){return Math.abs(this.scale.x)*this._texture.orig.width}set width(ze){this._setWidth(ze,this._texture.orig.width),this._width=ze}get height(){return Math.abs(this.scale.y)*this._texture.orig.height}set height(ze){this._setHeight(ze,this._texture.orig.height),this._height=ze}getSize(ze){return ze||(ze={}),ze.width=Math.abs(this.scale.x)*this._texture.orig.width,ze.height=Math.abs(this.scale.y)*this._texture.orig.height,ze}setSize(ze,Gr){typeof ze=="object"?(Gr=ze.height??ze.width,ze=ze.width):Gr??(Gr=ze),ze!==void 0&&this._setWidth(ze,this._texture.orig.width),Gr!==void 0&&this._setHeight(Gr,this._texture.orig.height)}}const tempBounds$3=new Bounds;function addMaskBounds(Yr,ze,Gr){const Wr=tempBounds$3;Yr.measurable=!0,getGlobalBounds(Yr,Gr,Wr),ze.addBoundsMask(Wr),Yr.measurable=!1}function addMaskLocalBounds(Yr,ze,Gr){const Wr=boundsPool.get();Yr.measurable=!0;const Kr=matrixPool.get().identity(),Zr=getMatrixRelativeToParent(Yr,Gr,Kr);getLocalBounds(Yr,Wr,Zr),Yr.measurable=!1,ze.addBoundsMask(Wr),matrixPool.return(Kr),boundsPool.return(Wr)}function getMatrixRelativeToParent(Yr,ze,Gr){return Yr?(Yr!==ze&&(getMatrixRelativeToParent(Yr.parent,ze,Gr),Yr.updateLocalTransform(),Gr.append(Yr.localTransform)),Gr):(warn("Mask bounds, renderable is not inside the root container"),Gr)}class AlphaMask{constructor(ze){this.priority=0,this.inverse=!1,this.pipe="alphaMask",ze!=null&&ze.mask&&this.init(ze.mask)}init(ze){this.mask=ze,this.renderMaskToTexture=!(ze instanceof Sprite),this.mask.renderable=this.renderMaskToTexture,this.mask.includeInBuild=!this.renderMaskToTexture,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask=null}addBounds(ze,Gr){this.inverse||addMaskBounds(this.mask,ze,Gr)}addLocalBounds(ze,Gr){addMaskLocalBounds(this.mask,ze,Gr)}containsPoint(ze,Gr){const Wr=this.mask;return Gr(Wr,ze)}destroy(){this.reset()}static test(ze){return ze instanceof Sprite}}AlphaMask.extension=ExtensionType.MaskEffect;class ColorMask{constructor(ze){this.priority=0,this.pipe="colorMask",ze!=null&&ze.mask&&this.init(ze.mask)}init(ze){this.mask=ze}destroy(){}static test(ze){return typeof ze=="number"}}ColorMask.extension=ExtensionType.MaskEffect;class StencilMask{constructor(ze){this.priority=0,this.pipe="stencilMask",ze!=null&&ze.mask&&this.init(ze.mask)}init(ze){this.mask=ze,this.mask.includeInBuild=!1,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask.includeInBuild=!0,this.mask=null}addBounds(ze,Gr){addMaskBounds(this.mask,ze,Gr)}addLocalBounds(ze,Gr){addMaskLocalBounds(this.mask,ze,Gr)}containsPoint(ze,Gr){const Wr=this.mask;return Gr(Wr,ze)}destroy(){this.reset()}static test(ze){return ze instanceof Container}}StencilMask.extension=ExtensionType.MaskEffect;const BrowserAdapter={createCanvas:(Yr,ze)=>{const Gr=document.createElement("canvas");return Gr.width=Yr,Gr.height=ze,Gr},getCanvasRenderingContext2D:()=>CanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>document.baseURI??window.location.href,getFontFaceSet:()=>document.fonts,fetch:(Yr,ze)=>fetch(Yr,ze),parseXML:Yr=>new DOMParser().parseFromString(Yr,"text/xml")};let currentAdapter=BrowserAdapter;const DOMAdapter={get(){return currentAdapter},set(Yr){currentAdapter=Yr}};class CanvasSource extends TextureSource{constructor(ze){ze.resource||(ze.resource=DOMAdapter.get().createCanvas()),ze.width||(ze.width=ze.resource.width,ze.autoDensity||(ze.width/=ze.resolution)),ze.height||(ze.height=ze.resource.height,ze.autoDensity||(ze.height/=ze.resolution)),super(ze),this.uploadMethodId="image",this.autoDensity=ze.autoDensity,this.resizeCanvas(),this.transparent=!!ze.transparent}resizeCanvas(){this.autoDensity&&"style"in this.resource&&(this.resource.style.width=`${this.width}px`,this.resource.style.height=`${this.height}px`),(this.resource.width!==this.pixelWidth||this.resource.height!==this.pixelHeight)&&(this.resource.width=this.pixelWidth,this.resource.height=this.pixelHeight)}resize(ze=this.width,Gr=this.height,Wr=this._resolution){const Kr=super.resize(ze,Gr,Wr);return Kr&&this.resizeCanvas(),Kr}static test(ze){return globalThis.HTMLCanvasElement&&ze instanceof HTMLCanvasElement||globalThis.OffscreenCanvas&&ze instanceof OffscreenCanvas}get context2D(){return this._context2D||(this._context2D=this.resource.getContext("2d"))}}CanvasSource.extension=ExtensionType.TextureSource;class ImageSource extends TextureSource{constructor(ze){if(ze.resource&&globalThis.HTMLImageElement&&ze.resource instanceof HTMLImageElement){const Gr=DOMAdapter.get().createCanvas(ze.resource.width,ze.resource.height);Gr.getContext("2d").drawImage(ze.resource,0,0,ze.resource.width,ze.resource.height),ze.resource=Gr,warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.")}super(ze),this.uploadMethodId="image",this.autoGarbageCollect=!0}static test(ze){return globalThis.HTMLImageElement&&ze instanceof HTMLImageElement||typeof ImageBitmap<"u"&&ze instanceof ImageBitmap||globalThis.VideoFrame&&ze instanceof VideoFrame}}ImageSource.extension=ExtensionType.TextureSource;var UPDATE_PRIORITY=(Yr=>(Yr[Yr.INTERACTION=50]="INTERACTION",Yr[Yr.HIGH=25]="HIGH",Yr[Yr.NORMAL=0]="NORMAL",Yr[Yr.LOW=-25]="LOW",Yr[Yr.UTILITY=-50]="UTILITY",Yr))(UPDATE_PRIORITY||{});class TickerListener{constructor(ze,Gr=null,Wr=0,Kr=!1){this.next=null,this.previous=null,this._destroyed=!1,this._fn=ze,this._context=Gr,this.priority=Wr,this._once=Kr}match(ze,Gr=null){return this._fn===ze&&this._context===Gr}emit(ze){this._fn&&(this._context?this._fn.call(this._context,ze):this._fn(ze));const Gr=this.next;return this._once&&this.destroy(!0),this._destroyed&&(this.next=null),Gr}connect(ze){this.previous=ze,ze.next&&(ze.next.previous=this),this.next=ze.next,ze.next=this}destroy(ze=!1){this._destroyed=!0,this._fn=null,this._context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);const Gr=this.next;return this.next=ze?null:Gr,this.previous=null,Gr}}const _Ticker=class Yi{constructor(){this.autoStart=!1,this.deltaTime=1,this.lastTime=-1,this.speed=1,this.started=!1,this._requestId=null,this._maxElapsedMS=100,this._minElapsedMS=0,this._protected=!1,this._lastFrame=-1,this._head=new TickerListener(null,null,1/0),this.deltaMS=1/Yi.targetFPMS,this.elapsedMS=1/Yi.targetFPMS,this._tick=ze=>{this._requestId=null,this.started&&(this.update(ze),this.started&&this._requestId===null&&this._head.next&&(this._requestId=requestAnimationFrame(this._tick)))}}_requestIfNeeded(){this._requestId===null&&this._head.next&&(this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))}_cancelIfNeeded(){this._requestId!==null&&(cancelAnimationFrame(this._requestId),this._requestId=null)}_startIfPossible(){this.started?this._requestIfNeeded():this.autoStart&&this.start()}add(ze,Gr,Wr=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(ze,Gr,Wr))}addOnce(ze,Gr,Wr=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(ze,Gr,Wr,!0))}_addListener(ze){let Gr=this._head.next,Wr=this._head;if(!Gr)ze.connect(Wr);else{for(;Gr;){if(ze.priority>Gr.priority){ze.connect(Wr);break}Wr=Gr,Gr=Gr.next}ze.previous||ze.connect(Wr)}return this._startIfPossible(),this}remove(ze,Gr){let Wr=this._head.next;for(;Wr;)Wr.match(ze,Gr)?Wr=Wr.destroy():Wr=Wr.next;return this._head.next||this._cancelIfNeeded(),this}get count(){if(!this._head)return 0;let ze=0,Gr=this._head;for(;Gr=Gr.next;)ze++;return ze}start(){this.started||(this.started=!0,this._requestIfNeeded())}stop(){this.started&&(this.started=!1,this._cancelIfNeeded())}destroy(){if(!this._protected){this.stop();let ze=this._head.next;for(;ze;)ze=ze.destroy(!0);this._head.destroy(),this._head=null}}update(ze=performance.now()){let Gr;if(ze>this.lastTime){if(Gr=this.elapsedMS=ze-this.lastTime,Gr>this._maxElapsedMS&&(Gr=this._maxElapsedMS),Gr*=this.speed,this._minElapsedMS){const Zr=ze-this._lastFrame|0;if(Zr<this._minElapsedMS)return;this._lastFrame=ze-Zr%this._minElapsedMS}this.deltaMS=Gr,this.deltaTime=this.deltaMS*Yi.targetFPMS;const Wr=this._head;let Kr=Wr.next;for(;Kr;)Kr=Kr.emit(this);Wr.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=ze}get FPS(){return 1e3/this.elapsedMS}get minFPS(){return 1e3/this._maxElapsedMS}set minFPS(ze){const Gr=Math.min(this.maxFPS,ze),Wr=Math.min(Math.max(0,Gr)/1e3,Yi.targetFPMS);this._maxElapsedMS=1/Wr}get maxFPS(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0}set maxFPS(ze){if(ze===0)this._minElapsedMS=0;else{const Gr=Math.max(this.minFPS,ze);this._minElapsedMS=1/(Gr/1e3)}}static get shared(){if(!Yi._shared){const ze=Yi._shared=new Yi;ze.autoStart=!0,ze._protected=!0}return Yi._shared}static get system(){if(!Yi._system){const ze=Yi._system=new Yi;ze.autoStart=!0,ze._protected=!0}return Yi._system}};_Ticker.targetFPMS=.06;let Ticker=_Ticker,promise;async function detectVideoAlphaMode(){return promise??(promise=(async()=>{var Qr;const ze=document.createElement("canvas").getContext("webgl");if(!ze)return"premultiply-alpha-on-upload";const Gr=await new Promise(Jr=>{const ei=document.createElement("video");ei.onloadeddata=()=>Jr(ei),ei.onerror=()=>Jr(null),ei.autoplay=!1,ei.crossOrigin="anonymous",ei.preload="auto",ei.src="data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",ei.load()});if(!Gr)return"premultiply-alpha-on-upload";const Wr=ze.createTexture();ze.bindTexture(ze.TEXTURE_2D,Wr);const Kr=ze.createFramebuffer();ze.bindFramebuffer(ze.FRAMEBUFFER,Kr),ze.framebufferTexture2D(ze.FRAMEBUFFER,ze.COLOR_ATTACHMENT0,ze.TEXTURE_2D,Wr,0),ze.pixelStorei(ze.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),ze.pixelStorei(ze.UNPACK_COLORSPACE_CONVERSION_WEBGL,ze.NONE),ze.texImage2D(ze.TEXTURE_2D,0,ze.RGBA,ze.RGBA,ze.UNSIGNED_BYTE,Gr);const Zr=new Uint8Array(4);return ze.readPixels(0,0,1,1,ze.RGBA,ze.UNSIGNED_BYTE,Zr),ze.deleteFramebuffer(Kr),ze.deleteTexture(Wr),(Qr=ze.getExtension("WEBGL_lose_context"))==null||Qr.loseContext(),Zr[0]<=Zr[3]?"premultiplied-alpha":"premultiply-alpha-on-upload"})()),promise}const _VideoSource=class Ts extends TextureSource{constructor(ze){super(ze),this.isReady=!1,this.uploadMethodId="video",ze={...Ts.defaultOptions,...ze},this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=ze.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=ze.autoPlay!==!1,this.alphaMode=ze.alphaMode??"premultiply-alpha-on-upload",this._videoFrameRequestCallback=this._videoFrameRequestCallback.bind(this),this._videoFrameRequestCallbackHandle=null,this._load=null,this._resolve=null,this._reject=null,this._onCanPlay=this._onCanPlay.bind(this),this._onCanPlayThrough=this._onCanPlayThrough.bind(this),this._onError=this._onError.bind(this),this._onPlayStart=this._onPlayStart.bind(this),this._onPlayStop=this._onPlayStop.bind(this),this._onSeeked=this._onSeeked.bind(this),ze.autoLoad!==!1&&this.load()}updateFrame(){if(!this.destroyed){if(this._updateFPS){const ze=Ticker.shared.elapsedMS*this.resource.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-ze)}(!this._updateFPS||this._msToNextUpdate<=0)&&(this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0),this.isValid&&this.update()}}_videoFrameRequestCallback(){this.updateFrame(),this.destroyed?this._videoFrameRequestCallbackHandle=null:this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)}get isValid(){return!!this.resource.videoWidth&&!!this.resource.videoHeight}async load(){if(this._load)return this._load;const ze=this.resource,Gr=this.options;return(ze.readyState===ze.HAVE_ENOUGH_DATA||ze.readyState===ze.HAVE_FUTURE_DATA)&&ze.width&&ze.height&&(ze.complete=!0),ze.addEventListener("play",this._onPlayStart),ze.addEventListener("pause",this._onPlayStop),ze.addEventListener("seeked",this._onSeeked),this._isSourceReady()?this._mediaReady():(Gr.preload||ze.addEventListener("canplay",this._onCanPlay),ze.addEventListener("canplaythrough",this._onCanPlayThrough),ze.addEventListener("error",this._onError,!0)),this.alphaMode=await detectVideoAlphaMode(),this._load=new Promise((Wr,Kr)=>{this.isValid?Wr(this):(this._resolve=Wr,this._reject=Kr,Gr.preloadTimeoutMs!==void 0&&(this._preloadTimeout=setTimeout(()=>{this._onError(new ErrorEvent(`Preload exceeded timeout of ${Gr.preloadTimeoutMs}ms`))})),ze.load())}),this._load}_onError(ze){this.resource.removeEventListener("error",this._onError,!0),this.emit("error",ze),this._reject&&(this._reject(ze),this._reject=null,this._resolve=null)}_isSourcePlaying(){const ze=this.resource;return!ze.paused&&!ze.ended}_isSourceReady(){return this.resource.readyState>2}_onPlayStart(){this.isValid||this._mediaReady(),this._configureAutoUpdate()}_onPlayStop(){this._configureAutoUpdate()}_onSeeked(){this._autoUpdate&&!this._isSourcePlaying()&&(this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0)}_onCanPlay(){this.resource.removeEventListener("canplay",this._onCanPlay),this._mediaReady()}_onCanPlayThrough(){this.resource.removeEventListener("canplaythrough",this._onCanPlay),this._preloadTimeout&&(clearTimeout(this._preloadTimeout),this._preloadTimeout=void 0),this._mediaReady()}_mediaReady(){const ze=this.resource;this.isValid&&(this.isReady=!0,this.resize(ze.videoWidth,ze.videoHeight)),this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0,this._resolve&&(this._resolve(this),this._resolve=null,this._reject=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&this.resource.play()}destroy(){this._configureAutoUpdate();const ze=this.resource;ze&&(ze.removeEventListener("play",this._onPlayStart),ze.removeEventListener("pause",this._onPlayStop),ze.removeEventListener("seeked",this._onSeeked),ze.removeEventListener("canplay",this._onCanPlay),ze.removeEventListener("canplaythrough",this._onCanPlayThrough),ze.removeEventListener("error",this._onError,!0),ze.pause(),ze.src="",ze.load()),super.destroy()}get autoUpdate(){return this._autoUpdate}set autoUpdate(ze){ze!==this._autoUpdate&&(this._autoUpdate=ze,this._configureAutoUpdate())}get updateFPS(){return this._updateFPS}set updateFPS(ze){ze!==this._updateFPS&&(this._updateFPS=ze,this._configureAutoUpdate())}_configureAutoUpdate(){this._autoUpdate&&this._isSourcePlaying()?!this._updateFPS&&this.resource.requestVideoFrameCallback?(this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0),this._videoFrameRequestCallbackHandle===null&&(this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker||(Ticker.shared.add(this.updateFrame,this),this._isConnectedToTicker=!0,this._msToNextUpdate=0)):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0))}static test(ze){return globalThis.HTMLVideoElement&&ze instanceof HTMLVideoElement}};_VideoSource.extension=ExtensionType.TextureSource;_VideoSource.defaultOptions={...TextureSource.defaultOptions,autoLoad:!0,autoPlay:!0,updateFPS:0,crossorigin:!0,loop:!1,muted:!0,playsinline:!0,preload:!1};_VideoSource.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};let VideoSource=_VideoSource;const convertToList=(Yr,ze,Gr=!1)=>(Array.isArray(Yr)||(Yr=[Yr]),ze?Yr.map(Wr=>typeof Wr=="string"||Gr?ze(Wr):Wr):Yr);class CacheClass{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(ze){return this._cache.has(ze)}get(ze){const Gr=this._cache.get(ze);return Gr||warn(`[Assets] Asset id ${ze} was not found in the Cache`),Gr}set(ze,Gr){const Wr=convertToList(ze);let Kr;for(let ei=0;ei<this.parsers.length;ei++){const ti=this.parsers[ei];if(ti.test(Gr)){Kr=ti.getCacheableAssets(Wr,Gr);break}}const Zr=new Map(Object.entries(Kr||{}));Kr||Wr.forEach(ei=>{Zr.set(ei,Gr)});const Qr=[...Zr.keys()],Jr={cacheKeys:Qr,keys:Wr};Wr.forEach(ei=>{this._cacheMap.set(ei,Jr)}),Qr.forEach(ei=>{const ti=Kr?Kr[ei]:Gr;this._cache.has(ei)&&this._cache.get(ei)!==ti&&warn("[Cache] already has key:",ei),this._cache.set(ei,Zr.get(ei))})}remove(ze){if(!this._cacheMap.has(ze)){warn(`[Assets] Asset id ${ze} was not found in the Cache`);return}const Gr=this._cacheMap.get(ze);Gr.cacheKeys.forEach(Kr=>{this._cache.delete(Kr)}),Gr.keys.forEach(Kr=>{this._cacheMap.delete(Kr)})}get parsers(){return this._parsers}}const Cache=new CacheClass,sources=[];extensions.handleByList(ExtensionType.TextureSource,sources);function textureSourceFrom(Yr={}){const ze=Yr&&Yr.resource,Gr=ze?Yr.resource:Yr,Wr=ze?Yr:{resource:Yr};for(let Kr=0;Kr<sources.length;Kr++){const Zr=sources[Kr];if(Zr.test(Gr))return new Zr(Wr)}throw new Error(`Could not find a source type for resource: ${Wr.resource}`)}function resourceToTexture(Yr={},ze=!1){const Gr=Yr&&Yr.resource,Wr=Gr?Yr.resource:Yr,Kr=Gr?Yr:{resource:Yr};if(!ze&&Cache.has(Wr))return Cache.get(Wr);const Zr=new Texture({source:textureSourceFrom(Kr)});return Zr.on("destroy",()=>{Cache.has(Wr)&&Cache.remove(Wr)}),ze||Cache.set(Wr,Zr),Zr}function textureFrom(Yr,ze=!1){return typeof Yr=="string"?Cache.get(Yr):Yr instanceof TextureSource?new Texture({source:Yr}):resourceToTexture(Yr,ze)}Texture.from=textureFrom;TextureSource.from=textureSourceFrom;extensions.add(AlphaMask,ColorMask,StencilMask,VideoSource,ImageSource,CanvasSource,BufferImageSource);var LoaderParserPriority=(Yr=>(Yr[Yr.Low=0]="Low",Yr[Yr.Normal=1]="Normal",Yr[Yr.High=2]="High",Yr))(LoaderParserPriority||{});function assertPath(Yr){if(typeof Yr!="string")throw new TypeError(`Path must be a string. Received ${JSON.stringify(Yr)}`)}function removeUrlParams(Yr){return Yr.split("?")[0].split("#")[0]}function escapeRegExp(Yr){return Yr.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function replaceAll(Yr,ze,Gr){return Yr.replace(new RegExp(escapeRegExp(ze),"g"),Gr)}function normalizeStringPosix(Yr,ze){let Gr="",Wr=0,Kr=-1,Zr=0,Qr=-1;for(let Jr=0;Jr<=Yr.length;++Jr){if(Jr<Yr.length)Qr=Yr.charCodeAt(Jr);else{if(Qr===47)break;Qr=47}if(Qr===47){if(!(Kr===Jr-1||Zr===1))if(Kr!==Jr-1&&Zr===2){if(Gr.length<2||Wr!==2||Gr.charCodeAt(Gr.length-1)!==46||Gr.charCodeAt(Gr.length-2)!==46){if(Gr.length>2){const ei=Gr.lastIndexOf("/");if(ei!==Gr.length-1){ei===-1?(Gr="",Wr=0):(Gr=Gr.slice(0,ei),Wr=Gr.length-1-Gr.lastIndexOf("/")),Kr=Jr,Zr=0;continue}}else if(Gr.length===2||Gr.length===1){Gr="",Wr=0,Kr=Jr,Zr=0;continue}}}else Gr.length>0?Gr+=`/${Yr.slice(Kr+1,Jr)}`:Gr=Yr.slice(Kr+1,Jr),Wr=Jr-Kr-1;Kr=Jr,Zr=0}else Qr===46&&Zr!==-1?++Zr:Zr=-1}return Gr}const path={toPosix(Yr){return replaceAll(Yr,"\\","/")},isUrl(Yr){return/^https?:/.test(this.toPosix(Yr))},isDataUrl(Yr){return/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(Yr)},isBlobUrl(Yr){return Yr.startsWith("blob:")},hasProtocol(Yr){return/^[^/:]+:/.test(this.toPosix(Yr))},getProtocol(Yr){assertPath(Yr),Yr=this.toPosix(Yr);const ze=/^file:\/\/\//.exec(Yr);if(ze)return ze[0];const Gr=/^[^/:]+:\/{0,2}/.exec(Yr);return Gr?Gr[0]:""},toAbsolute(Yr,ze,Gr){if(assertPath(Yr),this.isDataUrl(Yr)||this.isBlobUrl(Yr))return Yr;const Wr=removeUrlParams(this.toPosix(ze??DOMAdapter.get().getBaseUrl())),Kr=removeUrlParams(this.toPosix(Gr??this.rootname(Wr)));return Yr=this.toPosix(Yr),Yr.startsWith("/")?path.join(Kr,Yr.slice(1)):this.isAbsolute(Yr)?Yr:this.join(Wr,Yr)},normalize(Yr){if(assertPath(Yr),Yr.length===0)return".";if(this.isDataUrl(Yr)||this.isBlobUrl(Yr))return Yr;Yr=this.toPosix(Yr);let ze="";const Gr=Yr.startsWith("/");this.hasProtocol(Yr)&&(ze=this.rootname(Yr),Yr=Yr.slice(ze.length));const Wr=Yr.endsWith("/");return Yr=normalizeStringPosix(Yr),Yr.length>0&&Wr&&(Yr+="/"),Gr?`/${Yr}`:ze+Yr},isAbsolute(Yr){return assertPath(Yr),Yr=this.toPosix(Yr),this.hasProtocol(Yr)?!0:Yr.startsWith("/")},join(...Yr){if(Yr.length===0)return".";let ze;for(let Gr=0;Gr<Yr.length;++Gr){const Wr=Yr[Gr];if(assertPath(Wr),Wr.length>0)if(ze===void 0)ze=Wr;else{const Kr=Yr[Gr-1]??"";this.joinExtensions.includes(this.extname(Kr).toLowerCase())?ze+=`/../${Wr}`:ze+=`/${Wr}`}}return ze===void 0?".":this.normalize(ze)},dirname(Yr){if(assertPath(Yr),Yr.length===0)return".";Yr=this.toPosix(Yr);let ze=Yr.charCodeAt(0);const Gr=ze===47;let Wr=-1,Kr=!0;const Zr=this.getProtocol(Yr),Qr=Yr;Yr=Yr.slice(Zr.length);for(let Jr=Yr.length-1;Jr>=1;--Jr)if(ze=Yr.charCodeAt(Jr),ze===47){if(!Kr){Wr=Jr;break}}else Kr=!1;return Wr===-1?Gr?"/":this.isUrl(Qr)?Zr+Yr:Zr:Gr&&Wr===1?"//":Zr+Yr.slice(0,Wr)},rootname(Yr){assertPath(Yr),Yr=this.toPosix(Yr);let ze="";if(Yr.startsWith("/")?ze="/":ze=this.getProtocol(Yr),this.isUrl(Yr)){const Gr=Yr.indexOf("/",ze.length);Gr!==-1?ze=Yr.slice(0,Gr):ze=Yr,ze.endsWith("/")||(ze+="/")}return ze},basename(Yr,ze){assertPath(Yr),ze&&assertPath(ze),Yr=removeUrlParams(this.toPosix(Yr));let Gr=0,Wr=-1,Kr=!0,Zr;if(ze!==void 0&&ze.length>0&&ze.length<=Yr.length){if(ze.length===Yr.length&&ze===Yr)return"";let Qr=ze.length-1,Jr=-1;for(Zr=Yr.length-1;Zr>=0;--Zr){const ei=Yr.charCodeAt(Zr);if(ei===47){if(!Kr){Gr=Zr+1;break}}else Jr===-1&&(Kr=!1,Jr=Zr+1),Qr>=0&&(ei===ze.charCodeAt(Qr)?--Qr===-1&&(Wr=Zr):(Qr=-1,Wr=Jr))}return Gr===Wr?Wr=Jr:Wr===-1&&(Wr=Yr.length),Yr.slice(Gr,Wr)}for(Zr=Yr.length-1;Zr>=0;--Zr)if(Yr.charCodeAt(Zr)===47){if(!Kr){Gr=Zr+1;break}}else Wr===-1&&(Kr=!1,Wr=Zr+1);return Wr===-1?"":Yr.slice(Gr,Wr)},extname(Yr){assertPath(Yr),Yr=removeUrlParams(this.toPosix(Yr));let ze=-1,Gr=0,Wr=-1,Kr=!0,Zr=0;for(let Qr=Yr.length-1;Qr>=0;--Qr){const Jr=Yr.charCodeAt(Qr);if(Jr===47){if(!Kr){Gr=Qr+1;break}continue}Wr===-1&&(Kr=!1,Wr=Qr+1),Jr===46?ze===-1?ze=Qr:Zr!==1&&(Zr=1):ze!==-1&&(Zr=-1)}return ze===-1||Wr===-1||Zr===0||Zr===1&&ze===Wr-1&&ze===Gr+1?"":Yr.slice(ze,Wr)},parse(Yr){assertPath(Yr);const ze={root:"",dir:"",base:"",ext:"",name:""};if(Yr.length===0)return ze;Yr=removeUrlParams(this.toPosix(Yr));let Gr=Yr.charCodeAt(0);const Wr=this.isAbsolute(Yr);let Kr;ze.root=this.rootname(Yr),Wr||this.hasProtocol(Yr)?Kr=1:Kr=0;let Zr=-1,Qr=0,Jr=-1,ei=!0,ti=Yr.length-1,ri=0;for(;ti>=Kr;--ti){if(Gr=Yr.charCodeAt(ti),Gr===47){if(!ei){Qr=ti+1;break}continue}Jr===-1&&(ei=!1,Jr=ti+1),Gr===46?Zr===-1?Zr=ti:ri!==1&&(ri=1):Zr!==-1&&(ri=-1)}return Zr===-1||Jr===-1||ri===0||ri===1&&Zr===Jr-1&&Zr===Qr+1?Jr!==-1&&(Qr===0&&Wr?ze.base=ze.name=Yr.slice(1,Jr):ze.base=ze.name=Yr.slice(Qr,Jr)):(Qr===0&&Wr?(ze.name=Yr.slice(1,Zr),ze.base=Yr.slice(1,Jr)):(ze.name=Yr.slice(Qr,Zr),ze.base=Yr.slice(Qr,Jr)),ze.ext=Yr.slice(Zr,Jr)),ze.dir=this.dirname(Yr),ze},sep:"/",delimiter:":",joinExtensions:[".html"]};function processX(Yr,ze,Gr,Wr,Kr){const Zr=ze[Gr];for(let Qr=0;Qr<Zr.length;Qr++){const Jr=Zr[Qr];Gr<ze.length-1?processX(Yr.replace(Wr[Gr],Jr),ze,Gr+1,Wr,Kr):Kr.push(Yr.replace(Wr[Gr],Jr))}}function createStringVariations(Yr){const ze=/\{(.*?)\}/g,Gr=Yr.match(ze),Wr=[];if(Gr){const Kr=[];Gr.forEach(Zr=>{const Qr=Zr.substring(1,Zr.length-1).split(",");Kr.push(Qr)}),processX(Yr,Kr,0,Gr,Wr)}else Wr.push(Yr);return Wr}const isSingleItem=Yr=>!Array.isArray(Yr);class Resolver{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(ze,Gr)=>`${ze}${this._bundleIdConnector}${Gr}`,extractAssetIdFromBundle:(ze,Gr)=>Gr.replace(`${ze}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(ze){if(this._bundleIdConnector=ze.connector??this._bundleIdConnector,this._createBundleAssetId=ze.createBundleAssetId??this._createBundleAssetId,this._extractAssetIdFromBundle=ze.extractAssetIdFromBundle??this._extractAssetIdFromBundle,this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar"))!=="bar")throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...ze){ze.forEach(Gr=>{this._preferredOrder.push(Gr),Gr.priority||(Gr.priority=Object.keys(Gr.params))}),this._resolverHash={}}set basePath(ze){this._basePath=ze}get basePath(){return this._basePath}set rootPath(ze){this._rootPath=ze}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(ze){if(typeof ze=="string")this._defaultSearchParams=ze;else{const Gr=ze;this._defaultSearchParams=Object.keys(Gr).map(Wr=>`${encodeURIComponent(Wr)}=${encodeURIComponent(Gr[Wr])}`).join("&")}}getAlias(ze){const{alias:Gr,src:Wr}=ze;return convertToList(Gr||Wr,Zr=>typeof Zr=="string"?Zr:Array.isArray(Zr)?Zr.map(Qr=>(Qr==null?void 0:Qr.src)??Qr):Zr!=null&&Zr.src?Zr.src:Zr,!0)}addManifest(ze){this._manifest&&warn("[Resolver] Manifest already exists, this will be overwritten"),this._manifest=ze,ze.bundles.forEach(Gr=>{this.addBundle(Gr.name,Gr.assets)})}addBundle(ze,Gr){const Wr=[];let Kr=Gr;Array.isArray(Gr)||(Kr=Object.entries(Gr).map(([Zr,Qr])=>typeof Qr=="string"||Array.isArray(Qr)?{alias:Zr,src:Qr}:{alias:Zr,...Qr})),Kr.forEach(Zr=>{const Qr=Zr.src,Jr=Zr.alias;let ei;if(typeof Jr=="string"){const ti=this._createBundleAssetId(ze,Jr);Wr.push(ti),ei=[Jr,ti]}else{const ti=Jr.map(ri=>this._createBundleAssetId(ze,ri));Wr.push(...ti),ei=[...Jr,...ti]}this.add({...Zr,alias:ei,src:Qr})}),this._bundles[ze]=Wr}add(ze){const Gr=[];Array.isArray(ze)?Gr.push(...ze):Gr.push(ze);let Wr;Wr=Zr=>{this.hasKey(Zr)&&warn(`[Resolver] already has key: ${Zr} overwriting`)},convertToList(Gr).forEach(Zr=>{const{src:Qr}=Zr;let{data:Jr,format:ei,loadParser:ti}=Zr;const ri=convertToList(Qr).map(ni=>typeof ni=="string"?createStringVariations(ni):Array.isArray(ni)?ni:[ni]),ii=this.getAlias(Zr);Array.isArray(ii)?ii.forEach(Wr):Wr(ii);const si=[];ri.forEach(ni=>{ni.forEach(oi=>{let li={};if(typeof oi!="object"){li.src=oi;for(let ai=0;ai<this._parsers.length;ai++){const hi=this._parsers[ai];if(hi.test(oi)){li=hi.parse(oi);break}}}else Jr=oi.data??Jr,ei=oi.format??ei,ti=oi.loadParser??ti,li={...li,...oi};if(!ii)throw new Error(`[Resolver] alias is undefined for this asset: ${li.src}`);li=this._buildResolvedAsset(li,{aliases:ii,data:Jr,format:ei,loadParser:ti}),si.push(li)})}),ii.forEach(ni=>{this._assetMap[ni]=si})})}resolveBundle(ze){const Gr=isSingleItem(ze);ze=convertToList(ze);const Wr={};return ze.forEach(Kr=>{const Zr=this._bundles[Kr];if(Zr){const Qr=this.resolve(Zr),Jr={};for(const ei in Qr){const ti=Qr[ei];Jr[this._extractAssetIdFromBundle(Kr,ei)]=ti}Wr[Kr]=Jr}}),Gr?Wr[ze[0]]:Wr}resolveUrl(ze){const Gr=this.resolve(ze);if(typeof ze!="string"){const Wr={};for(const Kr in Gr)Wr[Kr]=Gr[Kr].src;return Wr}return Gr.src}resolve(ze){const Gr=isSingleItem(ze);ze=convertToList(ze);const Wr={};return ze.forEach(Kr=>{if(!this._resolverHash[Kr])if(this._assetMap[Kr]){let Zr=this._assetMap[Kr];const Qr=this._getPreferredOrder(Zr);Qr==null||Qr.priority.forEach(Jr=>{Qr.params[Jr].forEach(ei=>{const ti=Zr.filter(ri=>ri[Jr]?ri[Jr]===ei:!1);ti.length&&(Zr=ti)})}),this._resolverHash[Kr]=Zr[0]}else this._resolverHash[Kr]=this._buildResolvedAsset({alias:[Kr],src:Kr},{});Wr[Kr]=this._resolverHash[Kr]}),Gr?Wr[ze[0]]:Wr}hasKey(ze){return!!this._assetMap[ze]}hasBundle(ze){return!!this._bundles[ze]}_getPreferredOrder(ze){for(let Gr=0;Gr<ze.length;Gr++){const Wr=ze[Gr],Kr=this._preferredOrder.find(Zr=>Zr.params.format.includes(Wr.format));if(Kr)return Kr}return this._preferredOrder[0]}_appendDefaultSearchParams(ze){if(!this._defaultSearchParams)return ze;const Gr=/\?/.test(ze)?"&":"?";return`${ze}${Gr}${this._defaultSearchParams}`}_buildResolvedAsset(ze,Gr){const{aliases:Wr,data:Kr,loadParser:Zr,format:Qr}=Gr;return(this._basePath||this._rootPath)&&(ze.src=path.toAbsolute(ze.src,this._basePath,this._rootPath)),ze.alias=Wr??ze.alias??[ze.src],ze.src=this._appendDefaultSearchParams(ze.src),ze.data={...Kr||{},...ze.data},ze.loadParser=Zr??ze.loadParser,ze.format=Qr??ze.format??getUrlExtension(ze.src),ze}}Resolver.RETINA_PREFIX=/@([0-9\.]+)x/;function getUrlExtension(Yr){return Yr.split(".").pop().split("?").shift().split("#").shift()}const copySearchParams=(Yr,ze)=>{const Gr=ze.split("?")[1];return Gr&&(Yr+=`?${Gr}`),Yr},_Spritesheet=class ns{constructor(ze,Gr){this.linkedSheets=[],this._texture=ze instanceof Texture?ze:null,this.textureSource=ze.source,this.textures={},this.animations={},this.data=Gr;const Wr=parseFloat(Gr.meta.scale);Wr?(this.resolution=Wr,ze.source.resolution=this.resolution):this.resolution=ze.source._resolution,this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}parse(){return new Promise(ze=>{this._callback=ze,this._batchIndex=0,this._frameKeys.length<=ns.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()})}_processFrames(ze){let Gr=ze;const Wr=ns.BATCH_SIZE;for(;Gr-ze<Wr&&Gr<this._frameKeys.length;){const Kr=this._frameKeys[Gr],Zr=this._frames[Kr],Qr=Zr.frame;if(Qr){let Jr=null,ei=null;const ti=Zr.trimmed!==!1&&Zr.sourceSize?Zr.sourceSize:Zr.frame,ri=new Rectangle(0,0,Math.floor(ti.w)/this.resolution,Math.floor(ti.h)/this.resolution);Zr.rotated?Jr=new Rectangle(Math.floor(Qr.x)/this.resolution,Math.floor(Qr.y)/this.resolution,Math.floor(Qr.h)/this.resolution,Math.floor(Qr.w)/this.resolution):Jr=new Rectangle(Math.floor(Qr.x)/this.resolution,Math.floor(Qr.y)/this.resolution,Math.floor(Qr.w)/this.resolution,Math.floor(Qr.h)/this.resolution),Zr.trimmed!==!1&&Zr.spriteSourceSize&&(ei=new Rectangle(Math.floor(Zr.spriteSourceSize.x)/this.resolution,Math.floor(Zr.spriteSourceSize.y)/this.resolution,Math.floor(Qr.w)/this.resolution,Math.floor(Qr.h)/this.resolution)),this.textures[Kr]=new Texture({source:this.textureSource,frame:Jr,orig:ri,trim:ei,rotate:Zr.rotated?2:0,defaultAnchor:Zr.anchor,defaultBorders:Zr.borders,label:Kr.toString()})}Gr++}}_processAnimations(){const ze=this.data.animations||{};for(const Gr in ze){this.animations[Gr]=[];for(let Wr=0;Wr<ze[Gr].length;Wr++){const Kr=ze[Gr][Wr];this.animations[Gr].push(this.textures[Kr])}}}_parseComplete(){const ze=this._callback;this._callback=null,this._batchIndex=0,ze.call(this,this.textures)}_nextBatch(){this._processFrames(this._batchIndex*ns.BATCH_SIZE),this._batchIndex++,setTimeout(()=>{this._batchIndex*ns.BATCH_SIZE<this._frameKeys.length?this._nextBatch():(this._processAnimations(),this._parseComplete())},0)}destroy(ze=!1){var Gr;for(const Wr in this.textures)this.textures[Wr].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,ze&&((Gr=this._texture)==null||Gr.destroy(),this.textureSource.destroy()),this._texture=null,this.textureSource=null,this.linkedSheets=[]}};_Spritesheet.BATCH_SIZE=1e3;let Spritesheet=_Spritesheet;const validImages=["jpg","png","jpeg","avif","webp","basis","etc2","bc7","bc6h","bc5","bc4","bc3","bc2","bc1","eac","astc"];function getCacheableAssets(Yr,ze,Gr){const Wr={};if(Yr.forEach(Kr=>{Wr[Kr]=ze}),Object.keys(ze.textures).forEach(Kr=>{Wr[Kr]=ze.textures[Kr]}),!Gr){const Kr=path.dirname(Yr[0]);ze.linkedSheets.forEach((Zr,Qr)=>{const Jr=getCacheableAssets([`${Kr}/${ze.data.meta.related_multi_packs[Qr]}`],Zr,!0);Object.assign(Wr,Jr)})}return Wr}const spritesheetAsset={extension:ExtensionType.Asset,cache:{test:Yr=>Yr instanceof Spritesheet,getCacheableAssets:(Yr,ze)=>getCacheableAssets(Yr,ze,!1)},resolver:{extension:{type:ExtensionType.ResolveParser,name:"resolveSpritesheet"},test:Yr=>{const Gr=Yr.split("?")[0].split("."),Wr=Gr.pop(),Kr=Gr.pop();return Wr==="json"&&validImages.includes(Kr)},parse:Yr=>{var Gr;const ze=Yr.split(".");return{resolution:parseFloat(((Gr=Resolver.RETINA_PREFIX.exec(Yr))==null?void 0:Gr[1])??"1"),format:ze[ze.length-2],src:Yr}}},loader:{name:"spritesheetLoader",extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Normal,name:"spritesheetLoader"},async testParse(Yr,ze){return path.extname(ze.src).toLowerCase()===".json"&&!!Yr.frames},async parse(Yr,ze,Gr){var ri,ii;const{texture:Wr,imageFilename:Kr,textureOptions:Zr}=(ze==null?void 0:ze.data)??{};let Qr=path.dirname(ze.src);Qr&&Qr.lastIndexOf("/")!==Qr.length-1&&(Qr+="/");let Jr;if(Wr instanceof Texture)Jr=Wr;else{const si=copySearchParams(Qr+(Kr??Yr.meta.image),ze.src);Jr=(await Gr.load([{src:si,data:Zr}]))[si]}const ei=new Spritesheet(Jr.source,Yr);await ei.parse();const ti=(ri=Yr==null?void 0:Yr.meta)==null?void 0:ri.related_multi_packs;if(Array.isArray(ti)){const si=[];for(const oi of ti){if(typeof oi!="string")continue;let li=Qr+oi;(ii=ze.data)!=null&&ii.ignoreMultiPack||(li=copySearchParams(li,ze.src),si.push(Gr.load({src:li,data:{textureOptions:Zr,ignoreMultiPack:!0}})))}const ni=await Promise.all(si);ei.linkedSheets=ni,ni.forEach(oi=>{oi.linkedSheets=[ei].concat(ei.linkedSheets.filter(li=>li!==oi))})}return ei},async unload(Yr,ze,Gr){await Gr.unload(Yr.textureSource._sourceOrigin),Yr.destroy(!1)}}};extensions.add(spritesheetAsset);class FederatedEvent{constructor(ze){this.bubbles=!0,this.cancelBubble=!0,this.cancelable=!1,this.composed=!1,this.defaultPrevented=!1,this.eventPhase=FederatedEvent.prototype.NONE,this.propagationStopped=!1,this.propagationImmediatelyStopped=!1,this.layer=new Point$1,this.page=new Point$1,this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.manager=ze}get layerX(){return this.layer.x}get layerY(){return this.layer.y}get pageX(){return this.page.x}get pageY(){return this.page.y}get data(){return this}composedPath(){return this.manager&&(!this.path||this.path[this.path.length-1]!==this.target)&&(this.path=this.target?this.manager.propagationPath(this.target):[]),this.path}initEvent(ze,Gr,Wr){throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}initUIEvent(ze,Gr,Wr,Kr,Zr){throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}preventDefault(){this.nativeEvent instanceof Event&&this.nativeEvent.cancelable&&this.nativeEvent.preventDefault(),this.defaultPrevented=!0}stopImmediatePropagation(){this.propagationImmediatelyStopped=!0}stopPropagation(){this.propagationStopped=!0}}var appleIphone=/iPhone/i,appleIpod=/iPod/i,appleTablet=/iPad/i,appleUniversal=/\biOS-universal(?:.+)Mac\b/i,androidPhone=/\bAndroid(?:.+)Mobile\b/i,androidTablet=/Android/i,amazonPhone=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,amazonTablet=/Silk/i,windowsPhone=/Windows Phone/i,windowsTablet=/\bWindows(?:.+)ARM\b/i,otherBlackBerry=/BlackBerry/i,otherBlackBerry10=/BB10/i,otherOpera=/Opera Mini/i,otherChrome=/\b(CriOS|Chrome)(?:.+)Mobile/i,otherFirefox=/Mobile(?:.+)Firefox\b/i,isAppleTabletOnIos13=function(Yr){return typeof Yr<"u"&&Yr.platform==="MacIntel"&&typeof Yr.maxTouchPoints=="number"&&Yr.maxTouchPoints>1&&typeof MSStream>"u"};function createMatch(Yr){return function(ze){return ze.test(Yr)}}function isMobile$1(Yr){var ze={userAgent:"",platform:"",maxTouchPoints:0};!Yr&&typeof navigator<"u"?ze={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0}:typeof Yr=="string"?ze.userAgent=Yr:Yr&&Yr.userAgent&&(ze={userAgent:Yr.userAgent,platform:Yr.platform,maxTouchPoints:Yr.maxTouchPoints||0});var Gr=ze.userAgent,Wr=Gr.split("[FBAN");typeof Wr[1]<"u"&&(Gr=Wr[0]),Wr=Gr.split("Twitter"),typeof Wr[1]<"u"&&(Gr=Wr[0]);var Kr=createMatch(Gr),Zr={apple:{phone:Kr(appleIphone)&&!Kr(windowsPhone),ipod:Kr(appleIpod),tablet:!Kr(appleIphone)&&(Kr(appleTablet)||isAppleTabletOnIos13(ze))&&!Kr(windowsPhone),universal:Kr(appleUniversal),device:(Kr(appleIphone)||Kr(appleIpod)||Kr(appleTablet)||Kr(appleUniversal)||isAppleTabletOnIos13(ze))&&!Kr(windowsPhone)},amazon:{phone:Kr(amazonPhone),tablet:!Kr(amazonPhone)&&Kr(amazonTablet),device:Kr(amazonPhone)||Kr(amazonTablet)},android:{phone:!Kr(windowsPhone)&&Kr(amazonPhone)||!Kr(windowsPhone)&&Kr(androidPhone),tablet:!Kr(windowsPhone)&&!Kr(amazonPhone)&&!Kr(androidPhone)&&(Kr(amazonTablet)||Kr(androidTablet)),device:!Kr(windowsPhone)&&(Kr(amazonPhone)||Kr(amazonTablet)||Kr(androidPhone)||Kr(androidTablet))||Kr(/\bokhttp\b/i)},windows:{phone:Kr(windowsPhone),tablet:Kr(windowsTablet),device:Kr(windowsPhone)||Kr(windowsTablet)},other:{blackberry:Kr(otherBlackBerry),blackberry10:Kr(otherBlackBerry10),opera:Kr(otherOpera),firefox:Kr(otherFirefox),chrome:Kr(otherChrome),device:Kr(otherBlackBerry)||Kr(otherBlackBerry10)||Kr(otherOpera)||Kr(otherFirefox)||Kr(otherChrome)},any:!1,phone:!1,tablet:!1};return Zr.any=Zr.apple.device||Zr.android.device||Zr.windows.device||Zr.other.device,Zr.phone=Zr.apple.phone||Zr.android.phone||Zr.windows.phone,Zr.tablet=Zr.apple.tablet||Zr.android.tablet||Zr.windows.tablet,Zr}const isMobileCall=isMobile$1.default??isMobile$1,isMobile=isMobileCall(globalThis.navigator),KEY_CODE_TAB=9,DIV_TOUCH_SIZE=100,DIV_TOUCH_POS_X=0,DIV_TOUCH_POS_Y=0,DIV_TOUCH_ZINDEX=2,DIV_HOOK_SIZE=1,DIV_HOOK_POS_X=-1e3,DIV_HOOK_POS_Y=-1e3,DIV_HOOK_ZINDEX=2,_AccessibilitySystem=class Ss{constructor(ze,Gr=isMobile){this._mobileInfo=Gr,this.debug=!1,this._activateOnTab=!0,this._deactivateOnMouseMove=!0,this._isActive=!1,this._isMobileAccessibility=!1,this._div=null,this._pool=[],this._renderId=0,this._children=[],this._androidUpdateCount=0,this._androidUpdateFrequency=500,this._hookDiv=null,(Gr.tablet||Gr.phone)&&this._createTouchHook(),this._renderer=ze}get isActive(){return this._isActive}get isMobileAccessibility(){return this._isMobileAccessibility}get hookDiv(){return this._hookDiv}_createTouchHook(){const ze=document.createElement("button");ze.style.width=`${DIV_HOOK_SIZE}px`,ze.style.height=`${DIV_HOOK_SIZE}px`,ze.style.position="absolute",ze.style.top=`${DIV_HOOK_POS_X}px`,ze.style.left=`${DIV_HOOK_POS_Y}px`,ze.style.zIndex=DIV_HOOK_ZINDEX.toString(),ze.style.backgroundColor="#FF0000",ze.title="select to enable accessibility for this content",ze.addEventListener("focus",()=>{this._isMobileAccessibility=!0,this._activate(),this._destroyTouchHook()}),document.body.appendChild(ze),this._hookDiv=ze}_destroyTouchHook(){this._hookDiv&&(document.body.removeChild(this._hookDiv),this._hookDiv=null)}_activate(){if(this._isActive)return;this._isActive=!0,this._div||(this._div=document.createElement("div"),this._div.style.width=`${DIV_TOUCH_SIZE}px`,this._div.style.height=`${DIV_TOUCH_SIZE}px`,this._div.style.position="absolute",this._div.style.top=`${DIV_TOUCH_POS_X}px`,this._div.style.left=`${DIV_TOUCH_POS_Y}px`,this._div.style.zIndex=DIV_TOUCH_ZINDEX.toString(),this._div.style.pointerEvents="none"),this._activateOnTab&&(this._onKeyDown=this._onKeyDown.bind(this),globalThis.addEventListener("keydown",this._onKeyDown,!1)),this._deactivateOnMouseMove&&(this._onMouseMove=this._onMouseMove.bind(this),globalThis.document.addEventListener("mousemove",this._onMouseMove,!0));const ze=this._renderer.view.canvas;if(ze.parentNode)ze.parentNode.appendChild(this._div),this._initAccessibilitySetup();else{const Gr=new MutationObserver(()=>{ze.parentNode&&(ze.parentNode.appendChild(this._div),Gr.disconnect(),this._initAccessibilitySetup())});Gr.observe(document.body,{childList:!0,subtree:!0})}}_initAccessibilitySetup(){this._renderer.runners.postrender.add(this),this._renderer.lastObjectRendered&&this._updateAccessibleObjects(this._renderer.lastObjectRendered)}_deactivate(){if(!(!this._isActive||this._isMobileAccessibility)){this._isActive=!1,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),this._activateOnTab&&globalThis.addEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.remove(this);for(const ze of this._children)ze._accessibleDiv&&ze._accessibleDiv.parentNode&&(ze._accessibleDiv.parentNode.removeChild(ze._accessibleDiv),ze._accessibleDiv=null),ze._accessibleActive=!1;this._pool.forEach(ze=>{ze.parentNode&&ze.parentNode.removeChild(ze)}),this._div&&this._div.parentNode&&this._div.parentNode.removeChild(this._div),this._pool=[],this._children=[]}}_updateAccessibleObjects(ze){if(!ze.visible||!ze.accessibleChildren)return;ze.accessible&&(ze._accessibleActive||this._addChild(ze),ze._renderId=this._renderId);const Gr=ze.children;if(Gr)for(let Wr=0;Wr<Gr.length;Wr++)this._updateAccessibleObjects(Gr[Wr])}init(ze){const Wr={accessibilityOptions:{...Ss.defaultOptions,...(ze==null?void 0:ze.accessibilityOptions)||{}}};this.debug=Wr.accessibilityOptions.debug,this._activateOnTab=Wr.accessibilityOptions.activateOnTab,this._deactivateOnMouseMove=Wr.accessibilityOptions.deactivateOnMouseMove,Wr.accessibilityOptions.enabledByDefault?this._activate():this._activateOnTab&&(this._onKeyDown=this._onKeyDown.bind(this),globalThis.addEventListener("keydown",this._onKeyDown,!1)),this._renderer.runners.postrender.remove(this)}postrender(){const ze=performance.now();if(this._mobileInfo.android.device&&ze<this._androidUpdateCount||(this._androidUpdateCount=ze+this._androidUpdateFrequency,!this._renderer.renderingToScreen||!this._renderer.view.canvas))return;const Gr=new Set;if(this._renderer.lastObjectRendered){this._updateAccessibleObjects(this._renderer.lastObjectRendered);for(const Wr of this._children)Wr._renderId===this._renderId&&Gr.add(this._children.indexOf(Wr))}for(let Wr=this._children.length-1;Wr>=0;Wr--){const Kr=this._children[Wr];Gr.has(Wr)||(Kr._accessibleDiv&&Kr._accessibleDiv.parentNode&&(Kr._accessibleDiv.parentNode.removeChild(Kr._accessibleDiv),this._pool.push(Kr._accessibleDiv),Kr._accessibleDiv=null),Kr._accessibleActive=!1,removeItems(this._children,Wr,1))}if(this._renderer.renderingToScreen){const{x:Wr,y:Kr,width:Zr,height:Qr}=this._renderer.screen,Jr=this._div;Jr.style.left=`${Wr}px`,Jr.style.top=`${Kr}px`,Jr.style.width=`${Zr}px`,Jr.style.height=`${Qr}px`}for(let Wr=0;Wr<this._children.length;Wr++){const Kr=this._children[Wr];if(!Kr._accessibleActive||!Kr._accessibleDiv)continue;const Zr=Kr._accessibleDiv,Qr=Kr.hitArea||Kr.getBounds().rectangle;if(Kr.hitArea){const Jr=Kr.worldTransform,ei=this._renderer.resolution,ti=this._renderer.resolution;Zr.style.left=`${(Jr.tx+Qr.x*Jr.a)*ei}px`,Zr.style.top=`${(Jr.ty+Qr.y*Jr.d)*ti}px`,Zr.style.width=`${Qr.width*Jr.a*ei}px`,Zr.style.height=`${Qr.height*Jr.d*ti}px`}else{this._capHitArea(Qr);const Jr=this._renderer.resolution,ei=this._renderer.resolution;Zr.style.left=`${Qr.x*Jr}px`,Zr.style.top=`${Qr.y*ei}px`,Zr.style.width=`${Qr.width*Jr}px`,Zr.style.height=`${Qr.height*ei}px`}}this._renderId++}_updateDebugHTML(ze){ze.innerHTML=`type: ${ze.type}</br> title : ${ze.title}</br> tabIndex: ${ze.tabIndex}`}_capHitArea(ze){ze.x<0&&(ze.width+=ze.x,ze.x=0),ze.y<0&&(ze.height+=ze.y,ze.y=0);const{width:Gr,height:Wr}=this._renderer;ze.x+ze.width>Gr&&(ze.width=Gr-ze.x),ze.y+ze.height>Wr&&(ze.height=Wr-ze.y)}_addChild(ze){let Gr=this._pool.pop();Gr||(ze.accessibleType==="button"?Gr=document.createElement("button"):(Gr=document.createElement(ze.accessibleType),Gr.style.cssText=`
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `,ze.accessibleText&&(Gr.innerText=ze.accessibleText)),Gr.style.width=`${DIV_TOUCH_SIZE}px`,Gr.style.height=`${DIV_TOUCH_SIZE}px`,Gr.style.backgroundColor=this.debug?"rgba(255,255,255,0.5)":"transparent",Gr.style.position="absolute",Gr.style.zIndex=DIV_TOUCH_ZINDEX.toString(),Gr.style.borderStyle="none",navigator.userAgent.toLowerCase().includes("chrome")?Gr.setAttribute("aria-live","off"):Gr.setAttribute("aria-live","polite"),navigator.userAgent.match(/rv:.*Gecko\//)?Gr.setAttribute("aria-relevant","additions"):Gr.setAttribute("aria-relevant","text"),Gr.addEventListener("click",this._onClick.bind(this)),Gr.addEventListener("focus",this._onFocus.bind(this)),Gr.addEventListener("focusout",this._onFocusOut.bind(this))),Gr.style.pointerEvents=ze.accessiblePointerEvents,Gr.type=ze.accessibleType,ze.accessibleTitle&&ze.accessibleTitle!==null?Gr.title=ze.accessibleTitle:(!ze.accessibleHint||ze.accessibleHint===null)&&(Gr.title=`container ${ze.tabIndex}`),ze.accessibleHint&&ze.accessibleHint!==null&&Gr.setAttribute("aria-label",ze.accessibleHint),this.debug&&this._updateDebugHTML(Gr),ze._accessibleActive=!0,ze._accessibleDiv=Gr,Gr.container=ze,this._children.push(ze),this._div.appendChild(ze._accessibleDiv),ze.interactive&&(ze._accessibleDiv.tabIndex=ze.tabIndex)}_dispatchEvent(ze,Gr){const{container:Wr}=ze.target,Kr=this._renderer.events.rootBoundary,Zr=Object.assign(new FederatedEvent(Kr),{target:Wr});Kr.rootTarget=this._renderer.lastObjectRendered,Gr.forEach(Qr=>Kr.dispatchEvent(Zr,Qr))}_onClick(ze){this._dispatchEvent(ze,["click","pointertap","tap"])}_onFocus(ze){ze.target.getAttribute("aria-live")||ze.target.setAttribute("aria-live","assertive"),this._dispatchEvent(ze,["mouseover"])}_onFocusOut(ze){ze.target.getAttribute("aria-live")||ze.target.setAttribute("aria-live","polite"),this._dispatchEvent(ze,["mouseout"])}_onKeyDown(ze){ze.keyCode!==KEY_CODE_TAB||!this._activateOnTab||this._activate()}_onMouseMove(ze){ze.movementX===0&&ze.movementY===0||this._deactivate()}destroy(){this._deactivate(),this._destroyTouchHook(),this._div=null,this._pool=null,this._children=null,this._renderer=null,this._activateOnTab&&globalThis.removeEventListener("keydown",this._onKeyDown)}setAccessibilityEnabled(ze){ze?this._activate():this._deactivate()}};_AccessibilitySystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"accessibility"};_AccessibilitySystem.defaultOptions={enabledByDefault:!1,debug:!1,activateOnTab:!0,deactivateOnMouseMove:!0};let AccessibilitySystem=_AccessibilitySystem;const accessibilityTarget={accessible:!1,accessibleTitle:null,accessibleHint:null,tabIndex:0,_accessibleActive:!1,_accessibleDiv:null,accessibleType:"button",accessibleText:null,accessiblePointerEvents:"auto",accessibleChildren:!0,_renderId:-1},idCounts=Object.create(null),idHash=Object.create(null);function createIdFromString(Yr,ze){let Gr=idHash[Yr];return Gr===void 0&&(idCounts[ze]===void 0&&(idCounts[ze]=1),idHash[Yr]=Gr=idCounts[ze]++),Gr}let context;function getTestContext(){return(!context||context!=null&&context.isContextLost())&&(context=DOMAdapter.get().createCanvas().getContext("webgl",{})),context}let maxFragmentPrecision;function getMaxFragmentPrecision(){if(!maxFragmentPrecision){maxFragmentPrecision="mediump";const Yr=getTestContext();Yr&&Yr.getShaderPrecisionFormat&&(maxFragmentPrecision=Yr.getShaderPrecisionFormat(Yr.FRAGMENT_SHADER,Yr.HIGH_FLOAT).precision?"highp":"mediump")}return maxFragmentPrecision}function addProgramDefines(Yr,ze,Gr){return ze?Yr:Gr?(Yr=Yr.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${Yr}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${Yr}
        `}function ensurePrecision(Yr,ze,Gr){const Wr=Gr?ze.maxSupportedFragmentPrecision:ze.maxSupportedVertexPrecision;if(Yr.substring(0,9)!=="precision"){let Kr=Gr?ze.requestedFragmentPrecision:ze.requestedVertexPrecision;return Kr==="highp"&&Wr!=="highp"&&(Kr="mediump"),`precision ${Kr} float;
${Yr}`}else if(Wr!=="highp"&&Yr.substring(0,15)==="precision highp")return Yr.replace("precision highp","precision mediump");return Yr}function insertVersion(Yr,ze){return ze?`#version 300 es
${Yr}`:Yr}const fragmentNameCache={},VertexNameCache={};function setProgramName(Yr,{name:ze="pixi-program"},Gr=!0){ze=ze.replace(/\s+/g,"-"),ze+=Gr?"-fragment":"-vertex";const Wr=Gr?fragmentNameCache:VertexNameCache;return Wr[ze]?(Wr[ze]++,ze+=`-${Wr[ze]}`):Wr[ze]=1,Yr.indexOf("#define SHADER_NAME")!==-1?Yr:`${`#define SHADER_NAME ${ze}`}
${Yr}`}function stripVersion(Yr,ze){return ze?Yr.replace("#version 300 es",""):Yr}const processes={stripVersion,ensurePrecision,addProgramDefines,setProgramName,insertVersion},programCache$1=Object.create(null),_GlProgram=class cs{constructor(ze){ze={...cs.defaultOptions,...ze};const Gr=ze.fragment.indexOf("#version 300 es")!==-1,Wr={stripVersion:Gr,ensurePrecision:{requestedFragmentPrecision:ze.preferredFragmentPrecision,requestedVertexPrecision:ze.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:getMaxFragmentPrecision()},setProgramName:{name:ze.name},addProgramDefines:Gr,insertVersion:Gr};let Kr=ze.fragment,Zr=ze.vertex;Object.keys(processes).forEach(Qr=>{const Jr=Wr[Qr];Kr=processes[Qr](Kr,Jr,!0),Zr=processes[Qr](Zr,Jr,!1)}),this.fragment=Kr,this.vertex=Zr,this.transformFeedbackVaryings=ze.transformFeedbackVaryings,this._key=createIdFromString(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(ze){const Gr=`${ze.vertex}:${ze.fragment}`;return programCache$1[Gr]||(programCache$1[Gr]=new cs(ze)),programCache$1[Gr]}};_GlProgram.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let GlProgram=_GlProgram;const attributeFormatData={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function getAttributeInfoFromFormat(Yr){return attributeFormatData[Yr]??attributeFormatData.float32}const WGSL_TO_VERTEX_TYPES={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function extractAttributesFromGpuProgram({source:Yr,entryPoint:ze}){const Gr={},Wr=Yr.indexOf(`fn ${ze}`);if(Wr!==-1){const Kr=Yr.indexOf("->",Wr);if(Kr!==-1){const Zr=Yr.substring(Wr,Kr),Qr=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let Jr;for(;(Jr=Qr.exec(Zr))!==null;){const ei=WGSL_TO_VERTEX_TYPES[Jr[3]]??"float32";Gr[Jr[2]]={location:parseInt(Jr[1],10),format:ei,stride:getAttributeInfoFromFormat(ei).stride,offset:0,instance:!1,start:0}}}}return Gr}function extractStructAndGroups(Yr){var ii,si;const ze=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,Gr=/@group\((\d+)\)/,Wr=/@binding\((\d+)\)/,Kr=/var(<[^>]+>)? (\w+)/,Zr=/:\s*(\w+)/,Qr=/struct\s+(\w+)\s*{([^}]+)}/g,Jr=/(\w+)\s*:\s*([\w\<\>]+)/g,ei=/struct\s+(\w+)/,ti=(ii=Yr.match(ze))==null?void 0:ii.map(ni=>({group:parseInt(ni.match(Gr)[1],10),binding:parseInt(ni.match(Wr)[1],10),name:ni.match(Kr)[2],isUniform:ni.match(Kr)[1]==="<uniform>",type:ni.match(Zr)[1]}));if(!ti)return{groups:[],structs:[]};const ri=((si=Yr.match(Qr))==null?void 0:si.map(ni=>{const oi=ni.match(ei)[1],li=ni.match(Jr).reduce((ai,hi)=>{const[fi,pi]=hi.split(":");return ai[fi.trim()]=pi.trim(),ai},{});return li?{name:oi,members:li}:null}).filter(({name:ni})=>ti.some(oi=>oi.type===ni)))??[];return{groups:ti,structs:ri}}var ShaderStage=(Yr=>(Yr[Yr.VERTEX=1]="VERTEX",Yr[Yr.FRAGMENT=2]="FRAGMENT",Yr[Yr.COMPUTE=4]="COMPUTE",Yr))(ShaderStage||{});function generateGpuLayoutGroups({groups:Yr}){const ze=[];for(let Gr=0;Gr<Yr.length;Gr++){const Wr=Yr[Gr];ze[Wr.group]||(ze[Wr.group]=[]),Wr.isUniform?ze[Wr.group].push({binding:Wr.binding,visibility:ShaderStage.VERTEX|ShaderStage.FRAGMENT,buffer:{type:"uniform"}}):Wr.type==="sampler"?ze[Wr.group].push({binding:Wr.binding,visibility:ShaderStage.FRAGMENT,sampler:{type:"filtering"}}):Wr.type==="texture_2d"&&ze[Wr.group].push({binding:Wr.binding,visibility:ShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return ze}function generateLayoutHash({groups:Yr}){const ze=[];for(let Gr=0;Gr<Yr.length;Gr++){const Wr=Yr[Gr];ze[Wr.group]||(ze[Wr.group]={}),ze[Wr.group][Wr.name]=Wr.binding}return ze}function removeStructAndGroupDuplicates(Yr,ze){const Gr=new Set,Wr=new Set,Kr=[...Yr.structs,...ze.structs].filter(Qr=>Gr.has(Qr.name)?!1:(Gr.add(Qr.name),!0)),Zr=[...Yr.groups,...ze.groups].filter(Qr=>{const Jr=`${Qr.name}-${Qr.binding}`;return Wr.has(Jr)?!1:(Wr.add(Jr),!0)});return{structs:Kr,groups:Zr}}const programCache=Object.create(null);class GpuProgram{constructor(ze){var Jr,ei;this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:Gr,vertex:Wr,layout:Kr,gpuLayout:Zr,name:Qr}=ze;if(this.name=Qr,this.fragment=Gr,this.vertex=Wr,Gr.source===Wr.source){const ti=extractStructAndGroups(Gr.source);this.structsAndGroups=ti}else{const ti=extractStructAndGroups(Wr.source),ri=extractStructAndGroups(Gr.source);this.structsAndGroups=removeStructAndGroupDuplicates(ti,ri)}this.layout=Kr??generateLayoutHash(this.structsAndGroups),this.gpuLayout=Zr??generateGpuLayoutGroups(this.structsAndGroups),this.autoAssignGlobalUniforms=((Jr=this.layout[0])==null?void 0:Jr.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((ei=this.layout[1])==null?void 0:ei.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:ze,fragment:Gr}=this,Wr=ze.source+Gr.source+ze.entryPoint+Gr.entryPoint;this._layoutKey=createIdFromString(Wr,"program")}get attributeData(){return this._attributeData??(this._attributeData=extractAttributesFromGpuProgram(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(ze){const Gr=`${ze.vertex.source}:${ze.fragment.source}:${ze.fragment.entryPoint}:${ze.vertex.entryPoint}`;return programCache[Gr]||(programCache[Gr]=new GpuProgram(ze)),programCache[Gr]}}const UNIFORM_TYPES_VALUES=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>","vec2<i32>","vec3<i32>","vec4<i32>"],UNIFORM_TYPES_MAP=UNIFORM_TYPES_VALUES.reduce((Yr,ze)=>(Yr[ze]=!0,Yr),{});function getDefaultUniformValue(Yr,ze){switch(Yr){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*ze);case"vec3<f32>":return new Float32Array(3*ze);case"vec4<f32>":return new Float32Array(4*ze);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const _UniformGroup=class Ps{constructor(ze,Gr){this._touched=0,this.uid=uid$1("uniform"),this._resourceType="uniformGroup",this._resourceId=uid$1("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,Gr={...Ps.defaultOptions,...Gr},this.uniformStructures=ze;const Wr={};for(const Kr in ze){const Zr=ze[Kr];if(Zr.name=Kr,Zr.size=Zr.size??1,!UNIFORM_TYPES_MAP[Zr.type])throw new Error(`Uniform type ${Zr.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);Zr.value??(Zr.value=getDefaultUniformValue(Zr.type,Zr.size)),Wr[Kr]=Zr.value}this.uniforms=Wr,this._dirtyId=1,this.ubo=Gr.ubo,this.isStatic=Gr.isStatic,this._signature=createIdFromString(Object.keys(Wr).map(Kr=>`${Kr}-${ze[Kr].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};_UniformGroup.defaultOptions={ubo:!1,isStatic:!1};let UniformGroup=_UniformGroup;class BindGroup{constructor(ze){this.resources=Object.create(null),this._dirty=!0;let Gr=0;for(const Wr in ze){const Kr=ze[Wr];this.setResource(Kr,Gr++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const ze=[];let Gr=0;for(const Wr in this.resources)ze[Gr++]=this.resources[Wr]._resourceId;this._key=ze.join("|")}setResource(ze,Gr){var Kr,Zr;const Wr=this.resources[Gr];ze!==Wr&&(Wr&&((Kr=ze.off)==null||Kr.call(ze,"change",this.onResourceChange,this)),(Zr=ze.on)==null||Zr.call(ze,"change",this.onResourceChange,this),this.resources[Gr]=ze,this._dirty=!0)}getResource(ze){return this.resources[ze]}_touch(ze){const Gr=this.resources;for(const Wr in Gr)Gr[Wr]._touched=ze}destroy(){var Gr;const ze=this.resources;for(const Wr in ze){const Kr=ze[Wr];(Gr=Kr.off)==null||Gr.call(Kr,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(ze){if(this._dirty=!0,ze.destroyed){const Gr=this.resources;for(const Wr in Gr)Gr[Wr]===ze&&(Gr[Wr]=null)}else this._updateKey()}}var RendererType=(Yr=>(Yr[Yr.WEBGL=1]="WEBGL",Yr[Yr.WEBGPU=2]="WEBGPU",Yr[Yr.BOTH=3]="BOTH",Yr))(RendererType||{});class Shader extends EventEmitter{constructor(ze){super(),this.uid=uid$1("shader"),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:Gr,glProgram:Wr,groups:Kr,resources:Zr,compatibleRenderers:Qr,groupMap:Jr}=ze;this.gpuProgram=Gr,this.glProgram=Wr,Qr===void 0&&(Qr=0,Gr&&(Qr|=RendererType.WEBGPU),Wr&&(Qr|=RendererType.WEBGL)),this.compatibleRenderers=Qr;const ei={};if(!Zr&&!Kr&&(Zr={}),Zr&&Kr)throw new Error("[Shader] Cannot have both resources and groups");if(!Gr&&Kr&&!Jr)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!Gr&&Kr&&Jr)for(const ti in Jr)for(const ri in Jr[ti]){const ii=Jr[ti][ri];ei[ii]={group:ti,binding:ri,name:ii}}else if(Gr&&Kr&&!Jr){const ti=Gr.structsAndGroups.groups;Jr={},ti.forEach(ri=>{Jr[ri.group]=Jr[ri.group]||{},Jr[ri.group][ri.binding]=ri.name,ei[ri.name]=ri})}else if(Zr){Kr={},Jr={},Gr&&Gr.structsAndGroups.groups.forEach(ii=>{Jr[ii.group]=Jr[ii.group]||{},Jr[ii.group][ii.binding]=ii.name,ei[ii.name]=ii});let ti=0;for(const ri in Zr)ei[ri]||(Kr[99]||(Kr[99]=new BindGroup,this._ownedBindGroups.push(Kr[99])),ei[ri]={group:99,binding:ti,name:ri},Jr[99]=Jr[99]||{},Jr[99][ti]=ri,ti++);for(const ri in Zr){const ii=ri;let si=Zr[ri];!si.source&&!si._resourceType&&(si=new UniformGroup(si));const ni=ei[ii];ni&&(Kr[ni.group]||(Kr[ni.group]=new BindGroup,this._ownedBindGroups.push(Kr[ni.group])),Kr[ni.group].setResource(si,ni.binding))}}this.groups=Kr,this._uniformBindMap=Jr,this.resources=this._buildResourceAccessor(Kr,ei)}addResource(ze,Gr,Wr){var Kr,Zr;(Kr=this._uniformBindMap)[Gr]||(Kr[Gr]={}),(Zr=this._uniformBindMap[Gr])[Wr]||(Zr[Wr]=ze),this.groups[Gr]||(this.groups[Gr]=new BindGroup,this._ownedBindGroups.push(this.groups[Gr]))}_buildResourceAccessor(ze,Gr){const Wr={};for(const Kr in Gr){const Zr=Gr[Kr];Object.defineProperty(Wr,Zr.name,{get(){return ze[Zr.group].getResource(Zr.binding)},set(Qr){ze[Zr.group].setResource(Qr,Zr.binding)}})}return Wr}destroy(ze=!1){var Gr,Wr;this.emit("destroy",this),ze&&((Gr=this.gpuProgram)==null||Gr.destroy(),(Wr=this.glProgram)==null||Wr.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(Kr=>{Kr.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(ze){const{gpu:Gr,gl:Wr,...Kr}=ze;let Zr,Qr;return Gr&&(Zr=GpuProgram.from(Gr)),Wr&&(Qr=GlProgram.from(Wr)),new Shader({gpuProgram:Zr,glProgram:Qr,...Kr})}}const blendModeIds={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},BLEND$1=0,OFFSET$1=1,CULLING$1=2,DEPTH_TEST$1=3,WINDING$1=4,DEPTH_MASK$1=5,_State=class Es{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<BLEND$1)}set blend(ze){!!(this.data&1<<BLEND$1)!==ze&&(this.data^=1<<BLEND$1)}get offsets(){return!!(this.data&1<<OFFSET$1)}set offsets(ze){!!(this.data&1<<OFFSET$1)!==ze&&(this.data^=1<<OFFSET$1)}set cullMode(ze){if(ze==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=ze==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<CULLING$1)}set culling(ze){!!(this.data&1<<CULLING$1)!==ze&&(this.data^=1<<CULLING$1)}get depthTest(){return!!(this.data&1<<DEPTH_TEST$1)}set depthTest(ze){!!(this.data&1<<DEPTH_TEST$1)!==ze&&(this.data^=1<<DEPTH_TEST$1)}get depthMask(){return!!(this.data&1<<DEPTH_MASK$1)}set depthMask(ze){!!(this.data&1<<DEPTH_MASK$1)!==ze&&(this.data^=1<<DEPTH_MASK$1)}get clockwiseFrontFace(){return!!(this.data&1<<WINDING$1)}set clockwiseFrontFace(ze){!!(this.data&1<<WINDING$1)!==ze&&(this.data^=1<<WINDING$1)}get blendMode(){return this._blendMode}set blendMode(ze){this.blend=ze!=="none",this._blendMode=ze,this._blendModeId=blendModeIds[ze]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(ze){this.offsets=!!ze,this._polygonOffset=ze}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const ze=new Es;return ze.depthTest=!1,ze.blend=!0,ze}};_State.default2d=_State.for2d();let State=_State;const _Filter=class hs extends Shader{constructor(ze){ze={...hs.defaultOptions,...ze},super(ze),this.enabled=!0,this._state=State.for2d(),this.blendMode=ze.blendMode,this.padding=ze.padding,typeof ze.antialias=="boolean"?this.antialias=ze.antialias?"on":"off":this.antialias=ze.antialias,this.resolution=ze.resolution,this.blendRequired=ze.blendRequired,this.clipToViewport=ze.clipToViewport,this.addResource("uTexture",0,1)}apply(ze,Gr,Wr,Kr){ze.applyFilter(this,Gr,Wr,Kr)}get blendMode(){return this._state.blendMode}set blendMode(ze){this._state.blendMode=ze}static from(ze){const{gpu:Gr,gl:Wr,...Kr}=ze;let Zr,Qr;return Gr&&(Zr=GpuProgram.from(Gr)),Wr&&(Qr=GlProgram.from(Wr)),new hs({gpuProgram:Zr,glProgram:Qr,...Kr})}};_Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let Filter=_Filter;const environments=[];extensions.handleByNamedList(ExtensionType.Environment,environments);async function loadEnvironmentExtensions(Yr){if(!Yr)for(let ze=0;ze<environments.length;ze++){const Gr=environments[ze];if(Gr.value.test()){await Gr.value.load();return}}}let unsafeEval;function unsafeEvalSupported(){if(typeof unsafeEval=="boolean")return unsafeEval;try{unsafeEval=new Function("param1","param2","param3","return param1[param2] === param3;")({a:"b"},"a","b")===!0}catch{unsafeEval=!1}return unsafeEval}var earcut$1={exports:{}},hasRequiredEarcut;function requireEarcut(){if(hasRequiredEarcut)return earcut$1.exports;hasRequiredEarcut=1,earcut$1.exports=Yr,earcut$1.exports.default=Yr;function Yr(ci,ui,di){di=di||2;var gi=ui&&ui.length,xi=gi?ui[0]*di:ci.length,bi=ze(ci,0,xi,di,!0),vi=[];if(!bi||bi.next===bi.prev)return vi;var Ei,Ii,wi,Di,Ni,Fi,Hi;if(gi&&(bi=ei(ci,ui,bi,di)),ci.length>80*di){Ei=wi=ci[0],Ii=Di=ci[1];for(var Oi=di;Oi<xi;Oi+=di)Ni=ci[Oi],Fi=ci[Oi+1],Ni<Ei&&(Ei=Ni),Fi<Ii&&(Ii=Fi),Ni>wi&&(wi=Ni),Fi>Di&&(Di=Fi);Hi=Math.max(wi-Ei,Di-Ii),Hi=Hi!==0?32767/Hi:0}return Wr(bi,vi,di,Ei,Ii,Hi,0),vi}function ze(ci,ui,di,gi,xi){var bi,vi;if(xi===Li(ci,ui,di,gi)>0)for(bi=ui;bi<di;bi+=gi)vi=Bi(bi,ci[bi],ci[bi+1],vi);else for(bi=di-gi;bi>=ui;bi-=gi)vi=Bi(bi,ci[bi],ci[bi+1],vi);return vi&&mi(vi,vi.next)&&(ki(vi),vi=vi.next),vi}function Gr(ci,ui){if(!ci)return ci;ui||(ui=ci);var di=ci,gi;do if(gi=!1,!di.steiner&&(mi(di,di.next)||pi(di.prev,di,di.next)===0)){if(ki(di),di=ui=di.prev,di===di.next)break;gi=!0}else di=di.next;while(gi||di!==ui);return ui}function Wr(ci,ui,di,gi,xi,bi,vi){if(ci){!vi&&bi&&ni(ci,gi,xi,bi);for(var Ei=ci,Ii,wi;ci.prev!==ci.next;){if(Ii=ci.prev,wi=ci.next,bi?Zr(ci,gi,xi,bi):Kr(ci)){ui.push(Ii.i/di|0),ui.push(ci.i/di|0),ui.push(wi.i/di|0),ki(ci),ci=wi.next,Ei=wi.next;continue}if(ci=wi,ci===Ei){vi?vi===1?(ci=Qr(Gr(ci),ui,di),Wr(ci,ui,di,gi,xi,bi,2)):vi===2&&Jr(ci,ui,di,gi,xi,bi):Wr(Gr(ci),ui,di,gi,xi,bi,1);break}}}}function Kr(ci){var ui=ci.prev,di=ci,gi=ci.next;if(pi(ui,di,gi)>=0)return!1;for(var xi=ui.x,bi=di.x,vi=gi.x,Ei=ui.y,Ii=di.y,wi=gi.y,Di=xi<bi?xi<vi?xi:vi:bi<vi?bi:vi,Ni=Ei<Ii?Ei<wi?Ei:wi:Ii<wi?Ii:wi,Fi=xi>bi?xi>vi?xi:vi:bi>vi?bi:vi,Hi=Ei>Ii?Ei>wi?Ei:wi:Ii>wi?Ii:wi,Oi=gi.next;Oi!==ui;){if(Oi.x>=Di&&Oi.x<=Fi&&Oi.y>=Ni&&Oi.y<=Hi&&hi(xi,Ei,bi,Ii,vi,wi,Oi.x,Oi.y)&&pi(Oi.prev,Oi,Oi.next)>=0)return!1;Oi=Oi.next}return!0}function Zr(ci,ui,di,gi){var xi=ci.prev,bi=ci,vi=ci.next;if(pi(xi,bi,vi)>=0)return!1;for(var Ei=xi.x,Ii=bi.x,wi=vi.x,Di=xi.y,Ni=bi.y,Fi=vi.y,Hi=Ei<Ii?Ei<wi?Ei:wi:Ii<wi?Ii:wi,Oi=Di<Ni?Di<Fi?Di:Fi:Ni<Fi?Ni:Fi,Xi=Ei>Ii?Ei>wi?Ei:wi:Ii>wi?Ii:wi,Vi=Di>Ni?Di>Fi?Di:Fi:Ni>Fi?Ni:Fi,zi=li(Hi,Oi,ui,di,gi),$i=li(Xi,Vi,ui,di,gi),Gi=ci.prevZ,Ui=ci.nextZ;Gi&&Gi.z>=zi&&Ui&&Ui.z<=$i;){if(Gi.x>=Hi&&Gi.x<=Xi&&Gi.y>=Oi&&Gi.y<=Vi&&Gi!==xi&&Gi!==vi&&hi(Ei,Di,Ii,Ni,wi,Fi,Gi.x,Gi.y)&&pi(Gi.prev,Gi,Gi.next)>=0||(Gi=Gi.prevZ,Ui.x>=Hi&&Ui.x<=Xi&&Ui.y>=Oi&&Ui.y<=Vi&&Ui!==xi&&Ui!==vi&&hi(Ei,Di,Ii,Ni,wi,Fi,Ui.x,Ui.y)&&pi(Ui.prev,Ui,Ui.next)>=0))return!1;Ui=Ui.nextZ}for(;Gi&&Gi.z>=zi;){if(Gi.x>=Hi&&Gi.x<=Xi&&Gi.y>=Oi&&Gi.y<=Vi&&Gi!==xi&&Gi!==vi&&hi(Ei,Di,Ii,Ni,wi,Fi,Gi.x,Gi.y)&&pi(Gi.prev,Gi,Gi.next)>=0)return!1;Gi=Gi.prevZ}for(;Ui&&Ui.z<=$i;){if(Ui.x>=Hi&&Ui.x<=Xi&&Ui.y>=Oi&&Ui.y<=Vi&&Ui!==xi&&Ui!==vi&&hi(Ei,Di,Ii,Ni,wi,Fi,Ui.x,Ui.y)&&pi(Ui.prev,Ui,Ui.next)>=0)return!1;Ui=Ui.nextZ}return!0}function Qr(ci,ui,di){var gi=ci;do{var xi=gi.prev,bi=gi.next.next;!mi(xi,bi)&&Ti(xi,gi,gi.next,bi)&&Ri(xi,bi)&&Ri(bi,xi)&&(ui.push(xi.i/di|0),ui.push(gi.i/di|0),ui.push(bi.i/di|0),ki(gi),ki(gi.next),gi=ci=bi),gi=gi.next}while(gi!==ci);return Gr(gi)}function Jr(ci,ui,di,gi,xi,bi){var vi=ci;do{for(var Ei=vi.next.next;Ei!==vi.prev;){if(vi.i!==Ei.i&&fi(vi,Ei)){var Ii=Si(vi,Ei);vi=Gr(vi,vi.next),Ii=Gr(Ii,Ii.next),Wr(vi,ui,di,gi,xi,bi,0),Wr(Ii,ui,di,gi,xi,bi,0);return}Ei=Ei.next}vi=vi.next}while(vi!==ci)}function ei(ci,ui,di,gi){var xi=[],bi,vi,Ei,Ii,wi;for(bi=0,vi=ui.length;bi<vi;bi++)Ei=ui[bi]*gi,Ii=bi<vi-1?ui[bi+1]*gi:ci.length,wi=ze(ci,Ei,Ii,gi,!1),wi===wi.next&&(wi.steiner=!0),xi.push(ai(wi));for(xi.sort(ti),bi=0;bi<xi.length;bi++)di=ri(xi[bi],di);return di}function ti(ci,ui){return ci.x-ui.x}function ri(ci,ui){var di=ii(ci,ui);if(!di)return ui;var gi=Si(di,ci);return Gr(gi,gi.next),Gr(di,di.next)}function ii(ci,ui){var di=ui,gi=ci.x,xi=ci.y,bi=-1/0,vi;do{if(xi<=di.y&&xi>=di.next.y&&di.next.y!==di.y){var Ei=di.x+(xi-di.y)*(di.next.x-di.x)/(di.next.y-di.y);if(Ei<=gi&&Ei>bi&&(bi=Ei,vi=di.x<di.next.x?di:di.next,Ei===gi))return vi}di=di.next}while(di!==ui);if(!vi)return null;var Ii=vi,wi=vi.x,Di=vi.y,Ni=1/0,Fi;di=vi;do gi>=di.x&&di.x>=wi&&gi!==di.x&&hi(xi<Di?gi:bi,xi,wi,Di,xi<Di?bi:gi,xi,di.x,di.y)&&(Fi=Math.abs(xi-di.y)/(gi-di.x),Ri(di,ci)&&(Fi<Ni||Fi===Ni&&(di.x>vi.x||di.x===vi.x&&si(vi,di)))&&(vi=di,Ni=Fi)),di=di.next;while(di!==Ii);return vi}function si(ci,ui){return pi(ci.prev,ci,ui.prev)<0&&pi(ui.next,ci,ci.next)<0}function ni(ci,ui,di,gi){var xi=ci;do xi.z===0&&(xi.z=li(xi.x,xi.y,ui,di,gi)),xi.prevZ=xi.prev,xi.nextZ=xi.next,xi=xi.next;while(xi!==ci);xi.prevZ.nextZ=null,xi.prevZ=null,oi(xi)}function oi(ci){var ui,di,gi,xi,bi,vi,Ei,Ii,wi=1;do{for(di=ci,ci=null,bi=null,vi=0;di;){for(vi++,gi=di,Ei=0,ui=0;ui<wi&&(Ei++,gi=gi.nextZ,!!gi);ui++);for(Ii=wi;Ei>0||Ii>0&&gi;)Ei!==0&&(Ii===0||!gi||di.z<=gi.z)?(xi=di,di=di.nextZ,Ei--):(xi=gi,gi=gi.nextZ,Ii--),bi?bi.nextZ=xi:ci=xi,xi.prevZ=bi,bi=xi;di=gi}bi.nextZ=null,wi*=2}while(vi>1);return ci}function li(ci,ui,di,gi,xi){return ci=(ci-di)*xi|0,ui=(ui-gi)*xi|0,ci=(ci|ci<<8)&16711935,ci=(ci|ci<<4)&252645135,ci=(ci|ci<<2)&858993459,ci=(ci|ci<<1)&1431655765,ui=(ui|ui<<8)&16711935,ui=(ui|ui<<4)&252645135,ui=(ui|ui<<2)&858993459,ui=(ui|ui<<1)&1431655765,ci|ui<<1}function ai(ci){var ui=ci,di=ci;do(ui.x<di.x||ui.x===di.x&&ui.y<di.y)&&(di=ui),ui=ui.next;while(ui!==ci);return di}function hi(ci,ui,di,gi,xi,bi,vi,Ei){return(xi-vi)*(ui-Ei)>=(ci-vi)*(bi-Ei)&&(ci-vi)*(gi-Ei)>=(di-vi)*(ui-Ei)&&(di-vi)*(bi-Ei)>=(xi-vi)*(gi-Ei)}function fi(ci,ui){return ci.next.i!==ui.i&&ci.prev.i!==ui.i&&!Ai(ci,ui)&&(Ri(ci,ui)&&Ri(ui,ci)&&Pi(ci,ui)&&(pi(ci.prev,ci,ui.prev)||pi(ci,ui.prev,ui))||mi(ci,ui)&&pi(ci.prev,ci,ci.next)>0&&pi(ui.prev,ui,ui.next)>0)}function pi(ci,ui,di){return(ui.y-ci.y)*(di.x-ui.x)-(ui.x-ci.x)*(di.y-ui.y)}function mi(ci,ui){return ci.x===ui.x&&ci.y===ui.y}function Ti(ci,ui,di,gi){var xi=_i(pi(ci,ui,di)),bi=_i(pi(ci,ui,gi)),vi=_i(pi(di,gi,ci)),Ei=_i(pi(di,gi,ui));return!!(xi!==bi&&vi!==Ei||xi===0&&yi(ci,di,ui)||bi===0&&yi(ci,gi,ui)||vi===0&&yi(di,ci,gi)||Ei===0&&yi(di,ui,gi))}function yi(ci,ui,di){return ui.x<=Math.max(ci.x,di.x)&&ui.x>=Math.min(ci.x,di.x)&&ui.y<=Math.max(ci.y,di.y)&&ui.y>=Math.min(ci.y,di.y)}function _i(ci){return ci>0?1:ci<0?-1:0}function Ai(ci,ui){var di=ci;do{if(di.i!==ci.i&&di.next.i!==ci.i&&di.i!==ui.i&&di.next.i!==ui.i&&Ti(di,di.next,ci,ui))return!0;di=di.next}while(di!==ci);return!1}function Ri(ci,ui){return pi(ci.prev,ci,ci.next)<0?pi(ci,ui,ci.next)>=0&&pi(ci,ci.prev,ui)>=0:pi(ci,ui,ci.prev)<0||pi(ci,ci.next,ui)<0}function Pi(ci,ui){var di=ci,gi=!1,xi=(ci.x+ui.x)/2,bi=(ci.y+ui.y)/2;do di.y>bi!=di.next.y>bi&&di.next.y!==di.y&&xi<(di.next.x-di.x)*(bi-di.y)/(di.next.y-di.y)+di.x&&(gi=!gi),di=di.next;while(di!==ci);return gi}function Si(ci,ui){var di=new Wi(ci.i,ci.x,ci.y),gi=new Wi(ui.i,ui.x,ui.y),xi=ci.next,bi=ui.prev;return ci.next=ui,ui.prev=ci,di.next=xi,xi.prev=di,gi.next=di,di.prev=gi,bi.next=gi,gi.prev=bi,gi}function Bi(ci,ui,di,gi){var xi=new Wi(ci,ui,di);return gi?(xi.next=gi.next,xi.prev=gi,gi.next.prev=xi,gi.next=xi):(xi.prev=xi,xi.next=xi),xi}function ki(ci){ci.next.prev=ci.prev,ci.prev.next=ci.next,ci.prevZ&&(ci.prevZ.nextZ=ci.nextZ),ci.nextZ&&(ci.nextZ.prevZ=ci.prevZ)}function Wi(ci,ui,di){this.i=ci,this.x=ui,this.y=di,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}Yr.deviation=function(ci,ui,di,gi){var xi=ui&&ui.length,bi=xi?ui[0]*di:ci.length,vi=Math.abs(Li(ci,0,bi,di));if(xi)for(var Ei=0,Ii=ui.length;Ei<Ii;Ei++){var wi=ui[Ei]*di,Di=Ei<Ii-1?ui[Ei+1]*di:ci.length;vi-=Math.abs(Li(ci,wi,Di,di))}var Ni=0;for(Ei=0;Ei<gi.length;Ei+=3){var Fi=gi[Ei]*di,Hi=gi[Ei+1]*di,Oi=gi[Ei+2]*di;Ni+=Math.abs((ci[Fi]-ci[Oi])*(ci[Hi+1]-ci[Fi+1])-(ci[Fi]-ci[Hi])*(ci[Oi+1]-ci[Fi+1]))}return vi===0&&Ni===0?0:Math.abs((Ni-vi)/vi)};function Li(ci,ui,di,gi){for(var xi=0,bi=ui,vi=di-gi;bi<di;bi+=gi)xi+=(ci[vi]-ci[bi])*(ci[bi+1]+ci[vi+1]),vi=bi;return xi}return Yr.flatten=function(ci){for(var ui=ci[0][0].length,di={vertices:[],holes:[],dimensions:ui},gi=0,xi=0;xi<ci.length;xi++){for(var bi=0;bi<ci[xi].length;bi++)for(var vi=0;vi<ui;vi++)di.vertices.push(ci[xi][bi][vi]);xi>0&&(gi+=ci[xi-1].length,di.holes.push(gi))}return di},earcut$1.exports}var earcutExports=requireEarcut();const earcut=getDefaultExportFromCjs(earcutExports);var CLEAR=(Yr=>(Yr[Yr.NONE=0]="NONE",Yr[Yr.COLOR=16384]="COLOR",Yr[Yr.STENCIL=1024]="STENCIL",Yr[Yr.DEPTH=256]="DEPTH",Yr[Yr.COLOR_DEPTH=16640]="COLOR_DEPTH",Yr[Yr.COLOR_STENCIL=17408]="COLOR_STENCIL",Yr[Yr.DEPTH_STENCIL=1280]="DEPTH_STENCIL",Yr[Yr.ALL=17664]="ALL",Yr))(CLEAR||{});class SystemRunner{constructor(ze){this.items=[],this._name=ze}emit(ze,Gr,Wr,Kr,Zr,Qr,Jr,ei){const{name:ti,items:ri}=this;for(let ii=0,si=ri.length;ii<si;ii++)ri[ii][ti](ze,Gr,Wr,Kr,Zr,Qr,Jr,ei);return this}add(ze){return ze[this._name]&&(this.remove(ze),this.items.push(ze)),this}remove(ze){const Gr=this.items.indexOf(ze);return Gr!==-1&&this.items.splice(Gr,1),this}contains(ze){return this.items.indexOf(ze)!==-1}removeAll(){return this.items.length=0,this}destroy(){this.removeAll(),this.items=null,this._name=null}get empty(){return this.items.length===0}get name(){return this._name}}const defaultRunners=["init","destroy","contextChange","resolutionChange","resetState","renderEnd","renderStart","render","update","postrender","prerender"],_AbstractRenderer=class Cs extends EventEmitter{constructor(ze){super(),this.runners=Object.create(null),this.renderPipes=Object.create(null),this._initOptions={},this._systemsHash=Object.create(null),this.type=ze.type,this.name=ze.name,this.config=ze;const Gr=[...defaultRunners,...this.config.runners??[]];this._addRunners(...Gr),this._unsafeEvalCheck()}async init(ze={}){const Gr=ze.skipExtensionImports===!0?!0:ze.manageImports===!1;await loadEnvironmentExtensions(Gr),this._addSystems(this.config.systems),this._addPipes(this.config.renderPipes,this.config.renderPipeAdaptors);for(const Wr in this._systemsHash)ze={...this._systemsHash[Wr].constructor.defaultOptions,...ze};ze={...Cs.defaultOptions,...ze},this._roundPixels=ze.roundPixels?1:0;for(let Wr=0;Wr<this.runners.init.items.length;Wr++)await this.runners.init.items[Wr].init(ze);this._initOptions=ze}render(ze,Gr){let Wr=ze;if(Wr instanceof Container&&(Wr={container:Wr},Gr&&(deprecation(v8_0_0,"passing a second argument is deprecated, please use render options instead"),Wr.target=Gr.renderTexture)),Wr.target||(Wr.target=this.view.renderTarget),Wr.target===this.view.renderTarget&&(this._lastObjectRendered=Wr.container,Wr.clearColor??(Wr.clearColor=this.background.colorRgba),Wr.clear??(Wr.clear=this.background.clearBeforeRender)),Wr.clearColor){const Kr=Array.isArray(Wr.clearColor)&&Wr.clearColor.length===4;Wr.clearColor=Kr?Wr.clearColor:Color.shared.setValue(Wr.clearColor).toArray()}Wr.transform||(Wr.container.updateLocalTransform(),Wr.transform=Wr.container.localTransform),Wr.container.enableRenderGroup(),this.runners.prerender.emit(Wr),this.runners.renderStart.emit(Wr),this.runners.render.emit(Wr),this.runners.renderEnd.emit(Wr),this.runners.postrender.emit(Wr)}resize(ze,Gr,Wr){const Kr=this.view.resolution;this.view.resize(ze,Gr,Wr),this.emit("resize",this.view.screen.width,this.view.screen.height,this.view.resolution),Wr!==void 0&&Wr!==Kr&&this.runners.resolutionChange.emit(Wr)}clear(ze={}){const Gr=this;ze.target||(ze.target=Gr.renderTarget.renderTarget),ze.clearColor||(ze.clearColor=this.background.colorRgba),ze.clear??(ze.clear=CLEAR.ALL);const{clear:Wr,clearColor:Kr,target:Zr}=ze;Color.shared.setValue(Kr??this.background.colorRgba),Gr.renderTarget.clear(Zr,Wr,Color.shared.toArray())}get resolution(){return this.view.resolution}set resolution(ze){this.view.resolution=ze,this.runners.resolutionChange.emit(ze)}get width(){return this.view.texture.frame.width}get height(){return this.view.texture.frame.height}get canvas(){return this.view.canvas}get lastObjectRendered(){return this._lastObjectRendered}get renderingToScreen(){return this.renderTarget.renderingToScreen}get screen(){return this.view.screen}_addRunners(...ze){ze.forEach(Gr=>{this.runners[Gr]=new SystemRunner(Gr)})}_addSystems(ze){let Gr;for(Gr in ze){const Wr=ze[Gr];this._addSystem(Wr.value,Wr.name)}}_addSystem(ze,Gr){const Wr=new ze(this);if(this[Gr])throw new Error(`Whoops! The name "${Gr}" is already in use`);this[Gr]=Wr,this._systemsHash[Gr]=Wr;for(const Kr in this.runners)this.runners[Kr].add(Wr);return this}_addPipes(ze,Gr){const Wr=Gr.reduce((Kr,Zr)=>(Kr[Zr.name]=Zr.value,Kr),{});ze.forEach(Kr=>{const Zr=Kr.value,Qr=Kr.name,Jr=Wr[Qr];this.renderPipes[Qr]=new Zr(this,Jr?new Jr:null)})}destroy(ze=!1){this.runners.destroy.items.reverse(),this.runners.destroy.emit(ze),Object.values(this.runners).forEach(Gr=>{Gr.destroy()}),this._systemsHash=null,this.renderPipes=null}generateTexture(ze){return this.textureGenerator.generateTexture(ze)}get roundPixels(){return!!this._roundPixels}_unsafeEvalCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}resetState(){this.runners.resetState.emit()}};_AbstractRenderer.defaultOptions={resolution:1,failIfMajorPerformanceCaveat:!1,roundPixels:!1};let AbstractRenderer=_AbstractRenderer,_isWebGLSupported;function isWebGLSupported(Yr){return _isWebGLSupported!==void 0||(_isWebGLSupported=(()=>{var Gr;const ze={stencil:!0,failIfMajorPerformanceCaveat:Yr??AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat};try{if(!DOMAdapter.get().getWebGLRenderingContext())return!1;let Kr=DOMAdapter.get().createCanvas().getContext("webgl",ze);const Zr=!!((Gr=Kr==null?void 0:Kr.getContextAttributes())!=null&&Gr.stencil);if(Kr){const Qr=Kr.getExtension("WEBGL_lose_context");Qr&&Qr.loseContext()}return Kr=null,Zr}catch{return!1}})()),_isWebGLSupported}let _isWebGPUSupported;async function isWebGPUSupported(Yr={}){return _isWebGPUSupported!==void 0||(_isWebGPUSupported=await(async()=>{const ze=DOMAdapter.get().getNavigator().gpu;if(!ze)return!1;try{return await(await ze.requestAdapter(Yr)).requestDevice(),!0}catch{return!1}})()),_isWebGPUSupported}const renderPriority=["webgl","webgpu","canvas"];async function autoDetectRenderer(Yr){let ze=[];Yr.preference?(ze.push(Yr.preference),renderPriority.forEach(Zr=>{Zr!==Yr.preference&&ze.push(Zr)})):ze=renderPriority.slice();let Gr,Wr={};for(let Zr=0;Zr<ze.length;Zr++){const Qr=ze[Zr];if(Qr==="webgpu"&&await isWebGPUSupported()){const{WebGPURenderer:Jr}=await __vitePreload(async()=>{const{WebGPURenderer:ei}=await Promise.resolve().then(()=>WebGPURenderer$1);return{WebGPURenderer:ei}},void 0);Gr=Jr,Wr={...Yr,...Yr.webgpu};break}else if(Qr==="webgl"&&isWebGLSupported(Yr.failIfMajorPerformanceCaveat??AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat)){const{WebGLRenderer:Jr}=await __vitePreload(async()=>{const{WebGLRenderer:ei}=await Promise.resolve().then(()=>WebGLRenderer$1);return{WebGLRenderer:ei}},void 0);Gr=Jr,Wr={...Yr,...Yr.webgl};break}else if(Qr==="canvas")throw Wr={...Yr},new Error("CanvasRenderer is not yet implemented")}if(delete Wr.webgpu,delete Wr.webgl,!Gr)throw new Error("No available renderer for the current environment");const Kr=new Gr;return await Kr.init(Wr),Kr}const VERSION="8.9.1";class ApplicationInitHook{static init(){var ze;(ze=globalThis.__PIXI_APP_INIT__)==null||ze.call(globalThis,this,VERSION)}static destroy(){}}ApplicationInitHook.extension=ExtensionType.Application;class RendererInitHook{constructor(ze){this._renderer=ze}init(){var ze;(ze=globalThis.__PIXI_RENDERER_INIT__)==null||ze.call(globalThis,this._renderer,VERSION)}destroy(){this._renderer=null}}RendererInitHook.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"initHook",priority:-10};const _Application=class us{constructor(...ze){this.stage=new Container,ze[0]!==void 0&&deprecation(v8_0_0,"Application constructor options are deprecated, please use Application.init() instead.")}async init(ze){ze={...ze},this.renderer=await autoDetectRenderer(ze),us._plugins.forEach(Gr=>{Gr.init.call(this,ze)})}render(){this.renderer.render({container:this.stage})}get canvas(){return this.renderer.canvas}get view(){return deprecation(v8_0_0,"Application.view is deprecated, please use Application.canvas instead."),this.renderer.canvas}get screen(){return this.renderer.screen}destroy(ze=!1,Gr=!1){const Wr=us._plugins.slice(0);Wr.reverse(),Wr.forEach(Kr=>{Kr.destroy.call(this)}),this.stage.destroy(Gr),this.stage=null,this.renderer.destroy(ze),this.renderer=null}};_Application._plugins=[];let Application=_Application;extensions.handleByList(ExtensionType.Application,Application._plugins);extensions.add(ApplicationInitHook);class ResizePlugin{static init(ze){Object.defineProperty(this,"resizeTo",{set(Gr){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=Gr,Gr&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let Gr,Wr;if(this._resizeTo===globalThis.window)Gr=globalThis.innerWidth,Wr=globalThis.innerHeight;else{const{clientWidth:Kr,clientHeight:Zr}=this._resizeTo;Gr=Kr,Wr=Zr}this.renderer.resize(Gr,Wr),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=ze.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=ExtensionType.Application;class TickerPlugin{static init(ze){ze=Object.assign({autoStart:!0,sharedTicker:!1},ze),Object.defineProperty(this,"ticker",{set(Gr){this._ticker&&this._ticker.remove(this.render,this),this._ticker=Gr,Gr&&Gr.add(this.render,this,UPDATE_PRIORITY.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=ze.sharedTicker?Ticker.shared:new Ticker,ze.autoStart&&this.start()}static destroy(){if(this._ticker){const ze=this._ticker;this.ticker=null,ze.destroy()}}}TickerPlugin.extension=ExtensionType.Application;class AbstractBitmapFont extends EventEmitter{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return deprecation(v8_0_0,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return deprecation(v8_0_0,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return deprecation(v8_0_0,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return deprecation(v8_0_0,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(ze=!1){var Gr;this.emit("destroy",this),this.removeAllListeners();for(const Wr in this.chars)(Gr=this.chars[Wr].texture)==null||Gr.destroy();this.chars=null,ze&&(this.pages.forEach(Wr=>Wr.texture.destroy(!0)),this.pages=null)}}const emptyColorStops=[{offset:0,color:"white"},{offset:1,color:"black"}],_FillGradient=class ds{constructor(...ze){this.uid=uid$1("fillGradient"),this.type="linear",this.colorStops=[];let Gr=ensureGradientOptions(ze);Gr={...Gr.type==="radial"?ds.defaultRadialOptions:ds.defaultLinearOptions,...definedProps(Gr)},this._textureSize=Gr.textureSize,Gr.type==="radial"?(this.center=Gr.center,this.outerCenter=Gr.outerCenter??this.center,this.innerRadius=Gr.innerRadius,this.outerRadius=Gr.outerRadius,this.scale=Gr.scale,this.rotation=Gr.rotation):(this.start=Gr.start,this.end=Gr.end),this.textureSpace=Gr.textureSpace,this.type=Gr.type,Gr.colorStops.forEach(Kr=>{this.addColorStop(Kr.offset,Kr.color)})}addColorStop(ze,Gr){return this.colorStops.push({offset:ze,color:Color.shared.setValue(Gr).toHexa()}),this}buildLinearGradient(){if(this.texture)return;const ze=this.colorStops.length?this.colorStops:emptyColorStops,Gr=this._textureSize,{canvas:Wr,context:Kr}=getCanvas(Gr,1),Zr=Kr.createLinearGradient(0,0,this._textureSize,0);addColorStops(Zr,ze),Kr.fillStyle=Zr,Kr.fillRect(0,0,Gr,1),this.texture=new Texture({source:new ImageSource({resource:Wr})});const{x:Qr,y:Jr}=this.start,{x:ei,y:ti}=this.end,ri=new Matrix,ii=ei-Qr,si=ti-Jr,ni=Math.sqrt(ii*ii+si*si),oi=Math.atan2(si,ii);ri.scale(ni/Gr,1),ri.rotate(oi),ri.translate(Qr,Jr),this.textureSpace==="local"&&ri.scale(Gr,Gr),this.transform=ri}buildGradient(){this.type==="linear"?this.buildLinearGradient():this.buildRadialGradient()}buildRadialGradient(){if(this.texture)return;const ze=this.colorStops.length?this.colorStops:emptyColorStops,Gr=this._textureSize,{canvas:Wr,context:Kr}=getCanvas(Gr,Gr),{x:Zr,y:Qr}=this.center,{x:Jr,y:ei}=this.outerCenter,ti=this.innerRadius,ri=this.outerRadius,ii=Jr-ri,si=ei-ri,ni=Gr/(ri*2),oi=(Zr-ii)*ni,li=(Qr-si)*ni,ai=Kr.createRadialGradient(oi,li,ti*ni,(Jr-ii)*ni,(ei-si)*ni,ri*ni);addColorStops(ai,ze),Kr.fillStyle=ze[ze.length-1].color,Kr.fillRect(0,0,Gr,Gr),Kr.fillStyle=ai,Kr.translate(oi,li),Kr.rotate(this.rotation),Kr.scale(1,this.scale),Kr.translate(-oi,-li),Kr.fillRect(0,0,Gr,Gr),this.texture=new Texture({source:new ImageSource({resource:Wr,addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"})});const hi=new Matrix;hi.scale(1/ni,1/ni),hi.translate(ii,si),this.textureSpace==="local"&&hi.scale(Gr,Gr),this.transform=hi}get styleKey(){return this.uid}destroy(){var ze;(ze=this.texture)==null||ze.destroy(!0),this.texture=null}};_FillGradient.defaultLinearOptions={start:{x:0,y:0},end:{x:0,y:1},colorStops:[],textureSpace:"local",type:"linear",textureSize:256};_FillGradient.defaultRadialOptions={center:{x:.5,y:.5},innerRadius:0,outerRadius:.5,colorStops:[],scale:1,textureSpace:"local",type:"radial",textureSize:256};let FillGradient=_FillGradient;function addColorStops(Yr,ze){for(let Gr=0;Gr<ze.length;Gr++){const Wr=ze[Gr];Yr.addColorStop(Wr.offset,Wr.color)}}function getCanvas(Yr,ze){const Gr=DOMAdapter.get().createCanvas(Yr,ze),Wr=Gr.getContext("2d");return{canvas:Gr,context:Wr}}function ensureGradientOptions(Yr){let ze=Yr[0]??{};return(typeof ze=="number"||Yr[1])&&(deprecation("8.5.2","use options object instead"),ze={type:"linear",start:{x:Yr[0],y:Yr[1]},end:{x:Yr[2],y:Yr[3]},textureSpace:Yr[4],textureSize:Yr[5]??FillGradient.defaultLinearOptions.textureSize}),ze}const repetitionMap={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class FillPattern{constructor(ze,Gr){this.uid=uid$1("fillPattern"),this.transform=new Matrix,this._styleKey=null,this.texture=ze,this.transform.scale(1/ze.frame.width,1/ze.frame.height),Gr&&(ze.source.style.addressModeU=repetitionMap[Gr].addressModeU,ze.source.style.addressModeV=repetitionMap[Gr].addressModeV)}setTransform(ze){const Gr=this.texture;this.transform.copyFrom(ze),this.transform.invert(),this.transform.scale(1/Gr.frame.width,1/Gr.frame.height),this._styleKey=null}get styleKey(){return this._styleKey?this._styleKey:(this._styleKey=`fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`,this._styleKey)}}var parseSvgPath,hasRequiredParseSvgPath;function requireParseSvgPath(){if(hasRequiredParseSvgPath)return parseSvgPath;hasRequiredParseSvgPath=1,parseSvgPath=Gr;var Yr={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},ze=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function Gr(Zr){var Qr=[];return Zr.replace(ze,function(Jr,ei,ti){var ri=ei.toLowerCase();for(ti=Kr(ti),ri=="m"&&ti.length>2&&(Qr.push([ei].concat(ti.splice(0,2))),ri="l",ei=ei=="m"?"l":"L");;){if(ti.length==Yr[ri])return ti.unshift(ei),Qr.push(ti);if(ti.length<Yr[ri])throw new Error("malformed path data");Qr.push([ei].concat(ti.splice(0,Yr[ri])))}}),Qr}var Wr=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function Kr(Zr){var Qr=Zr.match(Wr);return Qr?Qr.map(Number):[]}return parseSvgPath}var parseSvgPathExports=requireParseSvgPath();const parse=getDefaultExportFromCjs(parseSvgPathExports);function parseSVGPath(Yr,ze){const Gr=parse(Yr),Wr=[];let Kr=null,Zr=0,Qr=0;for(let Jr=0;Jr<Gr.length;Jr++){const ei=Gr[Jr],ti=ei[0],ri=ei;switch(ti){case"M":Zr=ri[1],Qr=ri[2],ze.moveTo(Zr,Qr);break;case"m":Zr+=ri[1],Qr+=ri[2],ze.moveTo(Zr,Qr);break;case"H":Zr=ri[1],ze.lineTo(Zr,Qr);break;case"h":Zr+=ri[1],ze.lineTo(Zr,Qr);break;case"V":Qr=ri[1],ze.lineTo(Zr,Qr);break;case"v":Qr+=ri[1],ze.lineTo(Zr,Qr);break;case"L":Zr=ri[1],Qr=ri[2],ze.lineTo(Zr,Qr);break;case"l":Zr+=ri[1],Qr+=ri[2],ze.lineTo(Zr,Qr);break;case"C":Zr=ri[5],Qr=ri[6],ze.bezierCurveTo(ri[1],ri[2],ri[3],ri[4],Zr,Qr);break;case"c":ze.bezierCurveTo(Zr+ri[1],Qr+ri[2],Zr+ri[3],Qr+ri[4],Zr+ri[5],Qr+ri[6]),Zr+=ri[5],Qr+=ri[6];break;case"S":Zr=ri[3],Qr=ri[4],ze.bezierCurveToShort(ri[1],ri[2],Zr,Qr);break;case"s":ze.bezierCurveToShort(Zr+ri[1],Qr+ri[2],Zr+ri[3],Qr+ri[4]),Zr+=ri[3],Qr+=ri[4];break;case"Q":Zr=ri[3],Qr=ri[4],ze.quadraticCurveTo(ri[1],ri[2],Zr,Qr);break;case"q":ze.quadraticCurveTo(Zr+ri[1],Qr+ri[2],Zr+ri[3],Qr+ri[4]),Zr+=ri[3],Qr+=ri[4];break;case"T":Zr=ri[1],Qr=ri[2],ze.quadraticCurveToShort(Zr,Qr);break;case"t":Zr+=ri[1],Qr+=ri[2],ze.quadraticCurveToShort(Zr,Qr);break;case"A":Zr=ri[6],Qr=ri[7],ze.arcToSvg(ri[1],ri[2],ri[3],ri[4],ri[5],Zr,Qr);break;case"a":Zr+=ri[6],Qr+=ri[7],ze.arcToSvg(ri[1],ri[2],ri[3],ri[4],ri[5],Zr,Qr);break;case"Z":case"z":ze.closePath(),Wr.length>0&&(Kr=Wr.pop(),Kr?(Zr=Kr.startX,Qr=Kr.startY):(Zr=0,Qr=0)),Kr=null;break;default:warn(`Unknown SVG path command: ${ti}`)}ti!=="Z"&&ti!=="z"&&Kr===null&&(Kr={startX:Zr,startY:Qr},Wr.push(Kr))}return ze}class Circle{constructor(ze=0,Gr=0,Wr=0){this.type="circle",this.x=ze,this.y=Gr,this.radius=Wr}clone(){return new Circle(this.x,this.y,this.radius)}contains(ze,Gr){if(this.radius<=0)return!1;const Wr=this.radius*this.radius;let Kr=this.x-ze,Zr=this.y-Gr;return Kr*=Kr,Zr*=Zr,Kr+Zr<=Wr}strokeContains(ze,Gr,Wr,Kr=.5){if(this.radius===0)return!1;const Zr=this.x-ze,Qr=this.y-Gr,Jr=this.radius,ei=(1-Kr)*Wr,ti=Math.sqrt(Zr*Zr+Qr*Qr);return ti<=Jr+ei&&ti>Jr-(Wr-ei)}getBounds(ze){return ze||(ze=new Rectangle),ze.x=this.x-this.radius,ze.y=this.y-this.radius,ze.width=this.radius*2,ze.height=this.radius*2,ze}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.radius=ze.radius,this}copyTo(ze){return ze.copyFrom(this),ze}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class Ellipse{constructor(ze=0,Gr=0,Wr=0,Kr=0){this.type="ellipse",this.x=ze,this.y=Gr,this.halfWidth=Wr,this.halfHeight=Kr}clone(){return new Ellipse(this.x,this.y,this.halfWidth,this.halfHeight)}contains(ze,Gr){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let Wr=(ze-this.x)/this.halfWidth,Kr=(Gr-this.y)/this.halfHeight;return Wr*=Wr,Kr*=Kr,Wr+Kr<=1}strokeContains(ze,Gr,Wr,Kr=.5){const{halfWidth:Zr,halfHeight:Qr}=this;if(Zr<=0||Qr<=0)return!1;const Jr=Wr*(1-Kr),ei=Wr-Jr,ti=Zr-ei,ri=Qr-ei,ii=Zr+Jr,si=Qr+Jr,ni=ze-this.x,oi=Gr-this.y,li=ni*ni/(ti*ti)+oi*oi/(ri*ri),ai=ni*ni/(ii*ii)+oi*oi/(si*si);return li>1&&ai<=1}getBounds(ze){return ze||(ze=new Rectangle),ze.x=this.x-this.halfWidth,ze.y=this.y-this.halfHeight,ze.width=this.halfWidth*2,ze.height=this.halfHeight*2,ze}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.halfWidth=ze.halfWidth,this.halfHeight=ze.halfHeight,this}copyTo(ze){return ze.copyFrom(this),ze}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function squaredDistanceToLineSegment(Yr,ze,Gr,Wr,Kr,Zr){const Qr=Yr-Gr,Jr=ze-Wr,ei=Kr-Gr,ti=Zr-Wr,ri=Qr*ei+Jr*ti,ii=ei*ei+ti*ti;let si=-1;ii!==0&&(si=ri/ii);let ni,oi;si<0?(ni=Gr,oi=Wr):si>1?(ni=Kr,oi=Zr):(ni=Gr+si*ei,oi=Wr+si*ti);const li=Yr-ni,ai=ze-oi;return li*li+ai*ai}let tempRect$3,tempRect2;class Polygon{constructor(...ze){this.type="polygon";let Gr=Array.isArray(ze[0])?ze[0]:ze;if(typeof Gr[0]!="number"){const Wr=[];for(let Kr=0,Zr=Gr.length;Kr<Zr;Kr++)Wr.push(Gr[Kr].x,Gr[Kr].y);Gr=Wr}this.points=Gr,this.closePath=!0}isClockwise(){let ze=0;const Gr=this.points,Wr=Gr.length;for(let Kr=0;Kr<Wr;Kr+=2){const Zr=Gr[Kr],Qr=Gr[Kr+1],Jr=Gr[(Kr+2)%Wr],ei=Gr[(Kr+3)%Wr];ze+=(Jr-Zr)*(ei+Qr)}return ze<0}containsPolygon(ze){const Gr=this.getBounds(tempRect$3),Wr=ze.getBounds(tempRect2);if(!Gr.containsRect(Wr))return!1;const Kr=ze.points;for(let Zr=0;Zr<Kr.length;Zr+=2){const Qr=Kr[Zr],Jr=Kr[Zr+1];if(!this.contains(Qr,Jr))return!1}return!0}clone(){const ze=this.points.slice(),Gr=new Polygon(ze);return Gr.closePath=this.closePath,Gr}contains(ze,Gr){let Wr=!1;const Kr=this.points.length/2;for(let Zr=0,Qr=Kr-1;Zr<Kr;Qr=Zr++){const Jr=this.points[Zr*2],ei=this.points[Zr*2+1],ti=this.points[Qr*2],ri=this.points[Qr*2+1];ei>Gr!=ri>Gr&&ze<(ti-Jr)*((Gr-ei)/(ri-ei))+Jr&&(Wr=!Wr)}return Wr}strokeContains(ze,Gr,Wr,Kr=.5){const Zr=Wr*Wr,Qr=Zr*(1-Kr),Jr=Zr-Qr,{points:ei}=this,ti=ei.length-(this.closePath?0:2);for(let ri=0;ri<ti;ri+=2){const ii=ei[ri],si=ei[ri+1],ni=ei[(ri+2)%ei.length],oi=ei[(ri+3)%ei.length],li=squaredDistanceToLineSegment(ze,Gr,ii,si,ni,oi),ai=Math.sign((ni-ii)*(Gr-si)-(oi-si)*(ze-ii));if(li<=(ai<0?Jr:Qr))return!0}return!1}getBounds(ze){ze||(ze=new Rectangle);const Gr=this.points;let Wr=1/0,Kr=-1/0,Zr=1/0,Qr=-1/0;for(let Jr=0,ei=Gr.length;Jr<ei;Jr+=2){const ti=Gr[Jr],ri=Gr[Jr+1];Wr=ti<Wr?ti:Wr,Kr=ti>Kr?ti:Kr,Zr=ri<Zr?ri:Zr,Qr=ri>Qr?ri:Qr}return ze.x=Wr,ze.width=Kr-Wr,ze.y=Zr,ze.height=Qr-Zr,ze}copyFrom(ze){return this.points=ze.points.slice(),this.closePath=ze.closePath,this}copyTo(ze){return ze.copyFrom(this),ze}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((ze,Gr)=>`${ze}, ${Gr}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}const isCornerWithinStroke=(Yr,ze,Gr,Wr,Kr,Zr,Qr)=>{const Jr=Yr-Gr,ei=ze-Wr,ti=Math.sqrt(Jr*Jr+ei*ei);return ti>=Kr-Zr&&ti<=Kr+Qr};class RoundedRectangle{constructor(ze=0,Gr=0,Wr=0,Kr=0,Zr=20){this.type="roundedRectangle",this.x=ze,this.y=Gr,this.width=Wr,this.height=Kr,this.radius=Zr}getBounds(ze){return ze||(ze=new Rectangle),ze.x=this.x,ze.y=this.y,ze.width=this.width,ze.height=this.height,ze}clone(){return new RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.width=ze.width,this.height=ze.height,this}copyTo(ze){return ze.copyFrom(this),ze}contains(ze,Gr){if(this.width<=0||this.height<=0)return!1;if(ze>=this.x&&ze<=this.x+this.width&&Gr>=this.y&&Gr<=this.y+this.height){const Wr=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(Gr>=this.y+Wr&&Gr<=this.y+this.height-Wr||ze>=this.x+Wr&&ze<=this.x+this.width-Wr)return!0;let Kr=ze-(this.x+Wr),Zr=Gr-(this.y+Wr);const Qr=Wr*Wr;if(Kr*Kr+Zr*Zr<=Qr||(Kr=ze-(this.x+this.width-Wr),Kr*Kr+Zr*Zr<=Qr)||(Zr=Gr-(this.y+this.height-Wr),Kr*Kr+Zr*Zr<=Qr)||(Kr=ze-(this.x+Wr),Kr*Kr+Zr*Zr<=Qr))return!0}return!1}strokeContains(ze,Gr,Wr,Kr=.5){const{x:Zr,y:Qr,width:Jr,height:ei,radius:ti}=this,ri=Wr*(1-Kr),ii=Wr-ri,si=Zr+ti,ni=Qr+ti,oi=Jr-ti*2,li=ei-ti*2,ai=Zr+Jr,hi=Qr+ei;return(ze>=Zr-ri&&ze<=Zr+ii||ze>=ai-ii&&ze<=ai+ri)&&Gr>=ni&&Gr<=ni+li||(Gr>=Qr-ri&&Gr<=Qr+ii||Gr>=hi-ii&&Gr<=hi+ri)&&ze>=si&&ze<=si+oi?!0:ze<si&&Gr<ni&&isCornerWithinStroke(ze,Gr,si,ni,ti,ii,ri)||ze>ai-ti&&Gr<ni&&isCornerWithinStroke(ze,Gr,ai-ti,ni,ti,ii,ri)||ze>ai-ti&&Gr>hi-ti&&isCornerWithinStroke(ze,Gr,ai-ti,hi-ti,ti,ii,ri)||ze<si&&Gr>hi-ti&&isCornerWithinStroke(ze,Gr,si,hi-ti,ti,ii,ri)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}const fragTemplate=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join(`
`);function generateIfTestSrc(Yr){let ze="";for(let Gr=0;Gr<Yr;++Gr)Gr>0&&(ze+=`
else `),Gr<Yr-1&&(ze+=`if(test == ${Gr}.0){}`);return ze}function checkMaxIfStatementsInShader(Yr,ze){if(Yr===0)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const Gr=ze.createShader(ze.FRAGMENT_SHADER);try{for(;;){const Wr=fragTemplate.replace(/%forloop%/gi,generateIfTestSrc(Yr));if(ze.shaderSource(Gr,Wr),ze.compileShader(Gr),!ze.getShaderParameter(Gr,ze.COMPILE_STATUS))Yr=Yr/2|0;else break}}finally{ze.deleteShader(Gr)}return Yr}let maxTexturesPerBatchCache=null;function getMaxTexturesPerBatch(){var ze;if(maxTexturesPerBatchCache)return maxTexturesPerBatchCache;const Yr=getTestContext();return maxTexturesPerBatchCache=Yr.getParameter(Yr.MAX_TEXTURE_IMAGE_UNITS),maxTexturesPerBatchCache=checkMaxIfStatementsInShader(maxTexturesPerBatchCache,Yr),(ze=Yr.getExtension("WEBGL_lose_context"))==null||ze.loseContext(),maxTexturesPerBatchCache}const cachedGroups={};function getTextureBatchBindGroup(Yr,ze){let Gr=2166136261;for(let Wr=0;Wr<ze;Wr++)Gr^=Yr[Wr].uid,Gr=Math.imul(Gr,16777619),Gr>>>=0;return cachedGroups[Gr]||generateTextureBatchBindGroup(Yr,ze,Gr)}let maxTextures=0;function generateTextureBatchBindGroup(Yr,ze,Gr){const Wr={};let Kr=0;maxTextures||(maxTextures=getMaxTexturesPerBatch());for(let Qr=0;Qr<maxTextures;Qr++){const Jr=Qr<ze?Yr[Qr]:Texture.EMPTY.source;Wr[Kr++]=Jr.source,Wr[Kr++]=Jr.style}const Zr=new BindGroup(Wr);return cachedGroups[Gr]=Zr,Zr}class ViewableBuffer{constructor(ze){typeof ze=="number"?this.rawBinaryData=new ArrayBuffer(ze):ze instanceof Uint8Array?this.rawBinaryData=ze.buffer:this.rawBinaryData=ze,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(ze){return this[`${ze}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(ze){switch(ze){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${ze} isn't a valid view type`)}}}function fastCopy(Yr,ze){const Gr=Yr.byteLength/8|0,Wr=new Float64Array(Yr,0,Gr);new Float64Array(ze,0,Gr).set(Wr);const Zr=Yr.byteLength-Gr*8;if(Zr>0){const Qr=new Uint8Array(Yr,Gr*8,Zr);new Uint8Array(ze,Gr*8,Zr).set(Qr)}}const BLEND_TO_NPM={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};var STENCIL_MODES=(Yr=>(Yr[Yr.DISABLED=0]="DISABLED",Yr[Yr.RENDERING_MASK_ADD=1]="RENDERING_MASK_ADD",Yr[Yr.MASK_ACTIVE=2]="MASK_ACTIVE",Yr[Yr.INVERSE_MASK_ACTIVE=3]="INVERSE_MASK_ACTIVE",Yr[Yr.RENDERING_MASK_REMOVE=4]="RENDERING_MASK_REMOVE",Yr[Yr.NONE=5]="NONE",Yr))(STENCIL_MODES||{});function getAdjustedBlendModeBlend(Yr,ze){return ze.alphaMode==="no-premultiply-alpha"&&BLEND_TO_NPM[Yr]||Yr}class BatchTextureArray{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let ze=0;ze<this.count;ze++){const Gr=this.textures[ze];this.textures[ze]=null,this.ids[Gr.uid]=null}this.count=0}}class Batch{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.textures=new BatchTextureArray,this.blendMode="normal",this.topology="triangle-strip",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}const batchPool=[];let batchPoolIndex=0;function getBatchFromPool(){return batchPoolIndex>0?batchPool[--batchPoolIndex]:new Batch}function returnBatchToPool(Yr){batchPool[batchPoolIndex++]=Yr}let BATCH_TICK=0;const _Batcher=class os{constructor(ze={}){this.uid=uid$1("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._elements=[],os.defaultOptions.maxTextures=os.defaultOptions.maxTextures??getMaxTexturesPerBatch(),ze={...os.defaultOptions,...ze};const{maxTextures:Gr,attributesInitialSize:Wr,indicesInitialSize:Kr}=ze;this.attributeBuffer=new ViewableBuffer(Wr*4),this.indexBuffer=new Uint16Array(Kr),this.maxTextures=Gr}begin(){this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0;for(let ze=0;ze<this.batchIndex;ze++)returnBatchToPool(this.batches[ze]);this.batchIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(ze){this._elements[this.elementSize++]=ze,ze._indexStart=this.indexSize,ze._attributeStart=this.attributeSize,ze._batcher=this,this.indexSize+=ze.indexSize,this.attributeSize+=ze.attributeSize*this.vertexSize}checkAndUpdateTexture(ze,Gr){const Wr=ze._batch.textures.ids[Gr._source.uid];return!Wr&&Wr!==0?!1:(ze._textureId=Wr,ze.texture=Gr,!0)}updateElement(ze){this.dirty=!0;const Gr=this.attributeBuffer;ze.packAsQuad?this.packQuadAttributes(ze,Gr.float32View,Gr.uint32View,ze._attributeStart,ze._textureId):this.packAttributes(ze,Gr.float32View,Gr.uint32View,ze._attributeStart,ze._textureId)}break(ze){const Gr=this._elements;if(!Gr[this.elementStart])return;let Wr=getBatchFromPool(),Kr=Wr.textures;Kr.clear();const Zr=Gr[this.elementStart];let Qr=getAdjustedBlendModeBlend(Zr.blendMode,Zr.texture._source),Jr=Zr.topology;this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const ei=this.attributeBuffer.float32View,ti=this.attributeBuffer.uint32View,ri=this.indexBuffer;let ii=this._batchIndexSize,si=this._batchIndexStart,ni="startBatch";const oi=this.maxTextures;for(let li=this.elementStart;li<this.elementSize;++li){const ai=Gr[li];Gr[li]=null;const fi=ai.texture._source,pi=getAdjustedBlendModeBlend(ai.blendMode,fi),mi=Qr!==pi||Jr!==ai.topology;if(fi._batchTick===BATCH_TICK&&!mi){ai._textureId=fi._textureBindLocation,ii+=ai.indexSize,ai.packAsQuad?(this.packQuadAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packQuadIndex(ri,ai._indexStart,ai._attributeStart/this.vertexSize)):(this.packAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packIndex(ai,ri,ai._indexStart,ai._attributeStart/this.vertexSize)),ai._batch=Wr;continue}fi._batchTick=BATCH_TICK,(Kr.count>=oi||mi)&&(this._finishBatch(Wr,si,ii-si,Kr,Qr,Jr,ze,ni),ni="renderBatch",si=ii,Qr=pi,Jr=ai.topology,Wr=getBatchFromPool(),Kr=Wr.textures,Kr.clear(),++BATCH_TICK),ai._textureId=fi._textureBindLocation=Kr.count,Kr.ids[fi.uid]=Kr.count,Kr.textures[Kr.count++]=fi,ai._batch=Wr,ii+=ai.indexSize,ai.packAsQuad?(this.packQuadAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packQuadIndex(ri,ai._indexStart,ai._attributeStart/this.vertexSize)):(this.packAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packIndex(ai,ri,ai._indexStart,ai._attributeStart/this.vertexSize))}Kr.count>0&&(this._finishBatch(Wr,si,ii-si,Kr,Qr,Jr,ze,ni),si=ii,++BATCH_TICK),this.elementStart=this.elementSize,this._batchIndexStart=si,this._batchIndexSize=ii}_finishBatch(ze,Gr,Wr,Kr,Zr,Qr,Jr,ei){ze.gpuBindGroup=null,ze.bindGroup=null,ze.action=ei,ze.batcher=this,ze.textures=Kr,ze.blendMode=Zr,ze.topology=Qr,ze.start=Gr,ze.size=Wr,++BATCH_TICK,this.batches[this.batchIndex++]=ze,Jr.add(ze)}finish(ze){this.break(ze)}ensureAttributeBuffer(ze){ze*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(ze*4)}ensureIndexBuffer(ze){ze<=this.indexBuffer.length||this._resizeIndexBuffer(ze)}_resizeAttributeBuffer(ze){const Gr=Math.max(ze,this.attributeBuffer.size*2),Wr=new ViewableBuffer(Gr);fastCopy(this.attributeBuffer.rawBinaryData,Wr.rawBinaryData),this.attributeBuffer=Wr}_resizeIndexBuffer(ze){const Gr=this.indexBuffer;let Wr=Math.max(ze,Gr.length*1.5);Wr+=Wr%2;const Kr=Wr>65535?new Uint32Array(Wr):new Uint16Array(Wr);if(Kr.BYTES_PER_ELEMENT!==Gr.BYTES_PER_ELEMENT)for(let Zr=0;Zr<Gr.length;Zr++)Kr[Zr]=Gr[Zr];else fastCopy(Gr.buffer,Kr.buffer);this.indexBuffer=Kr}packQuadIndex(ze,Gr,Wr){ze[Gr]=Wr+0,ze[Gr+1]=Wr+1,ze[Gr+2]=Wr+2,ze[Gr+3]=Wr+0,ze[Gr+4]=Wr+2,ze[Gr+5]=Wr+3}packIndex(ze,Gr,Wr,Kr){const Zr=ze.indices,Qr=ze.indexSize,Jr=ze.indexOffset,ei=ze.attributeOffset;for(let ti=0;ti<Qr;ti++)Gr[Wr++]=Kr+Zr[ti+Jr]-ei}destroy(){for(let ze=0;ze<this.batches.length;ze++)returnBatchToPool(this.batches[ze]);this.batches=null;for(let ze=0;ze<this._elements.length;ze++)this._elements[ze]._batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};_Batcher.defaultOptions={maxTextures:null,attributesInitialSize:4,indicesInitialSize:6};let Batcher=_Batcher;var BufferUsage=(Yr=>(Yr[Yr.MAP_READ=1]="MAP_READ",Yr[Yr.MAP_WRITE=2]="MAP_WRITE",Yr[Yr.COPY_SRC=4]="COPY_SRC",Yr[Yr.COPY_DST=8]="COPY_DST",Yr[Yr.INDEX=16]="INDEX",Yr[Yr.VERTEX=32]="VERTEX",Yr[Yr.UNIFORM=64]="UNIFORM",Yr[Yr.STORAGE=128]="STORAGE",Yr[Yr.INDIRECT=256]="INDIRECT",Yr[Yr.QUERY_RESOLVE=512]="QUERY_RESOLVE",Yr[Yr.STATIC=1024]="STATIC",Yr))(BufferUsage||{});class Buffer extends EventEmitter{constructor(ze){let{data:Gr,size:Wr}=ze;const{usage:Kr,label:Zr,shrinkToFit:Qr}=ze;super(),this.uid=uid$1("buffer"),this._resourceType="buffer",this._resourceId=uid$1("resource"),this._touched=0,this._updateID=1,this._dataInt32=null,this.shrinkToFit=!0,this.destroyed=!1,Gr instanceof Array&&(Gr=new Float32Array(Gr)),this._data=Gr,Wr??(Wr=Gr==null?void 0:Gr.byteLength);const Jr=!!Gr;this.descriptor={size:Wr,usage:Kr,mappedAtCreation:Jr,label:Zr},this.shrinkToFit=Qr??!0}get data(){return this._data}set data(ze){this.setDataWithSize(ze,ze.length,!0)}get dataInt32(){return this._dataInt32||(this._dataInt32=new Int32Array(this.data.buffer)),this._dataInt32}get static(){return!!(this.descriptor.usage&BufferUsage.STATIC)}set static(ze){ze?this.descriptor.usage|=BufferUsage.STATIC:this.descriptor.usage&=~BufferUsage.STATIC}setDataWithSize(ze,Gr,Wr){if(this._updateID++,this._updateSize=Gr*ze.BYTES_PER_ELEMENT,this._data===ze){Wr&&this.emit("update",this);return}const Kr=this._data;if(this._data=ze,this._dataInt32=null,!Kr||Kr.length!==ze.length){!this.shrinkToFit&&Kr&&ze.byteLength<Kr.byteLength?Wr&&this.emit("update",this):(this.descriptor.size=ze.byteLength,this._resourceId=uid$1("resource"),this.emit("change",this));return}Wr&&this.emit("update",this)}update(ze){this._updateSize=ze??this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function ensureIsBuffer(Yr,ze){if(!(Yr instanceof Buffer)){let Gr=ze?BufferUsage.INDEX:BufferUsage.VERTEX;Yr instanceof Array&&(ze?(Yr=new Uint32Array(Yr),Gr=BufferUsage.INDEX|BufferUsage.COPY_DST):(Yr=new Float32Array(Yr),Gr=BufferUsage.VERTEX|BufferUsage.COPY_DST)),Yr=new Buffer({data:Yr,label:ze?"index-mesh-buffer":"vertex-mesh-buffer",usage:Gr})}return Yr}function getGeometryBounds(Yr,ze,Gr){const Wr=Yr.getAttribute(ze);if(!Wr)return Gr.minX=0,Gr.minY=0,Gr.maxX=0,Gr.maxY=0,Gr;const Kr=Wr.buffer.data;let Zr=1/0,Qr=1/0,Jr=-1/0,ei=-1/0;const ti=Kr.BYTES_PER_ELEMENT,ri=(Wr.offset||0)/ti,ii=(Wr.stride||2*4)/ti;for(let si=ri;si<Kr.length;si+=ii){const ni=Kr[si],oi=Kr[si+1];ni>Jr&&(Jr=ni),oi>ei&&(ei=oi),ni<Zr&&(Zr=ni),oi<Qr&&(Qr=oi)}return Gr.minX=Zr,Gr.minY=Qr,Gr.maxX=Jr,Gr.maxY=ei,Gr}function ensureIsAttribute(Yr){return(Yr instanceof Buffer||Array.isArray(Yr)||Yr.BYTES_PER_ELEMENT)&&(Yr={buffer:Yr}),Yr.buffer=ensureIsBuffer(Yr.buffer,!1),Yr}class Geometry extends EventEmitter{constructor(ze={}){super(),this.uid=uid$1("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new Bounds,this._boundsDirty=!0;const{attributes:Gr,indexBuffer:Wr,topology:Kr}=ze;if(this.buffers=[],this.attributes={},Gr)for(const Zr in Gr)this.addAttribute(Zr,Gr[Zr]);this.instanceCount=ze.instanceCount??1,Wr&&this.addIndex(Wr),this.topology=Kr||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(ze){return this.attributes[ze]}getIndex(){return this.indexBuffer}getBuffer(ze){return this.getAttribute(ze).buffer}getSize(){for(const ze in this.attributes){const Gr=this.attributes[ze];return Gr.buffer.data.length/(Gr.stride/4||Gr.size)}return 0}addAttribute(ze,Gr){const Wr=ensureIsAttribute(Gr);this.buffers.indexOf(Wr.buffer)===-1&&(this.buffers.push(Wr.buffer),Wr.buffer.on("update",this.onBufferUpdate,this),Wr.buffer.on("change",this.onBufferUpdate,this)),this.attributes[ze]=Wr}addIndex(ze){this.indexBuffer=ensureIsBuffer(ze,!0),this.buffers.push(this.indexBuffer)}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,getGeometryBounds(this,"aPosition",this._bounds)):this._bounds}destroy(ze=!1){this.emit("destroy",this),this.removeAllListeners(),ze&&this.buffers.forEach(Gr=>Gr.destroy()),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}const placeHolderBufferData=new Float32Array(1),placeHolderIndexData=new Uint32Array(1);class BatchGeometry extends Geometry{constructor(){const Gr=new Buffer({data:placeHolderBufferData,label:"attribute-batch-buffer",usage:BufferUsage.VERTEX|BufferUsage.COPY_DST,shrinkToFit:!1}),Wr=new Buffer({data:placeHolderIndexData,label:"index-batch-buffer",usage:BufferUsage.INDEX|BufferUsage.COPY_DST,shrinkToFit:!1}),Kr=6*4;super({attributes:{aPosition:{buffer:Gr,format:"float32x2",stride:Kr,offset:0},aUV:{buffer:Gr,format:"float32x2",stride:Kr,offset:2*4},aColor:{buffer:Gr,format:"unorm8x4",stride:Kr,offset:4*4},aTextureIdAndRound:{buffer:Gr,format:"uint16x2",stride:Kr,offset:5*4}},indexBuffer:Wr})}}function addBits(Yr,ze,Gr){if(Yr)for(const Wr in Yr){const Kr=Wr.toLocaleLowerCase(),Zr=ze[Kr];if(Zr){let Qr=Yr[Wr];Wr==="header"&&(Qr=Qr.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),Gr&&Zr.push(`//----${Gr}----//`),Zr.push(Qr)}else warn(`${Wr} placement hook does not exist in shader`)}}const findHooksRx=/\{\{(.*?)\}\}/g;function compileHooks(Yr){var Wr;const ze={};return(((Wr=Yr.match(findHooksRx))==null?void 0:Wr.map(Kr=>Kr.replace(/[{()}]/g,"")))??[]).forEach(Kr=>{ze[Kr]=[]}),ze}function extractInputs(Yr,ze){let Gr;const Wr=/@in\s+([^;]+);/g;for(;(Gr=Wr.exec(Yr))!==null;)ze.push(Gr[1])}function compileInputs(Yr,ze,Gr=!1){const Wr=[];extractInputs(ze,Wr),Yr.forEach(Jr=>{Jr.header&&extractInputs(Jr.header,Wr)});const Kr=Wr;Gr&&Kr.sort();const Zr=Kr.map((Jr,ei)=>`       @location(${ei}) ${Jr},`).join(`
`);let Qr=ze.replace(/@in\s+[^;]+;\s*/g,"");return Qr=Qr.replace("{{in}}",`
${Zr}
`),Qr}function extractOutputs(Yr,ze){let Gr;const Wr=/@out\s+([^;]+);/g;for(;(Gr=Wr.exec(Yr))!==null;)ze.push(Gr[1])}function extractVariableName(Yr){const Gr=/\b(\w+)\s*:/g.exec(Yr);return Gr?Gr[1]:""}function stripVariable(Yr){const ze=/@.*?\s+/g;return Yr.replace(ze,"")}function compileOutputs(Yr,ze){const Gr=[];extractOutputs(ze,Gr),Yr.forEach(ei=>{ei.header&&extractOutputs(ei.header,Gr)});let Wr=0;const Kr=Gr.sort().map(ei=>ei.indexOf("builtin")>-1?ei:`@location(${Wr++}) ${ei}`).join(`,
`),Zr=Gr.sort().map(ei=>`       var ${stripVariable(ei)};`).join(`
`),Qr=`return VSOutput(
            ${Gr.sort().map(ei=>` ${extractVariableName(ei)}`).join(`,
`)});`;let Jr=ze.replace(/@out\s+[^;]+;\s*/g,"");return Jr=Jr.replace("{{struct}}",`
${Kr}
`),Jr=Jr.replace("{{start}}",`
${Zr}
`),Jr=Jr.replace("{{return}}",`
${Qr}
`),Jr}function injectBits(Yr,ze){let Gr=Yr;for(const Wr in ze){const Kr=ze[Wr];Kr.join(`
`).length?Gr=Gr.replace(`{{${Wr}}}`,`//-----${Wr} START-----//
${Kr.join(`
`)}
//----${Wr} FINISH----//`):Gr=Gr.replace(`{{${Wr}}}`,"")}return Gr}const cacheMap=Object.create(null),bitCacheMap=new Map;let CACHE_UID=0;function compileHighShader({template:Yr,bits:ze}){const Gr=generateCacheId(Yr,ze);if(cacheMap[Gr])return cacheMap[Gr];const{vertex:Wr,fragment:Kr}=compileInputsAndOutputs(Yr,ze);return cacheMap[Gr]=compileBits(Wr,Kr,ze),cacheMap[Gr]}function compileHighShaderGl({template:Yr,bits:ze}){const Gr=generateCacheId(Yr,ze);return cacheMap[Gr]||(cacheMap[Gr]=compileBits(Yr.vertex,Yr.fragment,ze)),cacheMap[Gr]}function compileInputsAndOutputs(Yr,ze){const Gr=ze.map(Qr=>Qr.vertex).filter(Qr=>!!Qr),Wr=ze.map(Qr=>Qr.fragment).filter(Qr=>!!Qr);let Kr=compileInputs(Gr,Yr.vertex,!0);Kr=compileOutputs(Gr,Kr);const Zr=compileInputs(Wr,Yr.fragment,!0);return{vertex:Kr,fragment:Zr}}function generateCacheId(Yr,ze){return ze.map(Gr=>(bitCacheMap.has(Gr)||bitCacheMap.set(Gr,CACHE_UID++),bitCacheMap.get(Gr))).sort((Gr,Wr)=>Gr-Wr).join("-")+Yr.vertex+Yr.fragment}function compileBits(Yr,ze,Gr){const Wr=compileHooks(Yr),Kr=compileHooks(ze);return Gr.forEach(Zr=>{addBits(Zr.vertex,Wr,Zr.name),addBits(Zr.fragment,Kr,Zr.name)}),{vertex:injectBits(Yr,Wr),fragment:injectBits(ze,Kr)}}const vertexGPUTemplate=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,fragmentGPUTemplate=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,vertexGlTemplate=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,fragmentGlTemplate=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`,globalUniformsBit={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},globalUniformsBitGl={name:"global-uniforms-bit",vertex:{header:`
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}};function compileHighShaderGpuProgram({bits:Yr,name:ze}){const Gr=compileHighShader({template:{fragment:fragmentGPUTemplate,vertex:vertexGPUTemplate},bits:[globalUniformsBit,...Yr]});return GpuProgram.from({name:ze,vertex:{source:Gr.vertex,entryPoint:"main"},fragment:{source:Gr.fragment,entryPoint:"main"}})}function compileHighShaderGlProgram({bits:Yr,name:ze}){return new GlProgram({name:ze,...compileHighShaderGl({template:{vertex:vertexGlTemplate,fragment:fragmentGlTemplate},bits:[globalUniformsBitGl,...Yr]})})}const colorBit={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},colorBitGl={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},textureBatchBitGpuCache={};function generateBindingSrc(Yr){const ze=[];if(Yr===1)ze.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),ze.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let Gr=0;for(let Wr=0;Wr<Yr;Wr++)ze.push(`@group(1) @binding(${Gr++}) var textureSource${Wr+1}: texture_2d<f32>;`),ze.push(`@group(1) @binding(${Gr++}) var textureSampler${Wr+1}: sampler;`)}return ze.join(`
`)}function generateSampleSrc(Yr){const ze=[];if(Yr===1)ze.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{ze.push("switch vTextureId {");for(let Gr=0;Gr<Yr;Gr++)Gr===Yr-1?ze.push("  default:{"):ze.push(`  case ${Gr}:{`),ze.push(`      outColor = textureSampleGrad(textureSource${Gr+1}, textureSampler${Gr+1}, vUV, uvDx, uvDy);`),ze.push("      break;}");ze.push("}")}return ze.join(`
`)}function generateTextureBatchBit(Yr){return textureBatchBitGpuCache[Yr]||(textureBatchBitGpuCache[Yr]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(Yr)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(Yr)}
            `}}),textureBatchBitGpuCache[Yr]}const textureBatchBitGlCache={};function generateSampleGlSrc(Yr){const ze=[];for(let Gr=0;Gr<Yr;Gr++)Gr>0&&ze.push("else"),Gr<Yr-1&&ze.push(`if(vTextureId < ${Gr}.5)`),ze.push("{"),ze.push(`	outColor = texture(uTextures[${Gr}], vUV);`),ze.push("}");return ze.join(`
`)}function generateTextureBatchBitGl(Yr){return textureBatchBitGlCache[Yr]||(textureBatchBitGlCache[Yr]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;

                uniform sampler2D uTextures[${Yr}];

            `,main:`

                ${generateSampleGlSrc(Yr)}
            `}}),textureBatchBitGlCache[Yr]}const roundPixelsBit={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},roundPixelsBitGl={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},batchSamplersUniformGroupHash={};function getBatchSamplersUniformGroup(Yr){let ze=batchSamplersUniformGroupHash[Yr];if(ze)return ze;const Gr=new Int32Array(Yr);for(let Wr=0;Wr<Yr;Wr++)Gr[Wr]=Wr;return ze=batchSamplersUniformGroupHash[Yr]=new UniformGroup({uTextures:{value:Gr,type:"i32",size:Yr}},{isStatic:!0}),ze}class DefaultShader extends Shader{constructor(ze){const Gr=compileHighShaderGlProgram({name:"batch",bits:[colorBitGl,generateTextureBatchBitGl(ze),roundPixelsBitGl]}),Wr=compileHighShaderGpuProgram({name:"batch",bits:[colorBit,generateTextureBatchBit(ze),roundPixelsBit]});super({glProgram:Gr,gpuProgram:Wr,resources:{batchSamplers:getBatchSamplersUniformGroup(ze)}})}}let defaultShader=null;const _DefaultBatcher=class ws extends Batcher{constructor(){super(...arguments),this.geometry=new BatchGeometry,this.shader=defaultShader||(defaultShader=new DefaultShader(this.maxTextures)),this.name=ws.extension.name,this.vertexSize=6}packAttributes(ze,Gr,Wr,Kr,Zr){const Qr=Zr<<16|ze.roundPixels&65535,Jr=ze.transform,ei=Jr.a,ti=Jr.b,ri=Jr.c,ii=Jr.d,si=Jr.tx,ni=Jr.ty,{positions:oi,uvs:li}=ze,ai=ze.color,hi=ze.attributeOffset,fi=hi+ze.attributeSize;for(let pi=hi;pi<fi;pi++){const mi=pi*2,Ti=oi[mi],yi=oi[mi+1];Gr[Kr++]=ei*Ti+ri*yi+si,Gr[Kr++]=ii*yi+ti*Ti+ni,Gr[Kr++]=li[mi],Gr[Kr++]=li[mi+1],Wr[Kr++]=ai,Wr[Kr++]=Qr}}packQuadAttributes(ze,Gr,Wr,Kr,Zr){const Qr=ze.texture,Jr=ze.transform,ei=Jr.a,ti=Jr.b,ri=Jr.c,ii=Jr.d,si=Jr.tx,ni=Jr.ty,oi=ze.bounds,li=oi.maxX,ai=oi.minX,hi=oi.maxY,fi=oi.minY,pi=Qr.uvs,mi=ze.color,Ti=Zr<<16|ze.roundPixels&65535;Gr[Kr+0]=ei*ai+ri*fi+si,Gr[Kr+1]=ii*fi+ti*ai+ni,Gr[Kr+2]=pi.x0,Gr[Kr+3]=pi.y0,Wr[Kr+4]=mi,Wr[Kr+5]=Ti,Gr[Kr+6]=ei*li+ri*fi+si,Gr[Kr+7]=ii*fi+ti*li+ni,Gr[Kr+8]=pi.x1,Gr[Kr+9]=pi.y1,Wr[Kr+10]=mi,Wr[Kr+11]=Ti,Gr[Kr+12]=ei*li+ri*hi+si,Gr[Kr+13]=ii*hi+ti*li+ni,Gr[Kr+14]=pi.x2,Gr[Kr+15]=pi.y2,Wr[Kr+16]=mi,Wr[Kr+17]=Ti,Gr[Kr+18]=ei*ai+ri*hi+si,Gr[Kr+19]=ii*hi+ti*ai+ni,Gr[Kr+20]=pi.x3,Gr[Kr+21]=pi.y3,Wr[Kr+22]=mi,Wr[Kr+23]=Ti}};_DefaultBatcher.extension={type:[ExtensionType.Batcher],name:"default"};let DefaultBatcher=_DefaultBatcher;function buildUvs(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr=null){let ei=0;Gr*=ze,Kr*=Zr;const ti=Jr.a,ri=Jr.b,ii=Jr.c,si=Jr.d,ni=Jr.tx,oi=Jr.ty;for(;ei<Qr;){const li=Yr[Gr],ai=Yr[Gr+1];Wr[Kr]=ti*li+ii*ai+ni,Wr[Kr+1]=ri*li+si*ai+oi,Kr+=Zr,Gr+=ze,ei++}}function buildSimpleUvs(Yr,ze,Gr,Wr){let Kr=0;for(ze*=Gr;Kr<Wr;)Yr[ze]=0,Yr[ze+1]=0,ze+=Gr,Kr++}function transformVertices(Yr,ze,Gr,Wr,Kr){const Zr=ze.a,Qr=ze.b,Jr=ze.c,ei=ze.d,ti=ze.tx,ri=ze.ty;Gr||(Gr=0),Wr||(Wr=2),Kr||(Kr=Yr.length/Wr-Gr);let ii=Gr*Wr;for(let si=0;si<Kr;si++){const ni=Yr[ii],oi=Yr[ii+1];Yr[ii]=Zr*ni+Jr*oi+ti,Yr[ii+1]=Qr*ni+ei*oi+ri,ii+=Wr}}const identityMatrix=new Matrix;class BatchableGraphics{constructor(){this.packAsQuad=!1,this.batcherName="default",this.topology="triangle-list",this.applyTransform=!0,this.roundPixels=0,this._batcher=null,this._batch=null}get uvs(){return this.geometryData.uvs}get positions(){return this.geometryData.vertices}get indices(){return this.geometryData.indices}get blendMode(){return this.applyTransform?this.renderable.groupBlendMode:"normal"}get color(){const ze=this.baseColor,Gr=ze>>16|ze&65280|(ze&255)<<16,Wr=this.renderable;return Wr?multiplyHexColors(Gr,Wr.groupColor)+(this.alpha*Wr.groupAlpha*255<<24):Gr+(this.alpha*255<<24)}get transform(){var ze;return((ze=this.renderable)==null?void 0:ze.groupTransform)||identityMatrix}copyTo(ze){ze.indexOffset=this.indexOffset,ze.indexSize=this.indexSize,ze.attributeOffset=this.attributeOffset,ze.attributeSize=this.attributeSize,ze.baseColor=this.baseColor,ze.alpha=this.alpha,ze.texture=this.texture,ze.geometryData=this.geometryData,ze.topology=this.topology}reset(){this.applyTransform=!0,this.renderable=null,this.topology="triangle-list"}}const buildCircle={extension:{type:ExtensionType.ShapeBuilder,name:"circle"},build(Yr,ze){let Gr,Wr,Kr,Zr,Qr,Jr;if(Yr.type==="circle"){const mi=Yr;Gr=mi.x,Wr=mi.y,Qr=Jr=mi.radius,Kr=Zr=0}else if(Yr.type==="ellipse"){const mi=Yr;Gr=mi.x,Wr=mi.y,Qr=mi.halfWidth,Jr=mi.halfHeight,Kr=Zr=0}else{const mi=Yr,Ti=mi.width/2,yi=mi.height/2;Gr=mi.x+Ti,Wr=mi.y+yi,Qr=Jr=Math.max(0,Math.min(mi.radius,Math.min(Ti,yi))),Kr=Ti-Qr,Zr=yi-Jr}if(!(Qr>=0&&Jr>=0&&Kr>=0&&Zr>=0))return ze;const ei=Math.ceil(2.3*Math.sqrt(Qr+Jr)),ti=ei*8+(Kr?4:0)+(Zr?4:0);if(ti===0)return ze;if(ei===0)return ze[0]=ze[6]=Gr+Kr,ze[1]=ze[3]=Wr+Zr,ze[2]=ze[4]=Gr-Kr,ze[5]=ze[7]=Wr-Zr,ze;let ri=0,ii=ei*4+(Kr?2:0)+2,si=ii,ni=ti,oi=Kr+Qr,li=Zr,ai=Gr+oi,hi=Gr-oi,fi=Wr+li;if(ze[ri++]=ai,ze[ri++]=fi,ze[--ii]=fi,ze[--ii]=hi,Zr){const mi=Wr-li;ze[si++]=hi,ze[si++]=mi,ze[--ni]=mi,ze[--ni]=ai}for(let mi=1;mi<ei;mi++){const Ti=Math.PI/2*(mi/ei),yi=Kr+Math.cos(Ti)*Qr,_i=Zr+Math.sin(Ti)*Jr,Ai=Gr+yi,Ri=Gr-yi,Pi=Wr+_i,Si=Wr-_i;ze[ri++]=Ai,ze[ri++]=Pi,ze[--ii]=Pi,ze[--ii]=Ri,ze[si++]=Ri,ze[si++]=Si,ze[--ni]=Si,ze[--ni]=Ai}oi=Kr,li=Zr+Jr,ai=Gr+oi,hi=Gr-oi,fi=Wr+li;const pi=Wr-li;return ze[ri++]=ai,ze[ri++]=fi,ze[--ni]=pi,ze[--ni]=ai,Kr&&(ze[ri++]=hi,ze[ri++]=fi,ze[--ni]=pi,ze[--ni]=hi),ze},triangulate(Yr,ze,Gr,Wr,Kr,Zr){if(Yr.length===0)return;let Qr=0,Jr=0;for(let ri=0;ri<Yr.length;ri+=2)Qr+=Yr[ri],Jr+=Yr[ri+1];Qr/=Yr.length/2,Jr/=Yr.length/2;let ei=Wr;ze[ei*Gr]=Qr,ze[ei*Gr+1]=Jr;const ti=ei++;for(let ri=0;ri<Yr.length;ri+=2)ze[ei*Gr]=Yr[ri],ze[ei*Gr+1]=Yr[ri+1],ri>0&&(Kr[Zr++]=ei,Kr[Zr++]=ti,Kr[Zr++]=ei-1),ei++;Kr[Zr++]=ti+1,Kr[Zr++]=ti,Kr[Zr++]=ei-1}},buildEllipse={...buildCircle,extension:{...buildCircle.extension,name:"ellipse"}},buildRoundedRectangle={...buildCircle,extension:{...buildCircle.extension,name:"roundedRectangle"}},closePointEps=1e-4,curveEps=1e-4;function getOrientationOfPoints(Yr){const ze=Yr.length;if(ze<6)return 1;let Gr=0;for(let Wr=0,Kr=Yr[ze-2],Zr=Yr[ze-1];Wr<ze;Wr+=2){const Qr=Yr[Wr],Jr=Yr[Wr+1];Gr+=(Qr-Kr)*(Jr+Zr),Kr=Qr,Zr=Jr}return Gr<0?-1:1}function square(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr){const ei=Yr-Gr*Kr,ti=ze-Wr*Kr,ri=Yr+Gr*Zr,ii=ze+Wr*Zr;let si,ni;Qr?(si=Wr,ni=-Gr):(si=-Wr,ni=Gr);const oi=ei+si,li=ti+ni,ai=ri+si,hi=ii+ni;return Jr.push(oi,li),Jr.push(ai,hi),2}function round(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr){const ei=Gr-Yr,ti=Wr-ze;let ri=Math.atan2(ei,ti),ii=Math.atan2(Kr-Yr,Zr-ze);Jr&&ri<ii?ri+=Math.PI*2:!Jr&&ri>ii&&(ii+=Math.PI*2);let si=ri;const ni=ii-ri,oi=Math.abs(ni),li=Math.sqrt(ei*ei+ti*ti),ai=(15*oi*Math.sqrt(li)/Math.PI>>0)+1,hi=ni/ai;if(si+=hi,Jr){Qr.push(Yr,ze),Qr.push(Gr,Wr);for(let fi=1,pi=si;fi<ai;fi++,pi+=hi)Qr.push(Yr,ze),Qr.push(Yr+Math.sin(pi)*li,ze+Math.cos(pi)*li);Qr.push(Yr,ze),Qr.push(Kr,Zr)}else{Qr.push(Gr,Wr),Qr.push(Yr,ze);for(let fi=1,pi=si;fi<ai;fi++,pi+=hi)Qr.push(Yr+Math.sin(pi)*li,ze+Math.cos(pi)*li),Qr.push(Yr,ze);Qr.push(Kr,Zr),Qr.push(Yr,ze)}return ai*2}function buildLine(Yr,ze,Gr,Wr,Kr,Zr){const Qr=closePointEps;if(Yr.length===0)return;const Jr=ze;let ei=Jr.alignment;if(ze.alignment!==.5){let gi=getOrientationOfPoints(Yr);ei=(ei-.5)*gi+.5}const ti=new Point$1(Yr[0],Yr[1]),ri=new Point$1(Yr[Yr.length-2],Yr[Yr.length-1]),ii=Wr,si=Math.abs(ti.x-ri.x)<Qr&&Math.abs(ti.y-ri.y)<Qr;if(ii){Yr=Yr.slice(),si&&(Yr.pop(),Yr.pop(),ri.set(Yr[Yr.length-2],Yr[Yr.length-1]));const gi=(ti.x+ri.x)*.5,xi=(ri.y+ti.y)*.5;Yr.unshift(gi,xi),Yr.push(gi,xi)}const ni=Kr,oi=Yr.length/2;let li=Yr.length;const ai=ni.length/2,hi=Jr.width/2,fi=hi*hi,pi=Jr.miterLimit*Jr.miterLimit;let mi=Yr[0],Ti=Yr[1],yi=Yr[2],_i=Yr[3],Ai=0,Ri=0,Pi=-(Ti-_i),Si=mi-yi,Bi=0,ki=0,Wi=Math.sqrt(Pi*Pi+Si*Si);Pi/=Wi,Si/=Wi,Pi*=hi,Si*=hi;const Li=ei,ci=(1-Li)*2,ui=Li*2;ii||(Jr.cap==="round"?li+=round(mi-Pi*(ci-ui)*.5,Ti-Si*(ci-ui)*.5,mi-Pi*ci,Ti-Si*ci,mi+Pi*ui,Ti+Si*ui,ni,!0)+2:Jr.cap==="square"&&(li+=square(mi,Ti,Pi,Si,ci,ui,!0,ni))),ni.push(mi-Pi*ci,Ti-Si*ci),ni.push(mi+Pi*ui,Ti+Si*ui);for(let gi=1;gi<oi-1;++gi){mi=Yr[(gi-1)*2],Ti=Yr[(gi-1)*2+1],yi=Yr[gi*2],_i=Yr[gi*2+1],Ai=Yr[(gi+1)*2],Ri=Yr[(gi+1)*2+1],Pi=-(Ti-_i),Si=mi-yi,Wi=Math.sqrt(Pi*Pi+Si*Si),Pi/=Wi,Si/=Wi,Pi*=hi,Si*=hi,Bi=-(_i-Ri),ki=yi-Ai,Wi=Math.sqrt(Bi*Bi+ki*ki),Bi/=Wi,ki/=Wi,Bi*=hi,ki*=hi;const xi=yi-mi,bi=Ti-_i,vi=yi-Ai,Ei=Ri-_i,Ii=xi*vi+bi*Ei,wi=bi*vi-Ei*xi,Di=wi<0;if(Math.abs(wi)<.001*Math.abs(Ii)){ni.push(yi-Pi*ci,_i-Si*ci),ni.push(yi+Pi*ui,_i+Si*ui),Ii>=0&&(Jr.join==="round"?li+=round(yi,_i,yi-Pi*ci,_i-Si*ci,yi-Bi*ci,_i-ki*ci,ni,!1)+4:li+=2,ni.push(yi-Bi*ui,_i-ki*ui),ni.push(yi+Bi*ci,_i+ki*ci));continue}const Ni=(-Pi+mi)*(-Si+_i)-(-Pi+yi)*(-Si+Ti),Fi=(-Bi+Ai)*(-ki+_i)-(-Bi+yi)*(-ki+Ri),Hi=(xi*Fi-vi*Ni)/wi,Oi=(Ei*Ni-bi*Fi)/wi,Xi=(Hi-yi)*(Hi-yi)+(Oi-_i)*(Oi-_i),Vi=yi+(Hi-yi)*ci,zi=_i+(Oi-_i)*ci,$i=yi-(Hi-yi)*ui,Gi=_i-(Oi-_i)*ui,Ui=Math.min(xi*xi+bi*bi,vi*vi+Ei*Ei),ji=Di?ci:ui,qi=Ui+ji*ji*fi;Xi<=qi?Jr.join==="bevel"||Xi/fi>pi?(Di?(ni.push(Vi,zi),ni.push(yi+Pi*ui,_i+Si*ui),ni.push(Vi,zi),ni.push(yi+Bi*ui,_i+ki*ui)):(ni.push(yi-Pi*ci,_i-Si*ci),ni.push($i,Gi),ni.push(yi-Bi*ci,_i-ki*ci),ni.push($i,Gi)),li+=2):Jr.join==="round"?Di?(ni.push(Vi,zi),ni.push(yi+Pi*ui,_i+Si*ui),li+=round(yi,_i,yi+Pi*ui,_i+Si*ui,yi+Bi*ui,_i+ki*ui,ni,!0)+4,ni.push(Vi,zi),ni.push(yi+Bi*ui,_i+ki*ui)):(ni.push(yi-Pi*ci,_i-Si*ci),ni.push($i,Gi),li+=round(yi,_i,yi-Pi*ci,_i-Si*ci,yi-Bi*ci,_i-ki*ci,ni,!1)+4,ni.push(yi-Bi*ci,_i-ki*ci),ni.push($i,Gi)):(ni.push(Vi,zi),ni.push($i,Gi)):(ni.push(yi-Pi*ci,_i-Si*ci),ni.push(yi+Pi*ui,_i+Si*ui),Jr.join==="round"?Di?li+=round(yi,_i,yi+Pi*ui,_i+Si*ui,yi+Bi*ui,_i+ki*ui,ni,!0)+2:li+=round(yi,_i,yi-Pi*ci,_i-Si*ci,yi-Bi*ci,_i-ki*ci,ni,!1)+2:Jr.join==="miter"&&Xi/fi<=pi&&(Di?(ni.push($i,Gi),ni.push($i,Gi)):(ni.push(Vi,zi),ni.push(Vi,zi)),li+=2),ni.push(yi-Bi*ci,_i-ki*ci),ni.push(yi+Bi*ui,_i+ki*ui),li+=2)}mi=Yr[(oi-2)*2],Ti=Yr[(oi-2)*2+1],yi=Yr[(oi-1)*2],_i=Yr[(oi-1)*2+1],Pi=-(Ti-_i),Si=mi-yi,Wi=Math.sqrt(Pi*Pi+Si*Si),Pi/=Wi,Si/=Wi,Pi*=hi,Si*=hi,ni.push(yi-Pi*ci,_i-Si*ci),ni.push(yi+Pi*ui,_i+Si*ui),ii||(Jr.cap==="round"?li+=round(yi-Pi*(ci-ui)*.5,_i-Si*(ci-ui)*.5,yi-Pi*ci,_i-Si*ci,yi+Pi*ui,_i+Si*ui,ni,!1)+2:Jr.cap==="square"&&(li+=square(yi,_i,Pi,Si,ci,ui,!1,ni)));const di=curveEps*curveEps;for(let gi=ai;gi<li+ai-2;++gi)mi=ni[gi*2],Ti=ni[gi*2+1],yi=ni[(gi+1)*2],_i=ni[(gi+1)*2+1],Ai=ni[(gi+2)*2],Ri=ni[(gi+2)*2+1],!(Math.abs(mi*(_i-Ri)+yi*(Ri-Ti)+Ai*(Ti-_i))<di)&&Zr.push(gi,gi+1,gi+2)}function buildPixelLine(Yr,ze,Gr,Wr){const Kr=closePointEps;if(Yr.length===0)return;const Zr=Yr[0],Qr=Yr[1],Jr=Yr[Yr.length-2],ei=Yr[Yr.length-1],ti=ze||Math.abs(Zr-Jr)<Kr&&Math.abs(Qr-ei)<Kr,ri=Gr,ii=Yr.length/2,si=ri.length/2;for(let ni=0;ni<ii;ni++)ri.push(Yr[ni*2]),ri.push(Yr[ni*2+1]);for(let ni=0;ni<ii-1;ni++)Wr.push(si+ni,si+ni+1);ti&&Wr.push(si+ii-1,si)}function triangulateWithHoles(Yr,ze,Gr,Wr,Kr,Zr,Qr){const Jr=earcut(Yr,ze,2);if(!Jr)return;for(let ti=0;ti<Jr.length;ti+=3)Zr[Qr++]=Jr[ti]+Kr,Zr[Qr++]=Jr[ti+1]+Kr,Zr[Qr++]=Jr[ti+2]+Kr;let ei=Kr*Wr;for(let ti=0;ti<Yr.length;ti+=2)Gr[ei]=Yr[ti],Gr[ei+1]=Yr[ti+1],ei+=Wr}const emptyArray=[],buildPolygon={extension:{type:ExtensionType.ShapeBuilder,name:"polygon"},build(Yr,ze){for(let Gr=0;Gr<Yr.points.length;Gr++)ze[Gr]=Yr.points[Gr];return ze},triangulate(Yr,ze,Gr,Wr,Kr,Zr){triangulateWithHoles(Yr,emptyArray,ze,Gr,Wr,Kr,Zr)}},buildRectangle={extension:{type:ExtensionType.ShapeBuilder,name:"rectangle"},build(Yr,ze){const Gr=Yr,Wr=Gr.x,Kr=Gr.y,Zr=Gr.width,Qr=Gr.height;return Zr>=0&&Qr>=0&&(ze[0]=Wr,ze[1]=Kr,ze[2]=Wr+Zr,ze[3]=Kr,ze[4]=Wr+Zr,ze[5]=Kr+Qr,ze[6]=Wr,ze[7]=Kr+Qr),ze},triangulate(Yr,ze,Gr,Wr,Kr,Zr){let Qr=0;Wr*=Gr,ze[Wr+Qr]=Yr[0],ze[Wr+Qr+1]=Yr[1],Qr+=Gr,ze[Wr+Qr]=Yr[2],ze[Wr+Qr+1]=Yr[3],Qr+=Gr,ze[Wr+Qr]=Yr[6],ze[Wr+Qr+1]=Yr[7],Qr+=Gr,ze[Wr+Qr]=Yr[4],ze[Wr+Qr+1]=Yr[5],Qr+=Gr;const Jr=Wr/Gr;Kr[Zr++]=Jr,Kr[Zr++]=Jr+1,Kr[Zr++]=Jr+2,Kr[Zr++]=Jr+1,Kr[Zr++]=Jr+3,Kr[Zr++]=Jr+2}},buildTriangle={extension:{type:ExtensionType.ShapeBuilder,name:"triangle"},build(Yr,ze){return ze[0]=Yr.x,ze[1]=Yr.y,ze[2]=Yr.x2,ze[3]=Yr.y2,ze[4]=Yr.x3,ze[5]=Yr.y3,ze},triangulate(Yr,ze,Gr,Wr,Kr,Zr){let Qr=0;Wr*=Gr,ze[Wr+Qr]=Yr[0],ze[Wr+Qr+1]=Yr[1],Qr+=Gr,ze[Wr+Qr]=Yr[2],ze[Wr+Qr+1]=Yr[3],Qr+=Gr,ze[Wr+Qr]=Yr[4],ze[Wr+Qr+1]=Yr[5];const Jr=Wr/Gr;Kr[Zr++]=Jr,Kr[Zr++]=Jr+1,Kr[Zr++]=Jr+2}},tempTextureMatrix$1=new Matrix,tempRect$2=new Rectangle;function generateTextureMatrix(Yr,ze,Gr,Wr){const Kr=ze.matrix?Yr.copyFrom(ze.matrix).invert():Yr.identity();if(ze.textureSpace==="local"){const Zr=Gr.getBounds(tempRect$2);Kr.translate(-Zr.x,-Zr.y),Kr.scale(1/Zr.width,1/Zr.height)}else{Kr.translate(ze.texture.frame.x,ze.texture.frame.y),Kr.scale(1/ze.texture.source.width,1/ze.texture.source.height);const Zr=ze.texture.source.style;Zr.addressMode==="clamp-to-edge"&&(Zr.addressMode="repeat",Zr.update())}return Wr&&Kr.append(tempTextureMatrix$1.copyFrom(Wr).invert()),Kr}const shapeBuilders={};extensions.handleByMap(ExtensionType.ShapeBuilder,shapeBuilders);extensions.add(buildRectangle,buildPolygon,buildTriangle,buildCircle,buildEllipse,buildRoundedRectangle);const tempRect$1=new Rectangle,tempTextureMatrix=new Matrix;function buildContextBatches(Yr,ze){const{geometryData:Gr,batches:Wr}=ze;Wr.length=0,Gr.indices.length=0,Gr.vertices.length=0,Gr.uvs.length=0;for(let Kr=0;Kr<Yr.instructions.length;Kr++){const Zr=Yr.instructions[Kr];if(Zr.action==="texture")addTextureToGeometryData(Zr.data,Wr,Gr);else if(Zr.action==="fill"||Zr.action==="stroke"){const Qr=Zr.action==="stroke",Jr=Zr.data.path.shapePath,ei=Zr.data.style,ti=Zr.data.hole;Qr&&ti&&addShapePathToGeometryData(ti.shapePath,ei,!0,Wr,Gr),ti&&(Jr.shapePrimitives[Jr.shapePrimitives.length-1].holes=ti.shapePath.shapePrimitives),addShapePathToGeometryData(Jr,ei,Qr,Wr,Gr)}}}function addTextureToGeometryData(Yr,ze,Gr){const{vertices:Wr,uvs:Kr,indices:Zr}=Gr,Qr=Zr.length,Jr=Wr.length/2,ei=[],ti=shapeBuilders.rectangle,ri=tempRect$1,ii=Yr.image;ri.x=Yr.dx,ri.y=Yr.dy,ri.width=Yr.dw,ri.height=Yr.dh;const si=Yr.transform;ti.build(ri,ei),si&&transformVertices(ei,si),ti.triangulate(ei,Wr,2,Jr,Zr,Qr);const ni=ii.uvs;Kr.push(ni.x0,ni.y0,ni.x1,ni.y1,ni.x3,ni.y3,ni.x2,ni.y2);const oi=BigPool.get(BatchableGraphics);oi.indexOffset=Qr,oi.indexSize=Zr.length-Qr,oi.attributeOffset=Jr,oi.attributeSize=Wr.length/2-Jr,oi.baseColor=Yr.style,oi.alpha=Yr.alpha,oi.texture=ii,oi.geometryData=Gr,ze.push(oi)}function addShapePathToGeometryData(Yr,ze,Gr,Wr,Kr){const{vertices:Zr,uvs:Qr,indices:Jr}=Kr;Yr.shapePrimitives.forEach(({shape:ei,transform:ti,holes:ri})=>{const ii=Jr.length,si=Zr.length/2,ni=[],oi=shapeBuilders[ei.type];let li="triangle-list";if(oi.build(ei,ni),ti&&transformVertices(ni,ti),Gr){const pi=ei.closePath??!0,mi=ze;mi.pixelLine?(buildPixelLine(ni,pi,Zr,Jr),li="line-list"):buildLine(ni,mi,!1,pi,Zr,Jr)}else if(ri){const pi=[],mi=ni.slice();getHoleArrays(ri).forEach(yi=>{pi.push(mi.length/2),mi.push(...yi)}),triangulateWithHoles(mi,pi,Zr,2,si,Jr,ii)}else oi.triangulate(ni,Zr,2,si,Jr,ii);const ai=Qr.length/2,hi=ze.texture;if(hi!==Texture.WHITE){const pi=generateTextureMatrix(tempTextureMatrix,ze,ei,ti);buildUvs(Zr,2,si,Qr,ai,2,Zr.length/2-si,pi)}else buildSimpleUvs(Qr,ai,2,Zr.length/2-si);const fi=BigPool.get(BatchableGraphics);fi.indexOffset=ii,fi.indexSize=Jr.length-ii,fi.attributeOffset=si,fi.attributeSize=Zr.length/2-si,fi.baseColor=ze.color,fi.alpha=ze.alpha,fi.texture=hi,fi.geometryData=Kr,fi.topology=li,Wr.push(fi)})}function getHoleArrays(Yr){const ze=[];for(let Gr=0;Gr<Yr.length;Gr++){const Wr=Yr[Gr].shape,Kr=[];shapeBuilders[Wr.type].build(Wr,Kr),ze.push(Kr)}return ze}class GpuGraphicsContext{constructor(){this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}}class GraphicsContextRenderData{constructor(){this.batcher=new DefaultBatcher,this.instructions=new InstructionSet}init(){this.instructions.reset()}get geometry(){return deprecation(v8_3_4,"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."),this.batcher.geometry}}const _GraphicsContextSystem=class fs{constructor(ze){this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null),ze.renderableGC.addManagedHash(this,"_gpuContextHash"),ze.renderableGC.addManagedHash(this,"_graphicsDataContextHash")}init(ze){fs.defaultOptions.bezierSmoothness=(ze==null?void 0:ze.bezierSmoothness)??fs.defaultOptions.bezierSmoothness}getContextRenderData(ze){return this._graphicsDataContextHash[ze.uid]||this._initContextRenderData(ze)}updateGpuContext(ze){let Gr=this._gpuContextHash[ze.uid]||this._initContext(ze);if(ze.dirty){Gr?this._cleanGraphicsContextData(ze):Gr=this._initContext(ze),buildContextBatches(ze,Gr);const Wr=ze.batchMode;ze.customShader||Wr==="no-batch"?Gr.isBatchable=!1:Wr==="auto"&&(Gr.isBatchable=Gr.geometryData.vertices.length<400),ze.dirty=!1}return Gr}getGpuContext(ze){return this._gpuContextHash[ze.uid]||this._initContext(ze)}_initContextRenderData(ze){const Gr=BigPool.get(GraphicsContextRenderData),{batches:Wr,geometryData:Kr}=this._gpuContextHash[ze.uid],Zr=Kr.vertices.length,Qr=Kr.indices.length;for(let ri=0;ri<Wr.length;ri++)Wr[ri].applyTransform=!1;const Jr=Gr.batcher;Jr.ensureAttributeBuffer(Zr),Jr.ensureIndexBuffer(Qr),Jr.begin();for(let ri=0;ri<Wr.length;ri++){const ii=Wr[ri];Jr.add(ii)}Jr.finish(Gr.instructions);const ei=Jr.geometry;ei.indexBuffer.setDataWithSize(Jr.indexBuffer,Jr.indexSize,!0),ei.buffers[0].setDataWithSize(Jr.attributeBuffer.float32View,Jr.attributeSize,!0);const ti=Jr.batches;for(let ri=0;ri<ti.length;ri++){const ii=ti[ri];ii.bindGroup=getTextureBatchBindGroup(ii.textures.textures,ii.textures.count)}return this._graphicsDataContextHash[ze.uid]=Gr,Gr}_initContext(ze){const Gr=new GpuGraphicsContext;return Gr.context=ze,this._gpuContextHash[ze.uid]=Gr,ze.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[ze.uid]}onGraphicsContextDestroy(ze){this._cleanGraphicsContextData(ze),ze.off("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[ze.uid]=null}_cleanGraphicsContextData(ze){const Gr=this._gpuContextHash[ze.uid];Gr.isBatchable||this._graphicsDataContextHash[ze.uid]&&(BigPool.return(this.getContextRenderData(ze)),this._graphicsDataContextHash[ze.uid]=null),Gr.batches&&Gr.batches.forEach(Wr=>{BigPool.return(Wr)})}destroy(){for(const ze in this._gpuContextHash)this._gpuContextHash[ze]&&this.onGraphicsContextDestroy(this._gpuContextHash[ze].context)}};_GraphicsContextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"graphicsContext"};_GraphicsContextSystem.defaultOptions={bezierSmoothness:.5};let GraphicsContextSystem=_GraphicsContextSystem;const RECURSION_LIMIT$1=8,FLT_EPSILON$1=11920929e-14,PATH_DISTANCE_EPSILON$1=1;function buildAdaptiveBezier(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti){const ii=Math.min(.99,Math.max(0,ti??GraphicsContextSystem.defaultOptions.bezierSmoothness));let si=(PATH_DISTANCE_EPSILON$1-ii)/1;return si*=si,begin$1(ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,Yr,si),Yr}function begin$1(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti){recursive$1(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti,0),ei.push(Qr,Jr)}function recursive$1(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti,ri){if(ri>RECURSION_LIMIT$1)return;const ii=(Yr+Gr)/2,si=(ze+Wr)/2,ni=(Gr+Kr)/2,oi=(Wr+Zr)/2,li=(Kr+Qr)/2,ai=(Zr+Jr)/2,hi=(ii+ni)/2,fi=(si+oi)/2,pi=(ni+li)/2,mi=(oi+ai)/2,Ti=(hi+pi)/2,yi=(fi+mi)/2;if(ri>0){let _i=Qr-Yr,Ai=Jr-ze;const Ri=Math.abs((Gr-Qr)*Ai-(Wr-Jr)*_i),Pi=Math.abs((Kr-Qr)*Ai-(Zr-Jr)*_i);if(Ri>FLT_EPSILON$1&&Pi>FLT_EPSILON$1){if((Ri+Pi)*(Ri+Pi)<=ti*(_i*_i+Ai*Ai)){ei.push(Ti,yi);return}}else if(Ri>FLT_EPSILON$1){if(Ri*Ri<=ti*(_i*_i+Ai*Ai)){ei.push(Ti,yi);return}}else if(Pi>FLT_EPSILON$1){if(Pi*Pi<=ti*(_i*_i+Ai*Ai)){ei.push(Ti,yi);return}}else if(_i=Ti-(Yr+Qr)/2,Ai=yi-(ze+Jr)/2,_i*_i+Ai*Ai<=ti){ei.push(Ti,yi);return}}recursive$1(Yr,ze,ii,si,hi,fi,Ti,yi,ei,ti,ri+1),recursive$1(Ti,yi,pi,mi,li,ai,Qr,Jr,ei,ti,ri+1)}const RECURSION_LIMIT=8,FLT_EPSILON=11920929e-14,PATH_DISTANCE_EPSILON=1;function buildAdaptiveQuadratic(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr){const ti=Math.min(.99,Math.max(0,Jr??GraphicsContextSystem.defaultOptions.bezierSmoothness));let ri=(PATH_DISTANCE_EPSILON-ti)/1;return ri*=ri,begin(ze,Gr,Wr,Kr,Zr,Qr,Yr,ri),Yr}function begin(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr){recursive(Qr,Yr,ze,Gr,Wr,Kr,Zr,Jr,0),Qr.push(Kr,Zr)}function recursive(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr,ei){if(ei>RECURSION_LIMIT)return;const ti=(ze+Wr)/2,ri=(Gr+Kr)/2,ii=(Wr+Zr)/2,si=(Kr+Qr)/2,ni=(ti+ii)/2,oi=(ri+si)/2;let li=Zr-ze,ai=Qr-Gr;const hi=Math.abs((Wr-Zr)*ai-(Kr-Qr)*li);if(hi>FLT_EPSILON){if(hi*hi<=Jr*(li*li+ai*ai)){Yr.push(ni,oi);return}}else if(li=ni-(ze+Zr)/2,ai=oi-(Gr+Qr)/2,li*li+ai*ai<=Jr){Yr.push(ni,oi);return}recursive(Yr,ze,Gr,ti,ri,ni,oi,Jr,ei+1),recursive(Yr,ni,oi,ii,si,Zr,Qr,Jr,ei+1)}function buildArc(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr){let ei=Math.abs(Kr-Zr);(!Qr&&Kr>Zr||Qr&&Zr>Kr)&&(ei=2*Math.PI-ei),Jr||(Jr=Math.max(6,Math.floor(6*Math.pow(Wr,1/3)*(ei/Math.PI)))),Jr=Math.max(Jr,3);let ti=ei/Jr,ri=Kr;ti*=Qr?-1:1;for(let ii=0;ii<Jr+1;ii++){const si=Math.cos(ri),ni=Math.sin(ri),oi=ze+si*Wr,li=Gr+ni*Wr;Yr.push(oi,li),ri+=ti}}function buildArcTo(Yr,ze,Gr,Wr,Kr,Zr){const Qr=Yr[Yr.length-2],ei=Yr[Yr.length-1]-Gr,ti=Qr-ze,ri=Kr-Gr,ii=Wr-ze,si=Math.abs(ei*ii-ti*ri);if(si<1e-8||Zr===0){(Yr[Yr.length-2]!==ze||Yr[Yr.length-1]!==Gr)&&Yr.push(ze,Gr);return}const ni=ei*ei+ti*ti,oi=ri*ri+ii*ii,li=ei*ri+ti*ii,ai=Zr*Math.sqrt(ni)/si,hi=Zr*Math.sqrt(oi)/si,fi=ai*li/ni,pi=hi*li/oi,mi=ai*ii+hi*ti,Ti=ai*ri+hi*ei,yi=ti*(hi+fi),_i=ei*(hi+fi),Ai=ii*(ai+pi),Ri=ri*(ai+pi),Pi=Math.atan2(_i-Ti,yi-mi),Si=Math.atan2(Ri-Ti,Ai-mi);buildArc(Yr,mi+ze,Ti+Gr,Zr,Pi,Si,ti*ri>ii*ei)}const TAU=Math.PI*2,out={centerX:0,centerY:0,ang1:0,ang2:0},mapToEllipse=({x:Yr,y:ze},Gr,Wr,Kr,Zr,Qr,Jr,ei)=>{Yr*=Gr,ze*=Wr;const ti=Kr*Yr-Zr*ze,ri=Zr*Yr+Kr*ze;return ei.x=ti+Qr,ei.y=ri+Jr,ei};function approxUnitArc(Yr,ze){const Gr=ze===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(ze/4),Wr=ze===1.5707963267948966?.551915024494:Gr,Kr=Math.cos(Yr),Zr=Math.sin(Yr),Qr=Math.cos(Yr+ze),Jr=Math.sin(Yr+ze);return[{x:Kr-Zr*Wr,y:Zr+Kr*Wr},{x:Qr+Jr*Wr,y:Jr-Qr*Wr},{x:Qr,y:Jr}]}const vectorAngle=(Yr,ze,Gr,Wr)=>{const Kr=Yr*Wr-ze*Gr<0?-1:1;let Zr=Yr*Gr+ze*Wr;return Zr>1&&(Zr=1),Zr<-1&&(Zr=-1),Kr*Math.acos(Zr)},getArcCenter=(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti,ri,ii,si)=>{const ni=Math.pow(Kr,2),oi=Math.pow(Zr,2),li=Math.pow(ri,2),ai=Math.pow(ii,2);let hi=ni*oi-ni*ai-oi*li;hi<0&&(hi=0),hi/=ni*ai+oi*li,hi=Math.sqrt(hi)*(Qr===Jr?-1:1);const fi=hi*Kr/Zr*ii,pi=hi*-Zr/Kr*ri,mi=ti*fi-ei*pi+(Yr+Gr)/2,Ti=ei*fi+ti*pi+(ze+Wr)/2,yi=(ri-fi)/Kr,_i=(ii-pi)/Zr,Ai=(-ri-fi)/Kr,Ri=(-ii-pi)/Zr,Pi=vectorAngle(1,0,yi,_i);let Si=vectorAngle(yi,_i,Ai,Ri);Jr===0&&Si>0&&(Si-=TAU),Jr===1&&Si<0&&(Si+=TAU),si.centerX=mi,si.centerY=Ti,si.ang1=Pi,si.ang2=Si};function buildArcToSvg(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr=0,ei=0,ti=0){if(Zr===0||Qr===0)return;const ri=Math.sin(Jr*TAU/360),ii=Math.cos(Jr*TAU/360),si=ii*(ze-Wr)/2+ri*(Gr-Kr)/2,ni=-ri*(ze-Wr)/2+ii*(Gr-Kr)/2;if(si===0&&ni===0)return;Zr=Math.abs(Zr),Qr=Math.abs(Qr);const oi=Math.pow(si,2)/Math.pow(Zr,2)+Math.pow(ni,2)/Math.pow(Qr,2);oi>1&&(Zr*=Math.sqrt(oi),Qr*=Math.sqrt(oi)),getArcCenter(ze,Gr,Wr,Kr,Zr,Qr,ei,ti,ri,ii,si,ni,out);let{ang1:li,ang2:ai}=out;const{centerX:hi,centerY:fi}=out;let pi=Math.abs(ai)/(TAU/4);Math.abs(1-pi)<1e-7&&(pi=1);const mi=Math.max(Math.ceil(pi),1);ai/=mi;let Ti=Yr[Yr.length-2],yi=Yr[Yr.length-1];const _i={x:0,y:0};for(let Ai=0;Ai<mi;Ai++){const Ri=approxUnitArc(li,ai),{x:Pi,y:Si}=mapToEllipse(Ri[0],Zr,Qr,ii,ri,hi,fi,_i),{x:Bi,y:ki}=mapToEllipse(Ri[1],Zr,Qr,ii,ri,hi,fi,_i),{x:Wi,y:Li}=mapToEllipse(Ri[2],Zr,Qr,ii,ri,hi,fi,_i);buildAdaptiveBezier(Yr,Ti,yi,Pi,Si,Bi,ki,Wi,Li),Ti=Wi,yi=Li,li+=ai}}function roundedShapeArc(Yr,ze,Gr){const Wr=(Qr,Jr)=>{const ei=Jr.x-Qr.x,ti=Jr.y-Qr.y,ri=Math.sqrt(ei*ei+ti*ti),ii=ei/ri,si=ti/ri;return{len:ri,nx:ii,ny:si}},Kr=(Qr,Jr)=>{Qr===0?Yr.moveTo(Jr.x,Jr.y):Yr.lineTo(Jr.x,Jr.y)};let Zr=ze[ze.length-1];for(let Qr=0;Qr<ze.length;Qr++){const Jr=ze[Qr%ze.length],ei=Jr.radius??Gr;if(ei<=0){Kr(Qr,Jr),Zr=Jr;continue}const ti=ze[(Qr+1)%ze.length],ri=Wr(Jr,Zr),ii=Wr(Jr,ti);if(ri.len<1e-4||ii.len<1e-4){Kr(Qr,Jr),Zr=Jr;continue}let si=Math.asin(ri.nx*ii.ny-ri.ny*ii.nx),ni=1,oi=!1;ri.nx*ii.nx-ri.ny*-ii.ny<0?si<0?si=Math.PI+si:(si=Math.PI-si,ni=-1,oi=!0):si>0&&(ni=-1,oi=!0);const li=si/2;let ai,hi=Math.abs(Math.cos(li)*ei/Math.sin(li));hi>Math.min(ri.len/2,ii.len/2)?(hi=Math.min(ri.len/2,ii.len/2),ai=Math.abs(hi*Math.sin(li)/Math.cos(li))):ai=ei;const fi=Jr.x+ii.nx*hi+-ii.ny*ai*ni,pi=Jr.y+ii.ny*hi+ii.nx*ai*ni,mi=Math.atan2(ri.ny,ri.nx)+Math.PI/2*ni,Ti=Math.atan2(ii.ny,ii.nx)-Math.PI/2*ni;Qr===0&&Yr.moveTo(fi+Math.cos(mi)*ai,pi+Math.sin(mi)*ai),Yr.arc(fi,pi,ai,mi,Ti,oi),Zr=Jr}}function roundedShapeQuadraticCurve(Yr,ze,Gr,Wr){const Kr=(Jr,ei)=>Math.sqrt((Jr.x-ei.x)**2+(Jr.y-ei.y)**2),Zr=(Jr,ei,ti)=>({x:Jr.x+(ei.x-Jr.x)*ti,y:Jr.y+(ei.y-Jr.y)*ti}),Qr=ze.length;for(let Jr=0;Jr<Qr;Jr++){const ei=ze[(Jr+1)%Qr],ti=ei.radius??Gr;if(ti<=0){Jr===0?Yr.moveTo(ei.x,ei.y):Yr.lineTo(ei.x,ei.y);continue}const ri=ze[Jr],ii=ze[(Jr+2)%Qr],si=Kr(ri,ei);let ni;if(si<1e-4)ni=ei;else{const ai=Math.min(si/2,ti);ni=Zr(ei,ri,ai/si)}const oi=Kr(ii,ei);let li;if(oi<1e-4)li=ei;else{const ai=Math.min(oi/2,ti);li=Zr(ei,ii,ai/oi)}Jr===0?Yr.moveTo(ni.x,ni.y):Yr.lineTo(ni.x,ni.y),Yr.quadraticCurveTo(ei.x,ei.y,li.x,li.y,Wr)}}const tempRectangle=new Rectangle;class ShapePath{constructor(ze){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Bounds,this._graphicsPath2D=ze,this.signed=ze.checkForHoles}moveTo(ze,Gr){return this.startPoly(ze,Gr),this}lineTo(ze,Gr){this._ensurePoly();const Wr=this._currentPoly.points,Kr=Wr[Wr.length-2],Zr=Wr[Wr.length-1];return(Kr!==ze||Zr!==Gr)&&Wr.push(ze,Gr),this}arc(ze,Gr,Wr,Kr,Zr,Qr){this._ensurePoly(!1);const Jr=this._currentPoly.points;return buildArc(Jr,ze,Gr,Wr,Kr,Zr,Qr),this}arcTo(ze,Gr,Wr,Kr,Zr){this._ensurePoly();const Qr=this._currentPoly.points;return buildArcTo(Qr,ze,Gr,Wr,Kr,Zr),this}arcToSvg(ze,Gr,Wr,Kr,Zr,Qr,Jr){const ei=this._currentPoly.points;return buildArcToSvg(ei,this._currentPoly.lastX,this._currentPoly.lastY,Qr,Jr,ze,Gr,Wr,Kr,Zr),this}bezierCurveTo(ze,Gr,Wr,Kr,Zr,Qr,Jr){this._ensurePoly();const ei=this._currentPoly;return buildAdaptiveBezier(this._currentPoly.points,ei.lastX,ei.lastY,ze,Gr,Wr,Kr,Zr,Qr,Jr),this}quadraticCurveTo(ze,Gr,Wr,Kr,Zr){this._ensurePoly();const Qr=this._currentPoly;return buildAdaptiveQuadratic(this._currentPoly.points,Qr.lastX,Qr.lastY,ze,Gr,Wr,Kr,Zr),this}closePath(){return this.endPoly(!0),this}addPath(ze,Gr){this.endPoly(),Gr&&!Gr.isIdentity()&&(ze=ze.clone(!0),ze.transform(Gr));const Wr=this.shapePrimitives,Kr=Wr.length;for(let Zr=0;Zr<ze.instructions.length;Zr++){const Qr=ze.instructions[Zr];this[Qr.action](...Qr.data)}if(ze.checkForHoles&&Wr.length-Kr>1){let Zr=null;for(let Qr=Kr;Qr<Wr.length;Qr++){const Jr=Wr[Qr];if(Jr.shape.type==="polygon"){const ei=Jr.shape,ti=Zr==null?void 0:Zr.shape;ti&&ti.containsPolygon(ei)?(Zr.holes||(Zr.holes=[]),Zr.holes.push(Jr),Wr.copyWithin(Qr,Qr+1),Wr.length--,Qr--):Zr=Jr}}}return this}finish(ze=!1){this.endPoly(ze)}rect(ze,Gr,Wr,Kr,Zr){return this.drawShape(new Rectangle(ze,Gr,Wr,Kr),Zr),this}circle(ze,Gr,Wr,Kr){return this.drawShape(new Circle(ze,Gr,Wr),Kr),this}poly(ze,Gr,Wr){const Kr=new Polygon(ze);return Kr.closePath=Gr,this.drawShape(Kr,Wr),this}regularPoly(ze,Gr,Wr,Kr,Zr=0,Qr){Kr=Math.max(Kr|0,3);const Jr=-1*Math.PI/2+Zr,ei=Math.PI*2/Kr,ti=[];for(let ri=0;ri<Kr;ri++){const ii=Jr-ri*ei;ti.push(ze+Wr*Math.cos(ii),Gr+Wr*Math.sin(ii))}return this.poly(ti,!0,Qr),this}roundPoly(ze,Gr,Wr,Kr,Zr,Qr=0,Jr){if(Kr=Math.max(Kr|0,3),Zr<=0)return this.regularPoly(ze,Gr,Wr,Kr,Qr);const ei=Wr*Math.sin(Math.PI/Kr)-.001;Zr=Math.min(Zr,ei);const ti=-1*Math.PI/2+Qr,ri=Math.PI*2/Kr,ii=(Kr-2)*Math.PI/Kr/2;for(let si=0;si<Kr;si++){const ni=si*ri+ti,oi=ze+Wr*Math.cos(ni),li=Gr+Wr*Math.sin(ni),ai=ni+Math.PI+ii,hi=ni-Math.PI-ii,fi=oi+Zr*Math.cos(ai),pi=li+Zr*Math.sin(ai),mi=oi+Zr*Math.cos(hi),Ti=li+Zr*Math.sin(hi);si===0?this.moveTo(fi,pi):this.lineTo(fi,pi),this.quadraticCurveTo(oi,li,mi,Ti,Jr)}return this.closePath()}roundShape(ze,Gr,Wr=!1,Kr){return ze.length<3?this:(Wr?roundedShapeQuadraticCurve(this,ze,Gr,Kr):roundedShapeArc(this,ze,Gr),this.closePath())}filletRect(ze,Gr,Wr,Kr,Zr){if(Zr===0)return this.rect(ze,Gr,Wr,Kr);const Qr=Math.min(Wr,Kr)/2,Jr=Math.min(Qr,Math.max(-Qr,Zr)),ei=ze+Wr,ti=Gr+Kr,ri=Jr<0?-Jr:0,ii=Math.abs(Jr);return this.moveTo(ze,Gr+ii).arcTo(ze+ri,Gr+ri,ze+ii,Gr,ii).lineTo(ei-ii,Gr).arcTo(ei-ri,Gr+ri,ei,Gr+ii,ii).lineTo(ei,ti-ii).arcTo(ei-ri,ti-ri,ze+Wr-ii,ti,ii).lineTo(ze+ii,ti).arcTo(ze+ri,ti-ri,ze,ti-ii,ii).closePath()}chamferRect(ze,Gr,Wr,Kr,Zr,Qr){if(Zr<=0)return this.rect(ze,Gr,Wr,Kr);const Jr=Math.min(Zr,Math.min(Wr,Kr)/2),ei=ze+Wr,ti=Gr+Kr,ri=[ze+Jr,Gr,ei-Jr,Gr,ei,Gr+Jr,ei,ti-Jr,ei-Jr,ti,ze+Jr,ti,ze,ti-Jr,ze,Gr+Jr];for(let ii=ri.length-1;ii>=2;ii-=2)ri[ii]===ri[ii-2]&&ri[ii-1]===ri[ii-3]&&ri.splice(ii-1,2);return this.poly(ri,!0,Qr)}ellipse(ze,Gr,Wr,Kr,Zr){return this.drawShape(new Ellipse(ze,Gr,Wr,Kr),Zr),this}roundRect(ze,Gr,Wr,Kr,Zr,Qr){return this.drawShape(new RoundedRectangle(ze,Gr,Wr,Kr,Zr),Qr),this}drawShape(ze,Gr){return this.endPoly(),this.shapePrimitives.push({shape:ze,transform:Gr}),this}startPoly(ze,Gr){let Wr=this._currentPoly;return Wr&&this.endPoly(),Wr=new Polygon,Wr.points.push(ze,Gr),this._currentPoly=Wr,this}endPoly(ze=!1){const Gr=this._currentPoly;return Gr&&Gr.points.length>2&&(Gr.closePath=ze,this.shapePrimitives.push({shape:Gr})),this._currentPoly=null,this}_ensurePoly(ze=!0){if(!this._currentPoly&&(this._currentPoly=new Polygon,ze)){const Gr=this.shapePrimitives[this.shapePrimitives.length-1];if(Gr){let Wr=Gr.shape.x,Kr=Gr.shape.y;if(Gr.transform&&!Gr.transform.isIdentity()){const Zr=Gr.transform,Qr=Wr;Wr=Zr.a*Wr+Zr.c*Kr+Zr.tx,Kr=Zr.b*Qr+Zr.d*Kr+Zr.ty}this._currentPoly.points.push(Wr,Kr)}else this._currentPoly.points.push(0,0)}}buildPath(){const ze=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let Gr=0;Gr<ze.instructions.length;Gr++){const Wr=ze.instructions[Gr];this[Wr.action](...Wr.data)}this.finish()}get bounds(){const ze=this._bounds;ze.clear();const Gr=this.shapePrimitives;for(let Wr=0;Wr<Gr.length;Wr++){const Kr=Gr[Wr],Zr=Kr.shape.getBounds(tempRectangle);Kr.transform?ze.addRect(Zr,Kr.transform):ze.addRect(Zr)}return ze}}class GraphicsPath{constructor(ze,Gr=!1){this.instructions=[],this.uid=uid$1("graphicsPath"),this._dirty=!0,this.checkForHoles=Gr,typeof ze=="string"?parseSVGPath(ze,this):this.instructions=(ze==null?void 0:ze.slice())??[]}get shapePath(){return this._shapePath||(this._shapePath=new ShapePath(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(ze,Gr){return ze=ze.clone(),this.instructions.push({action:"addPath",data:[ze,Gr]}),this._dirty=!0,this}arc(...ze){return this.instructions.push({action:"arc",data:ze}),this._dirty=!0,this}arcTo(...ze){return this.instructions.push({action:"arcTo",data:ze}),this._dirty=!0,this}arcToSvg(...ze){return this.instructions.push({action:"arcToSvg",data:ze}),this._dirty=!0,this}bezierCurveTo(...ze){return this.instructions.push({action:"bezierCurveTo",data:ze}),this._dirty=!0,this}bezierCurveToShort(ze,Gr,Wr,Kr,Zr){const Qr=this.instructions[this.instructions.length-1],Jr=this.getLastPoint(Point$1.shared);let ei=0,ti=0;if(!Qr||Qr.action!=="bezierCurveTo")ei=Jr.x,ti=Jr.y;else{ei=Qr.data[2],ti=Qr.data[3];const ri=Jr.x,ii=Jr.y;ei=ri+(ri-ei),ti=ii+(ii-ti)}return this.instructions.push({action:"bezierCurveTo",data:[ei,ti,ze,Gr,Wr,Kr,Zr]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...ze){return this.instructions.push({action:"ellipse",data:ze}),this._dirty=!0,this}lineTo(...ze){return this.instructions.push({action:"lineTo",data:ze}),this._dirty=!0,this}moveTo(...ze){return this.instructions.push({action:"moveTo",data:ze}),this}quadraticCurveTo(...ze){return this.instructions.push({action:"quadraticCurveTo",data:ze}),this._dirty=!0,this}quadraticCurveToShort(ze,Gr,Wr){const Kr=this.instructions[this.instructions.length-1],Zr=this.getLastPoint(Point$1.shared);let Qr=0,Jr=0;if(!Kr||Kr.action!=="quadraticCurveTo")Qr=Zr.x,Jr=Zr.y;else{Qr=Kr.data[0],Jr=Kr.data[1];const ei=Zr.x,ti=Zr.y;Qr=ei+(ei-Qr),Jr=ti+(ti-Jr)}return this.instructions.push({action:"quadraticCurveTo",data:[Qr,Jr,ze,Gr,Wr]}),this._dirty=!0,this}rect(ze,Gr,Wr,Kr,Zr){return this.instructions.push({action:"rect",data:[ze,Gr,Wr,Kr,Zr]}),this._dirty=!0,this}circle(ze,Gr,Wr,Kr){return this.instructions.push({action:"circle",data:[ze,Gr,Wr,Kr]}),this._dirty=!0,this}roundRect(...ze){return this.instructions.push({action:"roundRect",data:ze}),this._dirty=!0,this}poly(...ze){return this.instructions.push({action:"poly",data:ze}),this._dirty=!0,this}regularPoly(...ze){return this.instructions.push({action:"regularPoly",data:ze}),this._dirty=!0,this}roundPoly(...ze){return this.instructions.push({action:"roundPoly",data:ze}),this._dirty=!0,this}roundShape(...ze){return this.instructions.push({action:"roundShape",data:ze}),this._dirty=!0,this}filletRect(...ze){return this.instructions.push({action:"filletRect",data:ze}),this._dirty=!0,this}chamferRect(...ze){return this.instructions.push({action:"chamferRect",data:ze}),this._dirty=!0,this}star(ze,Gr,Wr,Kr,Zr,Qr,Jr){Zr||(Zr=Kr/2);const ei=-1*Math.PI/2+Qr,ti=Wr*2,ri=Math.PI*2/ti,ii=[];for(let si=0;si<ti;si++){const ni=si%2?Zr:Kr,oi=si*ri+ei;ii.push(ze+ni*Math.cos(oi),Gr+ni*Math.sin(oi))}return this.poly(ii,!0,Jr),this}clone(ze=!1){const Gr=new GraphicsPath;if(Gr.checkForHoles=this.checkForHoles,!ze)Gr.instructions=this.instructions.slice();else for(let Wr=0;Wr<this.instructions.length;Wr++){const Kr=this.instructions[Wr];Gr.instructions.push({action:Kr.action,data:Kr.data.slice()})}return Gr}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(ze){if(ze.isIdentity())return this;const Gr=ze.a,Wr=ze.b,Kr=ze.c,Zr=ze.d,Qr=ze.tx,Jr=ze.ty;let ei=0,ti=0,ri=0,ii=0,si=0,ni=0,oi=0,li=0;for(let ai=0;ai<this.instructions.length;ai++){const hi=this.instructions[ai],fi=hi.data;switch(hi.action){case"moveTo":case"lineTo":ei=fi[0],ti=fi[1],fi[0]=Gr*ei+Kr*ti+Qr,fi[1]=Wr*ei+Zr*ti+Jr;break;case"bezierCurveTo":ri=fi[0],ii=fi[1],si=fi[2],ni=fi[3],ei=fi[4],ti=fi[5],fi[0]=Gr*ri+Kr*ii+Qr,fi[1]=Wr*ri+Zr*ii+Jr,fi[2]=Gr*si+Kr*ni+Qr,fi[3]=Wr*si+Zr*ni+Jr,fi[4]=Gr*ei+Kr*ti+Qr,fi[5]=Wr*ei+Zr*ti+Jr;break;case"quadraticCurveTo":ri=fi[0],ii=fi[1],ei=fi[2],ti=fi[3],fi[0]=Gr*ri+Kr*ii+Qr,fi[1]=Wr*ri+Zr*ii+Jr,fi[2]=Gr*ei+Kr*ti+Qr,fi[3]=Wr*ei+Zr*ti+Jr;break;case"arcToSvg":ei=fi[5],ti=fi[6],oi=fi[0],li=fi[1],fi[0]=Gr*oi+Kr*li,fi[1]=Wr*oi+Zr*li,fi[5]=Gr*ei+Kr*ti+Qr,fi[6]=Wr*ei+Zr*ti+Jr;break;case"circle":fi[4]=adjustTransform(fi[3],ze);break;case"rect":fi[4]=adjustTransform(fi[4],ze);break;case"ellipse":fi[8]=adjustTransform(fi[8],ze);break;case"roundRect":fi[5]=adjustTransform(fi[5],ze);break;case"addPath":fi[0].transform(ze);break;case"poly":fi[2]=adjustTransform(fi[2],ze);break;default:warn("unknown transform action",hi.action);break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(ze){let Gr=this.instructions.length-1,Wr=this.instructions[Gr];if(!Wr)return ze.x=0,ze.y=0,ze;for(;Wr.action==="closePath";){if(Gr--,Gr<0)return ze.x=0,ze.y=0,ze;Wr=this.instructions[Gr]}switch(Wr.action){case"moveTo":case"lineTo":ze.x=Wr.data[0],ze.y=Wr.data[1];break;case"quadraticCurveTo":ze.x=Wr.data[2],ze.y=Wr.data[3];break;case"bezierCurveTo":ze.x=Wr.data[4],ze.y=Wr.data[5];break;case"arc":case"arcToSvg":ze.x=Wr.data[5],ze.y=Wr.data[6];break;case"addPath":Wr.data[0].getLastPoint(ze);break}return ze}}function adjustTransform(Yr,ze){return Yr?Yr.prepend(ze):ze.clone()}function parseSVGFloatAttribute(Yr,ze,Gr){const Wr=Yr.getAttribute(ze);return Wr?Number(Wr):Gr}function parseSVGDefinitions(Yr,ze){const Gr=Yr.querySelectorAll("defs");for(let Wr=0;Wr<Gr.length;Wr++){const Kr=Gr[Wr];for(let Zr=0;Zr<Kr.children.length;Zr++){const Qr=Kr.children[Zr];switch(Qr.nodeName.toLowerCase()){case"lineargradient":ze.defs[Qr.id]=parseLinearGradient(Qr);break;case"radialgradient":ze.defs[Qr.id]=parseRadialGradient();break}}}}function parseLinearGradient(Yr){const ze=parseSVGFloatAttribute(Yr,"x1",0),Gr=parseSVGFloatAttribute(Yr,"y1",0),Wr=parseSVGFloatAttribute(Yr,"x2",1),Kr=parseSVGFloatAttribute(Yr,"y2",0),Zr=Yr.getAttribute("gradientUnits")||"objectBoundingBox",Qr=new FillGradient(ze,Gr,Wr,Kr,Zr==="objectBoundingBox"?"local":"global");for(let Jr=0;Jr<Yr.children.length;Jr++){const ei=Yr.children[Jr],ti=parseSVGFloatAttribute(ei,"offset",0),ri=Color.shared.setValue(ei.getAttribute("stop-color")).toNumber();Qr.addColorStop(ti,ri)}return Qr}function parseRadialGradient(Yr){return warn("[SVG Parser] Radial gradients are not yet supported"),new FillGradient(0,0,1,0)}function extractSvgUrlId(Yr){const ze=Yr.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);return ze?ze[1]:""}const styleAttributes={fill:{type:"paint",default:0},"fill-opacity":{type:"number",default:1},stroke:{type:"paint",default:0},"stroke-width":{type:"number",default:1},"stroke-opacity":{type:"number",default:1},"stroke-linecap":{type:"string",default:"butt"},"stroke-linejoin":{type:"string",default:"miter"},"stroke-miterlimit":{type:"number",default:10},"stroke-dasharray":{type:"string",default:"none"},"stroke-dashoffset":{type:"number",default:0},opacity:{type:"number",default:1}};function parseSVGStyle(Yr,ze){const Gr=Yr.getAttribute("style"),Wr={},Kr={},Zr={strokeStyle:Wr,fillStyle:Kr,useFill:!1,useStroke:!1};for(const Qr in styleAttributes){const Jr=Yr.getAttribute(Qr);Jr&&parseAttribute(ze,Zr,Qr,Jr.trim())}if(Gr){const Qr=Gr.split(";");for(let Jr=0;Jr<Qr.length;Jr++){const ei=Qr[Jr].trim(),[ti,ri]=ei.split(":");styleAttributes[ti]&&parseAttribute(ze,Zr,ti,ri.trim())}}return{strokeStyle:Zr.useStroke?Wr:null,fillStyle:Zr.useFill?Kr:null,useFill:Zr.useFill,useStroke:Zr.useStroke}}function parseAttribute(Yr,ze,Gr,Wr){switch(Gr){case"stroke":if(Wr!=="none"){if(Wr.startsWith("url(")){const Kr=extractSvgUrlId(Wr);ze.strokeStyle.fill=Yr.defs[Kr]}else ze.strokeStyle.color=Color.shared.setValue(Wr).toNumber();ze.useStroke=!0}break;case"stroke-width":ze.strokeStyle.width=Number(Wr);break;case"fill":if(Wr!=="none"){if(Wr.startsWith("url(")){const Kr=extractSvgUrlId(Wr);ze.fillStyle.fill=Yr.defs[Kr]}else ze.fillStyle.color=Color.shared.setValue(Wr).toNumber();ze.useFill=!0}break;case"fill-opacity":ze.fillStyle.alpha=Number(Wr);break;case"stroke-opacity":ze.strokeStyle.alpha=Number(Wr);break;case"opacity":ze.fillStyle.alpha=Number(Wr),ze.strokeStyle.alpha=Number(Wr);break}}function SVGParser(Yr,ze){if(typeof Yr=="string"){const Qr=document.createElement("div");Qr.innerHTML=Yr.trim(),Yr=Qr.querySelector("svg")}const Gr={context:ze,defs:{},path:new GraphicsPath};parseSVGDefinitions(Yr,Gr);const Wr=Yr.children,{fillStyle:Kr,strokeStyle:Zr}=parseSVGStyle(Yr,Gr);for(let Qr=0;Qr<Wr.length;Qr++){const Jr=Wr[Qr];Jr.nodeName.toLowerCase()!=="defs"&&renderChildren(Jr,Gr,Kr,Zr)}return ze}function renderChildren(Yr,ze,Gr,Wr){const Kr=Yr.children,{fillStyle:Zr,strokeStyle:Qr}=parseSVGStyle(Yr,ze);Zr&&Gr?Gr={...Gr,...Zr}:Zr&&(Gr=Zr),Qr&&Wr?Wr={...Wr,...Qr}:Qr&&(Wr=Qr);const Jr=!Gr&&!Wr;Jr&&(Gr={color:0});let ei,ti,ri,ii,si,ni,oi,li,ai,hi,fi,pi,mi,Ti,yi,_i,Ai;switch(Yr.nodeName.toLowerCase()){case"path":Ti=Yr.getAttribute("d"),Yr.getAttribute("fill-rule")==="evenodd"&&warn("SVG Evenodd fill rule not supported, your svg may render incorrectly"),yi=new GraphicsPath(Ti,!0),ze.context.path(yi),Gr&&ze.context.fill(Gr),Wr&&ze.context.stroke(Wr);break;case"circle":oi=parseSVGFloatAttribute(Yr,"cx",0),li=parseSVGFloatAttribute(Yr,"cy",0),ai=parseSVGFloatAttribute(Yr,"r",0),ze.context.ellipse(oi,li,ai,ai),Gr&&ze.context.fill(Gr),Wr&&ze.context.stroke(Wr);break;case"rect":ei=parseSVGFloatAttribute(Yr,"x",0),ti=parseSVGFloatAttribute(Yr,"y",0),_i=parseSVGFloatAttribute(Yr,"width",0),Ai=parseSVGFloatAttribute(Yr,"height",0),hi=parseSVGFloatAttribute(Yr,"rx",0),fi=parseSVGFloatAttribute(Yr,"ry",0),hi||fi?ze.context.roundRect(ei,ti,_i,Ai,hi||fi):ze.context.rect(ei,ti,_i,Ai),Gr&&ze.context.fill(Gr),Wr&&ze.context.stroke(Wr);break;case"ellipse":oi=parseSVGFloatAttribute(Yr,"cx",0),li=parseSVGFloatAttribute(Yr,"cy",0),hi=parseSVGFloatAttribute(Yr,"rx",0),fi=parseSVGFloatAttribute(Yr,"ry",0),ze.context.beginPath(),ze.context.ellipse(oi,li,hi,fi),Gr&&ze.context.fill(Gr),Wr&&ze.context.stroke(Wr);break;case"line":ri=parseSVGFloatAttribute(Yr,"x1",0),ii=parseSVGFloatAttribute(Yr,"y1",0),si=parseSVGFloatAttribute(Yr,"x2",0),ni=parseSVGFloatAttribute(Yr,"y2",0),ze.context.beginPath(),ze.context.moveTo(ri,ii),ze.context.lineTo(si,ni),Wr&&ze.context.stroke(Wr);break;case"polygon":mi=Yr.getAttribute("points"),pi=mi.match(/\d+/g).map(Ri=>parseInt(Ri,10)),ze.context.poly(pi,!0),Gr&&ze.context.fill(Gr),Wr&&ze.context.stroke(Wr);break;case"polyline":mi=Yr.getAttribute("points"),pi=mi.match(/\d+/g).map(Ri=>parseInt(Ri,10)),ze.context.poly(pi,!1),Wr&&ze.context.stroke(Wr);break;case"g":case"svg":break;default:{warn(`[SVG parser] <${Yr.nodeName}> elements unsupported`);break}}Jr&&(Gr=null);for(let Ri=0;Ri<Kr.length;Ri++)renderChildren(Kr[Ri],ze,Gr,Wr)}function isColorLike(Yr){return Color.isColorLike(Yr)}function isFillPattern(Yr){return Yr instanceof FillPattern}function isFillGradient(Yr){return Yr instanceof FillGradient}function isTexture(Yr){return Yr instanceof Texture}function handleColorLike(Yr,ze,Gr){const Wr=Color.shared.setValue(ze??0);return Yr.color=Wr.toNumber(),Yr.alpha=Wr.alpha===1?Gr.alpha:Wr.alpha,Yr.texture=Texture.WHITE,{...Gr,...Yr}}function handleTexture(Yr,ze,Gr){return Yr.texture=ze,{...Gr,...Yr}}function handleFillPattern(Yr,ze,Gr){return Yr.fill=ze,Yr.color=16777215,Yr.texture=ze.texture,Yr.matrix=ze.transform,{...Gr,...Yr}}function handleFillGradient(Yr,ze,Gr){return ze.buildGradient(),Yr.fill=ze,Yr.color=16777215,Yr.texture=ze.texture,Yr.matrix=ze.transform,Yr.textureSpace=ze.textureSpace,{...Gr,...Yr}}function handleFillObject(Yr,ze){const Gr={...ze,...Yr},Wr=Color.shared.setValue(Gr.color);return Gr.alpha*=Wr.alpha,Gr.color=Wr.toNumber(),Gr}function toFillStyle(Yr,ze){if(Yr==null)return null;const Gr={},Wr=Yr;return isColorLike(Yr)?handleColorLike(Gr,Yr,ze):isTexture(Yr)?handleTexture(Gr,Yr,ze):isFillPattern(Yr)?handleFillPattern(Gr,Yr,ze):isFillGradient(Yr)?handleFillGradient(Gr,Yr,ze):Wr.fill&&isFillPattern(Wr.fill)?handleFillPattern(Wr,Wr.fill,ze):Wr.fill&&isFillGradient(Wr.fill)?handleFillGradient(Wr,Wr.fill,ze):handleFillObject(Wr,ze)}function toStrokeStyle(Yr,ze){const{width:Gr,alignment:Wr,miterLimit:Kr,cap:Zr,join:Qr,pixelLine:Jr,...ei}=ze,ti=toFillStyle(Yr,ei);return ti?{width:Gr,alignment:Wr,miterLimit:Kr,cap:Zr,join:Qr,pixelLine:Jr,...ti}:null}const tmpPoint=new Point$1,tempMatrix$2=new Matrix,_GraphicsContext=class Ki extends EventEmitter{constructor(){super(...arguments),this.uid=uid$1("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new GraphicsPath,this._transform=new Matrix,this._fillStyle={...Ki.defaultFillStyle},this._strokeStyle={...Ki.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new Bounds,this._boundsDirty=!0}clone(){const ze=new Ki;return ze.batchMode=this.batchMode,ze.instructions=this.instructions.slice(),ze._activePath=this._activePath.clone(),ze._transform=this._transform.clone(),ze._fillStyle={...this._fillStyle},ze._strokeStyle={...this._strokeStyle},ze._stateStack=this._stateStack.slice(),ze._bounds=this._bounds.clone(),ze._boundsDirty=!0,ze}get fillStyle(){return this._fillStyle}set fillStyle(ze){this._fillStyle=toFillStyle(ze,Ki.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(ze){this._strokeStyle=toStrokeStyle(ze,Ki.defaultStrokeStyle)}setFillStyle(ze){return this._fillStyle=toFillStyle(ze,Ki.defaultFillStyle),this}setStrokeStyle(ze){return this._strokeStyle=toFillStyle(ze,Ki.defaultStrokeStyle),this}texture(ze,Gr,Wr,Kr,Zr,Qr){return this.instructions.push({action:"texture",data:{image:ze,dx:Wr||0,dy:Kr||0,dw:Zr||ze.frame.width,dh:Qr||ze.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:Gr?Color.shared.setValue(Gr).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new GraphicsPath,this}fill(ze,Gr){let Wr;const Kr=this.instructions[this.instructions.length-1];return this._tick===0&&Kr&&Kr.action==="stroke"?Wr=Kr.data.path:Wr=this._activePath.clone(),Wr?(ze!=null&&(Gr!==void 0&&typeof ze=="number"&&(deprecation(v8_0_0,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),ze={color:ze,alpha:Gr}),this._fillStyle=toFillStyle(ze,Ki.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:Wr}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:ze,y:Gr}=this._activePath.getLastPoint(Point$1.shared);this._activePath.clear(),this._activePath.moveTo(ze,Gr)}stroke(ze){let Gr;const Wr=this.instructions[this.instructions.length-1];return this._tick===0&&Wr&&Wr.action==="fill"?Gr=Wr.data.path:Gr=this._activePath.clone(),Gr?(ze!=null&&(this._strokeStyle=toStrokeStyle(ze,Ki.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:Gr}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let ze=0;ze<2;ze++){const Gr=this.instructions[this.instructions.length-1-ze],Wr=this._activePath.clone();if(Gr&&(Gr.action==="stroke"||Gr.action==="fill"))if(Gr.data.hole)Gr.data.hole.addPath(Wr);else{Gr.data.hole=Wr;break}}return this._initNextPathLocation(),this}arc(ze,Gr,Wr,Kr,Zr,Qr){this._tick++;const Jr=this._transform;return this._activePath.arc(Jr.a*ze+Jr.c*Gr+Jr.tx,Jr.b*ze+Jr.d*Gr+Jr.ty,Wr,Kr,Zr,Qr),this}arcTo(ze,Gr,Wr,Kr,Zr){this._tick++;const Qr=this._transform;return this._activePath.arcTo(Qr.a*ze+Qr.c*Gr+Qr.tx,Qr.b*ze+Qr.d*Gr+Qr.ty,Qr.a*Wr+Qr.c*Kr+Qr.tx,Qr.b*Wr+Qr.d*Kr+Qr.ty,Zr),this}arcToSvg(ze,Gr,Wr,Kr,Zr,Qr,Jr){this._tick++;const ei=this._transform;return this._activePath.arcToSvg(ze,Gr,Wr,Kr,Zr,ei.a*Qr+ei.c*Jr+ei.tx,ei.b*Qr+ei.d*Jr+ei.ty),this}bezierCurveTo(ze,Gr,Wr,Kr,Zr,Qr,Jr){this._tick++;const ei=this._transform;return this._activePath.bezierCurveTo(ei.a*ze+ei.c*Gr+ei.tx,ei.b*ze+ei.d*Gr+ei.ty,ei.a*Wr+ei.c*Kr+ei.tx,ei.b*Wr+ei.d*Kr+ei.ty,ei.a*Zr+ei.c*Qr+ei.tx,ei.b*Zr+ei.d*Qr+ei.ty,Jr),this}closePath(){var ze;return this._tick++,(ze=this._activePath)==null||ze.closePath(),this}ellipse(ze,Gr,Wr,Kr){return this._tick++,this._activePath.ellipse(ze,Gr,Wr,Kr,this._transform.clone()),this}circle(ze,Gr,Wr){return this._tick++,this._activePath.circle(ze,Gr,Wr,this._transform.clone()),this}path(ze){return this._tick++,this._activePath.addPath(ze,this._transform.clone()),this}lineTo(ze,Gr){this._tick++;const Wr=this._transform;return this._activePath.lineTo(Wr.a*ze+Wr.c*Gr+Wr.tx,Wr.b*ze+Wr.d*Gr+Wr.ty),this}moveTo(ze,Gr){this._tick++;const Wr=this._transform,Kr=this._activePath.instructions,Zr=Wr.a*ze+Wr.c*Gr+Wr.tx,Qr=Wr.b*ze+Wr.d*Gr+Wr.ty;return Kr.length===1&&Kr[0].action==="moveTo"?(Kr[0].data[0]=Zr,Kr[0].data[1]=Qr,this):(this._activePath.moveTo(Zr,Qr),this)}quadraticCurveTo(ze,Gr,Wr,Kr,Zr){this._tick++;const Qr=this._transform;return this._activePath.quadraticCurveTo(Qr.a*ze+Qr.c*Gr+Qr.tx,Qr.b*ze+Qr.d*Gr+Qr.ty,Qr.a*Wr+Qr.c*Kr+Qr.tx,Qr.b*Wr+Qr.d*Kr+Qr.ty,Zr),this}rect(ze,Gr,Wr,Kr){return this._tick++,this._activePath.rect(ze,Gr,Wr,Kr,this._transform.clone()),this}roundRect(ze,Gr,Wr,Kr,Zr){return this._tick++,this._activePath.roundRect(ze,Gr,Wr,Kr,Zr,this._transform.clone()),this}poly(ze,Gr){return this._tick++,this._activePath.poly(ze,Gr,this._transform.clone()),this}regularPoly(ze,Gr,Wr,Kr,Zr=0,Qr){return this._tick++,this._activePath.regularPoly(ze,Gr,Wr,Kr,Zr,Qr),this}roundPoly(ze,Gr,Wr,Kr,Zr,Qr){return this._tick++,this._activePath.roundPoly(ze,Gr,Wr,Kr,Zr,Qr),this}roundShape(ze,Gr,Wr,Kr){return this._tick++,this._activePath.roundShape(ze,Gr,Wr,Kr),this}filletRect(ze,Gr,Wr,Kr,Zr){return this._tick++,this._activePath.filletRect(ze,Gr,Wr,Kr,Zr),this}chamferRect(ze,Gr,Wr,Kr,Zr,Qr){return this._tick++,this._activePath.chamferRect(ze,Gr,Wr,Kr,Zr,Qr),this}star(ze,Gr,Wr,Kr,Zr=0,Qr=0){return this._tick++,this._activePath.star(ze,Gr,Wr,Kr,Zr,Qr,this._transform.clone()),this}svg(ze){return this._tick++,SVGParser(ze,this),this}restore(){const ze=this._stateStack.pop();return ze&&(this._transform=ze.transform,this._fillStyle=ze.fillStyle,this._strokeStyle=ze.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(ze){return this._transform.rotate(ze),this}scale(ze,Gr=ze){return this._transform.scale(ze,Gr),this}setTransform(ze,Gr,Wr,Kr,Zr,Qr){return ze instanceof Matrix?(this._transform.set(ze.a,ze.b,ze.c,ze.d,ze.tx,ze.ty),this):(this._transform.set(ze,Gr,Wr,Kr,Zr,Qr),this)}transform(ze,Gr,Wr,Kr,Zr,Qr){return ze instanceof Matrix?(this._transform.append(ze),this):(tempMatrix$2.set(ze,Gr,Wr,Kr,Zr,Qr),this._transform.append(tempMatrix$2),this)}translate(ze,Gr=ze){return this._transform.translate(ze,Gr),this}clear(){return this._activePath.clear(),this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const ze=this._bounds;ze.clear();for(let Gr=0;Gr<this.instructions.length;Gr++){const Wr=this.instructions[Gr],Kr=Wr.action;if(Kr==="fill"){const Zr=Wr.data;ze.addBounds(Zr.path.bounds)}else if(Kr==="texture"){const Zr=Wr.data;ze.addFrame(Zr.dx,Zr.dy,Zr.dx+Zr.dw,Zr.dy+Zr.dh,Zr.transform)}if(Kr==="stroke"){const Zr=Wr.data,Qr=Zr.style.alignment,Jr=Zr.style.width*(1-Qr),ei=Zr.path.bounds;ze.addFrame(ei.minX-Jr,ei.minY-Jr,ei.maxX+Jr,ei.maxY+Jr)}}return ze}containsPoint(ze){var Kr;if(!this.bounds.containsPoint(ze.x,ze.y))return!1;const Gr=this.instructions;let Wr=!1;for(let Zr=0;Zr<Gr.length;Zr++){const Qr=Gr[Zr],Jr=Qr.data,ei=Jr.path;if(!Qr.action||!ei)continue;const ti=Jr.style,ri=ei.shapePath.shapePrimitives;for(let ii=0;ii<ri.length;ii++){const si=ri[ii].shape;if(!ti||!si)continue;const ni=ri[ii].transform,oi=ni?ni.applyInverse(ze,tmpPoint):ze;if(Qr.action==="fill")Wr=si.contains(oi.x,oi.y);else{const ai=ti;Wr=si.strokeContains(oi.x,oi.y,ai.width,ai.alignment)}const li=Jr.hole;if(li){const ai=(Kr=li.shapePath)==null?void 0:Kr.shapePrimitives;if(ai)for(let hi=0;hi<ai.length;hi++)ai[hi].shape.contains(oi.x,oi.y)&&(Wr=!1)}if(Wr)return!0}}return Wr}destroy(ze=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof ze=="boolean"?ze:ze==null?void 0:ze.texture){const Wr=typeof ze=="boolean"?ze:ze==null?void 0:ze.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(Wr),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(Wr)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};_GraphicsContext.defaultFillStyle={color:16777215,alpha:1,texture:Texture.WHITE,matrix:null,fill:null,textureSpace:"local"};_GraphicsContext.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:Texture.WHITE,matrix:null,fill:null,textureSpace:"local",pixelLine:!1};let GraphicsContext=_GraphicsContext;const valuesToIterateForKeys=["align","breakWords","cssOverrides","fontVariant","fontWeight","leading","letterSpacing","lineHeight","padding","textBaseline","trim","whiteSpace","wordWrap","wordWrapWidth","fontFamily","fontStyle","fontSize"];function generateTextStyleKey(Yr){const ze=[];let Gr=0;for(let Wr=0;Wr<valuesToIterateForKeys.length;Wr++){const Kr=`_${valuesToIterateForKeys[Wr]}`;ze[Gr++]=Yr[Kr]}return Gr=addFillStyleKey(Yr._fill,ze,Gr),Gr=addStokeStyleKey(Yr._stroke,ze,Gr),Gr=addDropShadowKey(Yr.dropShadow,ze,Gr),ze.join("-")}function addFillStyleKey(Yr,ze,Gr){var Wr;return Yr&&(ze[Gr++]=Yr.color,ze[Gr++]=Yr.alpha,ze[Gr++]=(Wr=Yr.fill)==null?void 0:Wr.styleKey),Gr}function addStokeStyleKey(Yr,ze,Gr){return Yr&&(Gr=addFillStyleKey(Yr,ze,Gr),ze[Gr++]=Yr.width,ze[Gr++]=Yr.alignment,ze[Gr++]=Yr.cap,ze[Gr++]=Yr.join,ze[Gr++]=Yr.miterLimit),Gr}function addDropShadowKey(Yr,ze,Gr){return Yr&&(ze[Gr++]=Yr.alpha,ze[Gr++]=Yr.angle,ze[Gr++]=Yr.blur,ze[Gr++]=Yr.distance,ze[Gr++]=Color.shared.setValue(Yr.color).toNumber()),Gr}const _TextStyle=class es extends EventEmitter{constructor(ze={}){super(),convertV7Tov8Style(ze);const Gr={...es.defaultTextStyle,...ze};for(const Wr in Gr){const Kr=Wr;this[Kr]=Gr[Wr]}this.update()}get align(){return this._align}set align(ze){this._align=ze,this.update()}get breakWords(){return this._breakWords}set breakWords(ze){this._breakWords=ze,this.update()}get dropShadow(){return this._dropShadow}set dropShadow(ze){ze!==null&&typeof ze=="object"?this._dropShadow=this._createProxy({...es.defaultDropShadow,...ze}):this._dropShadow=ze?this._createProxy({...es.defaultDropShadow}):null,this.update()}get fontFamily(){return this._fontFamily}set fontFamily(ze){this._fontFamily=ze,this.update()}get fontSize(){return this._fontSize}set fontSize(ze){typeof ze=="string"?this._fontSize=parseInt(ze,10):this._fontSize=ze,this.update()}get fontStyle(){return this._fontStyle}set fontStyle(ze){this._fontStyle=ze.toLowerCase(),this.update()}get fontVariant(){return this._fontVariant}set fontVariant(ze){this._fontVariant=ze,this.update()}get fontWeight(){return this._fontWeight}set fontWeight(ze){this._fontWeight=ze,this.update()}get leading(){return this._leading}set leading(ze){this._leading=ze,this.update()}get letterSpacing(){return this._letterSpacing}set letterSpacing(ze){this._letterSpacing=ze,this.update()}get lineHeight(){return this._lineHeight}set lineHeight(ze){this._lineHeight=ze,this.update()}get padding(){return this._padding}set padding(ze){this._padding=ze,this.update()}get trim(){return this._trim}set trim(ze){this._trim=ze,this.update()}get textBaseline(){return this._textBaseline}set textBaseline(ze){this._textBaseline=ze,this.update()}get whiteSpace(){return this._whiteSpace}set whiteSpace(ze){this._whiteSpace=ze,this.update()}get wordWrap(){return this._wordWrap}set wordWrap(ze){this._wordWrap=ze,this.update()}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(ze){this._wordWrapWidth=ze,this.update()}get fill(){return this._originalFill}set fill(ze){ze!==this._originalFill&&(this._originalFill=ze,this._isFillStyle(ze)&&(this._originalFill=this._createProxy({...GraphicsContext.defaultFillStyle,...ze},()=>{this._fill=toFillStyle({...this._originalFill},GraphicsContext.defaultFillStyle)})),this._fill=toFillStyle(ze===0?"black":ze,GraphicsContext.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(ze){ze!==this._originalStroke&&(this._originalStroke=ze,this._isFillStyle(ze)&&(this._originalStroke=this._createProxy({...GraphicsContext.defaultStrokeStyle,...ze},()=>{this._stroke=toStrokeStyle({...this._originalStroke},GraphicsContext.defaultStrokeStyle)})),this._stroke=toStrokeStyle(ze,GraphicsContext.defaultStrokeStyle),this.update())}_generateKey(){return this._styleKey=generateTextStyleKey(this),this._styleKey}update(){this._styleKey=null,this.emit("update",this)}reset(){const ze=es.defaultTextStyle;for(const Gr in ze)this[Gr]=ze[Gr]}get styleKey(){return this._styleKey||this._generateKey()}clone(){return new es({align:this.align,breakWords:this.breakWords,dropShadow:this._dropShadow?{...this._dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth})}destroy(ze=!1){var Wr,Kr,Zr,Qr;if(this.removeAllListeners(),typeof ze=="boolean"?ze:ze==null?void 0:ze.texture){const Jr=typeof ze=="boolean"?ze:ze==null?void 0:ze.textureSource;(Wr=this._fill)!=null&&Wr.texture&&this._fill.texture.destroy(Jr),(Kr=this._originalFill)!=null&&Kr.texture&&this._originalFill.texture.destroy(Jr),(Zr=this._stroke)!=null&&Zr.texture&&this._stroke.texture.destroy(Jr),(Qr=this._originalStroke)!=null&&Qr.texture&&this._originalStroke.texture.destroy(Jr)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}_createProxy(ze,Gr){return new Proxy(ze,{set:(Wr,Kr,Zr)=>(Wr[Kr]=Zr,Gr==null||Gr(Kr,Zr),this.update(),!0)})}_isFillStyle(ze){return(ze??null)!==null&&!(Color.isColorLike(ze)||ze instanceof FillGradient||ze instanceof FillPattern)}};_TextStyle.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5};_TextStyle.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let TextStyle=_TextStyle;function convertV7Tov8Style(Yr){const ze=Yr;if(typeof ze.dropShadow=="boolean"&&ze.dropShadow){const Gr=TextStyle.defaultDropShadow;Yr.dropShadow={alpha:ze.dropShadowAlpha??Gr.alpha,angle:ze.dropShadowAngle??Gr.angle,blur:ze.dropShadowBlur??Gr.blur,color:ze.dropShadowColor??Gr.color,distance:ze.dropShadowDistance??Gr.distance}}if(ze.strokeThickness!==void 0){deprecation(v8_0_0,"strokeThickness is now a part of stroke");const Gr=ze.stroke;let Wr={};if(Color.isColorLike(Gr))Wr.color=Gr;else if(Gr instanceof FillGradient||Gr instanceof FillPattern)Wr.fill=Gr;else if(Object.hasOwnProperty.call(Gr,"color")||Object.hasOwnProperty.call(Gr,"fill"))Wr=Gr;else throw new Error("Invalid stroke value.");Yr.stroke={...Wr,width:ze.strokeThickness}}if(Array.isArray(ze.fillGradientStops)){deprecation(v8_0_0,"gradient fill is now a fill pattern: `new FillGradient(...)`");let Gr;Yr.fontSize==null?Yr.fontSize=TextStyle.defaultTextStyle.fontSize:typeof Yr.fontSize=="string"?Gr=parseInt(Yr.fontSize,10):Gr=Yr.fontSize;const Wr=new FillGradient({start:{x:0,y:0},end:{x:0,y:(Gr||0)*1.7}}),Kr=ze.fillGradientStops.map(Zr=>Color.shared.setValue(Zr).toNumber());Kr.forEach((Zr,Qr)=>{const Jr=Qr/(Kr.length-1);Wr.addColorStop(Jr,Zr)}),Yr.fill={fill:Wr}}}class CanvasPoolClass{constructor(ze){this._canvasPool=Object.create(null),this.canvasOptions=ze||{},this.enableFullScreen=!1}_createCanvasAndContext(ze,Gr){const Wr=DOMAdapter.get().createCanvas();Wr.width=ze,Wr.height=Gr;const Kr=Wr.getContext("2d");return{canvas:Wr,context:Kr}}getOptimalCanvasAndContext(ze,Gr,Wr=1){ze=Math.ceil(ze*Wr-1e-6),Gr=Math.ceil(Gr*Wr-1e-6),ze=nextPow2(ze),Gr=nextPow2(Gr);const Kr=(ze<<17)+(Gr<<1);this._canvasPool[Kr]||(this._canvasPool[Kr]=[]);let Zr=this._canvasPool[Kr].pop();return Zr||(Zr=this._createCanvasAndContext(ze,Gr)),Zr}returnCanvasAndContext(ze){const Gr=ze.canvas,{width:Wr,height:Kr}=Gr,Zr=(Wr<<17)+(Kr<<1);ze.context.clearRect(0,0,Wr,Kr),this._canvasPool[Zr].push(ze)}clear(){this._canvasPool={}}}const CanvasPool=new CanvasPoolClass,genericFontFamilies=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function fontStringFromTextStyle(Yr){const ze=typeof Yr.fontSize=="number"?`${Yr.fontSize}px`:Yr.fontSize;let Gr=Yr.fontFamily;Array.isArray(Yr.fontFamily)||(Gr=Yr.fontFamily.split(","));for(let Wr=Gr.length-1;Wr>=0;Wr--){let Kr=Gr[Wr].trim();!/([\"\'])[^\'\"]+\1/.test(Kr)&&!genericFontFamilies.includes(Kr)&&(Kr=`"${Kr}"`),Gr[Wr]=Kr}return`${Yr.fontStyle} ${Yr.fontVariant} ${Yr.fontWeight} ${ze} ${Gr.join(",")}`}const contextSettings={willReadFrequently:!0},_CanvasTextMetrics=class Mi{static get experimentalLetterSpacingSupported(){let ze=Mi._experimentalLetterSpacingSupported;if(ze!==void 0){const Gr=DOMAdapter.get().getCanvasRenderingContext2D().prototype;ze=Mi._experimentalLetterSpacingSupported="letterSpacing"in Gr||"textLetterSpacing"in Gr}return ze}constructor(ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti){this.text=ze,this.style=Gr,this.width=Wr,this.height=Kr,this.lines=Zr,this.lineWidths=Qr,this.lineHeight=Jr,this.maxLineWidth=ei,this.fontProperties=ti}static measureText(ze=" ",Gr,Wr=Mi._canvas,Kr=Gr.wordWrap){var fi;const Zr=`${ze}:${Gr.styleKey}`;if(Mi._measurementCache[Zr])return Mi._measurementCache[Zr];const Qr=fontStringFromTextStyle(Gr),Jr=Mi.measureFont(Qr);Jr.fontSize===0&&(Jr.fontSize=Gr.fontSize,Jr.ascent=Gr.fontSize);const ei=Mi.__context;ei.font=Qr;const ri=(Kr?Mi._wordWrap(ze,Gr,Wr):ze).split(/(?:\r\n|\r|\n)/),ii=new Array(ri.length);let si=0;for(let pi=0;pi<ri.length;pi++){const mi=Mi._measureText(ri[pi],Gr.letterSpacing,ei);ii[pi]=mi,si=Math.max(si,mi)}const ni=((fi=Gr._stroke)==null?void 0:fi.width)||0;let oi=si+ni;Gr.dropShadow&&(oi+=Gr.dropShadow.distance);const li=Gr.lineHeight||Jr.fontSize;let ai=Math.max(li,Jr.fontSize+ni)+(ri.length-1)*(li+Gr.leading);return Gr.dropShadow&&(ai+=Gr.dropShadow.distance),new Mi(ze,Gr,oi,ai,ri,ii,li+Gr.leading,si,Jr)}static _measureText(ze,Gr,Wr){let Kr=!1;Mi.experimentalLetterSpacingSupported&&(Mi.experimentalLetterSpacing?(Wr.letterSpacing=`${Gr}px`,Wr.textLetterSpacing=`${Gr}px`,Kr=!0):(Wr.letterSpacing="0px",Wr.textLetterSpacing="0px"));const Zr=Wr.measureText(ze);let Qr=Zr.width;const Jr=-Zr.actualBoundingBoxLeft;let ti=Zr.actualBoundingBoxRight-Jr;if(Qr>0)if(Kr)Qr-=Gr,ti-=Gr;else{const ri=(Mi.graphemeSegmenter(ze).length-1)*Gr;Qr+=ri,ti+=ri}return Math.max(Qr,ti)}static _wordWrap(ze,Gr,Wr=Mi._canvas){const Kr=Wr.getContext("2d",contextSettings);let Zr=0,Qr="",Jr="";const ei=Object.create(null),{letterSpacing:ti,whiteSpace:ri}=Gr,ii=Mi._collapseSpaces(ri),si=Mi._collapseNewlines(ri);let ni=!ii;const oi=Gr.wordWrapWidth+ti,li=Mi._tokenize(ze);for(let ai=0;ai<li.length;ai++){let hi=li[ai];if(Mi._isNewline(hi)){if(!si){Jr+=Mi._addLine(Qr),ni=!ii,Qr="",Zr=0;continue}hi=" "}if(ii){const pi=Mi.isBreakingSpace(hi),mi=Mi.isBreakingSpace(Qr[Qr.length-1]);if(pi&&mi)continue}const fi=Mi._getFromCache(hi,ti,ei,Kr);if(fi>oi)if(Qr!==""&&(Jr+=Mi._addLine(Qr),Qr="",Zr=0),Mi.canBreakWords(hi,Gr.breakWords)){const pi=Mi.wordWrapSplit(hi);for(let mi=0;mi<pi.length;mi++){let Ti=pi[mi],yi=Ti,_i=1;for(;pi[mi+_i];){const Ri=pi[mi+_i];if(!Mi.canBreakChars(yi,Ri,hi,mi,Gr.breakWords))Ti+=Ri;else break;yi=Ri,_i++}mi+=_i-1;const Ai=Mi._getFromCache(Ti,ti,ei,Kr);Ai+Zr>oi&&(Jr+=Mi._addLine(Qr),ni=!1,Qr="",Zr=0),Qr+=Ti,Zr+=Ai}}else{Qr.length>0&&(Jr+=Mi._addLine(Qr),Qr="",Zr=0);const pi=ai===li.length-1;Jr+=Mi._addLine(hi,!pi),ni=!1,Qr="",Zr=0}else fi+Zr>oi&&(ni=!1,Jr+=Mi._addLine(Qr),Qr="",Zr=0),(Qr.length>0||!Mi.isBreakingSpace(hi)||ni)&&(Qr+=hi,Zr+=fi)}return Jr+=Mi._addLine(Qr,!1),Jr}static _addLine(ze,Gr=!0){return ze=Mi._trimRight(ze),ze=Gr?`${ze}
`:ze,ze}static _getFromCache(ze,Gr,Wr,Kr){let Zr=Wr[ze];return typeof Zr!="number"&&(Zr=Mi._measureText(ze,Gr,Kr)+Gr,Wr[ze]=Zr),Zr}static _collapseSpaces(ze){return ze==="normal"||ze==="pre-line"}static _collapseNewlines(ze){return ze==="normal"}static _trimRight(ze){if(typeof ze!="string")return"";for(let Gr=ze.length-1;Gr>=0;Gr--){const Wr=ze[Gr];if(!Mi.isBreakingSpace(Wr))break;ze=ze.slice(0,-1)}return ze}static _isNewline(ze){return typeof ze!="string"?!1:Mi._newlines.includes(ze.charCodeAt(0))}static isBreakingSpace(ze,Gr){return typeof ze!="string"?!1:Mi._breakingSpaces.includes(ze.charCodeAt(0))}static _tokenize(ze){const Gr=[];let Wr="";if(typeof ze!="string")return Gr;for(let Kr=0;Kr<ze.length;Kr++){const Zr=ze[Kr],Qr=ze[Kr+1];if(Mi.isBreakingSpace(Zr,Qr)||Mi._isNewline(Zr)){Wr!==""&&(Gr.push(Wr),Wr=""),Gr.push(Zr);continue}Wr+=Zr}return Wr!==""&&Gr.push(Wr),Gr}static canBreakWords(ze,Gr){return Gr}static canBreakChars(ze,Gr,Wr,Kr,Zr){return!0}static wordWrapSplit(ze){return Mi.graphemeSegmenter(ze)}static measureFont(ze){if(Mi._fonts[ze])return Mi._fonts[ze];const Gr=Mi._context;Gr.font=ze;const Wr=Gr.measureText(Mi.METRICS_STRING+Mi.BASELINE_SYMBOL),Kr={ascent:Wr.actualBoundingBoxAscent,descent:Wr.actualBoundingBoxDescent,fontSize:Wr.actualBoundingBoxAscent+Wr.actualBoundingBoxDescent};return Mi._fonts[ze]=Kr,Kr}static clearMetrics(ze=""){ze?delete Mi._fonts[ze]:Mi._fonts={}}static get _canvas(){if(!Mi.__canvas){let ze;try{const Gr=new OffscreenCanvas(0,0),Wr=Gr.getContext("2d",contextSettings);if(Wr!=null&&Wr.measureText)return Mi.__canvas=Gr,Gr;ze=DOMAdapter.get().createCanvas()}catch{ze=DOMAdapter.get().createCanvas()}ze.width=ze.height=10,Mi.__canvas=ze}return Mi.__canvas}static get _context(){return Mi.__context||(Mi.__context=Mi._canvas.getContext("2d",contextSettings)),Mi.__context}};_CanvasTextMetrics.METRICS_STRING="|q";_CanvasTextMetrics.BASELINE_SYMBOL="M";_CanvasTextMetrics.BASELINE_MULTIPLIER=1.4;_CanvasTextMetrics.HEIGHT_MULTIPLIER=2;_CanvasTextMetrics.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const Yr=new Intl.Segmenter;return ze=>[...Yr.segment(ze)].map(Gr=>Gr.segment)}return Yr=>[...Yr]})();_CanvasTextMetrics.experimentalLetterSpacing=!1;_CanvasTextMetrics._fonts={};_CanvasTextMetrics._newlines=[10,13];_CanvasTextMetrics._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288];_CanvasTextMetrics._measurementCache={};let CanvasTextMetrics=_CanvasTextMetrics;const PRECISION=1e5;function getCanvasFillStyle(Yr,ze,Gr,Wr=0){if(Yr.texture===Texture.WHITE&&!Yr.fill)return Color.shared.setValue(Yr.color).setAlpha(Yr.alpha??1).toHexa();if(Yr.fill){if(Yr.fill instanceof FillPattern){const Kr=Yr.fill,Zr=ze.createPattern(Kr.texture.source.resource,"repeat"),Qr=Kr.transform.copyTo(Matrix.shared);return Qr.scale(Kr.texture.frame.width,Kr.texture.frame.height),Zr.setTransform(Qr),Zr}else if(Yr.fill instanceof FillGradient){const Kr=Yr.fill,Zr=Kr.type==="linear",Qr=Kr.textureSpace==="local";let Jr=1,ei=1;Qr&&Gr&&(Jr=Gr.width+Wr,ei=Gr.height+Wr);let ti,ri=!1;if(Zr){const{start:ii,end:si}=Kr;ti=ze.createLinearGradient(ii.x*Jr,ii.y*ei,si.x*Jr,si.y*ei),ri=Math.abs(si.x-ii.x)<Math.abs((si.y-ii.y)*.1)}else{const{center:ii,innerRadius:si,outerCenter:ni,outerRadius:oi}=Kr;ti=ze.createRadialGradient(ii.x*Jr,ii.y*ei,si*Jr,ni.x*Jr,ni.y*ei,oi*Jr)}if(ri&&Qr&&Gr){const ii=Gr.lineHeight/ei;for(let si=0;si<Gr.lines.length;si++){const ni=(si*Gr.lineHeight+Wr/2)/ei;Kr.colorStops.forEach(oi=>{const li=ni+oi.offset*ii;ti.addColorStop(Math.floor(li*PRECISION)/PRECISION,Color.shared.setValue(oi.color).toHex())})}}else Kr.colorStops.forEach(ii=>{ti.addColorStop(ii.offset,Color.shared.setValue(ii.color).toHex())});return ti}}else{const Kr=ze.createPattern(Yr.texture.source.resource,"repeat"),Zr=Yr.matrix.copyTo(Matrix.shared);return Zr.scale(Yr.texture.frame.width,Yr.texture.frame.height),Kr.setTransform(Zr),Kr}return warn("FillStyle not recognised",Yr),"red"}function resolveCharacters(Yr){if(Yr==="")return[];typeof Yr=="string"&&(Yr=[Yr]);const ze=[];for(let Gr=0,Wr=Yr.length;Gr<Wr;Gr++){const Kr=Yr[Gr];if(Array.isArray(Kr)){if(Kr.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${Kr.length}.`);if(Kr[0].length===0||Kr[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const Zr=Kr[0].charCodeAt(0),Qr=Kr[1].charCodeAt(0);if(Qr<Zr)throw new Error("[BitmapFont]: Invalid character range.");for(let Jr=Zr,ei=Qr;Jr<=ei;Jr++)ze.push(String.fromCharCode(Jr))}else ze.push(...Array.from(Kr))}if(ze.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return ze}const _DynamicBitmapFont=class As extends AbstractBitmapFont{constructor(ze){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const Gr={...As.defaultOptions,...ze};this._textureSize=Gr.textureSize,this._mipmap=Gr.mipmap;const Wr=Gr.style.clone();Gr.overrideFill&&(Wr._fill.color=16777215,Wr._fill.alpha=1,Wr._fill.texture=Texture.WHITE,Wr._fill.fill=null),this.applyFillAsTint=Gr.overrideFill;const Kr=Wr.fontSize;Wr.fontSize=this.baseMeasurementFontSize;const Zr=fontStringFromTextStyle(Wr);Gr.overrideSize?Wr._stroke&&(Wr._stroke.width*=this.baseRenderedFontSize/Kr):Wr.fontSize=this.baseRenderedFontSize=Kr,this._style=Wr,this._skipKerning=Gr.skipKerning??!1,this.resolution=Gr.resolution??1,this._padding=Gr.padding??4,this.fontMetrics=CanvasTextMetrics.measureFont(Zr),this.lineHeight=Wr.lineHeight||this.fontMetrics.fontSize||Wr.fontSize}ensureCharacters(ze){var ai,hi;const Gr=resolveCharacters(ze).filter(fi=>!this._currentChars.includes(fi)).filter((fi,pi,mi)=>mi.indexOf(fi)===pi);if(!Gr.length)return;this._currentChars=[...this._currentChars,...Gr];let Wr;this._currentPageIndex===-1?Wr=this._nextPage():Wr=this.pages[this._currentPageIndex];let{canvas:Kr,context:Zr}=Wr.canvasAndContext,Qr=Wr.texture.source;const Jr=this._style;let ei=this._currentX,ti=this._currentY;const ri=this.baseRenderedFontSize/this.baseMeasurementFontSize,ii=this._padding*ri;let si=0,ni=!1;const oi=Kr.width/this.resolution,li=Kr.height/this.resolution;for(let fi=0;fi<Gr.length;fi++){const pi=Gr[fi],mi=CanvasTextMetrics.measureText(pi,Jr,Kr,!1);mi.lineHeight=mi.height;const Ti=mi.width*ri,yi=Math.ceil((Jr.fontStyle==="italic"?2:1)*Ti),_i=mi.height*ri,Ai=yi+ii*2,Ri=_i+ii*2;if(ni=!1,pi!==`
`&&pi!=="\r"&&pi!=="	"&&pi!==" "&&(ni=!0,si=Math.ceil(Math.max(Ri,si))),ei+Ai>oi&&(ti+=si,si=Ri,ei=0,ti+si>li)){Qr.update();const Si=this._nextPage();Kr=Si.canvasAndContext.canvas,Zr=Si.canvasAndContext.context,Qr=Si.texture.source,ti=0}const Pi=Ti/ri-(((ai=Jr.dropShadow)==null?void 0:ai.distance)??0)-(((hi=Jr._stroke)==null?void 0:hi.width)??0);if(this.chars[pi]={id:pi.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:Pi,kerning:{}},ni){this._drawGlyph(Zr,mi,ei+ii,ti+ii,ri,Jr);const Si=Qr.width*ri,Bi=Qr.height*ri,ki=new Rectangle(ei/Si*Qr.width,ti/Bi*Qr.height,Ai/Si*Qr.width,Ri/Bi*Qr.height);this.chars[pi].texture=new Texture({source:Qr,frame:ki}),ei+=Math.ceil(Ai)}}Qr.update(),this._currentX=ei,this._currentY=ti,this._skipKerning&&this._applyKerning(Gr,Zr)}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(ze,Gr){const Wr=this._measureCache;for(let Kr=0;Kr<ze.length;Kr++){const Zr=ze[Kr];for(let Qr=0;Qr<this._currentChars.length;Qr++){const Jr=this._currentChars[Qr];let ei=Wr[Zr];ei||(ei=Wr[Zr]=Gr.measureText(Zr).width);let ti=Wr[Jr];ti||(ti=Wr[Jr]=Gr.measureText(Jr).width);let ri=Gr.measureText(Zr+Jr).width,ii=ri-(ei+ti);ii&&(this.chars[Zr].kerning[Jr]=ii),ri=Gr.measureText(Zr+Jr).width,ii=ri-(ei+ti),ii&&(this.chars[Jr].kerning[Zr]=ii)}}}_nextPage(){this._currentPageIndex++;const ze=this.resolution,Gr=CanvasPool.getOptimalCanvasAndContext(this._textureSize,this._textureSize,ze);this._setupContext(Gr.context,this._style,ze);const Wr=ze*(this.baseRenderedFontSize/this.baseMeasurementFontSize),Kr=new Texture({source:new ImageSource({resource:Gr.canvas,resolution:Wr,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})}),Zr={canvasAndContext:Gr,texture:Kr};return this.pages[this._currentPageIndex]=Zr,Zr}_setupContext(ze,Gr,Wr){Gr.fontSize=this.baseRenderedFontSize,ze.scale(Wr,Wr),ze.font=fontStringFromTextStyle(Gr),Gr.fontSize=this.baseMeasurementFontSize,ze.textBaseline=Gr.textBaseline;const Kr=Gr._stroke,Zr=(Kr==null?void 0:Kr.width)??0;if(Kr&&(ze.lineWidth=Zr,ze.lineJoin=Kr.join,ze.miterLimit=Kr.miterLimit,ze.strokeStyle=getCanvasFillStyle(Kr,ze)),Gr._fill&&(ze.fillStyle=getCanvasFillStyle(Gr._fill,ze)),Gr.dropShadow){const Qr=Gr.dropShadow,Jr=Color.shared.setValue(Qr.color).toArray(),ei=Qr.blur*Wr,ti=Qr.distance*Wr;ze.shadowColor=`rgba(${Jr[0]*255},${Jr[1]*255},${Jr[2]*255},${Qr.alpha})`,ze.shadowBlur=ei,ze.shadowOffsetX=Math.cos(Qr.angle)*ti,ze.shadowOffsetY=Math.sin(Qr.angle)*ti}else ze.shadowColor="black",ze.shadowBlur=0,ze.shadowOffsetX=0,ze.shadowOffsetY=0}_drawGlyph(ze,Gr,Wr,Kr,Zr,Qr){const Jr=Gr.text,ei=Gr.fontProperties,ti=Qr._stroke,ri=((ti==null?void 0:ti.width)??0)*Zr,ii=Wr+ri/2,si=Kr-ri/2,ni=ei.descent*Zr,oi=Gr.lineHeight*Zr;Qr.stroke&&ri&&ze.strokeText(Jr,ii,si+oi-ni),Qr._fill&&ze.fillText(Jr,ii,si+oi-ni)}destroy(){super.destroy();for(let ze=0;ze<this.pages.length;ze++){const{canvasAndContext:Gr,texture:Wr}=this.pages[ze];CanvasPool.returnCanvasAndContext(Gr),Wr.destroy(!0)}this.pages=null}};_DynamicBitmapFont.defaultOptions={textureSize:512,style:new TextStyle,mipmap:!0};let DynamicBitmapFont=_DynamicBitmapFont;function getBitmapTextLayout(Yr,ze,Gr,Wr){const Kr={width:0,height:0,offsetY:0,scale:ze.fontSize/Gr.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};Kr.offsetY=Gr.baseLineOffset;let Zr=Kr.lines[0],Qr=null,Jr=!0;const ei={width:0,start:0,index:0,positions:[],chars:[]},ti=oi=>{const li=Zr.width;for(let ai=0;ai<ei.index;ai++){const hi=oi.positions[ai];Zr.chars.push(oi.chars[ai]),Zr.charPositions.push(hi+li)}Zr.width+=oi.width,Jr=!1,ei.width=0,ei.index=0,ei.chars.length=0},ri=()=>{let oi=Zr.chars.length-1;if(Wr){let li=Zr.chars[oi];for(;li===" ";)Zr.width-=Gr.chars[li].xAdvance,li=Zr.chars[--oi]}Kr.width=Math.max(Kr.width,Zr.width),Zr={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},Jr=!0,Kr.lines.push(Zr),Kr.height+=Gr.lineHeight},ii=Gr.baseMeasurementFontSize/ze.fontSize,si=ze.letterSpacing*ii,ni=ze.wordWrapWidth*ii;for(let oi=0;oi<Yr.length+1;oi++){let li;const ai=oi===Yr.length;ai||(li=Yr[oi]);const hi=Gr.chars[li]||Gr.chars[" "];if(/(?:\s)/.test(li)||li==="\r"||li===`
`||ai){if(!Jr&&ze.wordWrap&&Zr.width+ei.width-si>ni?(ri(),ti(ei),ai||Zr.charPositions.push(0)):(ei.start=Zr.width,ti(ei),ai||Zr.charPositions.push(0)),li==="\r"||li===`
`)Zr.width!==0&&ri();else if(!ai){const Ti=hi.xAdvance+(hi.kerning[Qr]||0)+si;Zr.width+=Ti,Zr.spaceWidth=Ti,Zr.spacesIndex.push(Zr.charPositions.length),Zr.chars.push(li)}}else{const mi=hi.kerning[Qr]||0,Ti=hi.xAdvance+mi+si;ei.positions[ei.index++]=ei.width+mi,ei.chars.push(li),ei.width+=Ti}Qr=li}return ri(),ze.align==="center"?alignCenter(Kr):ze.align==="right"?alignRight(Kr):ze.align==="justify"&&alignJustify(Kr),Kr}function alignCenter(Yr){for(let ze=0;ze<Yr.lines.length;ze++){const Gr=Yr.lines[ze],Wr=Yr.width/2-Gr.width/2;for(let Kr=0;Kr<Gr.charPositions.length;Kr++)Gr.charPositions[Kr]+=Wr}}function alignRight(Yr){for(let ze=0;ze<Yr.lines.length;ze++){const Gr=Yr.lines[ze],Wr=Yr.width-Gr.width;for(let Kr=0;Kr<Gr.charPositions.length;Kr++)Gr.charPositions[Kr]+=Wr}}function alignJustify(Yr){const ze=Yr.width;for(let Gr=0;Gr<Yr.lines.length;Gr++){const Wr=Yr.lines[Gr];let Kr=0,Zr=Wr.spacesIndex[Kr++],Qr=0;const Jr=Wr.spacesIndex.length,ti=(ze-Wr.width)/Jr;for(let ri=0;ri<Wr.charPositions.length;ri++)ri===Zr&&(Zr=Wr.spacesIndex[Kr++],Qr+=ti),Wr.charPositions[ri]+=Qr}}let fontCount=0;class BitmapFontManagerClass{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(ze,Gr){var Qr;let Wr=`${Gr.fontFamily}-bitmap`,Kr=!0;if(Gr._fill.fill&&!Gr._stroke)Wr+=Gr._fill.fill.styleKey,Kr=!1;else if(Gr._stroke||Gr.dropShadow){let Jr=Gr.styleKey;Jr=Jr.substring(0,Jr.lastIndexOf("-")),Wr=`${Jr}-bitmap`,Kr=!1}if(!Cache.has(Wr)){const Jr=new DynamicBitmapFont({style:Gr,overrideFill:Kr,overrideSize:!0,...this.defaultOptions});fontCount++,fontCount>50&&warn("BitmapText",`You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),Jr.once("destroy",()=>{fontCount--,Cache.remove(Wr)}),Cache.set(Wr,Jr)}const Zr=Cache.get(Wr);return(Qr=Zr.ensureCharacters)==null||Qr.call(Zr,ze),Zr}getLayout(ze,Gr,Wr=!0){const Kr=this.getFont(ze,Gr);return getBitmapTextLayout([...ze],Gr,Kr,Wr)}measureText(ze,Gr,Wr=!0){return this.getLayout(ze,Gr,Wr)}install(...ze){var ti,ri,ii,si;let Gr=ze[0];typeof Gr=="string"&&(Gr={name:Gr,style:ze[1],chars:(ti=ze[2])==null?void 0:ti.chars,resolution:(ri=ze[2])==null?void 0:ri.resolution,padding:(ii=ze[2])==null?void 0:ii.padding,skipKerning:(si=ze[2])==null?void 0:si.skipKerning},deprecation(v8_0_0,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const Wr=Gr==null?void 0:Gr.name;if(!Wr)throw new Error("[BitmapFontManager] Property `name` is required.");Gr={...this.defaultOptions,...Gr};const Kr=Gr.style,Zr=Kr instanceof TextStyle?Kr:new TextStyle(Kr),Qr=Zr._fill.fill!==null&&Zr._fill.fill!==void 0,Jr=new DynamicBitmapFont({style:Zr,overrideFill:Qr,skipKerning:Gr.skipKerning,padding:Gr.padding,resolution:Gr.resolution,overrideSize:!1}),ei=resolveCharacters(Gr.chars);return Jr.ensureCharacters(ei.join("")),Cache.set(`${Wr}-bitmap`,Jr),Jr.once("destroy",()=>Cache.remove(`${Wr}-bitmap`)),Jr}uninstall(ze){const Gr=`${ze}-bitmap`,Wr=Cache.get(Gr);Wr&&Wr.destroy()}}const BitmapFontManager=new BitmapFontManagerClass;class BitmapFont extends AbstractBitmapFont{constructor(ze,Gr){super();const{textures:Wr,data:Kr}=ze;Object.keys(Kr.pages).forEach(Zr=>{const Qr=Kr.pages[parseInt(Zr,10)],Jr=Wr[Qr.id];this.pages.push({texture:Jr})}),Object.keys(Kr.chars).forEach(Zr=>{const Qr=Kr.chars[Zr],{frame:Jr,source:ei}=Wr[Qr.page],ti=new Rectangle(Qr.x+Jr.x,Qr.y+Jr.y,Qr.width,Qr.height),ri=new Texture({source:ei,frame:ti});this.chars[Zr]={id:Zr.codePointAt(0),xOffset:Qr.xOffset,yOffset:Qr.yOffset,xAdvance:Qr.xAdvance,kerning:Qr.kerning??{},texture:ri}}),this.baseRenderedFontSize=Kr.fontSize,this.baseMeasurementFontSize=Kr.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:Kr.fontSize},this.baseLineOffset=Kr.baseLineOffset,this.lineHeight=Kr.lineHeight,this.fontFamily=Kr.fontFamily,this.distanceField=Kr.distanceField??{type:"none",range:0},this.url=Gr}destroy(){super.destroy();for(let ze=0;ze<this.pages.length;ze++){const{texture:Gr}=this.pages[ze];Gr.destroy(!0)}this.pages=null}static install(ze){BitmapFontManager.install(ze)}static uninstall(ze){BitmapFontManager.uninstall(ze)}}const bitmapFontTextParser={test(Yr){return typeof Yr=="string"&&Yr.startsWith("info face=")},parse(Yr){const ze=Yr.match(/^[a-z]+\s+.+$/gm),Gr={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const ii in ze){const si=ze[ii].match(/^[a-z]+/gm)[0],ni=ze[ii].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),oi={};for(const li in ni){const ai=ni[li].split("="),hi=ai[0],fi=ai[1].replace(/"/gm,""),pi=parseFloat(fi),mi=isNaN(pi)?fi:pi;oi[hi]=mi}Gr[si].push(oi)}const Wr={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[Kr]=Gr.info,[Zr]=Gr.common,[Qr]=Gr.distanceField??[];Qr&&(Wr.distanceField={range:parseInt(Qr.distanceRange,10),type:Qr.fieldType}),Wr.fontSize=parseInt(Kr.size,10),Wr.fontFamily=Kr.face,Wr.lineHeight=parseInt(Zr.lineHeight,10);const Jr=Gr.page;for(let ii=0;ii<Jr.length;ii++)Wr.pages.push({id:parseInt(Jr[ii].id,10)||0,file:Jr[ii].file});const ei={};Wr.baseLineOffset=Wr.lineHeight-parseInt(Zr.base,10);const ti=Gr.char;for(let ii=0;ii<ti.length;ii++){const si=ti[ii],ni=parseInt(si.id,10);let oi=si.letter??si.char??String.fromCharCode(ni);oi==="space"&&(oi=" "),ei[ni]=oi,Wr.chars[oi]={id:ni,page:parseInt(si.page,10)||0,x:parseInt(si.x,10),y:parseInt(si.y,10),width:parseInt(si.width,10),height:parseInt(si.height,10),xOffset:parseInt(si.xoffset,10),yOffset:parseInt(si.yoffset,10),xAdvance:parseInt(si.xadvance,10),kerning:{}}}const ri=Gr.kerning||[];for(let ii=0;ii<ri.length;ii++){const si=parseInt(ri[ii].first,10),ni=parseInt(ri[ii].second,10),oi=parseInt(ri[ii].amount,10);Wr.chars[ei[ni]].kerning[ei[si]]=oi}return Wr}},bitmapFontXMLParser={test(Yr){const ze=Yr;return typeof ze!="string"&&"getElementsByTagName"in ze&&ze.getElementsByTagName("page").length&&ze.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(Yr){const ze={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},Gr=Yr.getElementsByTagName("info")[0],Wr=Yr.getElementsByTagName("common")[0],Kr=Yr.getElementsByTagName("distanceField")[0];Kr&&(ze.distanceField={type:Kr.getAttribute("fieldType"),range:parseInt(Kr.getAttribute("distanceRange"),10)});const Zr=Yr.getElementsByTagName("page"),Qr=Yr.getElementsByTagName("char"),Jr=Yr.getElementsByTagName("kerning");ze.fontSize=parseInt(Gr.getAttribute("size"),10),ze.fontFamily=Gr.getAttribute("face"),ze.lineHeight=parseInt(Wr.getAttribute("lineHeight"),10);for(let ti=0;ti<Zr.length;ti++)ze.pages.push({id:parseInt(Zr[ti].getAttribute("id"),10)||0,file:Zr[ti].getAttribute("file")});const ei={};ze.baseLineOffset=ze.lineHeight-parseInt(Wr.getAttribute("base"),10);for(let ti=0;ti<Qr.length;ti++){const ri=Qr[ti],ii=parseInt(ri.getAttribute("id"),10);let si=ri.getAttribute("letter")??ri.getAttribute("char")??String.fromCharCode(ii);si==="space"&&(si=" "),ei[ii]=si,ze.chars[si]={id:ii,page:parseInt(ri.getAttribute("page"),10)||0,x:parseInt(ri.getAttribute("x"),10),y:parseInt(ri.getAttribute("y"),10),width:parseInt(ri.getAttribute("width"),10),height:parseInt(ri.getAttribute("height"),10),xOffset:parseInt(ri.getAttribute("xoffset"),10),yOffset:parseInt(ri.getAttribute("yoffset"),10),xAdvance:parseInt(ri.getAttribute("xadvance"),10),kerning:{}}}for(let ti=0;ti<Jr.length;ti++){const ri=parseInt(Jr[ti].getAttribute("first"),10),ii=parseInt(Jr[ti].getAttribute("second"),10),si=parseInt(Jr[ti].getAttribute("amount"),10);ze.chars[ei[ii]].kerning[ei[ri]]=si}return ze}},bitmapFontXMLStringParser={test(Yr){return typeof Yr=="string"&&Yr.includes("<font>")?bitmapFontXMLParser.test(DOMAdapter.get().parseXML(Yr)):!1},parse(Yr){return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(Yr))}},validExtensions=[".xml",".fnt"],bitmapFontCachePlugin={extension:{type:ExtensionType.CacheParser,name:"cacheBitmapFont"},test:Yr=>Yr instanceof BitmapFont,getCacheableAssets(Yr,ze){const Gr={};return Yr.forEach(Wr=>{Gr[Wr]=ze,Gr[`${Wr}-bitmap`]=ze}),Gr[`${ze.fontFamily}-bitmap`]=ze,Gr}},loadBitmapFont={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Normal},name:"loadBitmapFont",test(Yr){return validExtensions.includes(path.extname(Yr).toLowerCase())},async testParse(Yr){return bitmapFontTextParser.test(Yr)||bitmapFontXMLStringParser.test(Yr)},async parse(Yr,ze,Gr){const Wr=bitmapFontTextParser.test(Yr)?bitmapFontTextParser.parse(Yr):bitmapFontXMLStringParser.parse(Yr),{src:Kr}=ze,{pages:Zr}=Wr,Qr=[],Jr=Wr.distanceField?{scaleMode:"linear",alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:!1,resolution:1}:{};for(let ii=0;ii<Zr.length;++ii){const si=Zr[ii].file;let ni=path.join(path.dirname(Kr),si);ni=copySearchParams(ni,Kr),Qr.push({src:ni,data:Jr})}const ei=await Gr.load(Qr),ti=Qr.map(ii=>ei[ii.src]);return new BitmapFont({data:Wr,textures:ti},Kr)},async load(Yr,ze){return await(await DOMAdapter.get().fetch(Yr)).text()},async unload(Yr,ze,Gr){await Promise.all(Yr.pages.map(Wr=>Gr.unload(Wr.texture.source._sourceOrigin))),Yr.destroy()}};class BackgroundLoader{constructor(ze,Gr=!1){this._loader=ze,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=Gr}add(ze){ze.forEach(Gr=>{this._assetList.push(Gr)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const ze=[],Gr=Math.min(this._assetList.length,this._maxConcurrent);for(let Wr=0;Wr<Gr;Wr++)ze.push(this._assetList.pop());await this._loader.load(ze),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(ze){this._isActive!==ze&&(this._isActive=ze,ze&&!this._isLoading&&this._next())}}const cacheTextureArray={extension:{type:ExtensionType.CacheParser,name:"cacheTextureArray"},test:Yr=>Array.isArray(Yr)&&Yr.every(ze=>ze instanceof Texture),getCacheableAssets:(Yr,ze)=>{const Gr={};return Yr.forEach(Wr=>{ze.forEach((Kr,Zr)=>{Gr[Wr+(Zr===0?"":Zr+1)]=Kr})}),Gr}};async function testImageFormat(Yr){if("Image"in globalThis)return new Promise(ze=>{const Gr=new Image;Gr.onload=()=>{ze(!0)},Gr.onerror=()=>{ze(!1)},Gr.src=Yr});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const ze=await(await fetch(Yr)).blob();await createImageBitmap(ze)}catch{return!1}return!0}return!1}const detectAvif={extension:{type:ExtensionType.DetectionParser,priority:1},test:async()=>testImageFormat("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async Yr=>[...Yr,"avif"],remove:async Yr=>Yr.filter(ze=>ze!=="avif")},imageFormats=["png","jpg","jpeg"],detectDefaults={extension:{type:ExtensionType.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async Yr=>[...Yr,...imageFormats],remove:async Yr=>Yr.filter(ze=>!imageFormats.includes(ze))},inWorker="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function testVideoFormat(Yr){return inWorker?!1:document.createElement("video").canPlayType(Yr)!==""}const detectMp4={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testVideoFormat("video/mp4"),add:async Yr=>[...Yr,"mp4","m4v"],remove:async Yr=>Yr.filter(ze=>ze!=="mp4"&&ze!=="m4v")},detectOgv={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testVideoFormat("video/ogg"),add:async Yr=>[...Yr,"ogv"],remove:async Yr=>Yr.filter(ze=>ze!=="ogv")},detectWebm={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testVideoFormat("video/webm"),add:async Yr=>[...Yr,"webm"],remove:async Yr=>Yr.filter(ze=>ze!=="webm")},detectWebp={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testImageFormat("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async Yr=>[...Yr,"webp"],remove:async Yr=>Yr.filter(ze=>ze!=="webp")};class Loader{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(ze,Gr,Wr)=>(this._parsersValidated=!1,ze[Gr]=Wr,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(ze,Gr){const Wr={promise:null,parser:null};return Wr.promise=(async()=>{var Qr,Jr;let Kr=null,Zr=null;if(Gr.loadParser&&(Zr=this._parserHash[Gr.loadParser],Zr||warn(`[Assets] specified load parser "${Gr.loadParser}" not found while loading ${ze}`)),!Zr){for(let ei=0;ei<this.parsers.length;ei++){const ti=this.parsers[ei];if(ti.load&&((Qr=ti.test)!=null&&Qr.call(ti,ze,Gr,this))){Zr=ti;break}}if(!Zr)return warn(`[Assets] ${ze} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}Kr=await Zr.load(ze,Gr,this),Wr.parser=Zr;for(let ei=0;ei<this.parsers.length;ei++){const ti=this.parsers[ei];ti.parse&&ti.parse&&await((Jr=ti.testParse)==null?void 0:Jr.call(ti,Kr,Gr,this))&&(Kr=await ti.parse(Kr,Gr,this)||Kr,Wr.parser=ti)}return Kr})(),Wr}async load(ze,Gr){this._parsersValidated||this._validateParsers();let Wr=0;const Kr={},Zr=isSingleItem(ze),Qr=convertToList(ze,ti=>({alias:[ti],src:ti,data:{}})),Jr=Qr.length,ei=Qr.map(async ti=>{const ri=path.toAbsolute(ti.src);if(!Kr[ti.src])try{this.promiseCache[ri]||(this.promiseCache[ri]=this._getLoadPromiseAndParser(ri,ti)),Kr[ti.src]=await this.promiseCache[ri].promise,Gr&&Gr(++Wr/Jr)}catch(ii){throw delete this.promiseCache[ri],delete Kr[ti.src],new Error(`[Loader.load] Failed to load ${ri}.
${ii}`)}});return await Promise.all(ei),Zr?Kr[Qr[0].src]:Kr}async unload(ze){const Wr=convertToList(ze,Kr=>({alias:[Kr],src:Kr})).map(async Kr=>{var Jr,ei;const Zr=path.toAbsolute(Kr.src),Qr=this.promiseCache[Zr];if(Qr){const ti=await Qr.promise;delete this.promiseCache[Zr],await((ei=(Jr=Qr.parser)==null?void 0:Jr.unload)==null?void 0:ei.call(Jr,ti,Kr,this))}});await Promise.all(Wr)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(ze=>ze.name).reduce((ze,Gr)=>(Gr.name?ze[Gr.name]&&warn(`[Assets] loadParser name conflict "${Gr.name}"`):warn("[Assets] loadParser should have a name"),{...ze,[Gr.name]:Gr}),{})}}function checkDataUrl(Yr,ze){if(Array.isArray(ze)){for(const Gr of ze)if(Yr.startsWith(`data:${Gr}`))return!0;return!1}return Yr.startsWith(`data:${ze}`)}function checkExtension(Yr,ze){const Gr=Yr.split("?")[0],Wr=path.extname(Gr).toLowerCase();return Array.isArray(ze)?ze.includes(Wr):Wr===ze}const validJSONExtension=".json",validJSONMIME="application/json",loadJson={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low},name:"loadJson",test(Yr){return checkDataUrl(Yr,validJSONMIME)||checkExtension(Yr,validJSONExtension)},async load(Yr){return await(await DOMAdapter.get().fetch(Yr)).json()}},validTXTExtension=".txt",validTXTMIME="text/plain",loadTxt={name:"loadTxt",extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low,name:"loadTxt"},test(Yr){return checkDataUrl(Yr,validTXTMIME)||checkExtension(Yr,validTXTExtension)},async load(Yr){return await(await DOMAdapter.get().fetch(Yr)).text()}},validWeights=["normal","bold","100","200","300","400","500","600","700","800","900"],validFontExtensions=[".ttf",".otf",".woff",".woff2"],validFontMIMEs=["font/ttf","font/otf","font/woff","font/woff2"],CSS_IDENT_TOKEN_REGEX=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function getFontFamilyName(Yr){const ze=path.extname(Yr),Kr=path.basename(Yr,ze).replace(/(-|_)/g," ").toLowerCase().split(" ").map(Jr=>Jr.charAt(0).toUpperCase()+Jr.slice(1));let Zr=Kr.length>0;for(const Jr of Kr)if(!Jr.match(CSS_IDENT_TOKEN_REGEX)){Zr=!1;break}let Qr=Kr.join(" ");return Zr||(Qr=`"${Qr.replace(/[\\"]/g,"\\$&")}"`),Qr}const validURICharactersRegex=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function encodeURIWhenNeeded(Yr){return validURICharactersRegex.test(Yr)?Yr:encodeURI(Yr)}const loadWebFont={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low},name:"loadWebFont",test(Yr){return checkDataUrl(Yr,validFontMIMEs)||checkExtension(Yr,validFontExtensions)},async load(Yr,ze){var Wr,Kr,Zr;const Gr=DOMAdapter.get().getFontFaceSet();if(Gr){const Qr=[],Jr=((Wr=ze.data)==null?void 0:Wr.family)??getFontFamilyName(Yr),ei=((Zr=(Kr=ze.data)==null?void 0:Kr.weights)==null?void 0:Zr.filter(ri=>validWeights.includes(ri)))??["normal"],ti=ze.data??{};for(let ri=0;ri<ei.length;ri++){const ii=ei[ri],si=new FontFace(Jr,`url(${encodeURIWhenNeeded(Yr)})`,{...ti,weight:ii});await si.load(),Gr.add(si),Qr.push(si)}return Cache.set(`${Jr}-and-url`,{url:Yr,fontFaces:Qr}),Qr.length===1?Qr[0]:Qr}return warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(Yr){(Array.isArray(Yr)?Yr:[Yr]).forEach(ze=>{Cache.remove(`${ze.family}-and-url`),DOMAdapter.get().getFontFaceSet().delete(ze)})}};function getResolutionOfUrl(Yr,ze=1){var Wr;const Gr=(Wr=Resolver.RETINA_PREFIX)==null?void 0:Wr.exec(Yr);return Gr?parseFloat(Gr[1]):ze}function createTexture(Yr,ze,Gr){Yr.label=Gr,Yr._sourceOrigin=Gr;const Wr=new Texture({source:Yr,label:Gr}),Kr=()=>{delete ze.promiseCache[Gr],Cache.has(Gr)&&Cache.remove(Gr)};return Wr.source.once("destroy",()=>{ze.promiseCache[Gr]&&(warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."),Kr())}),Wr.once("destroy",()=>{Yr.destroyed||(warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),Kr())}),Wr}const validSVGExtension=".svg",validSVGMIME="image/svg+xml",loadSvg={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low,name:"loadSVG"},name:"loadSVG",config:{crossOrigin:"anonymous",parseAsGraphicsContext:!1},test(Yr){return checkDataUrl(Yr,validSVGMIME)||checkExtension(Yr,validSVGExtension)},async load(Yr,ze,Gr){var Wr;return((Wr=ze.data)==null?void 0:Wr.parseAsGraphicsContext)??this.config.parseAsGraphicsContext?loadAsGraphics(Yr):loadAsTexture(Yr,ze,Gr,this.config.crossOrigin)},unload(Yr){Yr.destroy(!0)}};async function loadAsTexture(Yr,ze,Gr,Wr){var ai,hi,fi;const Zr=await(await DOMAdapter.get().fetch(Yr)).blob(),Qr=URL.createObjectURL(Zr),Jr=new Image;Jr.src=Qr,Jr.crossOrigin=Wr,await Jr.decode(),URL.revokeObjectURL(Qr);const ei=document.createElement("canvas"),ti=ei.getContext("2d"),ri=((ai=ze.data)==null?void 0:ai.resolution)||getResolutionOfUrl(Yr),ii=((hi=ze.data)==null?void 0:hi.width)??Jr.width,si=((fi=ze.data)==null?void 0:fi.height)??Jr.height;ei.width=ii*ri,ei.height=si*ri,ti.drawImage(Jr,0,0,ii*ri,si*ri);const{parseAsGraphicsContext:ni,...oi}=ze.data??{},li=new ImageSource({resource:ei,alphaMode:"premultiply-alpha-on-upload",resolution:ri,...oi});return createTexture(li,Gr,Yr)}async function loadAsGraphics(Yr){const Gr=await(await DOMAdapter.get().fetch(Yr)).text(),Wr=new GraphicsContext;return Wr.svg(Gr),Wr}const WORKER_CODE$1=`(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;let WORKER_URL$1=null,WorkerInstance$1=class{constructor(){WORKER_URL$1||(WORKER_URL$1=URL.createObjectURL(new Blob([WORKER_CODE$1],{type:"application/javascript"}))),this.worker=new Worker(WORKER_URL$1)}};WorkerInstance$1.revokeObjectURL=function(){WORKER_URL$1&&(URL.revokeObjectURL(WORKER_URL$1),WORKER_URL$1=null)};const WORKER_CODE=`(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;let WORKER_URL=null;class WorkerInstance{constructor(){WORKER_URL||(WORKER_URL=URL.createObjectURL(new Blob([WORKER_CODE],{type:"application/javascript"}))),this.worker=new Worker(WORKER_URL)}}WorkerInstance.revokeObjectURL=function(){WORKER_URL&&(URL.revokeObjectURL(WORKER_URL),WORKER_URL=null)};let UUID=0,MAX_WORKERS;class WorkerManagerClass{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(ze=>{const{worker:Gr}=new WorkerInstance$1;Gr.addEventListener("message",Wr=>{Gr.terminate(),WorkerInstance$1.revokeObjectURL(),ze(Wr.data)})}),this._isImageBitmapSupported)}loadImageBitmap(ze,Gr){var Wr;return this._run("loadImageBitmap",[ze,(Wr=Gr==null?void 0:Gr.data)==null?void 0:Wr.alphaMode])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){MAX_WORKERS===void 0&&(MAX_WORKERS=navigator.hardwareConcurrency||4);let ze=this._workerPool.pop();return!ze&&this._createdWorkers<MAX_WORKERS&&(this._createdWorkers++,ze=new WorkerInstance().worker,ze.addEventListener("message",Gr=>{this._complete(Gr.data),this._returnWorker(Gr.target),this._next()})),ze}_returnWorker(ze){this._workerPool.push(ze)}_complete(ze){ze.error!==void 0?this._resolveHash[ze.uuid].reject(ze.error):this._resolveHash[ze.uuid].resolve(ze.data),this._resolveHash[ze.uuid]=null}async _run(ze,Gr){await this._initWorkers();const Wr=new Promise((Kr,Zr)=>{this._queue.push({id:ze,arguments:Gr,resolve:Kr,reject:Zr})});return this._next(),Wr}_next(){if(!this._queue.length)return;const ze=this._getWorker();if(!ze)return;const Gr=this._queue.pop(),Wr=Gr.id;this._resolveHash[UUID]={resolve:Gr.resolve,reject:Gr.reject},ze.postMessage({data:Gr.arguments,uuid:UUID++,id:Wr})}}const WorkerManager=new WorkerManagerClass,validImageExtensions=[".jpeg",".jpg",".png",".webp",".avif"],validImageMIMEs=["image/jpeg","image/png","image/webp","image/avif"];async function loadImageBitmap(Yr,ze){var Kr;const Gr=await DOMAdapter.get().fetch(Yr);if(!Gr.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${Yr}: ${Gr.status} ${Gr.statusText}`);const Wr=await Gr.blob();return((Kr=ze==null?void 0:ze.data)==null?void 0:Kr.alphaMode)==="premultiplied-alpha"?createImageBitmap(Wr,{premultiplyAlpha:"none"}):createImageBitmap(Wr)}const loadTextures={name:"loadTextures",extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.High,name:"loadTextures"},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(Yr){return checkDataUrl(Yr,validImageMIMEs)||checkExtension(Yr,validImageExtensions)},async load(Yr,ze,Gr){var Zr;let Wr=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await WorkerManager.isImageBitmapSupported()?Wr=await WorkerManager.loadImageBitmap(Yr,ze):Wr=await loadImageBitmap(Yr,ze):Wr=await new Promise((Qr,Jr)=>{Wr=new Image,Wr.crossOrigin=this.config.crossOrigin,Wr.src=Yr,Wr.complete?Qr(Wr):(Wr.onload=()=>{Qr(Wr)},Wr.onerror=Jr)});const Kr=new ImageSource({resource:Wr,alphaMode:"premultiply-alpha-on-upload",resolution:((Zr=ze.data)==null?void 0:Zr.resolution)||getResolutionOfUrl(Yr),...ze.data});return createTexture(Kr,Gr,Yr)},unload(Yr){Yr.destroy(!0)}},validVideoExtensions=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"],validVideoMIMEs=validVideoExtensions.map(Yr=>`video/${Yr.substring(1)}`);function crossOrigin(Yr,ze,Gr){Gr===void 0&&!ze.startsWith("data:")?Yr.crossOrigin=determineCrossOrigin(ze):Gr!==!1&&(Yr.crossOrigin=typeof Gr=="string"?Gr:"anonymous")}function preloadVideo(Yr){return new Promise((ze,Gr)=>{Yr.addEventListener("canplaythrough",Wr),Yr.addEventListener("error",Kr),Yr.load();function Wr(){Zr(),ze()}function Kr(Qr){Zr(),Gr(Qr)}function Zr(){Yr.removeEventListener("canplaythrough",Wr),Yr.removeEventListener("error",Kr)}})}function determineCrossOrigin(Yr,ze=globalThis.location){if(Yr.startsWith("data:"))return"";ze||(ze=globalThis.location);const Gr=new URL(Yr,document.baseURI);return Gr.hostname!==ze.hostname||Gr.port!==ze.port||Gr.protocol!==ze.protocol?"anonymous":""}const loadVideoTextures={name:"loadVideo",extension:{type:ExtensionType.LoadParser,name:"loadVideo"},test(Yr){const ze=checkDataUrl(Yr,validVideoMIMEs),Gr=checkExtension(Yr,validVideoExtensions);return ze||Gr},async load(Yr,ze,Gr){var ei,ti;const Wr={...VideoSource.defaultOptions,resolution:((ei=ze.data)==null?void 0:ei.resolution)||getResolutionOfUrl(Yr),alphaMode:((ti=ze.data)==null?void 0:ti.alphaMode)||await detectVideoAlphaMode(),...ze.data},Kr=document.createElement("video"),Zr={preload:Wr.autoLoad!==!1?"auto":void 0,"webkit-playsinline":Wr.playsinline!==!1?"":void 0,playsinline:Wr.playsinline!==!1?"":void 0,muted:Wr.muted===!0?"":void 0,loop:Wr.loop===!0?"":void 0,autoplay:Wr.autoPlay!==!1?"":void 0};Object.keys(Zr).forEach(ri=>{const ii=Zr[ri];ii!==void 0&&Kr.setAttribute(ri,ii)}),Wr.muted===!0&&(Kr.muted=!0),crossOrigin(Kr,Yr,Wr.crossorigin);const Qr=document.createElement("source");let Jr;if(Yr.startsWith("data:"))Jr=Yr.slice(5,Yr.indexOf(";"));else if(!Yr.startsWith("blob:")){const ri=Yr.split("?")[0].slice(Yr.lastIndexOf(".")+1).toLowerCase();Jr=VideoSource.MIME_TYPES[ri]||`video/${ri}`}return Qr.src=Yr,Jr&&(Qr.type=Jr),new Promise(ri=>{const ii=async()=>{const si=new VideoSource({...Wr,resource:Kr});Kr.removeEventListener("canplay",ii),ze.data.preload&&await preloadVideo(Kr),ri(createTexture(si,Gr,Yr))};Kr.addEventListener("canplay",ii),Kr.appendChild(Qr)})},unload(Yr){Yr.destroy(!0)}},resolveTextureUrl={extension:{type:ExtensionType.ResolveParser,name:"resolveTexture"},test:loadTextures.test,parse:Yr=>{var ze;return{resolution:parseFloat(((ze=Resolver.RETINA_PREFIX.exec(Yr))==null?void 0:ze[1])??"1"),format:Yr.split(".").pop(),src:Yr}}},resolveJsonUrl={extension:{type:ExtensionType.ResolveParser,priority:-2,name:"resolveJson"},test:Yr=>Resolver.RETINA_PREFIX.test(Yr)&&Yr.endsWith(".json"),parse:resolveTextureUrl.parse};class AssetsClass{constructor(){this._detections=[],this._initialized=!1,this.resolver=new Resolver,this.loader=new Loader,this.cache=Cache,this._backgroundLoader=new BackgroundLoader(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(ze={}){var Zr,Qr;if(this._initialized){warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");return}if(this._initialized=!0,ze.defaultSearchParams&&this.resolver.setDefaultSearchParams(ze.defaultSearchParams),ze.basePath&&(this.resolver.basePath=ze.basePath),ze.bundleIdentifier&&this.resolver.setBundleIdentifier(ze.bundleIdentifier),ze.manifest){let Jr=ze.manifest;typeof Jr=="string"&&(Jr=await this.load(Jr)),this.resolver.addManifest(Jr)}const Gr=((Zr=ze.texturePreference)==null?void 0:Zr.resolution)??1,Wr=typeof Gr=="number"?[Gr]:Gr,Kr=await this._detectFormats({preferredFormats:(Qr=ze.texturePreference)==null?void 0:Qr.format,skipDetections:ze.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:Kr,resolution:Wr}}),ze.preferences&&this.setPreferences(ze.preferences)}add(ze){this.resolver.add(ze)}async load(ze,Gr){this._initialized||await this.init();const Wr=isSingleItem(ze),Kr=convertToList(ze).map(Jr=>{if(typeof Jr!="string"){const ei=this.resolver.getAlias(Jr);return ei.some(ti=>!this.resolver.hasKey(ti))&&this.add(Jr),Array.isArray(ei)?ei[0]:ei}return this.resolver.hasKey(Jr)||this.add({alias:Jr,src:Jr}),Jr}),Zr=this.resolver.resolve(Kr),Qr=await this._mapLoadToResolve(Zr,Gr);return Wr?Qr[Kr[0]]:Qr}addBundle(ze,Gr){this.resolver.addBundle(ze,Gr)}async loadBundle(ze,Gr){this._initialized||await this.init();let Wr=!1;typeof ze=="string"&&(Wr=!0,ze=[ze]);const Kr=this.resolver.resolveBundle(ze),Zr={},Qr=Object.keys(Kr);let Jr=0,ei=0;const ti=()=>{Gr==null||Gr(++Jr/ei)},ri=Qr.map(ii=>{const si=Kr[ii];return ei+=Object.keys(si).length,this._mapLoadToResolve(si,ti).then(ni=>{Zr[ii]=ni})});return await Promise.all(ri),Wr?Zr[ze[0]]:Zr}async backgroundLoad(ze){this._initialized||await this.init(),typeof ze=="string"&&(ze=[ze]);const Gr=this.resolver.resolve(ze);this._backgroundLoader.add(Object.values(Gr))}async backgroundLoadBundle(ze){this._initialized||await this.init(),typeof ze=="string"&&(ze=[ze]);const Gr=this.resolver.resolveBundle(ze);Object.values(Gr).forEach(Wr=>{this._backgroundLoader.add(Object.values(Wr))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(ze){if(typeof ze=="string")return Cache.get(ze);const Gr={};for(let Wr=0;Wr<ze.length;Wr++)Gr[Wr]=Cache.get(ze[Wr]);return Gr}async _mapLoadToResolve(ze,Gr){const Wr=[...new Set(Object.values(ze))];this._backgroundLoader.active=!1;const Kr=await this.loader.load(Wr,Gr);this._backgroundLoader.active=!0;const Zr={};return Wr.forEach(Qr=>{const Jr=Kr[Qr.src],ei=[Qr.src];Qr.alias&&ei.push(...Qr.alias),ei.forEach(ti=>{Zr[ti]=Jr}),Cache.set(ei,Jr)}),Zr}async unload(ze){this._initialized||await this.init();const Gr=convertToList(ze).map(Kr=>typeof Kr!="string"?Kr.src:Kr),Wr=this.resolver.resolve(Gr);await this._unloadFromResolved(Wr)}async unloadBundle(ze){this._initialized||await this.init(),ze=convertToList(ze);const Gr=this.resolver.resolveBundle(ze),Wr=Object.keys(Gr).map(Kr=>this._unloadFromResolved(Gr[Kr]));await Promise.all(Wr)}async _unloadFromResolved(ze){const Gr=Object.values(ze);Gr.forEach(Wr=>{Cache.remove(Wr.src)}),await this.loader.unload(Gr)}async _detectFormats(ze){let Gr=[];ze.preferredFormats&&(Gr=Array.isArray(ze.preferredFormats)?ze.preferredFormats:[ze.preferredFormats]);for(const Wr of ze.detections)ze.skipDetections||await Wr.test()?Gr=await Wr.add(Gr):ze.skipDetections||(Gr=await Wr.remove(Gr));return Gr=Gr.filter((Wr,Kr)=>Gr.indexOf(Wr)===Kr),Gr}get detections(){return this._detections}setPreferences(ze){this.loader.parsers.forEach(Gr=>{Gr.config&&Object.keys(Gr.config).filter(Wr=>Wr in ze).forEach(Wr=>{Gr.config[Wr]=ze[Wr]})})}}const Assets=new AssetsClass;extensions.handleByList(ExtensionType.LoadParser,Assets.loader.parsers).handleByList(ExtensionType.ResolveParser,Assets.resolver.parsers).handleByList(ExtensionType.CacheParser,Assets.cache.parsers).handleByList(ExtensionType.DetectionParser,Assets.detections);extensions.add(cacheTextureArray,detectDefaults,detectAvif,detectWebp,detectMp4,detectOgv,detectWebm,loadJson,loadTxt,loadWebFont,loadSvg,loadTextures,loadVideoTextures,loadBitmapFont,bitmapFontCachePlugin,resolveTextureUrl,resolveJsonUrl);const assetKeyMap={loader:ExtensionType.LoadParser,resolver:ExtensionType.ResolveParser,cache:ExtensionType.CacheParser,detection:ExtensionType.DetectionParser};extensions.handle(ExtensionType.Asset,Yr=>{const ze=Yr.ref;Object.entries(assetKeyMap).filter(([Gr])=>!!ze[Gr]).forEach(([Gr,Wr])=>extensions.add(Object.assign(ze[Gr],{extension:ze[Gr].extension??Wr})))},Yr=>{const ze=Yr.ref;Object.keys(assetKeyMap).filter(Gr=>!!ze[Gr]).forEach(Gr=>extensions.remove(ze[Gr]))});class DOMPipe{constructor(ze){this._destroyRenderableBound=this.destroyRenderable.bind(this),this._attachedDomElements=[],this._renderer=ze,this._renderer.runners.postrender.add(this),this._domElement=document.createElement("div"),this._domElement.style.position="absolute",this._domElement.style.top="0",this._domElement.style.left="0",this._domElement.style.pointerEvents="none",this._domElement.style.zIndex="1000"}addRenderable(ze,Gr){this._attachedDomElements.includes(ze)||(this._attachedDomElements.push(ze),ze.on("destroyed",this._destroyRenderableBound))}updateRenderable(ze){}validateRenderable(ze){return!0}destroyRenderable(ze){const Gr=this._attachedDomElements.indexOf(ze);Gr!==-1&&this._attachedDomElements.splice(Gr,1),ze.off("destroyed",this._destroyRenderableBound)}postrender(){var Wr;const ze=this._attachedDomElements;if(ze.length===0){this._domElement.remove();return}const Gr=this._renderer.view.canvas;this._domElement.parentNode!==Gr.parentNode&&((Wr=Gr.parentNode)==null||Wr.appendChild(this._domElement)),this._domElement.style.transform=`translate(${Gr.offsetLeft}px, ${Gr.offsetTop}px)`;for(let Kr=0;Kr<ze.length;Kr++){const Zr=ze[Kr],Qr=Zr.element;if(!Zr.parent||Zr.globalDisplayStatus<7)Qr.remove(),ze.splice(Kr,1),Kr--;else{this._domElement.contains(Qr)||(Qr.style.position="absolute",Qr.style.pointerEvents="auto",this._domElement.appendChild(Qr));const Jr=Zr.worldTransform,ei=Zr._anchor,ti=Zr.width*ei.x,ri=Zr.height*ei.y;Qr.style.transformOrigin=`${ti}px ${ri}px`,Qr.style.transform=`matrix(${Jr.a}, ${Jr.b}, ${Jr.c}, ${Jr.d}, ${Jr.tx-ti}, ${Jr.ty-ri})`,Qr.style.opacity=Zr.groupAlpha.toString()}}}destroy(){this._renderer.runners.postrender.remove(this);for(let ze=0;ze<this._attachedDomElements.length;ze++){const Gr=this._attachedDomElements[ze];Gr.off("destroyed",this._destroyRenderableBound),Gr.element.remove()}this._attachedDomElements.length=0,this._domElement.remove(),this._renderer=null}}DOMPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"dom"};class EventsTickerClass{constructor(){this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}init(ze){this.removeTickerListener(),this.events=ze,this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}get pauseUpdate(){return this._pauseUpdate}set pauseUpdate(ze){this._pauseUpdate=ze}addTickerListener(){this._tickerAdded||!this.domElement||(Ticker.system.add(this._tickerUpdate,this,UPDATE_PRIORITY.INTERACTION),this._tickerAdded=!0)}removeTickerListener(){this._tickerAdded&&(Ticker.system.remove(this._tickerUpdate,this),this._tickerAdded=!1)}pointerMoved(){this._didMove=!0}_update(){if(!this.domElement||this._pauseUpdate)return;if(this._didMove){this._didMove=!1;return}const ze=this.events._rootPointerEvent;this.events.supportsTouchEvents&&ze.pointerType==="touch"||globalThis.document.dispatchEvent(new PointerEvent("pointermove",{clientX:ze.clientX,clientY:ze.clientY,pointerType:ze.pointerType,pointerId:ze.pointerId}))}_tickerUpdate(ze){this._deltaTime+=ze.deltaTime,!(this._deltaTime<this.interactionFrequency)&&(this._deltaTime=0,this._update())}}const EventsTicker=new EventsTickerClass;class FederatedMouseEvent extends FederatedEvent{constructor(){super(...arguments),this.client=new Point$1,this.movement=new Point$1,this.offset=new Point$1,this.global=new Point$1,this.screen=new Point$1}get clientX(){return this.client.x}get clientY(){return this.client.y}get x(){return this.clientX}get y(){return this.clientY}get movementX(){return this.movement.x}get movementY(){return this.movement.y}get offsetX(){return this.offset.x}get offsetY(){return this.offset.y}get globalX(){return this.global.x}get globalY(){return this.global.y}get screenX(){return this.screen.x}get screenY(){return this.screen.y}getLocalPosition(ze,Gr,Wr){return ze.worldTransform.applyInverse(Wr||this.global,Gr)}getModifierState(ze){return"getModifierState"in this.nativeEvent&&this.nativeEvent.getModifierState(ze)}initMouseEvent(ze,Gr,Wr,Kr,Zr,Qr,Jr,ei,ti,ri,ii,si,ni,oi,li){throw new Error("Method not implemented.")}}class FederatedPointerEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.width=0,this.height=0,this.isPrimary=!1}getCoalescedEvents(){return this.type==="pointermove"||this.type==="mousemove"||this.type==="touchmove"?[this]:[]}getPredictedEvents(){throw new Error("getPredictedEvents is not supported!")}}class FederatedWheelEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.DOM_DELTA_PIXEL=0,this.DOM_DELTA_LINE=1,this.DOM_DELTA_PAGE=2}}FederatedWheelEvent.DOM_DELTA_PIXEL=0;FederatedWheelEvent.DOM_DELTA_LINE=1;FederatedWheelEvent.DOM_DELTA_PAGE=2;const PROPAGATION_LIMIT=2048,tempHitLocation=new Point$1,tempLocalMapping=new Point$1;class EventBoundary{constructor(ze){this.dispatch=new EventEmitter,this.moveOnAll=!1,this.enableGlobalMoveEvents=!0,this.mappingState={trackingData:{}},this.eventPool=new Map,this._allInteractiveElements=[],this._hitElements=[],this._isPointerMoveEvent=!1,this.rootTarget=ze,this.hitPruneFn=this.hitPruneFn.bind(this),this.hitTestFn=this.hitTestFn.bind(this),this.mapPointerDown=this.mapPointerDown.bind(this),this.mapPointerMove=this.mapPointerMove.bind(this),this.mapPointerOut=this.mapPointerOut.bind(this),this.mapPointerOver=this.mapPointerOver.bind(this),this.mapPointerUp=this.mapPointerUp.bind(this),this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this),this.mapWheel=this.mapWheel.bind(this),this.mappingTable={},this.addEventMapping("pointerdown",this.mapPointerDown),this.addEventMapping("pointermove",this.mapPointerMove),this.addEventMapping("pointerout",this.mapPointerOut),this.addEventMapping("pointerleave",this.mapPointerOut),this.addEventMapping("pointerover",this.mapPointerOver),this.addEventMapping("pointerup",this.mapPointerUp),this.addEventMapping("pointerupoutside",this.mapPointerUpOutside),this.addEventMapping("wheel",this.mapWheel)}addEventMapping(ze,Gr){this.mappingTable[ze]||(this.mappingTable[ze]=[]),this.mappingTable[ze].push({fn:Gr,priority:0}),this.mappingTable[ze].sort((Wr,Kr)=>Wr.priority-Kr.priority)}dispatchEvent(ze,Gr){ze.propagationStopped=!1,ze.propagationImmediatelyStopped=!1,this.propagate(ze,Gr),this.dispatch.emit(Gr||ze.type,ze)}mapEvent(ze){if(!this.rootTarget)return;const Gr=this.mappingTable[ze.type];if(Gr)for(let Wr=0,Kr=Gr.length;Wr<Kr;Wr++)Gr[Wr].fn(ze);else warn(`[EventBoundary]: Event mapping not defined for ${ze.type}`)}hitTest(ze,Gr){EventsTicker.pauseUpdate=!0;const Kr=this._isPointerMoveEvent&&this.enableGlobalMoveEvents?"hitTestMoveRecursive":"hitTestRecursive",Zr=this[Kr](this.rootTarget,this.rootTarget.eventMode,tempHitLocation.set(ze,Gr),this.hitTestFn,this.hitPruneFn);return Zr&&Zr[0]}propagate(ze,Gr){if(!ze.target)return;const Wr=ze.composedPath();ze.eventPhase=ze.CAPTURING_PHASE;for(let Kr=0,Zr=Wr.length-1;Kr<Zr;Kr++)if(ze.currentTarget=Wr[Kr],this.notifyTarget(ze,Gr),ze.propagationStopped||ze.propagationImmediatelyStopped)return;if(ze.eventPhase=ze.AT_TARGET,ze.currentTarget=ze.target,this.notifyTarget(ze,Gr),!(ze.propagationStopped||ze.propagationImmediatelyStopped)){ze.eventPhase=ze.BUBBLING_PHASE;for(let Kr=Wr.length-2;Kr>=0;Kr--)if(ze.currentTarget=Wr[Kr],this.notifyTarget(ze,Gr),ze.propagationStopped||ze.propagationImmediatelyStopped)return}}all(ze,Gr,Wr=this._allInteractiveElements){if(Wr.length===0)return;ze.eventPhase=ze.BUBBLING_PHASE;const Kr=Array.isArray(Gr)?Gr:[Gr];for(let Zr=Wr.length-1;Zr>=0;Zr--)Kr.forEach(Qr=>{ze.currentTarget=Wr[Zr],this.notifyTarget(ze,Qr)})}propagationPath(ze){const Gr=[ze];for(let Wr=0;Wr<PROPAGATION_LIMIT&&ze!==this.rootTarget&&ze.parent;Wr++){if(!ze.parent)throw new Error("Cannot find propagation path to disconnected target");Gr.push(ze.parent),ze=ze.parent}return Gr.reverse(),Gr}hitTestMoveRecursive(ze,Gr,Wr,Kr,Zr,Qr=!1){let Jr=!1;if(this._interactivePrune(ze))return null;if((ze.eventMode==="dynamic"||Gr==="dynamic")&&(EventsTicker.pauseUpdate=!1),ze.interactiveChildren&&ze.children){const ri=ze.children;for(let ii=ri.length-1;ii>=0;ii--){const si=ri[ii],ni=this.hitTestMoveRecursive(si,this._isInteractive(Gr)?Gr:si.eventMode,Wr,Kr,Zr,Qr||Zr(ze,Wr));if(ni){if(ni.length>0&&!ni[ni.length-1].parent)continue;const oi=ze.isInteractive();(ni.length>0||oi)&&(oi&&this._allInteractiveElements.push(ze),ni.push(ze)),this._hitElements.length===0&&(this._hitElements=ni),Jr=!0}}}const ei=this._isInteractive(Gr),ti=ze.isInteractive();return ti&&ti&&this._allInteractiveElements.push(ze),Qr||this._hitElements.length>0?null:Jr?this._hitElements:ei&&!Zr(ze,Wr)&&Kr(ze,Wr)?ti?[ze]:[]:null}hitTestRecursive(ze,Gr,Wr,Kr,Zr){if(this._interactivePrune(ze)||Zr(ze,Wr))return null;if((ze.eventMode==="dynamic"||Gr==="dynamic")&&(EventsTicker.pauseUpdate=!1),ze.interactiveChildren&&ze.children){const ei=ze.children,ti=Wr;for(let ri=ei.length-1;ri>=0;ri--){const ii=ei[ri],si=this.hitTestRecursive(ii,this._isInteractive(Gr)?Gr:ii.eventMode,ti,Kr,Zr);if(si){if(si.length>0&&!si[si.length-1].parent)continue;const ni=ze.isInteractive();return(si.length>0||ni)&&si.push(ze),si}}}const Qr=this._isInteractive(Gr),Jr=ze.isInteractive();return Qr&&Kr(ze,Wr)?Jr?[ze]:[]:null}_isInteractive(ze){return ze==="static"||ze==="dynamic"}_interactivePrune(ze){return!ze||!ze.visible||!ze.renderable||!ze.measurable||ze.eventMode==="none"||ze.eventMode==="passive"&&!ze.interactiveChildren}hitPruneFn(ze,Gr){if(ze.hitArea&&(ze.worldTransform.applyInverse(Gr,tempLocalMapping),!ze.hitArea.contains(tempLocalMapping.x,tempLocalMapping.y)))return!0;if(ze.effects&&ze.effects.length)for(let Wr=0;Wr<ze.effects.length;Wr++){const Kr=ze.effects[Wr];if(Kr.containsPoint&&!Kr.containsPoint(Gr,this.hitTestFn))return!0}return!1}hitTestFn(ze,Gr){return ze.hitArea?!0:ze!=null&&ze.containsPoint?(ze.worldTransform.applyInverse(Gr,tempLocalMapping),ze.containsPoint(tempLocalMapping)):!1}notifyTarget(ze,Gr){var Zr,Qr;if(!ze.currentTarget.isInteractive())return;Gr??(Gr=ze.type);const Wr=`on${Gr}`;(Qr=(Zr=ze.currentTarget)[Wr])==null||Qr.call(Zr,ze);const Kr=ze.eventPhase===ze.CAPTURING_PHASE||ze.eventPhase===ze.AT_TARGET?`${Gr}capture`:Gr;this._notifyListeners(ze,Kr),ze.eventPhase===ze.AT_TARGET&&this._notifyListeners(ze,Gr)}mapPointerDown(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.createPointerEvent(ze);if(this.dispatchEvent(Gr,"pointerdown"),Gr.pointerType==="touch")this.dispatchEvent(Gr,"touchstart");else if(Gr.pointerType==="mouse"||Gr.pointerType==="pen"){const Kr=Gr.button===2;this.dispatchEvent(Gr,Kr?"rightdown":"mousedown")}const Wr=this.trackingData(ze.pointerId);Wr.pressTargetsByButton[ze.button]=Gr.composedPath(),this.freeEvent(Gr)}mapPointerMove(ze){var ei,ti;if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}this._allInteractiveElements.length=0,this._hitElements.length=0,this._isPointerMoveEvent=!0;const Gr=this.createPointerEvent(ze);this._isPointerMoveEvent=!1;const Wr=Gr.pointerType==="mouse"||Gr.pointerType==="pen",Kr=this.trackingData(ze.pointerId),Zr=this.findMountedTarget(Kr.overTargets);if(((ei=Kr.overTargets)==null?void 0:ei.length)>0&&Zr!==Gr.target){const ri=ze.type==="mousemove"?"mouseout":"pointerout",ii=this.createPointerEvent(ze,ri,Zr);if(this.dispatchEvent(ii,"pointerout"),Wr&&this.dispatchEvent(ii,"mouseout"),!Gr.composedPath().includes(Zr)){const si=this.createPointerEvent(ze,"pointerleave",Zr);for(si.eventPhase=si.AT_TARGET;si.target&&!Gr.composedPath().includes(si.target);)si.currentTarget=si.target,this.notifyTarget(si),Wr&&this.notifyTarget(si,"mouseleave"),si.target=si.target.parent;this.freeEvent(si)}this.freeEvent(ii)}if(Zr!==Gr.target){const ri=ze.type==="mousemove"?"mouseover":"pointerover",ii=this.clonePointerEvent(Gr,ri);this.dispatchEvent(ii,"pointerover"),Wr&&this.dispatchEvent(ii,"mouseover");let si=Zr==null?void 0:Zr.parent;for(;si&&si!==this.rootTarget.parent&&si!==Gr.target;)si=si.parent;if(!si||si===this.rootTarget.parent){const oi=this.clonePointerEvent(Gr,"pointerenter");for(oi.eventPhase=oi.AT_TARGET;oi.target&&oi.target!==Zr&&oi.target!==this.rootTarget.parent;)oi.currentTarget=oi.target,this.notifyTarget(oi),Wr&&this.notifyTarget(oi,"mouseenter"),oi.target=oi.target.parent;this.freeEvent(oi)}this.freeEvent(ii)}const Qr=[],Jr=this.enableGlobalMoveEvents??!0;this.moveOnAll?Qr.push("pointermove"):this.dispatchEvent(Gr,"pointermove"),Jr&&Qr.push("globalpointermove"),Gr.pointerType==="touch"&&(this.moveOnAll?Qr.splice(1,0,"touchmove"):this.dispatchEvent(Gr,"touchmove"),Jr&&Qr.push("globaltouchmove")),Wr&&(this.moveOnAll?Qr.splice(1,0,"mousemove"):this.dispatchEvent(Gr,"mousemove"),Jr&&Qr.push("globalmousemove"),this.cursor=(ti=Gr.target)==null?void 0:ti.cursor),Qr.length>0&&this.all(Gr,Qr),this._allInteractiveElements.length=0,this._hitElements.length=0,Kr.overTargets=Gr.composedPath(),this.freeEvent(Gr)}mapPointerOver(ze){var Qr;if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.trackingData(ze.pointerId),Wr=this.createPointerEvent(ze),Kr=Wr.pointerType==="mouse"||Wr.pointerType==="pen";this.dispatchEvent(Wr,"pointerover"),Kr&&this.dispatchEvent(Wr,"mouseover"),Wr.pointerType==="mouse"&&(this.cursor=(Qr=Wr.target)==null?void 0:Qr.cursor);const Zr=this.clonePointerEvent(Wr,"pointerenter");for(Zr.eventPhase=Zr.AT_TARGET;Zr.target&&Zr.target!==this.rootTarget.parent;)Zr.currentTarget=Zr.target,this.notifyTarget(Zr),Kr&&this.notifyTarget(Zr,"mouseenter"),Zr.target=Zr.target.parent;Gr.overTargets=Wr.composedPath(),this.freeEvent(Wr),this.freeEvent(Zr)}mapPointerOut(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.trackingData(ze.pointerId);if(Gr.overTargets){const Wr=ze.pointerType==="mouse"||ze.pointerType==="pen",Kr=this.findMountedTarget(Gr.overTargets),Zr=this.createPointerEvent(ze,"pointerout",Kr);this.dispatchEvent(Zr),Wr&&this.dispatchEvent(Zr,"mouseout");const Qr=this.createPointerEvent(ze,"pointerleave",Kr);for(Qr.eventPhase=Qr.AT_TARGET;Qr.target&&Qr.target!==this.rootTarget.parent;)Qr.currentTarget=Qr.target,this.notifyTarget(Qr),Wr&&this.notifyTarget(Qr,"mouseleave"),Qr.target=Qr.target.parent;Gr.overTargets=null,this.freeEvent(Zr),this.freeEvent(Qr)}this.cursor=null}mapPointerUp(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=performance.now(),Wr=this.createPointerEvent(ze);if(this.dispatchEvent(Wr,"pointerup"),Wr.pointerType==="touch")this.dispatchEvent(Wr,"touchend");else if(Wr.pointerType==="mouse"||Wr.pointerType==="pen"){const Jr=Wr.button===2;this.dispatchEvent(Wr,Jr?"rightup":"mouseup")}const Kr=this.trackingData(ze.pointerId),Zr=this.findMountedTarget(Kr.pressTargetsByButton[ze.button]);let Qr=Zr;if(Zr&&!Wr.composedPath().includes(Zr)){let Jr=Zr;for(;Jr&&!Wr.composedPath().includes(Jr);){if(Wr.currentTarget=Jr,this.notifyTarget(Wr,"pointerupoutside"),Wr.pointerType==="touch")this.notifyTarget(Wr,"touchendoutside");else if(Wr.pointerType==="mouse"||Wr.pointerType==="pen"){const ei=Wr.button===2;this.notifyTarget(Wr,ei?"rightupoutside":"mouseupoutside")}Jr=Jr.parent}delete Kr.pressTargetsByButton[ze.button],Qr=Jr}if(Qr){const Jr=this.clonePointerEvent(Wr,"click");Jr.target=Qr,Jr.path=null,Kr.clicksByButton[ze.button]||(Kr.clicksByButton[ze.button]={clickCount:0,target:Jr.target,timeStamp:Gr});const ei=Kr.clicksByButton[ze.button];if(ei.target===Jr.target&&Gr-ei.timeStamp<200?++ei.clickCount:ei.clickCount=1,ei.target=Jr.target,ei.timeStamp=Gr,Jr.detail=ei.clickCount,Jr.pointerType==="mouse"){const ti=Jr.button===2;this.dispatchEvent(Jr,ti?"rightclick":"click")}else Jr.pointerType==="touch"&&this.dispatchEvent(Jr,"tap");this.dispatchEvent(Jr,"pointertap"),this.freeEvent(Jr)}this.freeEvent(Wr)}mapPointerUpOutside(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.trackingData(ze.pointerId),Wr=this.findMountedTarget(Gr.pressTargetsByButton[ze.button]),Kr=this.createPointerEvent(ze);if(Wr){let Zr=Wr;for(;Zr;)Kr.currentTarget=Zr,this.notifyTarget(Kr,"pointerupoutside"),Kr.pointerType==="touch"?this.notifyTarget(Kr,"touchendoutside"):(Kr.pointerType==="mouse"||Kr.pointerType==="pen")&&this.notifyTarget(Kr,Kr.button===2?"rightupoutside":"mouseupoutside"),Zr=Zr.parent;delete Gr.pressTargetsByButton[ze.button]}this.freeEvent(Kr)}mapWheel(ze){if(!(ze instanceof FederatedWheelEvent)){warn("EventBoundary cannot map a non-wheel event as a wheel event");return}const Gr=this.createWheelEvent(ze);this.dispatchEvent(Gr),this.freeEvent(Gr)}findMountedTarget(ze){if(!ze)return null;let Gr=ze[0];for(let Wr=1;Wr<ze.length&&ze[Wr].parent===Gr;Wr++)Gr=ze[Wr];return Gr}createPointerEvent(ze,Gr,Wr){const Kr=this.allocateEvent(FederatedPointerEvent);return this.copyPointerData(ze,Kr),this.copyMouseData(ze,Kr),this.copyData(ze,Kr),Kr.nativeEvent=ze.nativeEvent,Kr.originalEvent=ze,Kr.target=Wr??this.hitTest(Kr.global.x,Kr.global.y)??this._hitElements[0],typeof Gr=="string"&&(Kr.type=Gr),Kr}createWheelEvent(ze){const Gr=this.allocateEvent(FederatedWheelEvent);return this.copyWheelData(ze,Gr),this.copyMouseData(ze,Gr),this.copyData(ze,Gr),Gr.nativeEvent=ze.nativeEvent,Gr.originalEvent=ze,Gr.target=this.hitTest(Gr.global.x,Gr.global.y),Gr}clonePointerEvent(ze,Gr){const Wr=this.allocateEvent(FederatedPointerEvent);return Wr.nativeEvent=ze.nativeEvent,Wr.originalEvent=ze.originalEvent,this.copyPointerData(ze,Wr),this.copyMouseData(ze,Wr),this.copyData(ze,Wr),Wr.target=ze.target,Wr.path=ze.composedPath().slice(),Wr.type=Gr??Wr.type,Wr}copyWheelData(ze,Gr){Gr.deltaMode=ze.deltaMode,Gr.deltaX=ze.deltaX,Gr.deltaY=ze.deltaY,Gr.deltaZ=ze.deltaZ}copyPointerData(ze,Gr){ze instanceof FederatedPointerEvent&&Gr instanceof FederatedPointerEvent&&(Gr.pointerId=ze.pointerId,Gr.width=ze.width,Gr.height=ze.height,Gr.isPrimary=ze.isPrimary,Gr.pointerType=ze.pointerType,Gr.pressure=ze.pressure,Gr.tangentialPressure=ze.tangentialPressure,Gr.tiltX=ze.tiltX,Gr.tiltY=ze.tiltY,Gr.twist=ze.twist)}copyMouseData(ze,Gr){ze instanceof FederatedMouseEvent&&Gr instanceof FederatedMouseEvent&&(Gr.altKey=ze.altKey,Gr.button=ze.button,Gr.buttons=ze.buttons,Gr.client.copyFrom(ze.client),Gr.ctrlKey=ze.ctrlKey,Gr.metaKey=ze.metaKey,Gr.movement.copyFrom(ze.movement),Gr.screen.copyFrom(ze.screen),Gr.shiftKey=ze.shiftKey,Gr.global.copyFrom(ze.global))}copyData(ze,Gr){Gr.isTrusted=ze.isTrusted,Gr.srcElement=ze.srcElement,Gr.timeStamp=performance.now(),Gr.type=ze.type,Gr.detail=ze.detail,Gr.view=ze.view,Gr.which=ze.which,Gr.layer.copyFrom(ze.layer),Gr.page.copyFrom(ze.page)}trackingData(ze){return this.mappingState.trackingData[ze]||(this.mappingState.trackingData[ze]={pressTargetsByButton:{},clicksByButton:{},overTarget:null}),this.mappingState.trackingData[ze]}allocateEvent(ze){this.eventPool.has(ze)||this.eventPool.set(ze,[]);const Gr=this.eventPool.get(ze).pop()||new ze(this);return Gr.eventPhase=Gr.NONE,Gr.currentTarget=null,Gr.defaultPrevented=!1,Gr.path=null,Gr.target=null,Gr}freeEvent(ze){if(ze.manager!==this)throw new Error("It is illegal to free an event not managed by this EventBoundary!");const Gr=ze.constructor;this.eventPool.has(Gr)||this.eventPool.set(Gr,[]),this.eventPool.get(Gr).push(ze)}_notifyListeners(ze,Gr){const Wr=ze.currentTarget._events[Gr];if(Wr)if("fn"in Wr)Wr.once&&ze.currentTarget.removeListener(Gr,Wr.fn,void 0,!0),Wr.fn.call(Wr.context,ze);else for(let Kr=0,Zr=Wr.length;Kr<Zr&&!ze.propagationImmediatelyStopped;Kr++)Wr[Kr].once&&ze.currentTarget.removeListener(Gr,Wr[Kr].fn,void 0,!0),Wr[Kr].fn.call(Wr[Kr].context,ze)}}const MOUSE_POINTER_ID=1,TOUCH_TO_POINTER={touchstart:"pointerdown",touchend:"pointerup",touchendoutside:"pointerupoutside",touchmove:"pointermove",touchcancel:"pointercancel"},_EventSystem=class ps{constructor(ze){this.supportsTouchEvents="ontouchstart"in globalThis,this.supportsPointerEvents=!!globalThis.PointerEvent,this.domElement=null,this.resolution=1,this.renderer=ze,this.rootBoundary=new EventBoundary(null),EventsTicker.init(this),this.autoPreventDefault=!0,this._eventsAdded=!1,this._rootPointerEvent=new FederatedPointerEvent(null),this._rootWheelEvent=new FederatedWheelEvent(null),this.cursorStyles={default:"inherit",pointer:"pointer"},this.features=new Proxy({...ps.defaultEventFeatures},{set:(Gr,Wr,Kr)=>(Wr==="globalMove"&&(this.rootBoundary.enableGlobalMoveEvents=Kr),Gr[Wr]=Kr,!0)}),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onPointerOverOut=this._onPointerOverOut.bind(this),this.onWheel=this.onWheel.bind(this)}static get defaultEventMode(){return this._defaultEventMode}init(ze){const{canvas:Gr,resolution:Wr}=this.renderer;this.setTargetElement(Gr),this.resolution=Wr,ps._defaultEventMode=ze.eventMode??"passive",Object.assign(this.features,ze.eventFeatures??{}),this.rootBoundary.enableGlobalMoveEvents=this.features.globalMove}resolutionChange(ze){this.resolution=ze}destroy(){this.setTargetElement(null),this.renderer=null,this._currentCursor=null}setCursor(ze){ze||(ze="default");let Gr=!0;if(globalThis.OffscreenCanvas&&this.domElement instanceof OffscreenCanvas&&(Gr=!1),this._currentCursor===ze)return;this._currentCursor=ze;const Wr=this.cursorStyles[ze];if(Wr)switch(typeof Wr){case"string":Gr&&(this.domElement.style.cursor=Wr);break;case"function":Wr(ze);break;case"object":Gr&&Object.assign(this.domElement.style,Wr);break}else Gr&&typeof ze=="string"&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,ze)&&(this.domElement.style.cursor=ze)}get pointer(){return this._rootPointerEvent}_onPointerDown(ze){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const Gr=this._normalizeToPointerData(ze);this.autoPreventDefault&&Gr[0].isNormalized&&(ze.cancelable||!("cancelable"in ze))&&ze.preventDefault();for(let Wr=0,Kr=Gr.length;Wr<Kr;Wr++){const Zr=Gr[Wr],Qr=this._bootstrapEvent(this._rootPointerEvent,Zr);this.rootBoundary.mapEvent(Qr)}this.setCursor(this.rootBoundary.cursor)}_onPointerMove(ze){if(!this.features.move)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,EventsTicker.pointerMoved();const Gr=this._normalizeToPointerData(ze);for(let Wr=0,Kr=Gr.length;Wr<Kr;Wr++){const Zr=this._bootstrapEvent(this._rootPointerEvent,Gr[Wr]);this.rootBoundary.mapEvent(Zr)}this.setCursor(this.rootBoundary.cursor)}_onPointerUp(ze){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;let Gr=ze.target;ze.composedPath&&ze.composedPath().length>0&&(Gr=ze.composedPath()[0]);const Wr=Gr!==this.domElement?"outside":"",Kr=this._normalizeToPointerData(ze);for(let Zr=0,Qr=Kr.length;Zr<Qr;Zr++){const Jr=this._bootstrapEvent(this._rootPointerEvent,Kr[Zr]);Jr.type+=Wr,this.rootBoundary.mapEvent(Jr)}this.setCursor(this.rootBoundary.cursor)}_onPointerOverOut(ze){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const Gr=this._normalizeToPointerData(ze);for(let Wr=0,Kr=Gr.length;Wr<Kr;Wr++){const Zr=this._bootstrapEvent(this._rootPointerEvent,Gr[Wr]);this.rootBoundary.mapEvent(Zr)}this.setCursor(this.rootBoundary.cursor)}onWheel(ze){if(!this.features.wheel)return;const Gr=this.normalizeWheelEvent(ze);this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,this.rootBoundary.mapEvent(Gr)}setTargetElement(ze){this._removeEvents(),this.domElement=ze,EventsTicker.domElement=ze,this._addEvents()}_addEvents(){if(this._eventsAdded||!this.domElement)return;EventsTicker.addTickerListener();const ze=this.domElement.style;ze&&(globalThis.navigator.msPointerEnabled?(ze.msContentZooming="none",ze.msTouchAction="none"):this.supportsPointerEvents&&(ze.touchAction="none")),this.supportsPointerEvents?(globalThis.document.addEventListener("pointermove",this._onPointerMove,!0),this.domElement.addEventListener("pointerdown",this._onPointerDown,!0),this.domElement.addEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.addEventListener("pointerover",this._onPointerOverOut,!0),globalThis.addEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.addEventListener("mousemove",this._onPointerMove,!0),this.domElement.addEventListener("mousedown",this._onPointerDown,!0),this.domElement.addEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.addEventListener("mouseover",this._onPointerOverOut,!0),globalThis.addEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.addEventListener("touchstart",this._onPointerDown,!0),this.domElement.addEventListener("touchend",this._onPointerUp,!0),this.domElement.addEventListener("touchmove",this._onPointerMove,!0))),this.domElement.addEventListener("wheel",this.onWheel,{passive:!0,capture:!0}),this._eventsAdded=!0}_removeEvents(){if(!this._eventsAdded||!this.domElement)return;EventsTicker.removeTickerListener();const ze=this.domElement.style;ze&&(globalThis.navigator.msPointerEnabled?(ze.msContentZooming="",ze.msTouchAction=""):this.supportsPointerEvents&&(ze.touchAction="")),this.supportsPointerEvents?(globalThis.document.removeEventListener("pointermove",this._onPointerMove,!0),this.domElement.removeEventListener("pointerdown",this._onPointerDown,!0),this.domElement.removeEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.removeEventListener("pointerover",this._onPointerOverOut,!0),globalThis.removeEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.removeEventListener("mousemove",this._onPointerMove,!0),this.domElement.removeEventListener("mousedown",this._onPointerDown,!0),this.domElement.removeEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.removeEventListener("mouseover",this._onPointerOverOut,!0),globalThis.removeEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.removeEventListener("touchstart",this._onPointerDown,!0),this.domElement.removeEventListener("touchend",this._onPointerUp,!0),this.domElement.removeEventListener("touchmove",this._onPointerMove,!0))),this.domElement.removeEventListener("wheel",this.onWheel,!0),this.domElement=null,this._eventsAdded=!1}mapPositionToPoint(ze,Gr,Wr){const Kr=this.domElement.isConnected?this.domElement.getBoundingClientRect():{width:this.domElement.width,height:this.domElement.height,left:0,top:0},Zr=1/this.resolution;ze.x=(Gr-Kr.left)*(this.domElement.width/Kr.width)*Zr,ze.y=(Wr-Kr.top)*(this.domElement.height/Kr.height)*Zr}_normalizeToPointerData(ze){const Gr=[];if(this.supportsTouchEvents&&ze instanceof TouchEvent)for(let Wr=0,Kr=ze.changedTouches.length;Wr<Kr;Wr++){const Zr=ze.changedTouches[Wr];typeof Zr.button>"u"&&(Zr.button=0),typeof Zr.buttons>"u"&&(Zr.buttons=1),typeof Zr.isPrimary>"u"&&(Zr.isPrimary=ze.touches.length===1&&ze.type==="touchstart"),typeof Zr.width>"u"&&(Zr.width=Zr.radiusX||1),typeof Zr.height>"u"&&(Zr.height=Zr.radiusY||1),typeof Zr.tiltX>"u"&&(Zr.tiltX=0),typeof Zr.tiltY>"u"&&(Zr.tiltY=0),typeof Zr.pointerType>"u"&&(Zr.pointerType="touch"),typeof Zr.pointerId>"u"&&(Zr.pointerId=Zr.identifier||0),typeof Zr.pressure>"u"&&(Zr.pressure=Zr.force||.5),typeof Zr.twist>"u"&&(Zr.twist=0),typeof Zr.tangentialPressure>"u"&&(Zr.tangentialPressure=0),typeof Zr.layerX>"u"&&(Zr.layerX=Zr.offsetX=Zr.clientX),typeof Zr.layerY>"u"&&(Zr.layerY=Zr.offsetY=Zr.clientY),Zr.isNormalized=!0,Zr.type=ze.type,Gr.push(Zr)}else if(!globalThis.MouseEvent||ze instanceof MouseEvent&&(!this.supportsPointerEvents||!(ze instanceof globalThis.PointerEvent))){const Wr=ze;typeof Wr.isPrimary>"u"&&(Wr.isPrimary=!0),typeof Wr.width>"u"&&(Wr.width=1),typeof Wr.height>"u"&&(Wr.height=1),typeof Wr.tiltX>"u"&&(Wr.tiltX=0),typeof Wr.tiltY>"u"&&(Wr.tiltY=0),typeof Wr.pointerType>"u"&&(Wr.pointerType="mouse"),typeof Wr.pointerId>"u"&&(Wr.pointerId=MOUSE_POINTER_ID),typeof Wr.pressure>"u"&&(Wr.pressure=.5),typeof Wr.twist>"u"&&(Wr.twist=0),typeof Wr.tangentialPressure>"u"&&(Wr.tangentialPressure=0),Wr.isNormalized=!0,Gr.push(Wr)}else Gr.push(ze);return Gr}normalizeWheelEvent(ze){const Gr=this._rootWheelEvent;return this._transferMouseData(Gr,ze),Gr.deltaX=ze.deltaX,Gr.deltaY=ze.deltaY,Gr.deltaZ=ze.deltaZ,Gr.deltaMode=ze.deltaMode,this.mapPositionToPoint(Gr.screen,ze.clientX,ze.clientY),Gr.global.copyFrom(Gr.screen),Gr.offset.copyFrom(Gr.screen),Gr.nativeEvent=ze,Gr.type=ze.type,Gr}_bootstrapEvent(ze,Gr){return ze.originalEvent=null,ze.nativeEvent=Gr,ze.pointerId=Gr.pointerId,ze.width=Gr.width,ze.height=Gr.height,ze.isPrimary=Gr.isPrimary,ze.pointerType=Gr.pointerType,ze.pressure=Gr.pressure,ze.tangentialPressure=Gr.tangentialPressure,ze.tiltX=Gr.tiltX,ze.tiltY=Gr.tiltY,ze.twist=Gr.twist,this._transferMouseData(ze,Gr),this.mapPositionToPoint(ze.screen,Gr.clientX,Gr.clientY),ze.global.copyFrom(ze.screen),ze.offset.copyFrom(ze.screen),ze.isTrusted=Gr.isTrusted,ze.type==="pointerleave"&&(ze.type="pointerout"),ze.type.startsWith("mouse")&&(ze.type=ze.type.replace("mouse","pointer")),ze.type.startsWith("touch")&&(ze.type=TOUCH_TO_POINTER[ze.type]||ze.type),ze}_transferMouseData(ze,Gr){ze.isTrusted=Gr.isTrusted,ze.srcElement=Gr.srcElement,ze.timeStamp=performance.now(),ze.type=Gr.type,ze.altKey=Gr.altKey,ze.button=Gr.button,ze.buttons=Gr.buttons,ze.client.x=Gr.clientX,ze.client.y=Gr.clientY,ze.ctrlKey=Gr.ctrlKey,ze.metaKey=Gr.metaKey,ze.movement.x=Gr.movementX,ze.movement.y=Gr.movementY,ze.page.x=Gr.pageX,ze.page.y=Gr.pageY,ze.relatedTarget=null,ze.shiftKey=Gr.shiftKey}};_EventSystem.extension={name:"events",type:[ExtensionType.WebGLSystem,ExtensionType.CanvasSystem,ExtensionType.WebGPUSystem],priority:-1};_EventSystem.defaultEventFeatures={move:!0,globalMove:!0,click:!0,wheel:!0};let EventSystem=_EventSystem;const FederatedContainer={onclick:null,onmousedown:null,onmouseenter:null,onmouseleave:null,onmousemove:null,onglobalmousemove:null,onmouseout:null,onmouseover:null,onmouseup:null,onmouseupoutside:null,onpointercancel:null,onpointerdown:null,onpointerenter:null,onpointerleave:null,onpointermove:null,onglobalpointermove:null,onpointerout:null,onpointerover:null,onpointertap:null,onpointerup:null,onpointerupoutside:null,onrightclick:null,onrightdown:null,onrightup:null,onrightupoutside:null,ontap:null,ontouchcancel:null,ontouchend:null,ontouchendoutside:null,ontouchmove:null,onglobaltouchmove:null,ontouchstart:null,onwheel:null,get interactive(){return this.eventMode==="dynamic"||this.eventMode==="static"},set interactive(Yr){this.eventMode=Yr?"static":"passive"},_internalEventMode:void 0,get eventMode(){return this._internalEventMode??EventSystem.defaultEventMode},set eventMode(Yr){this._internalEventMode=Yr},isInteractive(){return this.eventMode==="static"||this.eventMode==="dynamic"},interactiveChildren:!0,hitArea:null,addEventListener(Yr,ze,Gr){const Wr=typeof Gr=="boolean"&&Gr||typeof Gr=="object"&&Gr.capture,Kr=typeof Gr=="object"?Gr.signal:void 0,Zr=typeof Gr=="object"?Gr.once===!0:!1,Qr=typeof ze=="function"?void 0:ze;Yr=Wr?`${Yr}capture`:Yr;const Jr=typeof ze=="function"?ze:ze.handleEvent,ei=this;Kr&&Kr.addEventListener("abort",()=>{ei.off(Yr,Jr,Qr)}),Zr?ei.once(Yr,Jr,Qr):ei.on(Yr,Jr,Qr)},removeEventListener(Yr,ze,Gr){const Wr=typeof Gr=="boolean"&&Gr||typeof Gr=="object"&&Gr.capture,Kr=typeof ze=="function"?void 0:ze;Yr=Wr?`${Yr}capture`:Yr,ze=typeof ze=="function"?ze:ze.handleEvent,this.off(Yr,ze,Kr)},dispatchEvent(Yr){if(!(Yr instanceof FederatedEvent))throw new Error("Container cannot propagate events outside of the Federated Events API");return Yr.defaultPrevented=!1,Yr.path=null,Yr.target=this,Yr.manager.dispatchEvent(Yr),!Yr.defaultPrevented}};var vertex$2=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,fragment$2=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uColorMatrix[20];
uniform float uAlpha;

uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;

    if (uAlpha == 0.0) {
        finalColor = color;
        return;
    }

    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    vec4 result;

    result.r = (uColorMatrix[0] * color.r);
        result.r += (uColorMatrix[1] * color.g);
        result.r += (uColorMatrix[2] * color.b);
        result.r += (uColorMatrix[3] * color.a);
        result.r += uColorMatrix[4];

    result.g = (uColorMatrix[5] * color.r);
        result.g += (uColorMatrix[6] * color.g);
        result.g += (uColorMatrix[7] * color.b);
        result.g += (uColorMatrix[8] * color.a);
        result.g += uColorMatrix[9];

    result.b = (uColorMatrix[10] * color.r);
       result.b += (uColorMatrix[11] * color.g);
       result.b += (uColorMatrix[12] * color.b);
       result.b += (uColorMatrix[13] * color.a);
       result.b += uColorMatrix[14];

    result.a = (uColorMatrix[15] * color.r);
       result.a += (uColorMatrix[16] * color.g);
       result.a += (uColorMatrix[17] * color.b);
       result.a += (uColorMatrix[18] * color.a);
       result.a += uColorMatrix[19];

    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    finalColor = vec4(rgb, result.a);
}
`,source$1=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct ColorMatrixUniforms {
  uColorMatrix:array<vec4<f32>, 5>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;
@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
  };
  
fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
  );
}


@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {


  var c = textureSample(uTexture, uSampler, uv);
  
  if (colorMatrixUniforms.uAlpha == 0.0) {
    return c;
  }

 
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.r /= c.a;
      c.g /= c.a;
      c.b /= c.a;
    }

    var cm = colorMatrixUniforms.uColorMatrix;


    var result = vec4<f32>(0.);

    result.r = (cm[0][0] * c.r);
    result.r += (cm[0][1] * c.g);
    result.r += (cm[0][2] * c.b);
    result.r += (cm[0][3] * c.a);
    result.r += cm[1][0];

    result.g = (cm[1][1] * c.r);
    result.g += (cm[1][2] * c.g);
    result.g += (cm[1][3] * c.b);
    result.g += (cm[2][0] * c.a);
    result.g += cm[2][1];

    result.b = (cm[2][2] * c.r);
    result.b += (cm[2][3] * c.g);
    result.b += (cm[3][0] * c.b);
    result.b += (cm[3][1] * c.a);
    result.b += cm[3][2];

    result.a = (cm[3][3] * c.r);
    result.a += (cm[4][0] * c.g);
    result.a += (cm[4][1] * c.b);
    result.a += (cm[4][2] * c.a);
    result.a += cm[4][3];

    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);

    rgb.r *= result.a;
    rgb.g *= result.a;
    rgb.b *= result.a;

    return vec4(rgb, result.a);
}`;class ColorMatrixFilter extends Filter{constructor(ze={}){const Gr=new UniformGroup({uColorMatrix:{value:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],type:"f32",size:20},uAlpha:{value:1,type:"f32"}}),Wr=GpuProgram.from({vertex:{source:source$1,entryPoint:"mainVertex"},fragment:{source:source$1,entryPoint:"mainFragment"}}),Kr=GlProgram.from({vertex:vertex$2,fragment:fragment$2,name:"color-matrix-filter"});super({...ze,gpuProgram:Wr,glProgram:Kr,resources:{colorMatrixUniforms:Gr}}),this.alpha=1}_loadMatrix(ze,Gr=!1){let Wr=ze;Gr&&(this._multiply(Wr,this.matrix,ze),Wr=this._colorMatrix(Wr)),this.resources.colorMatrixUniforms.uniforms.uColorMatrix=Wr,this.resources.colorMatrixUniforms.update()}_multiply(ze,Gr,Wr){return ze[0]=Gr[0]*Wr[0]+Gr[1]*Wr[5]+Gr[2]*Wr[10]+Gr[3]*Wr[15],ze[1]=Gr[0]*Wr[1]+Gr[1]*Wr[6]+Gr[2]*Wr[11]+Gr[3]*Wr[16],ze[2]=Gr[0]*Wr[2]+Gr[1]*Wr[7]+Gr[2]*Wr[12]+Gr[3]*Wr[17],ze[3]=Gr[0]*Wr[3]+Gr[1]*Wr[8]+Gr[2]*Wr[13]+Gr[3]*Wr[18],ze[4]=Gr[0]*Wr[4]+Gr[1]*Wr[9]+Gr[2]*Wr[14]+Gr[3]*Wr[19]+Gr[4],ze[5]=Gr[5]*Wr[0]+Gr[6]*Wr[5]+Gr[7]*Wr[10]+Gr[8]*Wr[15],ze[6]=Gr[5]*Wr[1]+Gr[6]*Wr[6]+Gr[7]*Wr[11]+Gr[8]*Wr[16],ze[7]=Gr[5]*Wr[2]+Gr[6]*Wr[7]+Gr[7]*Wr[12]+Gr[8]*Wr[17],ze[8]=Gr[5]*Wr[3]+Gr[6]*Wr[8]+Gr[7]*Wr[13]+Gr[8]*Wr[18],ze[9]=Gr[5]*Wr[4]+Gr[6]*Wr[9]+Gr[7]*Wr[14]+Gr[8]*Wr[19]+Gr[9],ze[10]=Gr[10]*Wr[0]+Gr[11]*Wr[5]+Gr[12]*Wr[10]+Gr[13]*Wr[15],ze[11]=Gr[10]*Wr[1]+Gr[11]*Wr[6]+Gr[12]*Wr[11]+Gr[13]*Wr[16],ze[12]=Gr[10]*Wr[2]+Gr[11]*Wr[7]+Gr[12]*Wr[12]+Gr[13]*Wr[17],ze[13]=Gr[10]*Wr[3]+Gr[11]*Wr[8]+Gr[12]*Wr[13]+Gr[13]*Wr[18],ze[14]=Gr[10]*Wr[4]+Gr[11]*Wr[9]+Gr[12]*Wr[14]+Gr[13]*Wr[19]+Gr[14],ze[15]=Gr[15]*Wr[0]+Gr[16]*Wr[5]+Gr[17]*Wr[10]+Gr[18]*Wr[15],ze[16]=Gr[15]*Wr[1]+Gr[16]*Wr[6]+Gr[17]*Wr[11]+Gr[18]*Wr[16],ze[17]=Gr[15]*Wr[2]+Gr[16]*Wr[7]+Gr[17]*Wr[12]+Gr[18]*Wr[17],ze[18]=Gr[15]*Wr[3]+Gr[16]*Wr[8]+Gr[17]*Wr[13]+Gr[18]*Wr[18],ze[19]=Gr[15]*Wr[4]+Gr[16]*Wr[9]+Gr[17]*Wr[14]+Gr[18]*Wr[19]+Gr[19],ze}_colorMatrix(ze){const Gr=new Float32Array(ze);return Gr[4]/=255,Gr[9]/=255,Gr[14]/=255,Gr[19]/=255,Gr}brightness(ze,Gr){const Wr=[ze,0,0,0,0,0,ze,0,0,0,0,0,ze,0,0,0,0,0,1,0];this._loadMatrix(Wr,Gr)}tint(ze,Gr){const[Wr,Kr,Zr]=Color.shared.setValue(ze).toArray(),Qr=[Wr,0,0,0,0,0,Kr,0,0,0,0,0,Zr,0,0,0,0,0,1,0];this._loadMatrix(Qr,Gr)}greyscale(ze,Gr){const Wr=[ze,ze,ze,0,0,ze,ze,ze,0,0,ze,ze,ze,0,0,0,0,0,1,0];this._loadMatrix(Wr,Gr)}grayscale(ze,Gr){this.greyscale(ze,Gr)}blackAndWhite(ze){const Gr=[.3,.6,.1,0,0,.3,.6,.1,0,0,.3,.6,.1,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}hue(ze,Gr){ze=(ze||0)/180*Math.PI;const Wr=Math.cos(ze),Kr=Math.sin(ze),Zr=Math.sqrt,Qr=1/3,Jr=Zr(Qr),ei=Wr+(1-Wr)*Qr,ti=Qr*(1-Wr)-Jr*Kr,ri=Qr*(1-Wr)+Jr*Kr,ii=Qr*(1-Wr)+Jr*Kr,si=Wr+Qr*(1-Wr),ni=Qr*(1-Wr)-Jr*Kr,oi=Qr*(1-Wr)-Jr*Kr,li=Qr*(1-Wr)+Jr*Kr,ai=Wr+Qr*(1-Wr),hi=[ei,ti,ri,0,0,ii,si,ni,0,0,oi,li,ai,0,0,0,0,0,1,0];this._loadMatrix(hi,Gr)}contrast(ze,Gr){const Wr=(ze||0)+1,Kr=-.5*(Wr-1),Zr=[Wr,0,0,0,Kr,0,Wr,0,0,Kr,0,0,Wr,0,Kr,0,0,0,1,0];this._loadMatrix(Zr,Gr)}saturate(ze=0,Gr){const Wr=ze*2/3+1,Kr=(Wr-1)*-.5,Zr=[Wr,Kr,Kr,0,0,Kr,Wr,Kr,0,0,Kr,Kr,Wr,0,0,0,0,0,1,0];this._loadMatrix(Zr,Gr)}desaturate(){this.saturate(-1)}negative(ze){const Gr=[-1,0,0,1,0,0,-1,0,1,0,0,0,-1,1,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}sepia(ze){const Gr=[.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}technicolor(ze){const Gr=[1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0];this._loadMatrix(Gr,ze)}polaroid(ze){const Gr=[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}toBGR(ze){const Gr=[0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}kodachrome(ze){const Gr=[1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0];this._loadMatrix(Gr,ze)}browni(ze){const Gr=[.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0];this._loadMatrix(Gr,ze)}vintage(ze){const Gr=[.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0];this._loadMatrix(Gr,ze)}colorTone(ze,Gr,Wr,Kr,Zr){ze||(ze=.2),Gr||(Gr=.15),Wr||(Wr=16770432),Kr||(Kr=3375104);const Qr=Color.shared,[Jr,ei,ti]=Qr.setValue(Wr).toArray(),[ri,ii,si]=Qr.setValue(Kr).toArray(),ni=[.3,.59,.11,0,0,Jr,ei,ti,ze,0,ri,ii,si,Gr,0,Jr-ri,ei-ii,ti-si,0,0];this._loadMatrix(ni,Zr)}night(ze,Gr){ze||(ze=.1);const Wr=[ze*-2,-ze,0,0,0,-ze,0,ze,0,0,0,ze,ze*2,0,0,0,0,0,1,0];this._loadMatrix(Wr,Gr)}predator(ze,Gr){const Wr=[11.224130630493164*ze,-4.794486999511719*ze,-2.8746118545532227*ze,0*ze,.40342438220977783*ze,-3.6330697536468506*ze,9.193157196044922*ze,-2.951810836791992*ze,0*ze,-1.316135048866272*ze,-3.2184197902679443*ze,-4.2375030517578125*ze,7.476448059082031*ze,0*ze,.8044459223747253*ze,0,0,0,1,0];this._loadMatrix(Wr,Gr)}lsd(ze){const Gr=[2,-.4,.5,0,0,-.5,2,-.4,0,0,-.4,-.5,3,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}reset(){const ze=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];this._loadMatrix(ze,!1)}get matrix(){return this.resources.colorMatrixUniforms.uniforms.uColorMatrix}set matrix(ze){this.resources.colorMatrixUniforms.uniforms.uColorMatrix=ze}get alpha(){return this.resources.colorMatrixUniforms.uniforms.uAlpha}set alpha(ze){this.resources.colorMatrixUniforms.uniforms.uAlpha=ze}}class FilterPipe{constructor(ze){this._renderer=ze}push(ze,Gr,Wr){this._renderer.renderPipes.batch.break(Wr),Wr.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:Gr,filterEffect:ze})}pop(ze,Gr,Wr){this._renderer.renderPipes.batch.break(Wr),Wr.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(ze){ze.action==="pushFilter"?this._renderer.filter.push(ze):ze.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"filter"};function getGlobalRenderableBounds(Yr,ze){ze.clear();const Gr=ze.matrix;for(let Wr=0;Wr<Yr.length;Wr++){const Kr=Yr[Wr];Kr.globalDisplayStatus<7||(ze.matrix=Kr.worldTransform,ze.addBounds(Kr.bounds))}return ze.matrix=Gr,ze}const quadGeometry=new Geometry({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterSystem{constructor(ze){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup({}),this.renderer=ze}get activeBackTexture(){var ze;return(ze=this._activeFilterData)==null?void 0:ze.backTexture}push(ze){var ni;const Gr=this.renderer,Wr=ze.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const Kr=this._filterStack[this._filterStackIndex];if(this._filterStackIndex++,Wr.length===0){Kr.skip=!0;return}const Zr=Kr.bounds;if(ze.renderables?getGlobalRenderableBounds(ze.renderables,Zr):ze.filterEffect.filterArea?(Zr.clear(),Zr.addRect(ze.filterEffect.filterArea),Zr.applyMatrix(ze.container.worldTransform)):ze.container.getFastGlobalBounds(!0,Zr),ze.container){const li=(ze.container.renderGroup||ze.container.parentRenderGroup).cacheToLocalTransform;li&&Zr.applyMatrix(li)}const Qr=Gr.renderTarget.renderTarget.colorTexture.source;let Jr=1/0,ei=0,ti=!0,ri=!1,ii=!1,si=!0;for(let oi=0;oi<Wr.length;oi++){const li=Wr[oi];if(Jr=Math.min(Jr,li.resolution==="inherit"?Qr._resolution:li.resolution),ei+=li.padding,li.antialias==="off"?ti=!1:li.antialias==="inherit"&&ti&&(ti=Qr.antialias),li.clipToViewport||(si=!1),!!!(li.compatibleRenderers&Gr.type)){ii=!1;break}if(li.blendRequired&&!(((ni=Gr.backBuffer)==null?void 0:ni.useBackBuffer)??!0)){warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),ii=!1;break}ii=li.enabled||ii,ri||(ri=li.blendRequired)}if(!ii){Kr.skip=!0;return}if(si){const oi=Gr.renderTarget.rootViewPort,li=Gr.renderTarget.renderTarget.resolution;Zr.fitBounds(0,oi.width/li,0,oi.height/li)}if(Zr.scale(Jr).ceil().scale(1/Jr).pad(ei|0),!Zr.isPositive){Kr.skip=!0;return}Kr.skip=!1,Kr.bounds=Zr,Kr.blendRequired=ri,Kr.container=ze.container,Kr.filterEffect=ze.filterEffect,Kr.previousRenderSurface=Gr.renderTarget.renderSurface,Kr.inputTexture=TexturePool.getOptimalTexture(Zr.width,Zr.height,Jr,ti),Gr.renderTarget.bind(Kr.inputTexture,!0),Gr.globalUniforms.push({offset:Zr})}pop(){const ze=this.renderer;this._filterStackIndex--;const Gr=this._filterStack[this._filterStackIndex];if(Gr.skip)return;this._activeFilterData=Gr;const Wr=Gr.inputTexture,Kr=Gr.bounds;let Zr=Texture.EMPTY;if(ze.renderTarget.finishRenderPass(),Gr.blendRequired){const Jr=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null,ei=ze.renderTarget.getRenderTarget(Gr.previousRenderSurface);Zr=this.getBackTexture(ei,Kr,Jr)}Gr.backTexture=Zr;const Qr=Gr.filterEffect.filters;if(this._globalFilterBindGroup.setResource(Wr.source.style,2),this._globalFilterBindGroup.setResource(Zr.source,3),ze.globalUniforms.pop(),Qr.length===1)Qr[0].apply(this,Wr,Gr.previousRenderSurface,!1),TexturePool.returnTexture(Wr);else{let Jr=Gr.inputTexture,ei=TexturePool.getOptimalTexture(Kr.width,Kr.height,Jr.source._resolution,!1),ti=0;for(ti=0;ti<Qr.length-1;++ti){Qr[ti].apply(this,Jr,ei,!0);const ii=Jr;Jr=ei,ei=ii}Qr[ti].apply(this,Jr,Gr.previousRenderSurface,!1),TexturePool.returnTexture(Jr),TexturePool.returnTexture(ei)}Gr.blendRequired&&TexturePool.returnTexture(Zr)}getBackTexture(ze,Gr,Wr){const Kr=ze.colorTexture.source._resolution,Zr=TexturePool.getOptimalTexture(Gr.width,Gr.height,Kr,!1);let Qr=Gr.minX,Jr=Gr.minY;Wr&&(Qr-=Wr.minX,Jr-=Wr.minY),Qr=Math.floor(Qr*Kr),Jr=Math.floor(Jr*Kr);const ei=Math.ceil(Gr.width*Kr),ti=Math.ceil(Gr.height*Kr);return this.renderer.renderTarget.copyToTexture(ze,Zr,{x:Qr,y:Jr},{width:ei,height:ti},{x:0,y:0}),Zr}applyFilter(ze,Gr,Wr,Kr){const Zr=this.renderer,Qr=this._filterStack[this._filterStackIndex],Jr=Qr.bounds,ei=Point$1.shared,ri=Qr.previousRenderSurface===Wr;let ii=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,si=this._filterStackIndex-1;for(;si>0&&this._filterStack[si].skip;)--si;si>0&&(ii=this._filterStack[si].inputTexture.source._resolution);const ni=this._filterGlobalUniforms,oi=ni.uniforms,li=oi.uOutputFrame,ai=oi.uInputSize,hi=oi.uInputPixel,fi=oi.uInputClamp,pi=oi.uGlobalFrame,mi=oi.uOutputTexture;if(ri){let _i=this._filterStackIndex;for(;_i>0;){_i--;const Ai=this._filterStack[this._filterStackIndex-1];if(!Ai.skip){ei.x=Ai.bounds.minX,ei.y=Ai.bounds.minY;break}}li[0]=Jr.minX-ei.x,li[1]=Jr.minY-ei.y}else li[0]=0,li[1]=0;li[2]=Gr.frame.width,li[3]=Gr.frame.height,ai[0]=Gr.source.width,ai[1]=Gr.source.height,ai[2]=1/ai[0],ai[3]=1/ai[1],hi[0]=Gr.source.pixelWidth,hi[1]=Gr.source.pixelHeight,hi[2]=1/hi[0],hi[3]=1/hi[1],fi[0]=.5*hi[2],fi[1]=.5*hi[3],fi[2]=Gr.frame.width*ai[2]-.5*hi[2],fi[3]=Gr.frame.height*ai[3]-.5*hi[3];const Ti=this.renderer.renderTarget.rootRenderTarget.colorTexture;pi[0]=ei.x*ii,pi[1]=ei.y*ii,pi[2]=Ti.source.width*ii,pi[3]=Ti.source.height*ii;const yi=this.renderer.renderTarget.getRenderTarget(Wr);if(Zr.renderTarget.bind(Wr,!!Kr),Wr instanceof Texture?(mi[0]=Wr.frame.width,mi[1]=Wr.frame.height):(mi[0]=yi.width,mi[1]=yi.height),mi[2]=yi.isRoot?-1:1,ni.update(),Zr.renderPipes.uniformBatch){const _i=Zr.renderPipes.uniformBatch.getUboResource(ni);this._globalFilterBindGroup.setResource(_i,0)}else this._globalFilterBindGroup.setResource(ni,0);this._globalFilterBindGroup.setResource(Gr.source,1),this._globalFilterBindGroup.setResource(Gr.source.style,2),ze.groups[0]=this._globalFilterBindGroup,Zr.encoder.draw({geometry:quadGeometry,shader:ze,state:ze._state,topology:"triangle-list"}),Zr.type===RendererType.WEBGL&&Zr.renderTarget.finishRenderPass()}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Bounds,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(ze,Gr){const Wr=this._activeFilterData,Kr=ze.set(Wr.inputTexture._source.width,0,0,Wr.inputTexture._source.height,Wr.bounds.minX,Wr.bounds.minY),Zr=Gr.worldTransform.copyTo(Matrix.shared),Qr=Gr.renderGroup||Gr.parentRenderGroup;return Qr&&Qr.cacheToLocalTransform&&Zr.prepend(Qr.cacheToLocalTransform),Zr.invert(),Kr.prepend(Zr),Kr.scale(1/Gr.texture.frame.width,1/Gr.texture.frame.height),Kr.translate(Gr.anchor.x,Gr.anchor.y),Kr}}FilterSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"filter"};var fragment$1=`in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,vertex$1=`in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,source=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;class MaskFilter extends Filter{constructor(ze){const{sprite:Gr,...Wr}=ze,Kr=new TextureMatrix(Gr.texture),Zr=new UniformGroup({uFilterMatrix:{value:new Matrix,type:"mat3x3<f32>"},uMaskClamp:{value:Kr.uClampFrame,type:"vec4<f32>"},uAlpha:{value:1,type:"f32"},uInverse:{value:ze.inverse?1:0,type:"f32"}}),Qr=GpuProgram.from({vertex:{source,entryPoint:"mainVertex"},fragment:{source,entryPoint:"mainFragment"}}),Jr=GlProgram.from({vertex:vertex$1,fragment:fragment$1,name:"mask-filter"});super({...Wr,gpuProgram:Qr,glProgram:Jr,resources:{filterUniforms:Zr,uMaskTexture:Gr.texture.source}}),this.sprite=Gr,this._textureMatrix=Kr}set inverse(ze){this.resources.filterUniforms.uniforms.uInverse=ze?1:0}get inverse(){return this.resources.filterUniforms.uniforms.uInverse===1}apply(ze,Gr,Wr,Kr){this._textureMatrix.texture=this.sprite.texture,ze.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.uMaskTexture=this.sprite.texture.source,ze.applyFilter(this,Gr,Wr,Kr)}}class Graphics extends ViewContainer{constructor(ze){ze instanceof GraphicsContext&&(ze={context:ze});const{context:Gr,roundPixels:Wr,...Kr}=ze||{};super({label:"Graphics",...Kr}),this.renderPipeId="graphics",Gr?this._context=Gr:this._context=this._ownedContext=new GraphicsContext,this._context.on("update",this.onViewUpdate,this),this.allowChildren=!1,this.roundPixels=Wr??!1}set context(ze){ze!==this._context&&(this._context.off("update",this.onViewUpdate,this),this._context=ze,this._context.on("update",this.onViewUpdate,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}updateBounds(){}containsPoint(ze){return this._context.containsPoint(ze)}destroy(ze){this._ownedContext&&!ze?this._ownedContext.destroy(ze):(ze===!0||(ze==null?void 0:ze.context)===!0)&&this._context.destroy(ze),this._ownedContext=null,this._context=null,super.destroy(ze)}_callContextMethod(ze,Gr){return this.context[ze](...Gr),this}setFillStyle(...ze){return this._callContextMethod("setFillStyle",ze)}setStrokeStyle(...ze){return this._callContextMethod("setStrokeStyle",ze)}fill(...ze){return this._callContextMethod("fill",ze)}stroke(...ze){return this._callContextMethod("stroke",ze)}texture(...ze){return this._callContextMethod("texture",ze)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...ze){return this._callContextMethod("arc",ze)}arcTo(...ze){return this._callContextMethod("arcTo",ze)}arcToSvg(...ze){return this._callContextMethod("arcToSvg",ze)}bezierCurveTo(...ze){return this._callContextMethod("bezierCurveTo",ze)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...ze){return this._callContextMethod("ellipse",ze)}circle(...ze){return this._callContextMethod("circle",ze)}path(...ze){return this._callContextMethod("path",ze)}lineTo(...ze){return this._callContextMethod("lineTo",ze)}moveTo(...ze){return this._callContextMethod("moveTo",ze)}quadraticCurveTo(...ze){return this._callContextMethod("quadraticCurveTo",ze)}rect(...ze){return this._callContextMethod("rect",ze)}roundRect(...ze){return this._callContextMethod("roundRect",ze)}poly(...ze){return this._callContextMethod("poly",ze)}regularPoly(...ze){return this._callContextMethod("regularPoly",ze)}roundPoly(...ze){return this._callContextMethod("roundPoly",ze)}roundShape(...ze){return this._callContextMethod("roundShape",ze)}filletRect(...ze){return this._callContextMethod("filletRect",ze)}chamferRect(...ze){return this._callContextMethod("chamferRect",ze)}star(...ze){return this._callContextMethod("star",ze)}svg(...ze){return this._callContextMethod("svg",ze)}restore(...ze){return this._callContextMethod("restore",ze)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...ze){return this._callContextMethod("rotate",ze)}scaleTransform(...ze){return this._callContextMethod("scale",ze)}setTransform(...ze){return this._callContextMethod("setTransform",ze)}transform(...ze){return this._callContextMethod("transform",ze)}translateTransform(...ze){return this._callContextMethod("translate",ze)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(ze){this._context.fillStyle=ze}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(ze){this._context.strokeStyle=ze}clone(ze=!1){return ze?new Graphics(this._context.clone()):(this._ownedContext=null,new Graphics(this._context))}lineStyle(ze,Gr,Wr){deprecation(v8_0_0,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const Kr={};return ze&&(Kr.width=ze),Gr&&(Kr.color=Gr),Wr&&(Kr.alpha=Wr),this.context.strokeStyle=Kr,this}beginFill(ze,Gr){deprecation(v8_0_0,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const Wr={};return ze!==void 0&&(Wr.color=ze),Gr!==void 0&&(Wr.alpha=Gr),this.context.fillStyle=Wr,this}endFill(){deprecation(v8_0_0,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const ze=this.context.strokeStyle;return(ze.width!==GraphicsContext.defaultStrokeStyle.width||ze.color!==GraphicsContext.defaultStrokeStyle.color||ze.alpha!==GraphicsContext.defaultStrokeStyle.alpha)&&this.context.stroke(),this}drawCircle(...ze){return deprecation(v8_0_0,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",ze)}drawEllipse(...ze){return deprecation(v8_0_0,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",ze)}drawPolygon(...ze){return deprecation(v8_0_0,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",ze)}drawRect(...ze){return deprecation(v8_0_0,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",ze)}drawRoundedRect(...ze){return deprecation(v8_0_0,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",ze)}drawStar(...ze){return deprecation(v8_0_0,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",ze)}}const _MeshGeometry=class Ms extends Geometry{constructor(...ze){let Gr=ze[0]??{};Gr instanceof Float32Array&&(deprecation(v8_0_0,"use new MeshGeometry({ positions, uvs, indices }) instead"),Gr={positions:Gr,uvs:ze[1],indices:ze[2]}),Gr={...Ms.defaultOptions,...Gr};const Wr=Gr.positions||new Float32Array([0,0,1,0,1,1,0,1]);let Kr=Gr.uvs;Kr||(Gr.positions?Kr=new Float32Array(Wr.length):Kr=new Float32Array([0,0,1,0,1,1,0,1]));const Zr=Gr.indices||new Uint32Array([0,1,2,0,2,3]),Qr=Gr.shrinkBuffersToFit,Jr=new Buffer({data:Wr,label:"attribute-mesh-positions",shrinkToFit:Qr,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ei=new Buffer({data:Kr,label:"attribute-mesh-uvs",shrinkToFit:Qr,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ti=new Buffer({data:Zr,label:"index-mesh-buffer",shrinkToFit:Qr,usage:BufferUsage.INDEX|BufferUsage.COPY_DST});super({attributes:{aPosition:{buffer:Jr,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:ei,format:"float32x2",stride:2*4,offset:0}},indexBuffer:ti,topology:Gr.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(ze){this.attributes.aPosition.buffer.data=ze}get uvs(){return this.attributes.aUV.buffer.data}set uvs(ze){this.attributes.aUV.buffer.data=ze}get indices(){return this.indexBuffer.data}set indices(ze){this.indexBuffer.data=ze}};_MeshGeometry.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let MeshGeometry=_MeshGeometry;class AnimatedSprite extends Sprite{constructor(...ze){let Gr=ze[0];Array.isArray(ze[0])&&(Gr={textures:ze[0],autoUpdate:ze[1]});const{animationSpeed:Wr=1,autoPlay:Kr=!1,autoUpdate:Zr=!0,loop:Qr=!0,onComplete:Jr=null,onFrameChange:ei=null,onLoop:ti=null,textures:ri,updateAnchor:ii=!1,...si}=Gr,[ni]=ri;super({...si,texture:ni instanceof Texture?ni:ni.texture}),this._textures=null,this._durations=null,this._autoUpdate=Zr,this._isConnectedToTicker=!1,this.animationSpeed=Wr,this.loop=Qr,this.updateAnchor=ii,this.onComplete=Jr,this.onFrameChange=ei,this.onLoop=ti,this._currentTime=0,this._playing=!1,this._previousFrame=null,this.textures=ri,Kr&&this.play()}stop(){this._playing&&(this._playing=!1,this._autoUpdate&&this._isConnectedToTicker&&(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1))}play(){this._playing||(this._playing=!0,this._autoUpdate&&!this._isConnectedToTicker&&(Ticker.shared.add(this.update,this,UPDATE_PRIORITY.HIGH),this._isConnectedToTicker=!0))}gotoAndStop(ze){this.stop(),this.currentFrame=ze}gotoAndPlay(ze){this.currentFrame=ze,this.play()}update(ze){if(!this._playing)return;const Gr=ze.deltaTime,Wr=this.animationSpeed*Gr,Kr=this.currentFrame;if(this._durations!==null){let Zr=this._currentTime%1*this._durations[this.currentFrame];for(Zr+=Wr/60*1e3;Zr<0;)this._currentTime--,Zr+=this._durations[this.currentFrame];const Qr=Math.sign(this.animationSpeed*Gr);for(this._currentTime=Math.floor(this._currentTime);Zr>=this._durations[this.currentFrame];)Zr-=this._durations[this.currentFrame]*Qr,this._currentTime+=Qr;this._currentTime+=Zr/this._durations[this.currentFrame]}else this._currentTime+=Wr;this._currentTime<0&&!this.loop?(this.gotoAndStop(0),this.onComplete&&this.onComplete()):this._currentTime>=this._textures.length&&!this.loop?(this.gotoAndStop(this._textures.length-1),this.onComplete&&this.onComplete()):Kr!==this.currentFrame&&(this.loop&&this.onLoop&&(this.animationSpeed>0&&this.currentFrame<Kr||this.animationSpeed<0&&this.currentFrame>Kr)&&this.onLoop(),this._updateTexture())}_updateTexture(){const ze=this.currentFrame;this._previousFrame!==ze&&(this._previousFrame=ze,this.texture=this._textures[ze],this.updateAnchor&&this.texture.defaultAnchor&&this.anchor.copyFrom(this.texture.defaultAnchor),this.onFrameChange&&this.onFrameChange(this.currentFrame))}destroy(){this.stop(),super.destroy(),this.onComplete=null,this.onFrameChange=null,this.onLoop=null}static fromFrames(ze){const Gr=[];for(let Wr=0;Wr<ze.length;++Wr)Gr.push(Texture.from(ze[Wr]));return new AnimatedSprite(Gr)}static fromImages(ze){const Gr=[];for(let Wr=0;Wr<ze.length;++Wr)Gr.push(Texture.from(ze[Wr]));return new AnimatedSprite(Gr)}get totalFrames(){return this._textures.length}get textures(){return this._textures}set textures(ze){if(ze[0]instanceof Texture)this._textures=ze,this._durations=null;else{this._textures=[],this._durations=[];for(let Gr=0;Gr<ze.length;Gr++)this._textures.push(ze[Gr].texture),this._durations.push(ze[Gr].time)}this._previousFrame=null,this.gotoAndStop(0),this._updateTexture()}get currentFrame(){let ze=Math.floor(this._currentTime)%this._textures.length;return ze<0&&(ze+=this._textures.length),ze}set currentFrame(ze){if(ze<0||ze>this.totalFrames-1)throw new Error(`[AnimatedSprite]: Invalid frame index value ${ze}, expected to be between 0 and totalFrames ${this.totalFrames}.`);const Gr=this.currentFrame;this._currentTime=ze,Gr!==this.currentFrame&&this._updateTexture()}get playing(){return this._playing}get autoUpdate(){return this._autoUpdate}set autoUpdate(ze){ze!==this._autoUpdate&&(this._autoUpdate=ze,!this._autoUpdate&&this._isConnectedToTicker?(Ticker.shared.remove(this.update,this),this._isConnectedToTicker=!1):this._autoUpdate&&!this._isConnectedToTicker&&this._playing&&(Ticker.shared.add(this.update,this),this._isConnectedToTicker=!0))}}class AbstractText extends ViewContainer{constructor(ze,Gr){const{text:Wr,resolution:Kr,style:Zr,anchor:Qr,width:Jr,height:ei,roundPixels:ti,...ri}=ze;super({...ri}),this.batched=!0,this._resolution=null,this._autoResolution=!0,this._didTextUpdate=!0,this._styleClass=Gr,this.text=Wr??"",this.style=Zr,this.resolution=Kr??null,this.allowChildren=!1,this._anchor=new ObservablePoint({_onUpdate:()=>{this.onViewUpdate()}}),Qr&&(this.anchor=Qr),this.roundPixels=ti??!1,Jr!==void 0&&(this.width=Jr),ei!==void 0&&(this.height=ei)}get anchor(){return this._anchor}set anchor(ze){typeof ze=="number"?this._anchor.set(ze):this._anchor.copyFrom(ze)}set text(ze){ze=ze.toString(),this._text!==ze&&(this._text=ze,this.onViewUpdate())}get text(){return this._text}set resolution(ze){this._autoResolution=ze===null,this._resolution=ze,this.onViewUpdate()}get resolution(){return this._resolution}get style(){return this._style}set style(ze){var Gr;ze||(ze={}),(Gr=this._style)==null||Gr.off("update",this.onViewUpdate,this),ze instanceof this._styleClass?this._style=ze:this._style=new this._styleClass(ze),this._style.on("update",this.onViewUpdate,this),this.onViewUpdate()}get width(){return Math.abs(this.scale.x)*this.bounds.width}set width(ze){this._setWidth(ze,this.bounds.width)}get height(){return Math.abs(this.scale.y)*this.bounds.height}set height(ze){this._setHeight(ze,this.bounds.height)}getSize(ze){return ze||(ze={}),ze.width=Math.abs(this.scale.x)*this.bounds.width,ze.height=Math.abs(this.scale.y)*this.bounds.height,ze}setSize(ze,Gr){typeof ze=="object"?(Gr=ze.height??ze.width,ze=ze.width):Gr??(Gr=ze),ze!==void 0&&this._setWidth(ze,this.bounds.width),Gr!==void 0&&this._setHeight(Gr,this.bounds.height)}containsPoint(ze){const Gr=this.bounds.width,Wr=this.bounds.height,Kr=-Gr*this.anchor.x;let Zr=0;return ze.x>=Kr&&ze.x<=Kr+Gr&&(Zr=-Wr*this.anchor.y,ze.y>=Zr&&ze.y<=Zr+Wr)}onViewUpdate(){this.didViewUpdate||(this._didTextUpdate=!0),super.onViewUpdate()}_getKey(){return`${this.text}:${this._style.styleKey}:${this._resolution}`}destroy(ze=!1){super.destroy(ze),this.owner=null,this._bounds=null,this._anchor=null,(typeof ze=="boolean"?ze:ze!=null&&ze.style)&&this._style.destroy(ze),this._style=null,this._text=null}}function ensureTextOptions(Yr,ze){let Gr=Yr[0]??{};return(typeof Gr=="string"||Yr[1])&&(deprecation(v8_0_0,`use new ${ze}({ text: "hi!", style }) instead`),Gr={text:Gr,style:Yr[1]}),Gr}class Text extends AbstractText{constructor(...ze){const Gr=ensureTextOptions(ze,"Text");super(Gr,TextStyle),this.renderPipeId="text"}updateBounds(){const ze=this._bounds,Gr=this._anchor,Wr=CanvasTextMetrics.measureText(this._text,this._style),{width:Kr,height:Zr}=Wr;ze.minX=-Gr._x*Kr,ze.maxX=ze.minX+Kr,ze.minY=-Gr._y*Zr,ze.maxY=ze.minY+Zr}}function textStyleToCSS(Yr){const ze=Yr._stroke,Gr=Yr._fill,Kr=[`div { ${[`color: ${Color.shared.setValue(Gr.color).toHex()}`,`font-size: ${Yr.fontSize}px`,`font-family: ${Yr.fontFamily}`,`font-weight: ${Yr.fontWeight}`,`font-style: ${Yr.fontStyle}`,`font-variant: ${Yr.fontVariant}`,`letter-spacing: ${Yr.letterSpacing}px`,`text-align: ${Yr.align}`,`padding: ${Yr.padding}px`,`white-space: ${Yr.whiteSpace==="pre"&&Yr.wordWrap?"pre-wrap":Yr.whiteSpace}`,...Yr.lineHeight?[`line-height: ${Yr.lineHeight}px`]:[],...Yr.wordWrap?[`word-wrap: ${Yr.breakWords?"break-all":"break-word"}`,`max-width: ${Yr.wordWrapWidth}px`]:[],...ze?[strokeToCSS(ze)]:[],...Yr.dropShadow?[dropShadowToCSS(Yr.dropShadow)]:[],...Yr.cssOverrides].join(";")} }`];return tagStyleToCSS(Yr.tagStyles,Kr),Kr.join(" ")}function dropShadowToCSS(Yr){const ze=Color.shared.setValue(Yr.color).setAlpha(Yr.alpha).toHexa(),Gr=Math.round(Math.cos(Yr.angle)*Yr.distance),Wr=Math.round(Math.sin(Yr.angle)*Yr.distance),Kr=`${Gr}px ${Wr}px`;return Yr.blur>0?`text-shadow: ${Kr} ${Yr.blur}px ${ze}`:`text-shadow: ${Kr} ${ze}`}function strokeToCSS(Yr){return[`-webkit-text-stroke-width: ${Yr.width}px`,`-webkit-text-stroke-color: ${Color.shared.setValue(Yr.color).toHex()}`,`text-stroke-width: ${Yr.width}px`,`text-stroke-color: ${Color.shared.setValue(Yr.color).toHex()}`,"paint-order: stroke"].join(";")}const templates={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},transform={fill:Yr=>`color: ${Color.shared.setValue(Yr).toHex()}`,breakWords:Yr=>`word-wrap: ${Yr?"break-all":"break-word"}`,stroke:strokeToCSS,dropShadow:dropShadowToCSS};function tagStyleToCSS(Yr,ze){for(const Gr in Yr){const Wr=Yr[Gr],Kr=[];for(const Zr in Wr)transform[Zr]?Kr.push(transform[Zr](Wr[Zr])):templates[Zr]&&Kr.push(templates[Zr].replace("{{VALUE}}",Wr[Zr]));ze.push(`${Gr} { ${Kr.join(";")} }`)}}class HTMLTextStyle extends TextStyle{constructor(ze={}){super(ze),this._cssOverrides=[],this.cssOverrides??(this.cssOverrides=ze.cssOverrides),this.tagStyles=ze.tagStyles??{}}set cssOverrides(ze){this._cssOverrides=ze instanceof Array?ze:[ze],this.update()}get cssOverrides(){return this._cssOverrides}_generateKey(){return this._styleKey=generateTextStyleKey(this)+this._cssOverrides.join("-"),this._styleKey}update(){this._cssStyle=null,super.update()}clone(){return new HTMLTextStyle({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow?{...this.dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides})}get cssStyle(){return this._cssStyle||(this._cssStyle=textStyleToCSS(this)),this._cssStyle}addOverride(...ze){const Gr=ze.filter(Wr=>!this.cssOverrides.includes(Wr));Gr.length>0&&(this.cssOverrides.push(...Gr),this.update())}removeOverride(...ze){const Gr=ze.filter(Wr=>this.cssOverrides.includes(Wr));Gr.length>0&&(this.cssOverrides=this.cssOverrides.filter(Wr=>!Gr.includes(Wr)),this.update())}set fill(ze){typeof ze!="string"&&typeof ze!="number"&&warn("[HTMLTextStyle] only color fill is not supported by HTMLText"),super.fill=ze}set stroke(ze){ze&&typeof ze!="string"&&typeof ze!="number"&&warn("[HTMLTextStyle] only color stroke is not supported by HTMLText"),super.stroke=ze}}const nssvg="http://www.w3.org/2000/svg",nsxhtml="http://www.w3.org/1999/xhtml";class HTMLTextRenderData{constructor(){this.svgRoot=document.createElementNS(nssvg,"svg"),this.foreignObject=document.createElementNS(nssvg,"foreignObject"),this.domElement=document.createElementNS(nsxhtml,"div"),this.styleElement=document.createElementNS(nsxhtml,"style"),this.image=new Image;const{foreignObject:ze,svgRoot:Gr,styleElement:Wr,domElement:Kr}=this;ze.setAttribute("width","10000"),ze.setAttribute("height","10000"),ze.style.overflow="hidden",Gr.appendChild(ze),ze.appendChild(Wr),ze.appendChild(Kr)}}let tempHTMLTextRenderData;function measureHtmlText(Yr,ze,Gr,Wr){Wr||(Wr=tempHTMLTextRenderData||(tempHTMLTextRenderData=new HTMLTextRenderData));const{domElement:Kr,styleElement:Zr,svgRoot:Qr}=Wr;Kr.innerHTML=`<style>${ze.cssStyle};</style><div style='padding:0'>${Yr}</div>`,Kr.setAttribute("style","transform-origin: top left; display: inline-block"),Gr&&(Zr.textContent=Gr),document.body.appendChild(Qr);const Jr=Kr.getBoundingClientRect();Qr.remove();const ei=ze.padding*2;return{width:Jr.width-ei,height:Jr.height-ei}}class GlBatchAdaptor{constructor(){this._tempState=State.for2d(),this._didUploadHash={}}init(ze){ze.renderer.runners.contextChange.add(this)}contextChange(){this._didUploadHash={}}start(ze,Gr,Wr){const Kr=ze.renderer,Zr=this._didUploadHash[Wr.uid];Kr.shader.bind(Wr,Zr),Zr||(this._didUploadHash[Wr.uid]=!0),Kr.shader.updateUniformGroup(Kr.globalUniforms.uniformGroup),Kr.geometry.bind(Gr,Wr.glProgram)}execute(ze,Gr){const Wr=ze.renderer;this._tempState.blendMode=Gr.blendMode,Wr.state.set(this._tempState);const Kr=Gr.textures.textures;for(let Zr=0;Zr<Gr.textures.count;Zr++)Wr.texture.bind(Kr[Zr],Zr);Wr.geometry.draw(Gr.topology,Gr.size,Gr.start)}}GlBatchAdaptor.extension={type:[ExtensionType.WebGLPipesAdaptor],name:"batch"};const tempState=State.for2d();class GpuBatchAdaptor{start(ze,Gr,Wr){const Kr=ze.renderer,Zr=Kr.encoder,Qr=Wr.gpuProgram;this._shader=Wr,this._geometry=Gr,Zr.setGeometry(Gr,Qr),tempState.blendMode="normal",Kr.pipeline.getPipeline(Gr,Qr,tempState);const Jr=Kr.globalUniforms.bindGroup;Zr.resetBindGroup(1),Zr.setBindGroup(0,Jr,Qr)}execute(ze,Gr){const Wr=this._shader.gpuProgram,Kr=ze.renderer,Zr=Kr.encoder;if(!Gr.bindGroup){const ei=Gr.textures;Gr.bindGroup=getTextureBatchBindGroup(ei.textures,ei.count)}tempState.blendMode=Gr.blendMode;const Qr=Kr.bindGroup.getBindGroup(Gr.bindGroup,Wr,1),Jr=Kr.pipeline.getPipeline(this._geometry,Wr,tempState,Gr.topology);Gr.bindGroup._touch(Kr.textureGC.count),Zr.setPipeline(Jr),Zr.renderPassEncoder.setBindGroup(1,Qr),Zr.renderPassEncoder.drawIndexed(Gr.size,1,Gr.start)}}GpuBatchAdaptor.extension={type:[ExtensionType.WebGPUPipesAdaptor],name:"batch"};const _BatcherPipe=class Bs{constructor(ze,Gr){var Wr,Kr;this.state=State.for2d(),this._batchersByInstructionSet=Object.create(null),this._activeBatches=Object.create(null),this.renderer=ze,this._adaptor=Gr,(Kr=(Wr=this._adaptor).init)==null||Kr.call(Wr,this)}static getBatcher(ze){return new this._availableBatchers[ze]}buildStart(ze){let Gr=this._batchersByInstructionSet[ze.uid];Gr||(Gr=this._batchersByInstructionSet[ze.uid]=Object.create(null),Gr.default||(Gr.default=new DefaultBatcher)),this._activeBatches=Gr,this._activeBatch=this._activeBatches.default;for(const Wr in this._activeBatches)this._activeBatches[Wr].begin()}addToBatch(ze,Gr){if(this._activeBatch.name!==ze.batcherName){this._activeBatch.break(Gr);let Wr=this._activeBatches[ze.batcherName];Wr||(Wr=this._activeBatches[ze.batcherName]=Bs.getBatcher(ze.batcherName),Wr.begin()),this._activeBatch=Wr}this._activeBatch.add(ze)}break(ze){this._activeBatch.break(ze)}buildEnd(ze){this._activeBatch.break(ze);const Gr=this._activeBatches;for(const Wr in Gr){const Kr=Gr[Wr],Zr=Kr.geometry;Zr.indexBuffer.setDataWithSize(Kr.indexBuffer,Kr.indexSize,!0),Zr.buffers[0].setDataWithSize(Kr.attributeBuffer.float32View,Kr.attributeSize,!1)}}upload(ze){const Gr=this._batchersByInstructionSet[ze.uid];for(const Wr in Gr){const Kr=Gr[Wr],Zr=Kr.geometry;Kr.dirty&&(Kr.dirty=!1,Zr.buffers[0].update(Kr.attributeSize*4))}}execute(ze){if(ze.action==="startBatch"){const Gr=ze.batcher,Wr=Gr.geometry,Kr=Gr.shader;this._adaptor.start(this,Wr,Kr)}this._adaptor.execute(this,ze)}destroy(){this.state=null,this.renderer=null,this._adaptor=null;for(const ze in this._activeBatches)this._activeBatches[ze].destroy();this._activeBatches=null}};_BatcherPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"batch"};_BatcherPipe._availableBatchers=Object.create(null);let BatcherPipe=_BatcherPipe;extensions.handleByMap(ExtensionType.Batcher,BatcherPipe._availableBatchers);extensions.add(DefaultBatcher);const localUniformBit={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}},localUniformBitGroup2={...localUniformBit,vertex:{...localUniformBit.vertex,header:localUniformBit.vertex.header.replace("group(1)","group(2)")}},localUniformBitGl={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}},textureBit={name:"texture-bit",vertex:{header:`

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,main:`
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,main:`
            outColor = textureSample(uTexture, uSampler, vUV);
        `}},textureBitGl={name:"texture-bit",vertex:{header:`
            uniform mat3 uTextureMatrix;
        `,main:`
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
        uniform sampler2D uTexture;

         
        `,main:`
            outColor = texture(uTexture, vUV);
        `}},tempBounds$2=new Bounds;class AlphaMaskEffect extends FilterEffect{constructor(){super(),this.filters=[new MaskFilter({sprite:new Sprite(Texture.EMPTY),inverse:!1,resolution:"inherit",antialias:"inherit"})]}get sprite(){return this.filters[0].sprite}set sprite(ze){this.filters[0].sprite=ze}get inverse(){return this.filters[0].inverse}set inverse(ze){this.filters[0].inverse=ze}}class AlphaMaskPipe{constructor(ze){this._activeMaskStage=[],this._renderer=ze}push(ze,Gr,Wr){const Kr=this._renderer;if(Kr.renderPipes.batch.break(Wr),Wr.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1,maskedContainer:Gr}),ze.inverse=Gr._maskOptions.inverse,ze.renderMaskToTexture){const Zr=ze.mask;Zr.includeInBuild=!0,Zr.collectRenderables(Wr,Kr,null),Zr.includeInBuild=!1}Kr.renderPipes.batch.break(Wr),Wr.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask:ze,maskedContainer:Gr,inverse:Gr._maskOptions.inverse,canBundle:!1})}pop(ze,Gr,Wr){this._renderer.renderPipes.batch.break(Wr),Wr.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1})}execute(ze){const Gr=this._renderer,Wr=ze.mask.renderMaskToTexture;if(ze.action==="pushMaskBegin"){const Kr=BigPool.get(AlphaMaskEffect);if(Kr.inverse=ze.inverse,Wr){ze.mask.mask.measurable=!0;const Zr=getGlobalBounds(ze.mask.mask,!0,tempBounds$2);ze.mask.mask.measurable=!1,Zr.ceil();const Qr=Gr.renderTarget.renderTarget.colorTexture.source,Jr=TexturePool.getOptimalTexture(Zr.width,Zr.height,Qr._resolution,Qr.antialias);Gr.renderTarget.push(Jr,!0),Gr.globalUniforms.push({offset:Zr,worldColor:4294967295});const ei=Kr.sprite;ei.texture=Jr,ei.worldTransform.tx=Zr.minX,ei.worldTransform.ty=Zr.minY,this._activeMaskStage.push({filterEffect:Kr,maskedContainer:ze.maskedContainer,filterTexture:Jr})}else Kr.sprite=ze.mask.mask,this._activeMaskStage.push({filterEffect:Kr,maskedContainer:ze.maskedContainer})}else if(ze.action==="pushMaskEnd"){const Kr=this._activeMaskStage[this._activeMaskStage.length-1];Wr&&(Gr.type===RendererType.WEBGL&&Gr.renderTarget.finishRenderPass(),Gr.renderTarget.pop(),Gr.globalUniforms.pop()),Gr.filter.push({renderPipeId:"filter",action:"pushFilter",container:Kr.maskedContainer,filterEffect:Kr.filterEffect,canBundle:!1})}else if(ze.action==="popMaskEnd"){Gr.filter.pop();const Kr=this._activeMaskStage.pop();Wr&&TexturePool.returnTexture(Kr.filterTexture),BigPool.return(Kr.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}AlphaMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"alphaMask"};class ColorMaskPipe{constructor(ze){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=ze}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(ze,Gr,Wr){this._renderer.renderPipes.batch.break(Wr);const Zr=this._colorStack;Zr[this._colorStackIndex]=Zr[this._colorStackIndex-1]&ze.mask;const Qr=this._colorStack[this._colorStackIndex];Qr!==this._currentColor&&(this._currentColor=Qr,Wr.add({renderPipeId:"colorMask",colorMask:Qr,canBundle:!1})),this._colorStackIndex++}pop(ze,Gr,Wr){this._renderer.renderPipes.batch.break(Wr);const Zr=this._colorStack;this._colorStackIndex--;const Qr=Zr[this._colorStackIndex-1];Qr!==this._currentColor&&(this._currentColor=Qr,Wr.add({renderPipeId:"colorMask",colorMask:Qr,canBundle:!1}))}execute(ze){this._renderer.colorMask.setMask(ze.colorMask)}destroy(){this._colorStack=null}}ColorMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"colorMask"};class StencilMaskPipe{constructor(ze){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=ze}push(ze,Gr,Wr){var Kr;const Zr=ze,Qr=this._renderer;Qr.renderPipes.batch.break(Wr),Qr.renderPipes.blendMode.setBlendMode(Zr.mask,"none",Wr),Wr.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1});const Jr=Zr.mask;Jr.includeInBuild=!0,this._maskHash.has(Zr)||this._maskHash.set(Zr,{instructionsStart:0,instructionsLength:0});const ei=this._maskHash.get(Zr);ei.instructionsStart=Wr.instructionSize,Jr.collectRenderables(Wr,Qr,null),Jr.includeInBuild=!1,Qr.renderPipes.batch.break(Wr),Wr.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1});const ti=Wr.instructionSize-ei.instructionsStart-1;ei.instructionsLength=ti;const ri=Qr.renderTarget.renderTarget.uid;(Kr=this._maskStackHash)[ri]??(Kr[ri]=0)}pop(ze,Gr,Wr){const Kr=ze,Zr=this._renderer;Zr.renderPipes.batch.break(Wr),Zr.renderPipes.blendMode.setBlendMode(Kr.mask,"none",Wr),Wr.add({renderPipeId:"stencilMask",action:"popMaskBegin",inverse:Gr._maskOptions.inverse,canBundle:!1});const Qr=this._maskHash.get(ze);for(let Jr=0;Jr<Qr.instructionsLength;Jr++)Wr.instructions[Wr.instructionSize++]=Wr.instructions[Qr.instructionsStart++];Wr.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(ze){var Gr;const Wr=this._renderer,Kr=Wr.renderTarget.renderTarget.uid;let Zr=(Gr=this._maskStackHash)[Kr]??(Gr[Kr]=0);ze.action==="pushMaskBegin"?(Wr.renderTarget.ensureDepthStencil(),Wr.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD,Zr),Zr++,Wr.colorMask.setMask(0)):ze.action==="pushMaskEnd"?(ze.inverse?Wr.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE,Zr):Wr.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,Zr),Wr.colorMask.setMask(15)):ze.action==="popMaskBegin"?(Wr.colorMask.setMask(0),Zr!==0?Wr.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE,Zr):(Wr.renderTarget.clear(null,CLEAR.STENCIL),Wr.stencil.setStencilMode(STENCIL_MODES.DISABLED,Zr)),Zr--):ze.action==="popMaskEnd"&&(ze.inverse?Wr.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE,Zr):Wr.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,Zr),Wr.colorMask.setMask(15)),this._maskStackHash[Kr]=Zr}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}StencilMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"stencilMask"};var BUFFER_TYPE=(Yr=>(Yr[Yr.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",Yr[Yr.ARRAY_BUFFER=34962]="ARRAY_BUFFER",Yr[Yr.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",Yr))(BUFFER_TYPE||{});class GlBuffer{constructor(ze,Gr){this._lastBindBaseLocation=-1,this._lastBindCallId=-1,this.buffer=ze||null,this.updateID=-1,this.byteLength=-1,this.type=Gr}}class GlBufferSystem{constructor(ze){this._gpuBuffers=Object.create(null),this._boundBufferBases=Object.create(null),this._minBaseLocation=0,this._nextBindBaseIndex=this._minBaseLocation,this._bindCallId=0,this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuBuffers")}destroy(){this._renderer=null,this._gl=null,this._gpuBuffers=null,this._boundBufferBases=null}contextChange(){const ze=this._gl=this._renderer.gl;this._gpuBuffers=Object.create(null),this._maxBindings=ze.MAX_UNIFORM_BUFFER_BINDINGS?ze.getParameter(ze.MAX_UNIFORM_BUFFER_BINDINGS):0}getGlBuffer(ze){return this._gpuBuffers[ze.uid]||this.createGLBuffer(ze)}bind(ze){const{_gl:Gr}=this,Wr=this.getGlBuffer(ze);Gr.bindBuffer(Wr.type,Wr.buffer)}bindBufferBase(ze,Gr){const{_gl:Wr}=this;this._boundBufferBases[Gr]!==ze&&(this._boundBufferBases[Gr]=ze,ze._lastBindBaseLocation=Gr,Wr.bindBufferBase(Wr.UNIFORM_BUFFER,Gr,ze.buffer))}nextBindBase(ze){this._bindCallId++,this._minBaseLocation=0,ze&&(this._boundBufferBases[0]=null,this._minBaseLocation=1,this._nextBindBaseIndex<1&&(this._nextBindBaseIndex=1))}freeLocationForBufferBase(ze){let Gr=this.getLastBindBaseLocation(ze);if(Gr>=this._minBaseLocation)return ze._lastBindCallId=this._bindCallId,Gr;let Wr=0,Kr=this._nextBindBaseIndex;for(;Wr<2;){Kr>=this._maxBindings&&(Kr=this._minBaseLocation,Wr++);const Zr=this._boundBufferBases[Kr];if(Zr&&Zr._lastBindCallId===this._bindCallId){Kr++;continue}break}return Gr=Kr,this._nextBindBaseIndex=Kr+1,Wr>=2?-1:(ze._lastBindCallId=this._bindCallId,this._boundBufferBases[Gr]=null,Gr)}getLastBindBaseLocation(ze){const Gr=ze._lastBindBaseLocation;return this._boundBufferBases[Gr]===ze?Gr:-1}bindBufferRange(ze,Gr,Wr,Kr){const{_gl:Zr}=this;Wr||(Wr=0),Gr||(Gr=0),this._boundBufferBases[Gr]=null,Zr.bindBufferRange(Zr.UNIFORM_BUFFER,Gr||0,ze.buffer,Wr*256,Kr||256)}updateBuffer(ze){const{_gl:Gr}=this,Wr=this.getGlBuffer(ze);if(ze._updateID===Wr.updateID)return Wr;Wr.updateID=ze._updateID,Gr.bindBuffer(Wr.type,Wr.buffer);const Kr=ze.data,Zr=ze.descriptor.usage&BufferUsage.STATIC?Gr.STATIC_DRAW:Gr.DYNAMIC_DRAW;return Kr?Wr.byteLength>=Kr.byteLength?Gr.bufferSubData(Wr.type,0,Kr,0,ze._updateSize/Kr.BYTES_PER_ELEMENT):(Wr.byteLength=Kr.byteLength,Gr.bufferData(Wr.type,Kr,Zr)):(Wr.byteLength=ze.descriptor.size,Gr.bufferData(Wr.type,Wr.byteLength,Zr)),Wr}destroyAll(){const ze=this._gl;for(const Gr in this._gpuBuffers)ze.deleteBuffer(this._gpuBuffers[Gr].buffer);this._gpuBuffers=Object.create(null)}onBufferDestroy(ze,Gr){const Wr=this._gpuBuffers[ze.uid],Kr=this._gl;Gr||Kr.deleteBuffer(Wr.buffer),this._gpuBuffers[ze.uid]=null}createGLBuffer(ze){const{_gl:Gr}=this;let Wr=BUFFER_TYPE.ARRAY_BUFFER;ze.descriptor.usage&BufferUsage.INDEX?Wr=BUFFER_TYPE.ELEMENT_ARRAY_BUFFER:ze.descriptor.usage&BufferUsage.UNIFORM&&(Wr=BUFFER_TYPE.UNIFORM_BUFFER);const Kr=new GlBuffer(Gr.createBuffer(),Wr);return this._gpuBuffers[ze.uid]=Kr,ze.on("destroy",this.onBufferDestroy,this),Kr}resetState(){this._boundBufferBases=Object.create(null)}}GlBufferSystem.extension={type:[ExtensionType.WebGLSystem],name:"buffer"};const _GlContextSystem=class Rs{constructor(ze){this.supports={uint32Indices:!0,uniformBufferObject:!0,vertexArrayObject:!0,srgbTextures:!0,nonPowOf2wrapping:!0,msaa:!0,nonPowOf2mipmaps:!0},this._renderer=ze,this.extensions=Object.create(null),this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}contextChange(ze){this.gl=ze,this._renderer.gl=ze}init(ze){ze={...Rs.defaultOptions,...ze};let Gr=this.multiView=ze.multiView;if(ze.context&&Gr&&(warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."),Gr=!1),Gr?this.canvas=DOMAdapter.get().createCanvas(this._renderer.canvas.width,this._renderer.canvas.height):this.canvas=this._renderer.view.canvas,ze.context)this.initFromContext(ze.context);else{const Wr=this._renderer.background.alpha<1,Kr=ze.premultipliedAlpha??!0,Zr=ze.antialias&&!this._renderer.backBuffer.useBackBuffer;this.createContext(ze.preferWebGLVersion,{alpha:Wr,premultipliedAlpha:Kr,antialias:Zr,stencil:!0,preserveDrawingBuffer:ze.preserveDrawingBuffer,powerPreference:ze.powerPreference??"default"})}}ensureCanvasSize(ze){if(!this.multiView){ze!==this.canvas&&warn("multiView is disabled, but targetCanvas is not the main canvas");return}const{canvas:Gr}=this;(Gr.width<ze.width||Gr.height<ze.height)&&(Gr.width=Math.max(ze.width,ze.width),Gr.height=Math.max(ze.height,ze.height))}initFromContext(ze){this.gl=ze,this.webGLVersion=ze instanceof DOMAdapter.get().getWebGLRenderingContext()?1:2,this.getExtensions(),this.validateContext(ze),this._renderer.runners.contextChange.emit(ze);const Gr=this._renderer.view.canvas;Gr.addEventListener("webglcontextlost",this.handleContextLost,!1),Gr.addEventListener("webglcontextrestored",this.handleContextRestored,!1)}createContext(ze,Gr){let Wr;const Kr=this.canvas;if(ze===2&&(Wr=Kr.getContext("webgl2",Gr)),!Wr&&(Wr=Kr.getContext("webgl",Gr),!Wr))throw new Error("This browser does not support WebGL. Try using the canvas renderer");this.gl=Wr,this.initFromContext(this.gl)}getExtensions(){const{gl:ze}=this,Gr={anisotropicFiltering:ze.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:ze.getExtension("OES_texture_float_linear"),s3tc:ze.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:ze.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:ze.getExtension("WEBGL_compressed_texture_etc"),etc1:ze.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:ze.getExtension("WEBGL_compressed_texture_pvrtc")||ze.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:ze.getExtension("WEBGL_compressed_texture_atc"),astc:ze.getExtension("WEBGL_compressed_texture_astc"),bptc:ze.getExtension("EXT_texture_compression_bptc"),rgtc:ze.getExtension("EXT_texture_compression_rgtc"),loseContext:ze.getExtension("WEBGL_lose_context")};if(this.webGLVersion===1)this.extensions={...Gr,drawBuffers:ze.getExtension("WEBGL_draw_buffers"),depthTexture:ze.getExtension("WEBGL_depth_texture"),vertexArrayObject:ze.getExtension("OES_vertex_array_object")||ze.getExtension("MOZ_OES_vertex_array_object")||ze.getExtension("WEBKIT_OES_vertex_array_object"),uint32ElementIndex:ze.getExtension("OES_element_index_uint"),floatTexture:ze.getExtension("OES_texture_float"),floatTextureLinear:ze.getExtension("OES_texture_float_linear"),textureHalfFloat:ze.getExtension("OES_texture_half_float"),textureHalfFloatLinear:ze.getExtension("OES_texture_half_float_linear"),vertexAttribDivisorANGLE:ze.getExtension("ANGLE_instanced_arrays"),srgb:ze.getExtension("EXT_sRGB")};else{this.extensions={...Gr,colorBufferFloat:ze.getExtension("EXT_color_buffer_float")};const Wr=ze.getExtension("WEBGL_provoking_vertex");Wr&&Wr.provokingVertexWEBGL(Wr.FIRST_VERTEX_CONVENTION_WEBGL)}}handleContextLost(ze){ze.preventDefault(),this._contextLossForced&&(this._contextLossForced=!1,setTimeout(()=>{var Gr;this.gl.isContextLost()&&((Gr=this.extensions.loseContext)==null||Gr.restoreContext())},0))}handleContextRestored(){this.getExtensions(),this._renderer.runners.contextChange.emit(this.gl)}destroy(){var Gr;const ze=this._renderer.view.canvas;this._renderer=null,ze.removeEventListener("webglcontextlost",this.handleContextLost),ze.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),(Gr=this.extensions.loseContext)==null||Gr.loseContext()}forceContextLoss(){var ze;(ze=this.extensions.loseContext)==null||ze.loseContext(),this._contextLossForced=!0}validateContext(ze){const Gr=ze.getContextAttributes();Gr&&!Gr.stencil&&warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");const Wr=this.supports,Kr=this.webGLVersion===2,Zr=this.extensions;Wr.uint32Indices=Kr||!!Zr.uint32ElementIndex,Wr.uniformBufferObject=Kr,Wr.vertexArrayObject=Kr||!!Zr.vertexArrayObject,Wr.srgbTextures=Kr||!!Zr.srgb,Wr.nonPowOf2wrapping=Kr,Wr.nonPowOf2mipmaps=Kr,Wr.msaa=Kr,Wr.uint32Indices||warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly")}};_GlContextSystem.extension={type:[ExtensionType.WebGLSystem],name:"context"};_GlContextSystem.defaultOptions={context:null,premultipliedAlpha:!0,preserveDrawingBuffer:!1,powerPreference:void 0,preferWebGLVersion:2,multiView:!1};let GlContextSystem=_GlContextSystem;function ensureAttributes(Yr,ze){for(const Gr in Yr.attributes){const Wr=Yr.attributes[Gr],Kr=ze[Gr];Kr?(Wr.format??(Wr.format=Kr.format),Wr.offset??(Wr.offset=Kr.offset),Wr.instance??(Wr.instance=Kr.instance)):warn(`Attribute ${Gr} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}ensureStartAndStride(Yr)}function ensureStartAndStride(Yr){const{buffers:ze,attributes:Gr}=Yr,Wr={},Kr={};for(const Zr in ze){const Qr=ze[Zr];Wr[Qr.uid]=0,Kr[Qr.uid]=0}for(const Zr in Gr){const Qr=Gr[Zr];Wr[Qr.buffer.uid]+=getAttributeInfoFromFormat(Qr.format).stride}for(const Zr in Gr){const Qr=Gr[Zr];Qr.stride??(Qr.stride=Wr[Qr.buffer.uid]),Qr.start??(Qr.start=Kr[Qr.buffer.uid]),Kr[Qr.buffer.uid]+=getAttributeInfoFromFormat(Qr.format).stride}}var GL_FORMATS=(Yr=>(Yr[Yr.RGBA=6408]="RGBA",Yr[Yr.RGB=6407]="RGB",Yr[Yr.RG=33319]="RG",Yr[Yr.RED=6403]="RED",Yr[Yr.RGBA_INTEGER=36249]="RGBA_INTEGER",Yr[Yr.RGB_INTEGER=36248]="RGB_INTEGER",Yr[Yr.RG_INTEGER=33320]="RG_INTEGER",Yr[Yr.RED_INTEGER=36244]="RED_INTEGER",Yr[Yr.ALPHA=6406]="ALPHA",Yr[Yr.LUMINANCE=6409]="LUMINANCE",Yr[Yr.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",Yr[Yr.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",Yr[Yr.DEPTH_STENCIL=34041]="DEPTH_STENCIL",Yr))(GL_FORMATS||{}),GL_TARGETS=(Yr=>(Yr[Yr.TEXTURE_2D=3553]="TEXTURE_2D",Yr[Yr.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",Yr[Yr.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",Yr[Yr.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",Yr[Yr.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",Yr[Yr.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",Yr[Yr.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",Yr[Yr.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",Yr[Yr.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",Yr))(GL_TARGETS||{}),GL_TYPES=(Yr=>(Yr[Yr.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",Yr[Yr.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",Yr[Yr.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",Yr[Yr.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",Yr[Yr.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",Yr[Yr.UNSIGNED_INT=5125]="UNSIGNED_INT",Yr[Yr.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",Yr[Yr.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",Yr[Yr.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",Yr[Yr.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",Yr[Yr.BYTE=5120]="BYTE",Yr[Yr.SHORT=5122]="SHORT",Yr[Yr.INT=5124]="INT",Yr[Yr.FLOAT=5126]="FLOAT",Yr[Yr.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",Yr[Yr.HALF_FLOAT=36193]="HALF_FLOAT",Yr))(GL_TYPES||{});const infoMap={uint8x2:GL_TYPES.UNSIGNED_BYTE,uint8x4:GL_TYPES.UNSIGNED_BYTE,sint8x2:GL_TYPES.BYTE,sint8x4:GL_TYPES.BYTE,unorm8x2:GL_TYPES.UNSIGNED_BYTE,unorm8x4:GL_TYPES.UNSIGNED_BYTE,snorm8x2:GL_TYPES.BYTE,snorm8x4:GL_TYPES.BYTE,uint16x2:GL_TYPES.UNSIGNED_SHORT,uint16x4:GL_TYPES.UNSIGNED_SHORT,sint16x2:GL_TYPES.SHORT,sint16x4:GL_TYPES.SHORT,unorm16x2:GL_TYPES.UNSIGNED_SHORT,unorm16x4:GL_TYPES.UNSIGNED_SHORT,snorm16x2:GL_TYPES.SHORT,snorm16x4:GL_TYPES.SHORT,float16x2:GL_TYPES.HALF_FLOAT,float16x4:GL_TYPES.HALF_FLOAT,float32:GL_TYPES.FLOAT,float32x2:GL_TYPES.FLOAT,float32x3:GL_TYPES.FLOAT,float32x4:GL_TYPES.FLOAT,uint32:GL_TYPES.UNSIGNED_INT,uint32x2:GL_TYPES.UNSIGNED_INT,uint32x3:GL_TYPES.UNSIGNED_INT,uint32x4:GL_TYPES.UNSIGNED_INT,sint32:GL_TYPES.INT,sint32x2:GL_TYPES.INT,sint32x3:GL_TYPES.INT,sint32x4:GL_TYPES.INT};function getGlTypeFromFormat(Yr){return infoMap[Yr]??infoMap.float32}const topologyToGlMap={"point-list":0,"line-list":1,"line-strip":3,"triangle-list":4,"triangle-strip":5};class GlGeometrySystem{constructor(ze){this._geometryVaoHash=Object.create(null),this._renderer=ze,this._activeGeometry=null,this._activeVao=null,this.hasVao=!0,this.hasInstance=!0,this._renderer.renderableGC.addManagedHash(this,"_geometryVaoHash")}contextChange(){const ze=this.gl=this._renderer.gl;if(!this._renderer.context.supports.vertexArrayObject)throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");const Gr=this._renderer.context.extensions.vertexArrayObject;Gr&&(ze.createVertexArray=()=>Gr.createVertexArrayOES(),ze.bindVertexArray=Kr=>Gr.bindVertexArrayOES(Kr),ze.deleteVertexArray=Kr=>Gr.deleteVertexArrayOES(Kr));const Wr=this._renderer.context.extensions.vertexAttribDivisorANGLE;Wr&&(ze.drawArraysInstanced=(Kr,Zr,Qr,Jr)=>{Wr.drawArraysInstancedANGLE(Kr,Zr,Qr,Jr)},ze.drawElementsInstanced=(Kr,Zr,Qr,Jr,ei)=>{Wr.drawElementsInstancedANGLE(Kr,Zr,Qr,Jr,ei)},ze.vertexAttribDivisor=(Kr,Zr)=>Wr.vertexAttribDivisorANGLE(Kr,Zr)),this._activeGeometry=null,this._activeVao=null,this._geometryVaoHash=Object.create(null)}bind(ze,Gr){const Wr=this.gl;this._activeGeometry=ze;const Kr=this.getVao(ze,Gr);this._activeVao!==Kr&&(this._activeVao=Kr,Wr.bindVertexArray(Kr)),this.updateBuffers()}resetState(){this.unbind()}updateBuffers(){const ze=this._activeGeometry,Gr=this._renderer.buffer;for(let Wr=0;Wr<ze.buffers.length;Wr++){const Kr=ze.buffers[Wr];Gr.updateBuffer(Kr)}}checkCompatibility(ze,Gr){const Wr=ze.attributes,Kr=Gr._attributeData;for(const Zr in Kr)if(!Wr[Zr])throw new Error(`shader and geometry incompatible, geometry missing the "${Zr}" attribute`)}getSignature(ze,Gr){const Wr=ze.attributes,Kr=Gr._attributeData,Zr=["g",ze.uid];for(const Qr in Wr)Kr[Qr]&&Zr.push(Qr,Kr[Qr].location);return Zr.join("-")}getVao(ze,Gr){var Wr;return((Wr=this._geometryVaoHash[ze.uid])==null?void 0:Wr[Gr._key])||this.initGeometryVao(ze,Gr)}initGeometryVao(ze,Gr,Wr=!0){const Kr=this._renderer.gl,Zr=this._renderer.buffer;this._renderer.shader._getProgramData(Gr),this.checkCompatibility(ze,Gr);const Qr=this.getSignature(ze,Gr);this._geometryVaoHash[ze.uid]||(this._geometryVaoHash[ze.uid]=Object.create(null),ze.on("destroy",this.onGeometryDestroy,this));const Jr=this._geometryVaoHash[ze.uid];let ei=Jr[Qr];if(ei)return Jr[Gr._key]=ei,ei;ensureAttributes(ze,Gr._attributeData);const ti=ze.buffers;ei=Kr.createVertexArray(),Kr.bindVertexArray(ei);for(let ri=0;ri<ti.length;ri++){const ii=ti[ri];Zr.bind(ii)}return this.activateVao(ze,Gr),Jr[Gr._key]=ei,Jr[Qr]=ei,Kr.bindVertexArray(null),ei}onGeometryDestroy(ze,Gr){const Wr=this._geometryVaoHash[ze.uid],Kr=this.gl;if(Wr){if(Gr)for(const Zr in Wr)this._activeVao!==Wr[Zr]&&this.unbind(),Kr.deleteVertexArray(Wr[Zr]);this._geometryVaoHash[ze.uid]=null}}destroyAll(ze=!1){const Gr=this.gl;for(const Wr in this._geometryVaoHash){if(ze)for(const Kr in this._geometryVaoHash[Wr]){const Zr=this._geometryVaoHash[Wr];this._activeVao!==Zr&&this.unbind(),Gr.deleteVertexArray(Zr[Kr])}this._geometryVaoHash[Wr]=null}}activateVao(ze,Gr){var Jr;const Wr=this._renderer.gl,Kr=this._renderer.buffer,Zr=ze.attributes;ze.indexBuffer&&Kr.bind(ze.indexBuffer);let Qr=null;for(const ei in Zr){const ti=Zr[ei],ri=ti.buffer,ii=Kr.getGlBuffer(ri),si=Gr._attributeData[ei];if(si){Qr!==ii&&(Kr.bind(ri),Qr=ii);const ni=si.location;Wr.enableVertexAttribArray(ni);const oi=getAttributeInfoFromFormat(ti.format),li=getGlTypeFromFormat(ti.format);if(((Jr=si.format)==null?void 0:Jr.substring(1,4))==="int"?Wr.vertexAttribIPointer(ni,oi.size,li,ti.stride,ti.offset):Wr.vertexAttribPointer(ni,oi.size,li,oi.normalised,ti.stride,ti.offset),ti.instance)if(this.hasInstance){const ai=ti.divisor??1;Wr.vertexAttribDivisor(ni,ai)}else throw new Error("geometry error, GPU Instancing is not supported on this device")}}}draw(ze,Gr,Wr,Kr){const{gl:Zr}=this._renderer,Qr=this._activeGeometry,Jr=topologyToGlMap[ze||Qr.topology];if(Kr??(Kr=Qr.instanceCount),Qr.indexBuffer){const ei=Qr.indexBuffer.data.BYTES_PER_ELEMENT,ti=ei===2?Zr.UNSIGNED_SHORT:Zr.UNSIGNED_INT;Kr>1?Zr.drawElementsInstanced(Jr,Gr||Qr.indexBuffer.data.length,ti,(Wr||0)*ei,Kr):Zr.drawElements(Jr,Gr||Qr.indexBuffer.data.length,ti,(Wr||0)*ei)}else Kr>1?Zr.drawArraysInstanced(Jr,Wr||0,Gr||Qr.getSize(),Kr):Zr.drawArrays(Jr,Wr||0,Gr||Qr.getSize());return this}unbind(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null}destroy(){this._renderer=null,this.gl=null,this._activeVao=null,this._activeGeometry=null}}GlGeometrySystem.extension={type:[ExtensionType.WebGLSystem],name:"geometry"};const bigTriangleGeometry=new Geometry({attributes:{aPosition:[-1,-1,3,-1,-1,3]}}),_GlBackBufferSystem=class Is{constructor(ze){this.useBackBuffer=!1,this._useBackBufferThisRender=!1,this._renderer=ze}init(ze={}){const{useBackBuffer:Gr,antialias:Wr}={...Is.defaultOptions,...ze};this.useBackBuffer=Gr,this._antialias=Wr,this._renderer.context.supports.msaa||(warn("antialiasing, is not supported on when using the back buffer"),this._antialias=!1),this._state=State.for2d();const Kr=new GlProgram({vertex:`
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,fragment:`
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,name:"big-triangle"});this._bigTriangleShader=new Shader({glProgram:Kr,resources:{uTexture:Texture.WHITE.source}})}renderStart(ze){const Gr=this._renderer.renderTarget.getRenderTarget(ze.target);if(this._useBackBufferThisRender=this.useBackBuffer&&!!Gr.isRoot,this._useBackBufferThisRender){const Wr=this._renderer.renderTarget.getRenderTarget(ze.target);this._targetTexture=Wr.colorTexture,ze.target=this._getBackBufferTexture(Wr.colorTexture)}}renderEnd(){this._presentBackBuffer()}_presentBackBuffer(){const ze=this._renderer;ze.renderTarget.finishRenderPass(),this._useBackBufferThisRender&&(ze.renderTarget.bind(this._targetTexture,!1),this._bigTriangleShader.resources.uTexture=this._backBufferTexture.source,ze.encoder.draw({geometry:bigTriangleGeometry,shader:this._bigTriangleShader,state:this._state}))}_getBackBufferTexture(ze){return this._backBufferTexture=this._backBufferTexture||new Texture({source:new TextureSource({width:ze.width,height:ze.height,resolution:ze._resolution,antialias:this._antialias})}),this._backBufferTexture.source.resize(ze.width,ze.height,ze._resolution),this._backBufferTexture}destroy(){this._backBufferTexture&&(this._backBufferTexture.destroy(),this._backBufferTexture=null)}};_GlBackBufferSystem.extension={type:[ExtensionType.WebGLSystem],name:"backBuffer",priority:1};_GlBackBufferSystem.defaultOptions={useBackBuffer:!1};let GlBackBufferSystem=_GlBackBufferSystem;class GlColorMaskSystem{constructor(ze){this._colorMaskCache=15,this._renderer=ze}setMask(ze){this._colorMaskCache!==ze&&(this._colorMaskCache=ze,this._renderer.gl.colorMask(!!(ze&8),!!(ze&4),!!(ze&2),!!(ze&1)))}}GlColorMaskSystem.extension={type:[ExtensionType.WebGLSystem],name:"colorMask"};class GlEncoderSystem{constructor(ze){this.commandFinished=Promise.resolve(),this._renderer=ze}setGeometry(ze,Gr){this._renderer.geometry.bind(ze,Gr.glProgram)}finishRenderPass(){}draw(ze){const Gr=this._renderer,{geometry:Wr,shader:Kr,state:Zr,skipSync:Qr,topology:Jr,size:ei,start:ti,instanceCount:ri}=ze;Gr.shader.bind(Kr,Qr),Gr.geometry.bind(Wr,Gr.shader._activeProgram),Zr&&Gr.state.set(Zr),Gr.geometry.draw(Jr,ei,ti,ri??Wr.instanceCount)}destroy(){this._renderer=null}}GlEncoderSystem.extension={type:[ExtensionType.WebGLSystem],name:"encoder"};class GlRenderTarget{constructor(){this.width=-1,this.height=-1,this.msaa=!1,this.msaaRenderBuffer=[]}}const GpuStencilModesToPixi=[];GpuStencilModesToPixi[STENCIL_MODES.NONE]=void 0;GpuStencilModesToPixi[STENCIL_MODES.DISABLED]={stencilWriteMask:0,stencilReadMask:0};GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}};GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}};GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}};GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"replace"},stencilBack:{compare:"not-equal",passOp:"replace"}};class GlStencilSystem{constructor(ze){this._stencilCache={enabled:!1,stencilReference:0,stencilMode:STENCIL_MODES.NONE},this._renderTargetStencilState=Object.create(null),ze.renderTarget.onRenderTargetChange.add(this)}contextChange(ze){this._gl=ze,this._comparisonFuncMapping={always:ze.ALWAYS,never:ze.NEVER,equal:ze.EQUAL,"not-equal":ze.NOTEQUAL,less:ze.LESS,"less-equal":ze.LEQUAL,greater:ze.GREATER,"greater-equal":ze.GEQUAL},this._stencilOpsMapping={keep:ze.KEEP,zero:ze.ZERO,replace:ze.REPLACE,invert:ze.INVERT,"increment-clamp":ze.INCR,"decrement-clamp":ze.DECR,"increment-wrap":ze.INCR_WRAP,"decrement-wrap":ze.DECR_WRAP},this.resetState()}onRenderTargetChange(ze){if(this._activeRenderTarget===ze)return;this._activeRenderTarget=ze;let Gr=this._renderTargetStencilState[ze.uid];Gr||(Gr=this._renderTargetStencilState[ze.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this.setStencilMode(Gr.stencilMode,Gr.stencilReference)}resetState(){this._stencilCache.enabled=!1,this._stencilCache.stencilMode=STENCIL_MODES.NONE,this._stencilCache.stencilReference=0}setStencilMode(ze,Gr){const Wr=this._renderTargetStencilState[this._activeRenderTarget.uid],Kr=this._gl,Zr=GpuStencilModesToPixi[ze],Qr=this._stencilCache;if(Wr.stencilMode=ze,Wr.stencilReference=Gr,ze===STENCIL_MODES.DISABLED){this._stencilCache.enabled&&(this._stencilCache.enabled=!1,Kr.disable(Kr.STENCIL_TEST));return}this._stencilCache.enabled||(this._stencilCache.enabled=!0,Kr.enable(Kr.STENCIL_TEST)),(ze!==Qr.stencilMode||Qr.stencilReference!==Gr)&&(Qr.stencilMode=ze,Qr.stencilReference=Gr,Kr.stencilFunc(this._comparisonFuncMapping[Zr.stencilBack.compare],Gr,255),Kr.stencilOp(Kr.KEEP,Kr.KEEP,this._stencilOpsMapping[Zr.stencilBack.passOp]))}}GlStencilSystem.extension={type:[ExtensionType.WebGLSystem],name:"stencil"};class UboSystem{constructor(ze){this._syncFunctionHash=Object.create(null),this._adaptor=ze,this._systemCheck()}_systemCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(ze){const Gr=this.getUniformGroupData(ze);ze.buffer||(ze.buffer=new Buffer({data:new Float32Array(Gr.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}))}getUniformGroupData(ze){return this._syncFunctionHash[ze._signature]||this._initUniformGroup(ze)}_initUniformGroup(ze){const Gr=ze._signature;let Wr=this._syncFunctionHash[Gr];if(!Wr){const Kr=Object.keys(ze.uniformStructures).map(Jr=>ze.uniformStructures[Jr]),Zr=this._adaptor.createUboElements(Kr),Qr=this._generateUboSync(Zr.uboElements);Wr=this._syncFunctionHash[Gr]={layout:Zr,syncFunction:Qr}}return this._syncFunctionHash[Gr]}_generateUboSync(ze){return this._adaptor.generateUboSync(ze)}syncUniformGroup(ze,Gr,Wr){const Kr=this.getUniformGroupData(ze);ze.buffer||(ze.buffer=new Buffer({data:new Float32Array(Kr.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}));let Zr=null;return Gr||(Gr=ze.buffer.data,Zr=ze.buffer.dataInt32),Wr||(Wr=0),Kr.syncFunction(ze.uniforms,Gr,Zr,Wr),!0}updateUniformGroup(ze){if(ze.isStatic&&!ze._dirtyId)return!1;ze._dirtyId=0;const Gr=this.syncUniformGroup(ze);return ze.buffer.update(),Gr}destroy(){this._syncFunctionHash=null}}const WGSL_TO_STD40_SIZE={f32:4,i32:4,"vec2<f32>":8,"vec3<f32>":12,"vec4<f32>":16,"vec2<i32>":8,"vec3<i32>":12,"vec4<i32>":16,"mat2x2<f32>":16*2,"mat3x3<f32>":16*3,"mat4x4<f32>":16*4};function createUboElementsSTD40(Yr){const ze=Yr.map(Zr=>({data:Zr,offset:0,size:0})),Gr=16;let Wr=0,Kr=0;for(let Zr=0;Zr<ze.length;Zr++){const Qr=ze[Zr];if(Wr=WGSL_TO_STD40_SIZE[Qr.data.type],!Wr)throw new Error(`Unknown type ${Qr.data.type}`);Qr.data.size>1&&(Wr=Math.max(Wr,Gr)*Qr.data.size);const Jr=Wr===12?16:Wr;Qr.size=Wr;const ei=Kr%Gr;ei>0&&Gr-ei<Jr?Kr+=(Gr-ei)%16:Kr+=(Wr-ei%Wr)%Wr,Qr.offset=Kr,Kr+=Wr}return Kr=Math.ceil(Kr/16)*16,{uboElements:ze,size:Kr}}const uniformParsers=[{type:"mat3x3<f32>",test:Yr=>Yr.value.a!==void 0,ubo:`
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,uniform:`
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `},{type:"vec4<f32>",test:Yr=>Yr.type==="vec4<f32>"&&Yr.size===1&&Yr.value.width!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `},{type:"vec2<f32>",test:Yr=>Yr.type==="vec2<f32>"&&Yr.size===1&&Yr.value.x!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `},{type:"vec4<f32>",test:Yr=>Yr.type==="vec4<f32>"&&Yr.size===1&&Yr.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `},{type:"vec3<f32>",test:Yr=>Yr.type==="vec3<f32>"&&Yr.size===1&&Yr.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `}];function createUboSyncFunction(Yr,ze,Gr,Wr){const Kr=[`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];let Zr=0;for(let Jr=0;Jr<Yr.length;Jr++){const ei=Yr[Jr],ti=ei.data.name;let ri=!1,ii=0;for(let si=0;si<uniformParsers.length;si++)if(uniformParsers[si].test(ei.data)){ii=ei.offset/4,Kr.push(`name = "${ti}";`,`offset += ${ii-Zr};`,uniformParsers[si][ze]||uniformParsers[si].ubo),ri=!0;break}if(!ri)if(ei.data.size>1)ii=ei.offset/4,Kr.push(Gr(ei,ii-Zr));else{const si=Wr[ei.data.type];ii=ei.offset/4,Kr.push(`
                    v = uv.${ti};
                    offset += ${ii-Zr};
                    ${si};
                `)}Zr=ii}const Qr=Kr.join(`
`);return new Function("uv","data","dataInt32","offset",Qr)}function loopMatrix(Yr,ze){return`
        for (let i = 0; i < ${Yr*ze}; i++) {
            data[offset + (((i / ${Yr})|0) * 4) + (i % ${Yr})] = v[i];
        }
    `}const uboSyncFunctionsSTD40={f32:`
        data[offset] = v;`,i32:`
        dataInt32[offset] = v;`,"vec2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];`,"vec3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,"vec4<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,"vec2<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,"vec3<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,"vec4<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,"mat3x3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,"mat4x4<f32>":`
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,"mat3x2<f32>":loopMatrix(3,2),"mat4x2<f32>":loopMatrix(4,2),"mat2x3<f32>":loopMatrix(2,3),"mat4x3<f32>":loopMatrix(4,3),"mat2x4<f32>":loopMatrix(2,4),"mat3x4<f32>":loopMatrix(3,4)},uboSyncFunctionsWGSL={...uboSyncFunctionsSTD40,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `};function generateArraySyncSTD40(Yr,ze){const Gr=Math.max(WGSL_TO_STD40_SIZE[Yr.data.type]/16,1),Wr=Yr.data.value.length/Yr.data.size,Kr=(4-Wr%4)%4,Zr=Yr.data.type.indexOf("i32")>=0?"dataInt32":"data";return`
        v = uv.${Yr.data.name};
        offset += ${ze};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${Yr.data.size*Gr}; i++)
        {
            for(var j = 0; j < ${Wr}; j++)
            {
                ${Zr}[arrayOffset++] = v[t++];
            }
            ${Kr!==0?`arrayOffset += ${Kr};`:""}
        }
    `}function createUboSyncFunctionSTD40(Yr){return createUboSyncFunction(Yr,"uboStd40",generateArraySyncSTD40,uboSyncFunctionsSTD40)}class GlUboSystem extends UboSystem{constructor(){super({createUboElements:createUboElementsSTD40,generateUboSync:createUboSyncFunctionSTD40})}}GlUboSystem.extension={type:[ExtensionType.WebGLSystem],name:"ubo"};class GlRenderTargetAdaptor{constructor(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new Rectangle}init(ze,Gr){this._renderer=ze,this._renderTargetSystem=Gr,ze.runners.contextChange.add(this)}contextChange(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new Rectangle}copyToTexture(ze,Gr,Wr,Kr,Zr){const Qr=this._renderTargetSystem,Jr=this._renderer,ei=Qr.getGpuRenderTarget(ze),ti=Jr.gl;return this.finishRenderPass(ze),ti.bindFramebuffer(ti.FRAMEBUFFER,ei.resolveTargetFramebuffer),Jr.texture.bind(Gr,0),ti.copyTexSubImage2D(ti.TEXTURE_2D,0,Zr.x,Zr.y,Wr.x,Wr.y,Kr.width,Kr.height),Gr}startRenderPass(ze,Gr=!0,Wr,Kr){const Zr=this._renderTargetSystem,Qr=ze.colorTexture,Jr=Zr.getGpuRenderTarget(ze);let ei=Kr.y;ze.isRoot&&(ei=Qr.pixelHeight-Kr.height),ze.colorTextures.forEach(ii=>{this._renderer.texture.unbind(ii)});const ti=this._renderer.gl;ti.bindFramebuffer(ti.FRAMEBUFFER,Jr.framebuffer);const ri=this._viewPortCache;(ri.x!==Kr.x||ri.y!==ei||ri.width!==Kr.width||ri.height!==Kr.height)&&(ri.x=Kr.x,ri.y=ei,ri.width=Kr.width,ri.height=Kr.height,ti.viewport(Kr.x,ei,Kr.width,Kr.height)),!Jr.depthStencilRenderBuffer&&(ze.stencil||ze.depth)&&this._initStencil(Jr),this.clear(ze,Gr,Wr)}finishRenderPass(ze){const Wr=this._renderTargetSystem.getGpuRenderTarget(ze);if(!Wr.msaa)return;const Kr=this._renderer.gl;Kr.bindFramebuffer(Kr.FRAMEBUFFER,Wr.resolveTargetFramebuffer),Kr.bindFramebuffer(Kr.READ_FRAMEBUFFER,Wr.framebuffer),Kr.blitFramebuffer(0,0,Wr.width,Wr.height,0,0,Wr.width,Wr.height,Kr.COLOR_BUFFER_BIT,Kr.NEAREST),Kr.bindFramebuffer(Kr.FRAMEBUFFER,Wr.framebuffer)}initGpuRenderTarget(ze){const Wr=this._renderer.gl,Kr=new GlRenderTarget,Zr=ze.colorTexture;return CanvasSource.test(Zr.resource)?(this._renderer.context.ensureCanvasSize(ze.colorTexture.resource),Kr.framebuffer=null,Kr):(this._initColor(ze,Kr),Wr.bindFramebuffer(Wr.FRAMEBUFFER,null),Kr)}destroyGpuRenderTarget(ze){const Gr=this._renderer.gl;ze.framebuffer&&(Gr.deleteFramebuffer(ze.framebuffer),ze.framebuffer=null),ze.resolveTargetFramebuffer&&(Gr.deleteFramebuffer(ze.resolveTargetFramebuffer),ze.resolveTargetFramebuffer=null),ze.depthStencilRenderBuffer&&(Gr.deleteRenderbuffer(ze.depthStencilRenderBuffer),ze.depthStencilRenderBuffer=null),ze.msaaRenderBuffer.forEach(Wr=>{Gr.deleteRenderbuffer(Wr)}),ze.msaaRenderBuffer=null}clear(ze,Gr,Wr){if(!Gr)return;const Kr=this._renderTargetSystem;typeof Gr=="boolean"&&(Gr=Gr?CLEAR.ALL:CLEAR.NONE);const Zr=this._renderer.gl;if(Gr&CLEAR.COLOR){Wr??(Wr=Kr.defaultClearColor);const Qr=this._clearColorCache,Jr=Wr;(Qr[0]!==Jr[0]||Qr[1]!==Jr[1]||Qr[2]!==Jr[2]||Qr[3]!==Jr[3])&&(Qr[0]=Jr[0],Qr[1]=Jr[1],Qr[2]=Jr[2],Qr[3]=Jr[3],Zr.clearColor(Jr[0],Jr[1],Jr[2],Jr[3]))}Zr.clear(Gr)}resizeGpuRenderTarget(ze){if(ze.isRoot)return;const Wr=this._renderTargetSystem.getGpuRenderTarget(ze);this._resizeColor(ze,Wr),(ze.stencil||ze.depth)&&this._resizeStencil(Wr)}_initColor(ze,Gr){const Wr=this._renderer,Kr=Wr.gl,Zr=Kr.createFramebuffer();if(Gr.resolveTargetFramebuffer=Zr,Kr.bindFramebuffer(Kr.FRAMEBUFFER,Zr),Gr.width=ze.colorTexture.source.pixelWidth,Gr.height=ze.colorTexture.source.pixelHeight,ze.colorTextures.forEach((Qr,Jr)=>{const ei=Qr.source;ei.antialias&&(Wr.context.supports.msaa?Gr.msaa=!0:warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1")),Wr.texture.bindSource(ei,0);const ri=Wr.texture.getGlSource(ei).texture;Kr.framebufferTexture2D(Kr.FRAMEBUFFER,Kr.COLOR_ATTACHMENT0+Jr,3553,ri,0)}),Gr.msaa){const Qr=Kr.createFramebuffer();Gr.framebuffer=Qr,Kr.bindFramebuffer(Kr.FRAMEBUFFER,Qr),ze.colorTextures.forEach((Jr,ei)=>{const ti=Kr.createRenderbuffer();Gr.msaaRenderBuffer[ei]=ti})}else Gr.framebuffer=Zr;this._resizeColor(ze,Gr)}_resizeColor(ze,Gr){const Wr=ze.colorTexture.source;if(Gr.width=Wr.pixelWidth,Gr.height=Wr.pixelHeight,ze.colorTextures.forEach((Kr,Zr)=>{Zr!==0&&Kr.source.resize(Wr.width,Wr.height,Wr._resolution)}),Gr.msaa){const Kr=this._renderer,Zr=Kr.gl,Qr=Gr.framebuffer;Zr.bindFramebuffer(Zr.FRAMEBUFFER,Qr),ze.colorTextures.forEach((Jr,ei)=>{const ti=Jr.source;Kr.texture.bindSource(ti,0);const ii=Kr.texture.getGlSource(ti).internalFormat,si=Gr.msaaRenderBuffer[ei];Zr.bindRenderbuffer(Zr.RENDERBUFFER,si),Zr.renderbufferStorageMultisample(Zr.RENDERBUFFER,4,ii,ti.pixelWidth,ti.pixelHeight),Zr.framebufferRenderbuffer(Zr.FRAMEBUFFER,Zr.COLOR_ATTACHMENT0+ei,Zr.RENDERBUFFER,si)})}}_initStencil(ze){if(ze.framebuffer===null)return;const Gr=this._renderer.gl,Wr=Gr.createRenderbuffer();ze.depthStencilRenderBuffer=Wr,Gr.bindRenderbuffer(Gr.RENDERBUFFER,Wr),Gr.framebufferRenderbuffer(Gr.FRAMEBUFFER,Gr.DEPTH_STENCIL_ATTACHMENT,Gr.RENDERBUFFER,Wr),this._resizeStencil(ze)}_resizeStencil(ze){const Gr=this._renderer.gl;Gr.bindRenderbuffer(Gr.RENDERBUFFER,ze.depthStencilRenderBuffer),ze.msaa?Gr.renderbufferStorageMultisample(Gr.RENDERBUFFER,4,Gr.DEPTH24_STENCIL8,ze.width,ze.height):Gr.renderbufferStorage(Gr.RENDERBUFFER,this._renderer.context.webGLVersion===2?Gr.DEPTH24_STENCIL8:Gr.DEPTH_STENCIL,ze.width,ze.height)}prerender(ze){const Gr=ze.colorTexture.resource;this._renderer.context.multiView&&CanvasSource.test(Gr)&&this._renderer.context.ensureCanvasSize(Gr)}postrender(ze){if(this._renderer.context.multiView&&CanvasSource.test(ze.colorTexture.resource)){const Gr=this._renderer.context.canvas,Wr=ze.colorTexture;Wr.context2D.drawImage(Gr,0,Wr.pixelHeight-Gr.height)}}}function calculateProjection(Yr,ze,Gr,Wr,Kr,Zr){const Qr=Zr?1:-1;return Yr.identity(),Yr.a=1/Wr*2,Yr.d=Qr*(1/Kr*2),Yr.tx=-1-ze*Yr.a,Yr.ty=-Qr-Gr*Yr.d,Yr}const canvasCache=new Map;function getCanvasTexture(Yr,ze){if(!canvasCache.has(Yr)){const Gr=new Texture({source:new CanvasSource({resource:Yr,...ze})}),Wr=()=>{canvasCache.get(Yr)===Gr&&canvasCache.delete(Yr)};Gr.once("destroy",Wr),Gr.source.once("destroy",Wr),canvasCache.set(Yr,Gr)}return canvasCache.get(Yr)}function isRenderingToScreen(Yr){const ze=Yr.colorTexture.source.resource;return globalThis.HTMLCanvasElement&&ze instanceof HTMLCanvasElement&&document.body.contains(ze)}const _RenderTarget=class Gs{constructor(ze={}){if(this.uid=uid$1("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),this._managedColorTextures=!1,ze={...Gs.defaultOptions,...ze},this.stencil=ze.stencil,this.depth=ze.depth,this.isRoot=ze.isRoot,typeof ze.colorTextures=="number"){this._managedColorTextures=!0;for(let Gr=0;Gr<ze.colorTextures;Gr++)this.colorTextures.push(new TextureSource({width:ze.width,height:ze.height,resolution:ze.resolution,antialias:ze.antialias}))}else{this.colorTextures=[...ze.colorTextures.map(Wr=>Wr.source)];const Gr=this.colorTexture.source;this.resize(Gr.width,Gr.height,Gr._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),(ze.depthStencilTexture||this.stencil)&&(ze.depthStencilTexture instanceof Texture||ze.depthStencilTexture instanceof TextureSource?this.depthStencilTexture=ze.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const ze=this._size;return ze[0]=this.pixelWidth,ze[1]=this.pixelHeight,ze}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(ze){this.resize(ze.width,ze.height,ze._resolution,!0)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new TextureSource({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:!1,antialias:!1,mipLevelCount:1}))}resize(ze,Gr,Wr=this.resolution,Kr=!1){this.dirtyId++,this.colorTextures.forEach((Zr,Qr)=>{Kr&&Qr===0||Zr.source.resize(ze,Gr,Wr)}),this.depthStencilTexture&&this.depthStencilTexture.source.resize(ze,Gr,Wr)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this._managedColorTextures&&this.colorTextures.forEach(ze=>{ze.destroy()}),this.depthStencilTexture&&(this.depthStencilTexture.destroy(),delete this.depthStencilTexture)}};_RenderTarget.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:!1,depth:!1,antialias:!1,isRoot:!1};let RenderTarget=_RenderTarget;class RenderTargetSystem{constructor(ze){this.rootViewPort=new Rectangle,this.viewport=new Rectangle,this.onRenderTargetChange=new SystemRunner("onRenderTargetChange"),this.projectionMatrix=new Matrix,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=ze,ze.renderableGC.addManagedHash(this,"_gpuRenderTargetHash")}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target:ze,clear:Gr,clearColor:Wr,frame:Kr}){var Zr,Qr;this._renderTargetStack.length=0,this.push(ze,Gr,Wr,Kr),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=isRenderingToScreen(this.rootRenderTarget),(Qr=(Zr=this.adaptor).prerender)==null||Qr.call(Zr,this.rootRenderTarget)}postrender(){var ze,Gr;(Gr=(ze=this.adaptor).postrender)==null||Gr.call(ze,this.rootRenderTarget)}bind(ze,Gr=!0,Wr,Kr){const Zr=this.getRenderTarget(ze),Qr=this.renderTarget!==Zr;this.renderTarget=Zr,this.renderSurface=ze;const Jr=this.getGpuRenderTarget(Zr);(Zr.pixelWidth!==Jr.width||Zr.pixelHeight!==Jr.height)&&(this.adaptor.resizeGpuRenderTarget(Zr),Jr.width=Zr.pixelWidth,Jr.height=Zr.pixelHeight);const ei=Zr.colorTexture,ti=this.viewport,ri=ei.pixelWidth,ii=ei.pixelHeight;if(!Kr&&ze instanceof Texture&&(Kr=ze.frame),Kr){const si=ei._resolution;ti.x=Kr.x*si+.5|0,ti.y=Kr.y*si+.5|0,ti.width=Kr.width*si+.5|0,ti.height=Kr.height*si+.5|0}else ti.x=0,ti.y=0,ti.width=ri,ti.height=ii;return calculateProjection(this.projectionMatrix,0,0,ti.width/ei.resolution,ti.height/ei.resolution,!Zr.isRoot),this.adaptor.startRenderPass(Zr,Gr,Wr,ti),Qr&&this.onRenderTargetChange.emit(Zr),Zr}clear(ze,Gr=CLEAR.ALL,Wr){Gr&&(ze&&(ze=this.getRenderTarget(ze)),this.adaptor.clear(ze||this.renderTarget,Gr,Wr,this.viewport))}contextChange(){this._gpuRenderTargetHash=Object.create(null)}push(ze,Gr=CLEAR.ALL,Wr,Kr){const Zr=this.bind(ze,Gr,Wr,Kr);return this._renderTargetStack.push({renderTarget:Zr,frame:Kr}),Zr}pop(){this._renderTargetStack.pop();const ze=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(ze.renderTarget,!1,null,ze.frame)}getRenderTarget(ze){return ze.isTexture&&(ze=ze.source),this._renderSurfaceToRenderTargetHash.get(ze)??this._initRenderTarget(ze)}copyToTexture(ze,Gr,Wr,Kr,Zr){Wr.x<0&&(Kr.width+=Wr.x,Zr.x-=Wr.x,Wr.x=0),Wr.y<0&&(Kr.height+=Wr.y,Zr.y-=Wr.y,Wr.y=0);const{pixelWidth:Qr,pixelHeight:Jr}=ze;return Kr.width=Math.min(Kr.width,Qr-Wr.x),Kr.height=Math.min(Kr.height,Jr-Wr.y),this.adaptor.copyToTexture(ze,Gr,Wr,Kr,Zr)}ensureDepthStencil(){this.renderTarget.stencil||(this.renderTarget.stencil=!0,this.adaptor.startRenderPass(this.renderTarget,!1,null,this.viewport))}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach((ze,Gr)=>{ze!==Gr&&ze.destroy()}),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(ze){let Gr=null;return CanvasSource.test(ze)&&(ze=getCanvasTexture(ze).source),ze instanceof RenderTarget?Gr=ze:ze instanceof TextureSource&&(Gr=new RenderTarget({colorTextures:[ze]}),CanvasSource.test(ze.source.resource)&&(Gr.isRoot=!0),ze.once("destroy",()=>{Gr.destroy(),this._renderSurfaceToRenderTargetHash.delete(ze);const Wr=this._gpuRenderTargetHash[Gr.uid];Wr&&(this._gpuRenderTargetHash[Gr.uid]=null,this.adaptor.destroyGpuRenderTarget(Wr))})),this._renderSurfaceToRenderTargetHash.set(ze,Gr),Gr}getGpuRenderTarget(ze){return this._gpuRenderTargetHash[ze.uid]||(this._gpuRenderTargetHash[ze.uid]=this.adaptor.initGpuRenderTarget(ze))}resetState(){this.renderTarget=null,this.renderSurface=null}}class GlRenderTargetSystem extends RenderTargetSystem{constructor(ze){super(ze),this.adaptor=new GlRenderTargetAdaptor,this.adaptor.init(ze,this)}}GlRenderTargetSystem.extension={type:[ExtensionType.WebGLSystem],name:"renderTarget"};class BufferResource extends EventEmitter{constructor({buffer:ze,offset:Gr,size:Wr}){super(),this.uid=uid$1("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=uid$1("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=ze,this.offset=Gr|0,this.size=Wr,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=uid$1("resource"),this.emit("change",this)}destroy(ze=!1){this.destroyed=!0,ze&&this.buffer.destroy(),this.emit("change",this),this.buffer=null}}function generateShaderSyncCode(Yr,ze){const Gr=[],Wr=[`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];let Kr=!1,Zr=0;const Qr=ze._getProgramData(Yr.glProgram);for(const ei in Yr.groups){const ti=Yr.groups[ei];Gr.push(`
            resources = g[${ei}].resources;
        `);for(const ri in ti.resources){const ii=ti.resources[ri];if(ii instanceof UniformGroup)if(ii.ubo){const si=Yr._uniformBindMap[ei][Number(ri)];Gr.push(`
                        sS.bindUniformBlock(
                            resources[${ri}],
                            '${si}',
                            ${Yr.glProgram._uniformBlockData[si].index}
                        );
                    `)}else Gr.push(`
                        ugS.updateUniformGroup(resources[${ri}], p, sD);
                    `);else if(ii instanceof BufferResource){const si=Yr._uniformBindMap[ei][Number(ri)];Gr.push(`
                    sS.bindUniformBlock(
                        resources[${ri}],
                        '${si}',
                        ${Yr.glProgram._uniformBlockData[si].index}
                    );
                `)}else if(ii instanceof TextureSource){const si=Yr._uniformBindMap[ei][ri],ni=Qr.uniformData[si];ni&&(Kr||(Kr=!0,Wr.push(`
                        var tS = r.texture;
                        `)),ze._gl.uniform1i(ni.location,Zr),Gr.push(`
                        tS.bind(resources[${ri}], ${Zr});
                    `),Zr++)}}}const Jr=[...Wr,...Gr].join(`
`);return new Function("r","s","sD",Jr)}class GlProgramData{constructor(ze,Gr){this.program=ze,this.uniformData=Gr,this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBlockBindings={}}destroy(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBlockBindings=null,this.program=null}}function compileShader(Yr,ze,Gr){const Wr=Yr.createShader(ze);return Yr.shaderSource(Wr,Gr),Yr.compileShader(Wr),Wr}function booleanArray(Yr){const ze=new Array(Yr);for(let Gr=0;Gr<ze.length;Gr++)ze[Gr]=!1;return ze}function defaultValue(Yr,ze){switch(Yr){case"float":return 0;case"vec2":return new Float32Array(2*ze);case"vec3":return new Float32Array(3*ze);case"vec4":return new Float32Array(4*ze);case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"ivec2":return new Int32Array(2*ze);case"ivec3":return new Int32Array(3*ze);case"ivec4":return new Int32Array(4*ze);case"uvec2":return new Uint32Array(2*ze);case"uvec3":return new Uint32Array(3*ze);case"uvec4":return new Uint32Array(4*ze);case"bool":return!1;case"bvec2":return booleanArray(2*ze);case"bvec3":return booleanArray(3*ze);case"bvec4":return booleanArray(4*ze);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}let GL_TABLE=null;const GL_TO_GLSL_TYPES={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"},GLSL_TO_VERTEX_TYPES={float:"float32",vec2:"float32x2",vec3:"float32x3",vec4:"float32x4",int:"sint32",ivec2:"sint32x2",ivec3:"sint32x3",ivec4:"sint32x4",uint:"uint32",uvec2:"uint32x2",uvec3:"uint32x3",uvec4:"uint32x4",bool:"uint32",bvec2:"uint32x2",bvec3:"uint32x3",bvec4:"uint32x4"};function mapType(Yr,ze){if(!GL_TABLE){const Gr=Object.keys(GL_TO_GLSL_TYPES);GL_TABLE={};for(let Wr=0;Wr<Gr.length;++Wr){const Kr=Gr[Wr];GL_TABLE[Yr[Kr]]=GL_TO_GLSL_TYPES[Kr]}}return GL_TABLE[ze]}function mapGlToVertexFormat(Yr,ze){const Gr=mapType(Yr,ze);return GLSL_TO_VERTEX_TYPES[Gr]||"float32"}function extractAttributesFromGlProgram(Yr,ze,Gr=!1){const Wr={},Kr=ze.getProgramParameter(Yr,ze.ACTIVE_ATTRIBUTES);for(let Qr=0;Qr<Kr;Qr++){const Jr=ze.getActiveAttrib(Yr,Qr);if(Jr.name.startsWith("gl_"))continue;const ei=mapGlToVertexFormat(ze,Jr.type);Wr[Jr.name]={location:0,format:ei,stride:getAttributeInfoFromFormat(ei).stride,offset:0,instance:!1,start:0}}const Zr=Object.keys(Wr);if(Gr){Zr.sort((Qr,Jr)=>Qr>Jr?1:-1);for(let Qr=0;Qr<Zr.length;Qr++)Wr[Zr[Qr]].location=Qr,ze.bindAttribLocation(Yr,Qr,Zr[Qr]);ze.linkProgram(Yr)}else for(let Qr=0;Qr<Zr.length;Qr++)Wr[Zr[Qr]].location=ze.getAttribLocation(Yr,Zr[Qr]);return Wr}function getUboData(Yr,ze){if(!ze.ACTIVE_UNIFORM_BLOCKS)return{};const Gr={},Wr=ze.getProgramParameter(Yr,ze.ACTIVE_UNIFORM_BLOCKS);for(let Kr=0;Kr<Wr;Kr++){const Zr=ze.getActiveUniformBlockName(Yr,Kr),Qr=ze.getUniformBlockIndex(Yr,Zr),Jr=ze.getActiveUniformBlockParameter(Yr,Kr,ze.UNIFORM_BLOCK_DATA_SIZE);Gr[Zr]={name:Zr,index:Qr,size:Jr}}return Gr}function getUniformData(Yr,ze){const Gr={},Wr=ze.getProgramParameter(Yr,ze.ACTIVE_UNIFORMS);for(let Kr=0;Kr<Wr;Kr++){const Zr=ze.getActiveUniform(Yr,Kr),Qr=Zr.name.replace(/\[.*?\]$/,""),Jr=!!Zr.name.match(/\[.*?\]$/),ei=mapType(ze,Zr.type);Gr[Qr]={name:Qr,index:Kr,type:ei,size:Zr.size,isArray:Jr,value:defaultValue(ei,Zr.size)}}return Gr}function logPrettyShaderError(Yr,ze){const Gr=Yr.getShaderSource(ze).split(`
`).map((ti,ri)=>`${ri}: ${ti}`),Wr=Yr.getShaderInfoLog(ze),Kr=Wr.split(`
`),Zr={},Qr=Kr.map(ti=>parseFloat(ti.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1"))).filter(ti=>ti&&!Zr[ti]?(Zr[ti]=!0,!0):!1),Jr=[""];Qr.forEach(ti=>{Gr[ti-1]=`%c${Gr[ti-1]}%c`,Jr.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")});const ei=Gr.join(`
`);Jr[0]=ei,console.error(Wr),console.groupCollapsed("click to view full shader code"),console.warn(...Jr),console.groupEnd()}function logProgramError(Yr,ze,Gr,Wr){Yr.getProgramParameter(ze,Yr.LINK_STATUS)||(Yr.getShaderParameter(Gr,Yr.COMPILE_STATUS)||logPrettyShaderError(Yr,Gr),Yr.getShaderParameter(Wr,Yr.COMPILE_STATUS)||logPrettyShaderError(Yr,Wr),console.error("PixiJS Error: Could not initialize shader."),Yr.getProgramInfoLog(ze)!==""&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",Yr.getProgramInfoLog(ze)))}function generateProgram(Yr,ze){const Gr=compileShader(Yr,Yr.VERTEX_SHADER,ze.vertex),Wr=compileShader(Yr,Yr.FRAGMENT_SHADER,ze.fragment),Kr=Yr.createProgram();Yr.attachShader(Kr,Gr),Yr.attachShader(Kr,Wr);const Zr=ze.transformFeedbackVaryings;Zr&&(typeof Yr.transformFeedbackVaryings!="function"?warn("TransformFeedback is not supported but TransformFeedbackVaryings are given."):Yr.transformFeedbackVaryings(Kr,Zr.names,Zr.bufferMode==="separate"?Yr.SEPARATE_ATTRIBS:Yr.INTERLEAVED_ATTRIBS)),Yr.linkProgram(Kr),Yr.getProgramParameter(Kr,Yr.LINK_STATUS)||logProgramError(Yr,Kr,Gr,Wr),ze._attributeData=extractAttributesFromGlProgram(Kr,Yr,!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(ze.vertex)),ze._uniformData=getUniformData(Kr,Yr),ze._uniformBlockData=getUboData(Kr,Yr),Yr.deleteShader(Gr),Yr.deleteShader(Wr);const Qr={};for(const ei in ze._uniformData){const ti=ze._uniformData[ei];Qr[ei]={location:Yr.getUniformLocation(Kr,ei),value:defaultValue(ti.type,ti.size)}}return new GlProgramData(Kr,Qr)}const defaultSyncData={textureCount:0,blockIndex:0};class GlShaderSystem{constructor(ze){this._activeProgram=null,this._programDataHash=Object.create(null),this._shaderSyncFunctions=Object.create(null),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_programDataHash")}contextChange(ze){this._gl=ze,this._programDataHash=Object.create(null),this._shaderSyncFunctions=Object.create(null),this._activeProgram=null,this.maxTextures=getMaxTexturesPerBatch()}bind(ze,Gr){if(this._setProgram(ze.glProgram),Gr)return;defaultSyncData.textureCount=0,defaultSyncData.blockIndex=0;let Wr=this._shaderSyncFunctions[ze.glProgram._key];Wr||(Wr=this._shaderSyncFunctions[ze.glProgram._key]=this._generateShaderSync(ze,this)),this._renderer.buffer.nextBindBase(!!ze.glProgram.transformFeedbackVaryings),Wr(this._renderer,ze,defaultSyncData)}updateUniformGroup(ze){this._renderer.uniformGroup.updateUniformGroup(ze,this._activeProgram,defaultSyncData)}bindUniformBlock(ze,Gr,Wr=0){const Kr=this._renderer.buffer,Zr=this._getProgramData(this._activeProgram),Qr=ze._bufferResource;Qr||this._renderer.ubo.updateUniformGroup(ze);const Jr=ze.buffer,ei=Kr.updateBuffer(Jr),ti=Kr.freeLocationForBufferBase(ei);if(Qr){const{offset:ii,size:si}=ze;ii===0&&si===Jr.data.byteLength?Kr.bindBufferBase(ei,ti):Kr.bindBufferRange(ei,ti,ii)}else Kr.getLastBindBaseLocation(ei)!==ti&&Kr.bindBufferBase(ei,ti);const ri=this._activeProgram._uniformBlockData[Gr].index;Zr.uniformBlockBindings[Wr]!==ti&&(Zr.uniformBlockBindings[Wr]=ti,this._renderer.gl.uniformBlockBinding(Zr.program,ri,ti))}_setProgram(ze){if(this._activeProgram===ze)return;this._activeProgram=ze;const Gr=this._getProgramData(ze);this._gl.useProgram(Gr.program)}_getProgramData(ze){return this._programDataHash[ze._key]||this._createProgramData(ze)}_createProgramData(ze){const Gr=ze._key;return this._programDataHash[Gr]=generateProgram(this._gl,ze),this._programDataHash[Gr]}destroy(){for(const ze of Object.keys(this._programDataHash))this._programDataHash[ze].destroy(),this._programDataHash[ze]=null;this._programDataHash=null}_generateShaderSync(ze,Gr){return generateShaderSyncCode(ze,Gr)}resetState(){this._activeProgram=null}}GlShaderSystem.extension={type:[ExtensionType.WebGLSystem],name:"shader"};const UNIFORM_TO_SINGLE_SETTERS={f32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,"vec2<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,"vec3<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,"vec4<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,i32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,"vec2<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,"vec3<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,"vec4<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,u32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,"vec2<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,"vec3<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,"vec4<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,bool:`if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,"vec2<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,"vec3<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,"vec4<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,"mat2x2<f32>":"gl.uniformMatrix2fv(location, false, v);","mat3x3<f32>":"gl.uniformMatrix3fv(location, false, v);","mat4x4<f32>":"gl.uniformMatrix4fv(location, false, v);"},UNIFORM_TO_ARRAY_SETTERS={f32:"gl.uniform1fv(location, v);","vec2<f32>":"gl.uniform2fv(location, v);","vec3<f32>":"gl.uniform3fv(location, v);","vec4<f32>":"gl.uniform4fv(location, v);","mat2x2<f32>":"gl.uniformMatrix2fv(location, false, v);","mat3x3<f32>":"gl.uniformMatrix3fv(location, false, v);","mat4x4<f32>":"gl.uniformMatrix4fv(location, false, v);",i32:"gl.uniform1iv(location, v);","vec2<i32>":"gl.uniform2iv(location, v);","vec3<i32>":"gl.uniform3iv(location, v);","vec4<i32>":"gl.uniform4iv(location, v);",u32:"gl.uniform1iv(location, v);","vec2<u32>":"gl.uniform2iv(location, v);","vec3<u32>":"gl.uniform3iv(location, v);","vec4<u32>":"gl.uniform4iv(location, v);",bool:"gl.uniform1iv(location, v);","vec2<bool>":"gl.uniform2iv(location, v);","vec3<bool>":"gl.uniform3iv(location, v);","vec4<bool>":"gl.uniform4iv(location, v);"};function generateUniformsSync(Yr,ze){const Gr=[`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];for(const Wr in Yr.uniforms){if(!ze[Wr]){Yr.uniforms[Wr]instanceof UniformGroup?Yr.uniforms[Wr].ubo?Gr.push(`
                        renderer.shader.bindUniformBlock(uv.${Wr}, "${Wr}");
                    `):Gr.push(`
                        renderer.shader.updateUniformGroup(uv.${Wr});
                    `):Yr.uniforms[Wr]instanceof BufferResource&&Gr.push(`
                        renderer.shader.bindBufferResource(uv.${Wr}, "${Wr}");
                    `);continue}const Kr=Yr.uniformStructures[Wr];let Zr=!1;for(let Qr=0;Qr<uniformParsers.length;Qr++){const Jr=uniformParsers[Qr];if(Kr.type===Jr.type&&Jr.test(Kr)){Gr.push(`name = "${Wr}";`,uniformParsers[Qr].uniform),Zr=!0;break}}if(!Zr){const Jr=(Kr.size===1?UNIFORM_TO_SINGLE_SETTERS:UNIFORM_TO_ARRAY_SETTERS)[Kr.type].replace("location",`ud["${Wr}"].location`);Gr.push(`
            cu = ud["${Wr}"];
            cv = cu.value;
            v = uv["${Wr}"];
            ${Jr};`)}}return new Function("ud","uv","renderer","syncData",Gr.join(`
`))}class GlUniformGroupSystem{constructor(ze){this._cache={},this._uniformGroupSyncHash={},this._renderer=ze,this.gl=null,this._cache={}}contextChange(ze){this.gl=ze}updateUniformGroup(ze,Gr,Wr){const Kr=this._renderer.shader._getProgramData(Gr);(!ze.isStatic||ze._dirtyId!==Kr.uniformDirtyGroups[ze.uid])&&(Kr.uniformDirtyGroups[ze.uid]=ze._dirtyId,this._getUniformSyncFunction(ze,Gr)(Kr.uniformData,ze.uniforms,this._renderer,Wr))}_getUniformSyncFunction(ze,Gr){var Wr;return((Wr=this._uniformGroupSyncHash[ze._signature])==null?void 0:Wr[Gr._key])||this._createUniformSyncFunction(ze,Gr)}_createUniformSyncFunction(ze,Gr){const Wr=this._uniformGroupSyncHash[ze._signature]||(this._uniformGroupSyncHash[ze._signature]={}),Kr=this._getSignature(ze,Gr._uniformData,"u");return this._cache[Kr]||(this._cache[Kr]=this._generateUniformsSync(ze,Gr._uniformData)),Wr[Gr._key]=this._cache[Kr],Wr[Gr._key]}_generateUniformsSync(ze,Gr){return generateUniformsSync(ze,Gr)}_getSignature(ze,Gr,Wr){const Kr=ze.uniforms,Zr=[`${Wr}-`];for(const Qr in Kr)Zr.push(Qr),Gr[Qr]&&Zr.push(Gr[Qr].type);return Zr.join("-")}destroy(){this._renderer=null,this._cache=null}}GlUniformGroupSystem.extension={type:[ExtensionType.WebGLSystem],name:"uniformGroup"};function mapWebGLBlendModesToPixi(Yr){const ze={};if(ze.normal=[Yr.ONE,Yr.ONE_MINUS_SRC_ALPHA],ze.add=[Yr.ONE,Yr.ONE],ze.multiply=[Yr.DST_COLOR,Yr.ONE_MINUS_SRC_ALPHA,Yr.ONE,Yr.ONE_MINUS_SRC_ALPHA],ze.screen=[Yr.ONE,Yr.ONE_MINUS_SRC_COLOR,Yr.ONE,Yr.ONE_MINUS_SRC_ALPHA],ze.none=[0,0],ze["normal-npm"]=[Yr.SRC_ALPHA,Yr.ONE_MINUS_SRC_ALPHA,Yr.ONE,Yr.ONE_MINUS_SRC_ALPHA],ze["add-npm"]=[Yr.SRC_ALPHA,Yr.ONE,Yr.ONE,Yr.ONE],ze["screen-npm"]=[Yr.SRC_ALPHA,Yr.ONE_MINUS_SRC_COLOR,Yr.ONE,Yr.ONE_MINUS_SRC_ALPHA],ze.erase=[Yr.ZERO,Yr.ONE_MINUS_SRC_ALPHA],!(Yr instanceof DOMAdapter.get().getWebGLRenderingContext()))ze.min=[Yr.ONE,Yr.ONE,Yr.ONE,Yr.ONE,Yr.MIN,Yr.MIN],ze.max=[Yr.ONE,Yr.ONE,Yr.ONE,Yr.ONE,Yr.MAX,Yr.MAX];else{const Wr=Yr.getExtension("EXT_blend_minmax");Wr&&(ze.min=[Yr.ONE,Yr.ONE,Yr.ONE,Yr.ONE,Wr.MIN_EXT,Wr.MIN_EXT],ze.max=[Yr.ONE,Yr.ONE,Yr.ONE,Yr.ONE,Wr.MAX_EXT,Wr.MAX_EXT])}return ze}const BLEND=0,OFFSET=1,CULLING=2,DEPTH_TEST=3,WINDING=4,DEPTH_MASK=5,_GlStateSystem=class ms{constructor(ze){this._invertFrontFace=!1,this.gl=null,this.stateId=0,this.polygonOffset=0,this.blendMode="none",this._blendEq=!1,this.map=[],this.map[BLEND]=this.setBlend,this.map[OFFSET]=this.setOffset,this.map[CULLING]=this.setCullFace,this.map[DEPTH_TEST]=this.setDepthTest,this.map[WINDING]=this.setFrontFace,this.map[DEPTH_MASK]=this.setDepthMask,this.checks=[],this.defaultState=State.for2d(),ze.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(ze){this._invertFrontFace=!ze.isRoot,this._cullFace?this.setFrontFace(this._frontFace):this._frontFaceDirty=!0}contextChange(ze){this.gl=ze,this.blendModesMap=mapWebGLBlendModesToPixi(ze),this.resetState()}set(ze){if(ze||(ze=this.defaultState),this.stateId!==ze.data){let Gr=this.stateId^ze.data,Wr=0;for(;Gr;)Gr&1&&this.map[Wr].call(this,!!(ze.data&1<<Wr)),Gr>>=1,Wr++;this.stateId=ze.data}for(let Gr=0;Gr<this.checks.length;Gr++)this.checks[Gr](this,ze)}forceState(ze){ze||(ze=this.defaultState);for(let Gr=0;Gr<this.map.length;Gr++)this.map[Gr].call(this,!!(ze.data&1<<Gr));for(let Gr=0;Gr<this.checks.length;Gr++)this.checks[Gr](this,ze);this.stateId=ze.data}setBlend(ze){this._updateCheck(ms._checkBlendMode,ze),this.gl[ze?"enable":"disable"](this.gl.BLEND)}setOffset(ze){this._updateCheck(ms._checkPolygonOffset,ze),this.gl[ze?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}setDepthTest(ze){this.gl[ze?"enable":"disable"](this.gl.DEPTH_TEST)}setDepthMask(ze){this.gl.depthMask(ze)}setCullFace(ze){this._cullFace=ze,this.gl[ze?"enable":"disable"](this.gl.CULL_FACE),this._cullFace&&this._frontFaceDirty&&this.setFrontFace(this._frontFace)}setFrontFace(ze){this._frontFace=ze,this._frontFaceDirty=!1;const Gr=this._invertFrontFace?!ze:ze;this._glFrontFace!==Gr&&(this._glFrontFace=Gr,this.gl.frontFace(this.gl[Gr?"CW":"CCW"]))}setBlendMode(ze){if(this.blendModesMap[ze]||(ze="normal"),ze===this.blendMode)return;this.blendMode=ze;const Gr=this.blendModesMap[ze],Wr=this.gl;Gr.length===2?Wr.blendFunc(Gr[0],Gr[1]):Wr.blendFuncSeparate(Gr[0],Gr[1],Gr[2],Gr[3]),Gr.length===6?(this._blendEq=!0,Wr.blendEquationSeparate(Gr[4],Gr[5])):this._blendEq&&(this._blendEq=!1,Wr.blendEquationSeparate(Wr.FUNC_ADD,Wr.FUNC_ADD))}setPolygonOffset(ze,Gr){this.gl.polygonOffset(ze,Gr)}resetState(){this._glFrontFace=!1,this._frontFace=!1,this._cullFace=!1,this._frontFaceDirty=!1,this._invertFrontFace=!1,this.gl.frontFace(this.gl.CCW),this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode="",this.setBlendMode("normal")}_updateCheck(ze,Gr){const Wr=this.checks.indexOf(ze);Gr&&Wr===-1?this.checks.push(ze):!Gr&&Wr!==-1&&this.checks.splice(Wr,1)}static _checkBlendMode(ze,Gr){ze.setBlendMode(Gr.blendMode)}static _checkPolygonOffset(ze,Gr){ze.setPolygonOffset(1,Gr.polygonOffset)}destroy(){this.gl=null,this.checks.length=0}};_GlStateSystem.extension={type:[ExtensionType.WebGLSystem],name:"state"};let GlStateSystem=_GlStateSystem;class GlTexture{constructor(ze){this.target=GL_TARGETS.TEXTURE_2D,this.texture=ze,this.width=-1,this.height=-1,this.type=GL_TYPES.UNSIGNED_BYTE,this.internalFormat=GL_FORMATS.RGBA,this.format=GL_FORMATS.RGBA,this.samplerType=0}}const glUploadBufferImageResource={id:"buffer",upload(Yr,ze,Gr){ze.width===Yr.width||ze.height===Yr.height?Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,Yr.width,Yr.height,ze.format,ze.type,Yr.resource):Gr.texImage2D(ze.target,0,ze.internalFormat,Yr.width,Yr.height,0,ze.format,ze.type,Yr.resource),ze.width=Yr.width,ze.height=Yr.height}},compressedFormatMap={"bc1-rgba-unorm":!0,"bc1-rgba-unorm-srgb":!0,"bc2-rgba-unorm":!0,"bc2-rgba-unorm-srgb":!0,"bc3-rgba-unorm":!0,"bc3-rgba-unorm-srgb":!0,"bc4-r-unorm":!0,"bc4-r-snorm":!0,"bc5-rg-unorm":!0,"bc5-rg-snorm":!0,"bc6h-rgb-ufloat":!0,"bc6h-rgb-float":!0,"bc7-rgba-unorm":!0,"bc7-rgba-unorm-srgb":!0,"etc2-rgb8unorm":!0,"etc2-rgb8unorm-srgb":!0,"etc2-rgb8a1unorm":!0,"etc2-rgb8a1unorm-srgb":!0,"etc2-rgba8unorm":!0,"etc2-rgba8unorm-srgb":!0,"eac-r11unorm":!0,"eac-r11snorm":!0,"eac-rg11unorm":!0,"eac-rg11snorm":!0,"astc-4x4-unorm":!0,"astc-4x4-unorm-srgb":!0,"astc-5x4-unorm":!0,"astc-5x4-unorm-srgb":!0,"astc-5x5-unorm":!0,"astc-5x5-unorm-srgb":!0,"astc-6x5-unorm":!0,"astc-6x5-unorm-srgb":!0,"astc-6x6-unorm":!0,"astc-6x6-unorm-srgb":!0,"astc-8x5-unorm":!0,"astc-8x5-unorm-srgb":!0,"astc-8x6-unorm":!0,"astc-8x6-unorm-srgb":!0,"astc-8x8-unorm":!0,"astc-8x8-unorm-srgb":!0,"astc-10x5-unorm":!0,"astc-10x5-unorm-srgb":!0,"astc-10x6-unorm":!0,"astc-10x6-unorm-srgb":!0,"astc-10x8-unorm":!0,"astc-10x8-unorm-srgb":!0,"astc-10x10-unorm":!0,"astc-10x10-unorm-srgb":!0,"astc-12x10-unorm":!0,"astc-12x10-unorm-srgb":!0,"astc-12x12-unorm":!0,"astc-12x12-unorm-srgb":!0},glUploadCompressedTextureResource={id:"compressed",upload(Yr,ze,Gr){Gr.pixelStorei(Gr.UNPACK_ALIGNMENT,4);let Wr=Yr.pixelWidth,Kr=Yr.pixelHeight;const Zr=!!compressedFormatMap[Yr.format];for(let Qr=0;Qr<Yr.resource.length;Qr++){const Jr=Yr.resource[Qr];Zr?Gr.compressedTexImage2D(Gr.TEXTURE_2D,Qr,ze.internalFormat,Wr,Kr,0,Jr):Gr.texImage2D(Gr.TEXTURE_2D,Qr,ze.internalFormat,Wr,Kr,0,ze.format,ze.type,Jr),Wr=Math.max(Wr>>1,1),Kr=Math.max(Kr>>1,1)}}},glUploadImageResource={id:"image",upload(Yr,ze,Gr,Wr){const Kr=ze.width,Zr=ze.height,Qr=Yr.pixelWidth,Jr=Yr.pixelHeight,ei=Yr.resourceWidth,ti=Yr.resourceHeight;ei<Qr||ti<Jr?((Kr!==Qr||Zr!==Jr)&&Gr.texImage2D(ze.target,0,ze.internalFormat,Qr,Jr,0,ze.format,ze.type,null),Wr===2?Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,ei,ti,ze.format,ze.type,Yr.resource):Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,ze.format,ze.type,Yr.resource)):Kr===Qr&&Zr===Jr?Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,ze.format,ze.type,Yr.resource):Wr===2?Gr.texImage2D(ze.target,0,ze.internalFormat,Qr,Jr,0,ze.format,ze.type,Yr.resource):Gr.texImage2D(ze.target,0,ze.internalFormat,ze.format,ze.type,Yr.resource),ze.width=Qr,ze.height=Jr}},glUploadVideoResource={id:"video",upload(Yr,ze,Gr,Wr){if(!Yr.isValid){Gr.texImage2D(ze.target,0,ze.internalFormat,1,1,0,ze.format,ze.type,null);return}glUploadImageResource.upload(Yr,ze,Gr,Wr)}},scaleModeToGlFilter={linear:9729,nearest:9728},mipmapScaleModeToGlFilter={linear:{linear:9987,nearest:9985},nearest:{linear:9986,nearest:9984}},wrapModeToGlAddress={"clamp-to-edge":33071,repeat:10497,"mirror-repeat":33648},compareModeToGlCompare={never:512,less:513,equal:514,"less-equal":515,greater:516,"not-equal":517,"greater-equal":518,always:519};function applyStyleParams(Yr,ze,Gr,Wr,Kr,Zr,Qr,Jr){const ei=Zr;if(!Jr||Yr.addressModeU!=="repeat"||Yr.addressModeV!=="repeat"||Yr.addressModeW!=="repeat"){const ti=wrapModeToGlAddress[Qr?"clamp-to-edge":Yr.addressModeU],ri=wrapModeToGlAddress[Qr?"clamp-to-edge":Yr.addressModeV],ii=wrapModeToGlAddress[Qr?"clamp-to-edge":Yr.addressModeW];ze[Kr](ei,ze.TEXTURE_WRAP_S,ti),ze[Kr](ei,ze.TEXTURE_WRAP_T,ri),ze.TEXTURE_WRAP_R&&ze[Kr](ei,ze.TEXTURE_WRAP_R,ii)}if((!Jr||Yr.magFilter!=="linear")&&ze[Kr](ei,ze.TEXTURE_MAG_FILTER,scaleModeToGlFilter[Yr.magFilter]),Gr){if(!Jr||Yr.mipmapFilter!=="linear"){const ti=mipmapScaleModeToGlFilter[Yr.minFilter][Yr.mipmapFilter];ze[Kr](ei,ze.TEXTURE_MIN_FILTER,ti)}}else ze[Kr](ei,ze.TEXTURE_MIN_FILTER,scaleModeToGlFilter[Yr.minFilter]);if(Wr&&Yr.maxAnisotropy>1){const ti=Math.min(Yr.maxAnisotropy,ze.getParameter(Wr.MAX_TEXTURE_MAX_ANISOTROPY_EXT));ze[Kr](ei,Wr.TEXTURE_MAX_ANISOTROPY_EXT,ti)}Yr.compare&&ze[Kr](ei,ze.TEXTURE_COMPARE_FUNC,compareModeToGlCompare[Yr.compare])}function mapFormatToGlFormat(Yr){return{r8unorm:Yr.RED,r8snorm:Yr.RED,r8uint:Yr.RED,r8sint:Yr.RED,r16uint:Yr.RED,r16sint:Yr.RED,r16float:Yr.RED,rg8unorm:Yr.RG,rg8snorm:Yr.RG,rg8uint:Yr.RG,rg8sint:Yr.RG,r32uint:Yr.RED,r32sint:Yr.RED,r32float:Yr.RED,rg16uint:Yr.RG,rg16sint:Yr.RG,rg16float:Yr.RG,rgba8unorm:Yr.RGBA,"rgba8unorm-srgb":Yr.RGBA,rgba8snorm:Yr.RGBA,rgba8uint:Yr.RGBA,rgba8sint:Yr.RGBA,bgra8unorm:Yr.RGBA,"bgra8unorm-srgb":Yr.RGBA,rgb9e5ufloat:Yr.RGB,rgb10a2unorm:Yr.RGBA,rg11b10ufloat:Yr.RGB,rg32uint:Yr.RG,rg32sint:Yr.RG,rg32float:Yr.RG,rgba16uint:Yr.RGBA,rgba16sint:Yr.RGBA,rgba16float:Yr.RGBA,rgba32uint:Yr.RGBA,rgba32sint:Yr.RGBA,rgba32float:Yr.RGBA,stencil8:Yr.STENCIL_INDEX8,depth16unorm:Yr.DEPTH_COMPONENT,depth24plus:Yr.DEPTH_COMPONENT,"depth24plus-stencil8":Yr.DEPTH_STENCIL,depth32float:Yr.DEPTH_COMPONENT,"depth32float-stencil8":Yr.DEPTH_STENCIL}}function mapFormatToGlInternalFormat(Yr,ze){let Gr={},Wr=Yr.RGBA;return Yr instanceof DOMAdapter.get().getWebGLRenderingContext()?ze.srgb&&(Gr={"rgba8unorm-srgb":ze.srgb.SRGB8_ALPHA8_EXT,"bgra8unorm-srgb":ze.srgb.SRGB8_ALPHA8_EXT}):(Gr={"rgba8unorm-srgb":Yr.SRGB8_ALPHA8,"bgra8unorm-srgb":Yr.SRGB8_ALPHA8},Wr=Yr.RGBA8),{r8unorm:Yr.R8,r8snorm:Yr.R8_SNORM,r8uint:Yr.R8UI,r8sint:Yr.R8I,r16uint:Yr.R16UI,r16sint:Yr.R16I,r16float:Yr.R16F,rg8unorm:Yr.RG8,rg8snorm:Yr.RG8_SNORM,rg8uint:Yr.RG8UI,rg8sint:Yr.RG8I,r32uint:Yr.R32UI,r32sint:Yr.R32I,r32float:Yr.R32F,rg16uint:Yr.RG16UI,rg16sint:Yr.RG16I,rg16float:Yr.RG16F,rgba8unorm:Yr.RGBA,...Gr,rgba8snorm:Yr.RGBA8_SNORM,rgba8uint:Yr.RGBA8UI,rgba8sint:Yr.RGBA8I,bgra8unorm:Wr,rgb9e5ufloat:Yr.RGB9_E5,rgb10a2unorm:Yr.RGB10_A2,rg11b10ufloat:Yr.R11F_G11F_B10F,rg32uint:Yr.RG32UI,rg32sint:Yr.RG32I,rg32float:Yr.RG32F,rgba16uint:Yr.RGBA16UI,rgba16sint:Yr.RGBA16I,rgba16float:Yr.RGBA16F,rgba32uint:Yr.RGBA32UI,rgba32sint:Yr.RGBA32I,rgba32float:Yr.RGBA32F,stencil8:Yr.STENCIL_INDEX8,depth16unorm:Yr.DEPTH_COMPONENT16,depth24plus:Yr.DEPTH_COMPONENT24,"depth24plus-stencil8":Yr.DEPTH24_STENCIL8,depth32float:Yr.DEPTH_COMPONENT32F,"depth32float-stencil8":Yr.DEPTH32F_STENCIL8,...ze.s3tc?{"bc1-rgba-unorm":ze.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,"bc2-rgba-unorm":ze.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,"bc3-rgba-unorm":ze.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT}:{},...ze.s3tc_sRGB?{"bc1-rgba-unorm-srgb":ze.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,"bc2-rgba-unorm-srgb":ze.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,"bc3-rgba-unorm-srgb":ze.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}:{},...ze.rgtc?{"bc4-r-unorm":ze.rgtc.COMPRESSED_RED_RGTC1_EXT,"bc4-r-snorm":ze.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,"bc5-rg-unorm":ze.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,"bc5-rg-snorm":ze.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}:{},...ze.bptc?{"bc6h-rgb-float":ze.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,"bc6h-rgb-ufloat":ze.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,"bc7-rgba-unorm":ze.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,"bc7-rgba-unorm-srgb":ze.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT}:{},...ze.etc?{"etc2-rgb8unorm":ze.etc.COMPRESSED_RGB8_ETC2,"etc2-rgb8unorm-srgb":ze.etc.COMPRESSED_SRGB8_ETC2,"etc2-rgb8a1unorm":ze.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgb8a1unorm-srgb":ze.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgba8unorm":ze.etc.COMPRESSED_RGBA8_ETC2_EAC,"etc2-rgba8unorm-srgb":ze.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,"eac-r11unorm":ze.etc.COMPRESSED_R11_EAC,"eac-rg11unorm":ze.etc.COMPRESSED_SIGNED_RG11_EAC}:{},...ze.astc?{"astc-4x4-unorm":ze.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,"astc-4x4-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,"astc-5x4-unorm":ze.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,"astc-5x4-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,"astc-5x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,"astc-5x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,"astc-6x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,"astc-6x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,"astc-6x6-unorm":ze.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,"astc-6x6-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,"astc-8x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,"astc-8x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,"astc-8x6-unorm":ze.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,"astc-8x6-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,"astc-8x8-unorm":ze.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,"astc-8x8-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,"astc-10x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,"astc-10x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,"astc-10x6-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,"astc-10x6-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,"astc-10x8-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,"astc-10x8-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,"astc-10x10-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,"astc-10x10-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,"astc-12x10-unorm":ze.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,"astc-12x10-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,"astc-12x12-unorm":ze.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,"astc-12x12-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR}:{}}}function mapFormatToGlType(Yr){return{r8unorm:Yr.UNSIGNED_BYTE,r8snorm:Yr.BYTE,r8uint:Yr.UNSIGNED_BYTE,r8sint:Yr.BYTE,r16uint:Yr.UNSIGNED_SHORT,r16sint:Yr.SHORT,r16float:Yr.HALF_FLOAT,rg8unorm:Yr.UNSIGNED_BYTE,rg8snorm:Yr.BYTE,rg8uint:Yr.UNSIGNED_BYTE,rg8sint:Yr.BYTE,r32uint:Yr.UNSIGNED_INT,r32sint:Yr.INT,r32float:Yr.FLOAT,rg16uint:Yr.UNSIGNED_SHORT,rg16sint:Yr.SHORT,rg16float:Yr.HALF_FLOAT,rgba8unorm:Yr.UNSIGNED_BYTE,"rgba8unorm-srgb":Yr.UNSIGNED_BYTE,rgba8snorm:Yr.BYTE,rgba8uint:Yr.UNSIGNED_BYTE,rgba8sint:Yr.BYTE,bgra8unorm:Yr.UNSIGNED_BYTE,"bgra8unorm-srgb":Yr.UNSIGNED_BYTE,rgb9e5ufloat:Yr.UNSIGNED_INT_5_9_9_9_REV,rgb10a2unorm:Yr.UNSIGNED_INT_2_10_10_10_REV,rg11b10ufloat:Yr.UNSIGNED_INT_10F_11F_11F_REV,rg32uint:Yr.UNSIGNED_INT,rg32sint:Yr.INT,rg32float:Yr.FLOAT,rgba16uint:Yr.UNSIGNED_SHORT,rgba16sint:Yr.SHORT,rgba16float:Yr.HALF_FLOAT,rgba32uint:Yr.UNSIGNED_INT,rgba32sint:Yr.INT,rgba32float:Yr.FLOAT,stencil8:Yr.UNSIGNED_BYTE,depth16unorm:Yr.UNSIGNED_SHORT,depth24plus:Yr.UNSIGNED_INT,"depth24plus-stencil8":Yr.UNSIGNED_INT_24_8,depth32float:Yr.FLOAT,"depth32float-stencil8":Yr.FLOAT_32_UNSIGNED_INT_24_8_REV}}const BYTES_PER_PIXEL=4;class GlTextureSystem{constructor(ze){this.managedTextures=[],this._glTextures=Object.create(null),this._glSamplers=Object.create(null),this._boundTextures=[],this._activeTextureLocation=-1,this._boundSamplers=Object.create(null),this._uploads={image:glUploadImageResource,buffer:glUploadBufferImageResource,video:glUploadVideoResource,compressed:glUploadCompressedTextureResource},this._premultiplyAlpha=!1,this._useSeparateSamplers=!1,this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_glTextures"),this._renderer.renderableGC.addManagedHash(this,"_glSamplers")}contextChange(ze){this._gl=ze,this._mapFormatToInternalFormat||(this._mapFormatToInternalFormat=mapFormatToGlInternalFormat(ze,this._renderer.context.extensions),this._mapFormatToType=mapFormatToGlType(ze),this._mapFormatToFormat=mapFormatToGlFormat(ze)),this._glTextures=Object.create(null),this._glSamplers=Object.create(null),this._boundSamplers=Object.create(null),this._premultiplyAlpha=!1;for(let Gr=0;Gr<16;Gr++)this.bind(Texture.EMPTY,Gr)}initSource(ze){this.bind(ze)}bind(ze,Gr=0){const Wr=ze.source;ze?(this.bindSource(Wr,Gr),this._useSeparateSamplers&&this._bindSampler(Wr.style,Gr)):(this.bindSource(null,Gr),this._useSeparateSamplers&&this._bindSampler(null,Gr))}bindSource(ze,Gr=0){const Wr=this._gl;if(ze._touched=this._renderer.textureGC.count,this._boundTextures[Gr]!==ze){this._boundTextures[Gr]=ze,this._activateLocation(Gr),ze||(ze=Texture.EMPTY.source);const Kr=this.getGlSource(ze);Wr.bindTexture(Kr.target,Kr.texture)}}_bindSampler(ze,Gr=0){const Wr=this._gl;if(!ze){this._boundSamplers[Gr]=null,Wr.bindSampler(Gr,null);return}const Kr=this._getGlSampler(ze);this._boundSamplers[Gr]!==Kr&&(this._boundSamplers[Gr]=Kr,Wr.bindSampler(Gr,Kr))}unbind(ze){const Gr=ze.source,Wr=this._boundTextures,Kr=this._gl;for(let Zr=0;Zr<Wr.length;Zr++)if(Wr[Zr]===Gr){this._activateLocation(Zr);const Qr=this.getGlSource(Gr);Kr.bindTexture(Qr.target,null),Wr[Zr]=null}}_activateLocation(ze){this._activeTextureLocation!==ze&&(this._activeTextureLocation=ze,this._gl.activeTexture(this._gl.TEXTURE0+ze))}_initSource(ze){const Gr=this._gl,Wr=new GlTexture(Gr.createTexture());if(Wr.type=this._mapFormatToType[ze.format],Wr.internalFormat=this._mapFormatToInternalFormat[ze.format],Wr.format=this._mapFormatToFormat[ze.format],ze.autoGenerateMipmaps&&(this._renderer.context.supports.nonPowOf2mipmaps||ze.isPowerOfTwo)){const Kr=Math.max(ze.width,ze.height);ze.mipLevelCount=Math.floor(Math.log2(Kr))+1}return this._glTextures[ze.uid]=Wr,this.managedTextures.includes(ze)||(ze.on("update",this.onSourceUpdate,this),ze.on("resize",this.onSourceUpdate,this),ze.on("styleChange",this.onStyleChange,this),ze.on("destroy",this.onSourceDestroy,this),ze.on("unload",this.onSourceUnload,this),ze.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(ze)),this.onSourceUpdate(ze),this.updateStyle(ze,!1),Wr}onStyleChange(ze){this.updateStyle(ze,!1)}updateStyle(ze,Gr){const Wr=this._gl,Kr=this.getGlSource(ze);Wr.bindTexture(Wr.TEXTURE_2D,Kr.texture),this._boundTextures[this._activeTextureLocation]=ze,applyStyleParams(ze.style,Wr,ze.mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"texParameteri",Wr.TEXTURE_2D,!this._renderer.context.supports.nonPowOf2wrapping&&!ze.isPowerOfTwo,Gr)}onSourceUnload(ze){const Gr=this._glTextures[ze.uid];Gr&&(this.unbind(ze),this._glTextures[ze.uid]=null,this._gl.deleteTexture(Gr.texture))}onSourceUpdate(ze){const Gr=this._gl,Wr=this.getGlSource(ze);Gr.bindTexture(Gr.TEXTURE_2D,Wr.texture),this._boundTextures[this._activeTextureLocation]=ze;const Kr=ze.alphaMode==="premultiply-alpha-on-upload";this._premultiplyAlpha!==Kr&&(this._premultiplyAlpha=Kr,Gr.pixelStorei(Gr.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Kr)),this._uploads[ze.uploadMethodId]?this._uploads[ze.uploadMethodId].upload(ze,Wr,Gr,this._renderer.context.webGLVersion):Gr.texImage2D(Gr.TEXTURE_2D,0,Gr.RGBA,ze.pixelWidth,ze.pixelHeight,0,Gr.RGBA,Gr.UNSIGNED_BYTE,null),ze.autoGenerateMipmaps&&ze.mipLevelCount>1&&this.onUpdateMipmaps(ze,!1)}onUpdateMipmaps(ze,Gr=!0){Gr&&this.bindSource(ze,0);const Wr=this.getGlSource(ze);this._gl.generateMipmap(Wr.target)}onSourceDestroy(ze){ze.off("destroy",this.onSourceDestroy,this),ze.off("update",this.onSourceUpdate,this),ze.off("resize",this.onSourceUpdate,this),ze.off("unload",this.onSourceUnload,this),ze.off("styleChange",this.onStyleChange,this),ze.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(ze),1),this.onSourceUnload(ze)}_initSampler(ze){const Gr=this._gl,Wr=this._gl.createSampler();return this._glSamplers[ze._resourceId]=Wr,applyStyleParams(ze,Gr,this._boundTextures[this._activeTextureLocation].mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"samplerParameteri",Wr,!1,!0),this._glSamplers[ze._resourceId]}_getGlSampler(ze){return this._glSamplers[ze._resourceId]||this._initSampler(ze)}getGlSource(ze){return this._glTextures[ze.uid]||this._initSource(ze)}generateCanvas(ze){const{pixels:Gr,width:Wr,height:Kr}=this.getPixels(ze),Zr=DOMAdapter.get().createCanvas();Zr.width=Wr,Zr.height=Kr;const Qr=Zr.getContext("2d");if(Qr){const Jr=Qr.createImageData(Wr,Kr);Jr.data.set(Gr),Qr.putImageData(Jr,0,0)}return Zr}getPixels(ze){const Gr=ze.source.resolution,Wr=ze.frame,Kr=Math.max(Math.round(Wr.width*Gr),1),Zr=Math.max(Math.round(Wr.height*Gr),1),Qr=new Uint8Array(BYTES_PER_PIXEL*Kr*Zr),Jr=this._renderer,ei=Jr.renderTarget.getRenderTarget(ze),ti=Jr.renderTarget.getGpuRenderTarget(ei),ri=Jr.gl;return ri.bindFramebuffer(ri.FRAMEBUFFER,ti.resolveTargetFramebuffer),ri.readPixels(Math.round(Wr.x*Gr),Math.round(Wr.y*Gr),Kr,Zr,ri.RGBA,ri.UNSIGNED_BYTE,Qr),{pixels:new Uint8ClampedArray(Qr.buffer),width:Kr,height:Zr}}destroy(){this.managedTextures.slice().forEach(ze=>this.onSourceDestroy(ze)),this.managedTextures=null,this._renderer=null}resetState(){this._activeTextureLocation=-1,this._boundTextures.fill(Texture.EMPTY.source),this._boundSamplers=Object.create(null);const ze=this._gl;this._premultiplyAlpha=!1,ze.pixelStorei(ze.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this._premultiplyAlpha)}}GlTextureSystem.extension={type:[ExtensionType.WebGLSystem],name:"texture"};class GlGraphicsAdaptor{init(){const ze=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uRound:{value:0,type:"f32"}}),Gr=getMaxTexturesPerBatch(),Wr=compileHighShaderGlProgram({name:"graphics",bits:[colorBitGl,generateTextureBatchBitGl(Gr),localUniformBitGl,roundPixelsBitGl]});this.shader=new Shader({glProgram:Wr,resources:{localUniforms:ze,batchSamplers:getBatchSamplersUniformGroup(Gr)}})}execute(ze,Gr){const Wr=Gr.context,Kr=Wr.customShader||this.shader,Zr=ze.renderer,Qr=Zr.graphicsContext,{batcher:Jr,instructions:ei}=Qr.getContextRenderData(Wr);Kr.groups[0]=Zr.globalUniforms.bindGroup,Zr.state.set(ze.state),Zr.shader.bind(Kr),Zr.geometry.bind(Jr.geometry,Kr.glProgram);const ti=ei.instructions;for(let ri=0;ri<ei.instructionSize;ri++){const ii=ti[ri];if(ii.size){for(let si=0;si<ii.textures.count;si++)Zr.texture.bind(ii.textures.textures[si],si);Zr.geometry.draw(ii.topology,ii.size,ii.start)}}}destroy(){this.shader.destroy(!0),this.shader=null}}GlGraphicsAdaptor.extension={type:[ExtensionType.WebGLPipesAdaptor],name:"graphics"};class GlMeshAdaptor{init(){const ze=compileHighShaderGlProgram({name:"mesh",bits:[localUniformBitGl,textureBitGl,roundPixelsBitGl]});this._shader=new Shader({glProgram:ze,resources:{uTexture:Texture.EMPTY.source,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new Matrix}}}})}execute(ze,Gr){const Wr=ze.renderer;let Kr=Gr._shader;if(Kr){if(!Kr.glProgram){warn("Mesh shader has no glProgram",Gr.shader);return}}else{Kr=this._shader;const Zr=Gr.texture,Qr=Zr.source;Kr.resources.uTexture=Qr,Kr.resources.uSampler=Qr.style,Kr.resources.textureUniforms.uniforms.uTextureMatrix=Zr.textureMatrix.mapCoord}Kr.groups[100]=Wr.globalUniforms.bindGroup,Kr.groups[101]=ze.localUniformsBindGroup,Wr.encoder.draw({geometry:Gr._geometry,shader:Kr,state:Gr.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GlMeshAdaptor.extension={type:[ExtensionType.WebGLPipesAdaptor],name:"mesh"};class CustomRenderPipe{constructor(ze){this._renderer=ze}updateRenderable(){}destroyRenderable(){}validateRenderable(){return!1}addRenderable(ze,Gr){this._renderer.renderPipes.batch.break(Gr),Gr.add(ze)}execute(ze){ze.isRenderable&&ze.render(this._renderer)}destroy(){this._renderer=null}}CustomRenderPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"customRender"};class BatchableSprite{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}}function executeInstructions(Yr,ze){const Gr=Yr.instructionSet,Wr=Gr.instructions;for(let Kr=0;Kr<Gr.instructionSize;Kr++){const Zr=Wr[Kr];ze[Zr.renderPipeId].execute(Zr)}}const tempMatrix$1=new Matrix;class RenderGroupPipe{constructor(ze){this._renderer=ze}addRenderGroup(ze,Gr){ze.isCachedAsTexture?this._addRenderableCacheAsTexture(ze,Gr):this._addRenderableDirect(ze,Gr)}execute(ze){ze.isRenderable&&(ze.isCachedAsTexture?this._executeCacheAsTexture(ze):this._executeDirect(ze))}destroy(){this._renderer=null}_addRenderableDirect(ze,Gr){this._renderer.renderPipes.batch.break(Gr),ze._batchableRenderGroup&&(BigPool.return(ze._batchableRenderGroup),ze._batchableRenderGroup=null),Gr.add(ze)}_addRenderableCacheAsTexture(ze,Gr){const Wr=ze._batchableRenderGroup??(ze._batchableRenderGroup=BigPool.get(BatchableSprite));Wr.renderable=ze.root,Wr.transform=ze.root.relativeGroupTransform,Wr.texture=ze.texture,Wr.bounds=ze._textureBounds,Gr.add(ze),this._renderer.renderPipes.batch.addToBatch(Wr,Gr)}_executeCacheAsTexture(ze){if(ze.textureNeedsUpdate){ze.textureNeedsUpdate=!1;const Gr=tempMatrix$1.identity().translate(-ze._textureBounds.x,-ze._textureBounds.y);this._renderer.renderTarget.push(ze.texture,!0,null,ze.texture.frame),this._renderer.globalUniforms.push({worldTransformMatrix:Gr,worldColor:4294967295}),executeInstructions(ze,this._renderer.renderPipes),this._renderer.renderTarget.finishRenderPass(),this._renderer.renderTarget.pop(),this._renderer.globalUniforms.pop()}ze._batchableRenderGroup._batcher.updateElement(ze._batchableRenderGroup),ze._batchableRenderGroup._batcher.geometry.buffers[0].update()}_executeDirect(ze){this._renderer.globalUniforms.push({worldTransformMatrix:ze.inverseParentTextureTransform,worldColor:ze.worldColorAlpha}),executeInstructions(ze,this._renderer.renderPipes),this._renderer.globalUniforms.pop()}}RenderGroupPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"renderGroup"};function clearList(Yr,ze){ze||(ze=0);for(let Gr=ze;Gr<Yr.length&&Yr[Gr];Gr++)Yr[Gr]=null}const tempContainer=new Container,UPDATE_BLEND_COLOR_VISIBLE=UPDATE_VISIBLE|UPDATE_COLOR|UPDATE_BLEND;function updateRenderGroupTransforms(Yr,ze=!1){updateRenderGroupTransform(Yr);const Gr=Yr.childrenToUpdate,Wr=Yr.updateTick++;for(const Kr in Gr){const Zr=Number(Kr),Qr=Gr[Kr],Jr=Qr.list,ei=Qr.index;for(let ti=0;ti<ei;ti++){const ri=Jr[ti];ri.parentRenderGroup===Yr&&ri.relativeRenderGroupDepth===Zr&&updateTransformAndChildren(ri,Wr,0)}clearList(Jr,ei),Qr.index=0}if(ze)for(let Kr=0;Kr<Yr.renderGroupChildren.length;Kr++)updateRenderGroupTransforms(Yr.renderGroupChildren[Kr],ze)}function updateRenderGroupTransform(Yr){const ze=Yr.root;let Gr;if(Yr.renderGroupParent){const Wr=Yr.renderGroupParent;Yr.worldTransform.appendFrom(ze.relativeGroupTransform,Wr.worldTransform),Yr.worldColor=multiplyColors(ze.groupColor,Wr.worldColor),Gr=ze.groupAlpha*Wr.worldAlpha}else Yr.worldTransform.copyFrom(ze.localTransform),Yr.worldColor=ze.localColor,Gr=ze.localAlpha;Gr=Gr<0?0:Gr>1?1:Gr,Yr.worldAlpha=Gr,Yr.worldColorAlpha=Yr.worldColor+((Gr*255|0)<<24)}function updateTransformAndChildren(Yr,ze,Gr){if(ze===Yr.updateTick)return;Yr.updateTick=ze,Yr.didChange=!1;const Wr=Yr.localTransform;Yr.updateLocalTransform();const Kr=Yr.parent;if(Kr&&!Kr.renderGroup?(Gr|=Yr._updateFlags,Yr.relativeGroupTransform.appendFrom(Wr,Kr.relativeGroupTransform),Gr&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(Yr,Kr,Gr)):(Gr=Yr._updateFlags,Yr.relativeGroupTransform.copyFrom(Wr),Gr&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(Yr,tempContainer,Gr)),!Yr.renderGroup){const Zr=Yr.children,Qr=Zr.length;for(let ti=0;ti<Qr;ti++)updateTransformAndChildren(Zr[ti],ze,Gr);const Jr=Yr.parentRenderGroup,ei=Yr;ei.renderPipeId&&!Jr.structureDidChange&&Jr.updateRenderable(ei)}}function updateColorBlendVisibility(Yr,ze,Gr){if(Gr&UPDATE_COLOR){Yr.groupColor=multiplyColors(Yr.localColor,ze.groupColor);let Wr=Yr.localAlpha*ze.groupAlpha;Wr=Wr<0?0:Wr>1?1:Wr,Yr.groupAlpha=Wr,Yr.groupColorAlpha=Yr.groupColor+((Wr*255|0)<<24)}Gr&UPDATE_BLEND&&(Yr.groupBlendMode=Yr.localBlendMode==="inherit"?ze.groupBlendMode:Yr.localBlendMode),Gr&UPDATE_VISIBLE&&(Yr.globalDisplayStatus=Yr.localDisplayStatus&ze.globalDisplayStatus),Yr._updateFlags=0}function validateRenderables(Yr,ze){const{list:Gr,index:Wr}=Yr.childrenRenderablesToUpdate;let Kr=!1;for(let Zr=0;Zr<Wr;Zr++){const Qr=Gr[Zr];if(Kr=ze[Qr.renderPipeId].validateRenderable(Qr),Kr)break}return Yr.structureDidChange=Kr,Kr}const tempMatrix=new Matrix;class RenderGroupSystem{constructor(ze){this._renderer=ze}render({container:ze,transform:Gr}){const Wr=ze.parent,Kr=ze.renderGroup.renderGroupParent;ze.parent=null,ze.renderGroup.renderGroupParent=null;const Zr=this._renderer;let Qr=tempMatrix;Gr&&(Qr=Qr.copyFrom(ze.renderGroup.localTransform),ze.renderGroup.localTransform.copyFrom(Gr));const Jr=Zr.renderPipes;this._updateCachedRenderGroups(ze.renderGroup,null),this._updateRenderGroups(ze.renderGroup),Zr.globalUniforms.start({worldTransformMatrix:Gr?ze.renderGroup.localTransform:ze.renderGroup.worldTransform,worldColor:ze.renderGroup.worldColorAlpha}),executeInstructions(ze.renderGroup,Jr),Jr.uniformBatch&&Jr.uniformBatch.renderEnd(),Gr&&ze.renderGroup.localTransform.copyFrom(Qr),ze.parent=Wr,ze.renderGroup.renderGroupParent=Kr}destroy(){this._renderer=null}_updateCachedRenderGroups(ze,Gr){if(ze.isCachedAsTexture){if(!ze.updateCacheTexture)return;Gr=ze}ze._parentCacheAsTextureRenderGroup=Gr;for(let Wr=ze.renderGroupChildren.length-1;Wr>=0;Wr--)this._updateCachedRenderGroups(ze.renderGroupChildren[Wr],Gr);if(ze.invalidateMatrices(),ze.isCachedAsTexture){if(ze.textureNeedsUpdate){const Wr=ze.root.getLocalBounds();Wr.ceil();const Kr=ze.texture;ze.texture&&TexturePool.returnTexture(ze.texture);const Zr=this._renderer,Qr=ze.textureOptions.resolution||Zr.view.resolution,Jr=ze.textureOptions.antialias??Zr.view.antialias;ze.texture=TexturePool.getOptimalTexture(Wr.width,Wr.height,Qr,Jr),ze._textureBounds||(ze._textureBounds=new Bounds),ze._textureBounds.copyFrom(Wr),Kr!==ze.texture&&ze.renderGroupParent&&(ze.renderGroupParent.structureDidChange=!0)}}else ze.texture&&(TexturePool.returnTexture(ze.texture),ze.texture=null)}_updateRenderGroups(ze){const Gr=this._renderer,Wr=Gr.renderPipes;if(ze.runOnRender(Gr),ze.instructionSet.renderPipes=Wr,ze.structureDidChange?clearList(ze.childrenRenderablesToUpdate.list,0):validateRenderables(ze,Wr),updateRenderGroupTransforms(ze),ze.structureDidChange?(ze.structureDidChange=!1,this._buildInstructions(ze,Gr)):this._updateRenderables(ze),ze.childrenRenderablesToUpdate.index=0,Gr.renderPipes.batch.upload(ze.instructionSet),!(ze.isCachedAsTexture&&!ze.textureNeedsUpdate))for(let Kr=0;Kr<ze.renderGroupChildren.length;Kr++)this._updateRenderGroups(ze.renderGroupChildren[Kr])}_updateRenderables(ze){const{list:Gr,index:Wr}=ze.childrenRenderablesToUpdate;for(let Kr=0;Kr<Wr;Kr++){const Zr=Gr[Kr];Zr.didViewUpdate&&ze.updateRenderable(Zr)}clearList(Gr,Wr)}_buildInstructions(ze,Gr){const Wr=ze.root,Kr=ze.instructionSet;Kr.reset();const Zr=Gr.renderPipes?Gr:Gr.batch.renderer,Qr=Zr.renderPipes;Qr.batch.buildStart(Kr),Qr.blendMode.buildStart(),Qr.colorMask.buildStart(),Wr.sortableChildren&&Wr.sortChildren(),Wr.collectRenderablesWithEffects(Kr,Zr,null),Qr.batch.buildEnd(Kr),Qr.blendMode.buildEnd(Kr)}}RenderGroupSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"renderGroup"};class SpritePipe{constructor(ze){this._gpuSpriteHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuSpriteHash")}addRenderable(ze,Gr){const Wr=this._getGpuSprite(ze);ze.didViewUpdate&&this._updateBatchableSprite(ze,Wr),this._renderer.renderPipes.batch.addToBatch(Wr,Gr)}updateRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];ze.didViewUpdate&&this._updateBatchableSprite(ze,Gr),Gr._batcher.updateElement(Gr)}validateRenderable(ze){const Gr=this._getGpuSprite(ze);return!Gr._batcher.checkAndUpdateTexture(Gr,ze._texture)}destroyRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];BigPool.return(Gr),this._gpuSpriteHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(ze,Gr){Gr.bounds=ze.visualBounds,Gr.texture=ze._texture}_getGpuSprite(ze){return this._gpuSpriteHash[ze.uid]||this._initGPUSprite(ze)}_initGPUSprite(ze){const Gr=BigPool.get(BatchableSprite);return Gr.renderable=ze,Gr.transform=ze.groupTransform,Gr.texture=ze._texture,Gr.bounds=ze.visualBounds,Gr.roundPixels=this._renderer._roundPixels|ze._roundPixels,this._gpuSpriteHash[ze.uid]=Gr,ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuSpriteHash)BigPool.return(this._gpuSpriteHash[ze]);this._gpuSpriteHash=null,this._renderer=null}}SpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"sprite"};const _BackgroundSystem=class ks{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new Color(0),this.color=this._backgroundColor,this.alpha=1}init(ze){ze={...ks.defaultOptions,...ze},this.clearBeforeRender=ze.clearBeforeRender,this.color=ze.background||ze.backgroundColor||this._backgroundColor,this.alpha=ze.backgroundAlpha,this._backgroundColor.setAlpha(ze.backgroundAlpha)}get color(){return this._backgroundColor}set color(ze){this._backgroundColor.setValue(ze)}get alpha(){return this._backgroundColor.alpha}set alpha(ze){this._backgroundColor.setAlpha(ze)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};_BackgroundSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"background",priority:0};_BackgroundSystem.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};let BackgroundSystem=_BackgroundSystem;const BLEND_MODE_FILTERS={};extensions.handle(ExtensionType.BlendMode,Yr=>{if(!Yr.name)throw new Error("BlendMode extension must have a name property");BLEND_MODE_FILTERS[Yr.name]=Yr.ref},Yr=>{delete BLEND_MODE_FILTERS[Yr.name]});class BlendModePipe{constructor(ze){this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=ze,this._renderer.runners.prerender.add(this)}prerender(){this._activeBlendMode="normal",this._isAdvanced=!1}setBlendMode(ze,Gr,Wr){if(this._activeBlendMode===Gr){this._isAdvanced&&this._renderableList.push(ze);return}this._activeBlendMode=Gr,this._isAdvanced&&this._endAdvancedBlendMode(Wr),this._isAdvanced=!!BLEND_MODE_FILTERS[Gr],this._isAdvanced&&(this._beginAdvancedBlendMode(Wr),this._renderableList.push(ze))}_beginAdvancedBlendMode(ze){this._renderer.renderPipes.batch.break(ze);const Gr=this._activeBlendMode;if(!BLEND_MODE_FILTERS[Gr]){warn(`Unable to assign BlendMode: '${Gr}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);return}let Wr=this._filterHash[Gr];Wr||(Wr=this._filterHash[Gr]=new FilterEffect,Wr.filters=[new BLEND_MODE_FILTERS[Gr]]);const Kr={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect:Wr,canBundle:!1};this._renderableList=Kr.renderables,ze.add(Kr)}_endAdvancedBlendMode(ze){this._renderableList=null,this._renderer.renderPipes.batch.break(ze),ze.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(ze){this._isAdvanced&&this._endAdvancedBlendMode(ze)}destroy(){this._renderer=null,this._renderableList=null;for(const ze in this._filterHash)this._filterHash[ze].destroy();this._filterHash=null}}BlendModePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"blendMode"};const imageTypes={png:"image/png",jpg:"image/jpeg",webp:"image/webp"},_ExtractSystem=class Fs{constructor(ze){this._renderer=ze}_normalizeOptions(ze,Gr={}){return ze instanceof Container||ze instanceof Texture?{target:ze,...Gr}:{...Gr,...ze}}async image(ze){const Gr=new Image;return Gr.src=await this.base64(ze),Gr}async base64(ze){ze=this._normalizeOptions(ze,Fs.defaultImageOptions);const{format:Gr,quality:Wr}=ze,Kr=this.canvas(ze);if(Kr.toBlob!==void 0)return new Promise((Zr,Qr)=>{Kr.toBlob(Jr=>{if(!Jr){Qr(new Error("ICanvas.toBlob failed!"));return}const ei=new FileReader;ei.onload=()=>Zr(ei.result),ei.onerror=Qr,ei.readAsDataURL(Jr)},imageTypes[Gr],Wr)});if(Kr.toDataURL!==void 0)return Kr.toDataURL(imageTypes[Gr],Wr);if(Kr.convertToBlob!==void 0){const Zr=await Kr.convertToBlob({type:imageTypes[Gr],quality:Wr});return new Promise((Qr,Jr)=>{const ei=new FileReader;ei.onload=()=>Qr(ei.result),ei.onerror=Jr,ei.readAsDataURL(Zr)})}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(ze){ze=this._normalizeOptions(ze);const Gr=ze.target,Wr=this._renderer;if(Gr instanceof Texture)return Wr.texture.generateCanvas(Gr);const Kr=Wr.textureGenerator.generateTexture(ze),Zr=Wr.texture.generateCanvas(Kr);return Kr.destroy(!0),Zr}pixels(ze){ze=this._normalizeOptions(ze);const Gr=ze.target,Wr=this._renderer,Kr=Gr instanceof Texture?Gr:Wr.textureGenerator.generateTexture(ze),Zr=Wr.texture.getPixels(Kr);return Gr instanceof Container&&Kr.destroy(!0),Zr}texture(ze){return ze=this._normalizeOptions(ze),ze.target instanceof Texture?ze.target:this._renderer.textureGenerator.generateTexture(ze)}download(ze){ze=this._normalizeOptions(ze);const Gr=this.canvas(ze),Wr=document.createElement("a");Wr.download=ze.filename??"image.png",Wr.href=Gr.toDataURL("image/png"),document.body.appendChild(Wr),Wr.click(),document.body.removeChild(Wr)}log(ze){const Gr=ze.width??200;ze=this._normalizeOptions(ze);const Wr=this.canvas(ze),Kr=Wr.toDataURL();console.log(`[Pixi Texture] ${Wr.width}px ${Wr.height}px`);const Zr=["font-size: 1px;",`padding: ${Gr}px 300px;`,`background: url(${Kr}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",Zr)}destroy(){this._renderer=null}};_ExtractSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"extract"};_ExtractSystem.defaultImageOptions={format:"png",quality:1};let ExtractSystem=_ExtractSystem;class RenderTexture extends Texture{static create(ze){return new RenderTexture({source:new TextureSource(ze)})}resize(ze,Gr,Wr){return this.source.resize(ze,Gr,Wr),this}}const tempRect=new Rectangle,tempBounds$1=new Bounds,noColor=[0,0,0,0];class GenerateTextureSystem{constructor(ze){this._renderer=ze}generateTexture(ze){var ti;ze instanceof Container&&(ze={target:ze,frame:void 0,textureSourceOptions:{},resolution:void 0});const Gr=ze.resolution||this._renderer.resolution,Wr=ze.antialias||this._renderer.view.antialias,Kr=ze.target;let Zr=ze.clearColor;Zr?Zr=Array.isArray(Zr)&&Zr.length===4?Zr:Color.shared.setValue(Zr).toArray():Zr=noColor;const Qr=((ti=ze.frame)==null?void 0:ti.copyTo(tempRect))||getLocalBounds(Kr,tempBounds$1).rectangle;Qr.width=Math.max(Qr.width,1/Gr)|0,Qr.height=Math.max(Qr.height,1/Gr)|0;const Jr=RenderTexture.create({...ze.textureSourceOptions,width:Qr.width,height:Qr.height,resolution:Gr,antialias:Wr}),ei=Matrix.shared.translate(-Qr.x,-Qr.y);return this._renderer.render({container:Kr,transform:ei,target:Jr,clearColor:Zr}),Jr.source.updateMipmaps(),Jr}destroy(){this._renderer=null}}GenerateTextureSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"textureGenerator"};function color32BitToUniform(Yr,ze,Gr){const Wr=(Yr>>24&255)/255;ze[Gr++]=(Yr&255)/255*Wr,ze[Gr++]=(Yr>>8&255)/255*Wr,ze[Gr++]=(Yr>>16&255)/255*Wr,ze[Gr++]=Wr}class GlobalUniformSystem{constructor(ze){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=ze}reset(){this._stackIndex=0;for(let ze=0;ze<this._activeUniforms.length;ze++)this._uniformsPool.push(this._activeUniforms[ze]);for(let ze=0;ze<this._activeBindGroups.length;ze++)this._bindGroupPool.push(this._activeBindGroups[ze]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(ze){this.reset(),this.push(ze)}bind({size:ze,projectionMatrix:Gr,worldTransformMatrix:Wr,worldColor:Kr,offset:Zr}){const Qr=this._renderer.renderTarget.renderTarget,Jr=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{worldTransformMatrix:new Matrix,worldColor:4294967295,offset:new Point$1},ei={projectionMatrix:Gr||this._renderer.renderTarget.projectionMatrix,resolution:ze||Qr.size,worldTransformMatrix:Wr||Jr.worldTransformMatrix,worldColor:Kr||Jr.worldColor,offset:Zr||Jr.offset,bindGroup:null},ti=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(ti);const ri=ti.uniforms;ri.uProjectionMatrix=ei.projectionMatrix,ri.uResolution=ei.resolution,ri.uWorldTransformMatrix.copyFrom(ei.worldTransformMatrix),ri.uWorldTransformMatrix.tx-=ei.offset.x,ri.uWorldTransformMatrix.ty-=ei.offset.y,color32BitToUniform(ei.worldColor,ri.uWorldColorAlpha,0),ti.update();let ii;this._renderer.renderPipes.uniformBatch?ii=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(ti,!1):(ii=this._bindGroupPool.pop()||new BindGroup,this._activeBindGroups.push(ii),ii.setResource(ti,0)),ei.bindGroup=ii,this._currentGlobalUniformData=ei}push(ze){this.bind(ze),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1],this._renderer.type===RendererType.WEBGL&&this._currentGlobalUniformData.bindGroup.resources[0].update()}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get globalUniformData(){return this._currentGlobalUniformData}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new UniformGroup({uProjectionMatrix:{value:new Matrix,type:"mat3x3<f32>"},uWorldTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uWorldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{isStatic:!0})}destroy(){this._renderer=null}}GlobalUniformSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"globalUniforms"};let uid=1;class SchedulerSystem{constructor(){this._tasks=[],this._offset=0}init(){Ticker.system.add(this._update,this)}repeat(ze,Gr,Wr=!0){const Kr=uid++;let Zr=0;return Wr&&(this._offset+=1e3,Zr=this._offset),this._tasks.push({func:ze,duration:Gr,start:performance.now(),offset:Zr,last:performance.now(),repeat:!0,id:Kr}),Kr}cancel(ze){for(let Gr=0;Gr<this._tasks.length;Gr++)if(this._tasks[Gr].id===ze){this._tasks.splice(Gr,1);return}}_update(){const ze=performance.now();for(let Gr=0;Gr<this._tasks.length;Gr++){const Wr=this._tasks[Gr];if(ze-Wr.offset-Wr.last>=Wr.duration){const Kr=ze-Wr.start;Wr.func(Kr),Wr.last=ze}}}destroy(){Ticker.system.remove(this._update,this),this._tasks.length=0}}SchedulerSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"scheduler",priority:0};let saidHello=!1;function sayHello(Yr){if(!saidHello){if(DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const ze=[`%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${Yr}) http://www.pixijs.com/

`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...ze)}else globalThis.console&&globalThis.console.log(`PixiJS ${VERSION} - ${Yr} - http://www.pixijs.com/`);saidHello=!0}}class HelloSystem{constructor(ze){this._renderer=ze}init(ze){if(ze.hello){let Gr=this._renderer.name;this._renderer.type===RendererType.WEBGL&&(Gr+=` ${this._renderer.context.webGLVersion}`),sayHello(Gr)}}}HelloSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"hello",priority:-2};HelloSystem.defaultOptions={hello:!1};function cleanHash(Yr){let ze=!1;for(const Wr in Yr)if(Yr[Wr]==null){ze=!0;break}if(!ze)return Yr;const Gr=Object.create(null);for(const Wr in Yr){const Kr=Yr[Wr];Kr&&(Gr[Wr]=Kr)}return Gr}function cleanArray(Yr){let ze=0;for(let Gr=0;Gr<Yr.length;Gr++)Yr[Gr]==null?ze++:Yr[Gr-ze]=Yr[Gr];return Yr.length-=ze,Yr}let renderableGCTick=0;const _RenderableGCSystem=class Us{constructor(ze){this._managedRenderables=[],this._managedHashes=[],this._managedArrays=[],this._renderer=ze}init(ze){ze={...Us.defaultOptions,...ze},this.maxUnusedTime=ze.renderableGCMaxUnusedTime,this._frequency=ze.renderableGCFrequency,this.enabled=ze.renderableGCActive}get enabled(){return!!this._handler}set enabled(ze){this.enabled!==ze&&(ze?(this._handler=this._renderer.scheduler.repeat(()=>this.run(),this._frequency,!1),this._hashHandler=this._renderer.scheduler.repeat(()=>{for(const Gr of this._managedHashes)Gr.context[Gr.hash]=cleanHash(Gr.context[Gr.hash])},this._frequency),this._arrayHandler=this._renderer.scheduler.repeat(()=>{for(const Gr of this._managedArrays)cleanArray(Gr.context[Gr.hash])},this._frequency)):(this._renderer.scheduler.cancel(this._handler),this._renderer.scheduler.cancel(this._hashHandler),this._renderer.scheduler.cancel(this._arrayHandler)))}addManagedHash(ze,Gr){this._managedHashes.push({context:ze,hash:Gr})}addManagedArray(ze,Gr){this._managedArrays.push({context:ze,hash:Gr})}prerender({container:ze}){this._now=performance.now(),ze.renderGroup.gcTick=renderableGCTick++,this._updateInstructionGCTick(ze.renderGroup,ze.renderGroup.gcTick)}addRenderable(ze){this.enabled&&(ze._lastUsed===-1&&(this._managedRenderables.push(ze),ze.once("destroyed",this._removeRenderable,this)),ze._lastUsed=this._now)}run(){var Zr;const ze=this._now,Gr=this._managedRenderables,Wr=this._renderer.renderPipes;let Kr=0;for(let Qr=0;Qr<Gr.length;Qr++){const Jr=Gr[Qr];if(Jr===null){Kr++;continue}const ei=Jr.renderGroup??Jr.parentRenderGroup,ti=((Zr=ei==null?void 0:ei.instructionSet)==null?void 0:Zr.gcTick)??-1;if(((ei==null?void 0:ei.gcTick)??0)===ti&&(Jr._lastUsed=ze),ze-Jr._lastUsed>this.maxUnusedTime){if(!Jr.destroyed){const ri=Wr;ei&&(ei.structureDidChange=!0),ri[Jr.renderPipeId].destroyRenderable(Jr)}Jr._lastUsed=-1,Kr++,Jr.off("destroyed",this._removeRenderable,this)}else Gr[Qr-Kr]=Jr}Gr.length-=Kr}destroy(){this.enabled=!1,this._renderer=null,this._managedRenderables.length=0,this._managedHashes.length=0,this._managedArrays.length=0}_removeRenderable(ze){const Gr=this._managedRenderables.indexOf(ze);Gr>=0&&(ze.off("destroyed",this._removeRenderable,this),this._managedRenderables[Gr]=null)}_updateInstructionGCTick(ze,Gr){ze.instructionSet.gcTick=Gr;for(const Wr of ze.renderGroupChildren)this._updateInstructionGCTick(Wr,Gr)}};_RenderableGCSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"renderableGC",priority:0};_RenderableGCSystem.defaultOptions={renderableGCActive:!0,renderableGCMaxUnusedTime:6e4,renderableGCFrequency:3e4};let RenderableGCSystem=_RenderableGCSystem;const _TextureGCSystem=class Os{constructor(ze){this._renderer=ze,this.count=0,this.checkCount=0}init(ze){ze={...Os.defaultOptions,...ze},this.checkCountMax=ze.textureGCCheckCountMax,this.maxIdle=ze.textureGCAMaxIdle??ze.textureGCMaxIdle,this.active=ze.textureGCActive}postrender(){this._renderer.renderingToScreen&&(this.count++,this.active&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const ze=this._renderer.texture.managedTextures;for(let Gr=0;Gr<ze.length;Gr++){const Wr=ze[Gr];Wr.autoGarbageCollect&&Wr.resource&&Wr._touched>-1&&this.count-Wr._touched>this.maxIdle&&(Wr._touched=-1,Wr.unload())}}destroy(){this._renderer=null}};_TextureGCSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"textureGC"};_TextureGCSystem.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:null,textureGCMaxIdle:60*60,textureGCCheckCountMax:600};let TextureGCSystem=_TextureGCSystem;const _ViewSystem=class Ds{get autoDensity(){return this.texture.source.autoDensity}set autoDensity(ze){this.texture.source.autoDensity=ze}get resolution(){return this.texture.source._resolution}set resolution(ze){this.texture.source.resize(this.texture.source.width,this.texture.source.height,ze)}init(ze){ze={...Ds.defaultOptions,...ze},ze.view&&(deprecation(v8_0_0,"ViewSystem.view has been renamed to ViewSystem.canvas"),ze.canvas=ze.view),this.screen=new Rectangle(0,0,ze.width,ze.height),this.canvas=ze.canvas||DOMAdapter.get().createCanvas(),this.antialias=!!ze.antialias,this.texture=getCanvasTexture(this.canvas,ze),this.renderTarget=new RenderTarget({colorTextures:[this.texture],depth:!!ze.depth,isRoot:!0}),this.texture.source.transparent=ze.backgroundAlpha<1,this.resolution=ze.resolution}resize(ze,Gr,Wr){this.texture.source.resize(ze,Gr,Wr),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height}destroy(ze=!1){(typeof ze=="boolean"?ze:!!(ze!=null&&ze.removeView))&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};_ViewSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"view",priority:0};_ViewSystem.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};let ViewSystem=_ViewSystem;const SharedSystems=[BackgroundSystem,GlobalUniformSystem,HelloSystem,ViewSystem,RenderGroupSystem,TextureGCSystem,GenerateTextureSystem,ExtractSystem,RendererInitHook,RenderableGCSystem,SchedulerSystem],SharedRenderPipes=[BlendModePipe,BatcherPipe,SpritePipe,RenderGroupPipe,AlphaMaskPipe,StencilMaskPipe,ColorMaskPipe,CustomRenderPipe],DefaultWebGLSystems=[...SharedSystems,GlUboSystem,GlBackBufferSystem,GlContextSystem,GlBufferSystem,GlTextureSystem,GlRenderTargetSystem,GlGeometrySystem,GlUniformGroupSystem,GlShaderSystem,GlEncoderSystem,GlStateSystem,GlStencilSystem,GlColorMaskSystem],DefaultWebGLPipes=[...SharedRenderPipes],DefaultWebGLAdapters=[GlBatchAdaptor,GlMeshAdaptor,GlGraphicsAdaptor],systems$1=[],renderPipes$1=[],renderPipeAdaptors$1=[];extensions.handleByNamedList(ExtensionType.WebGLSystem,systems$1);extensions.handleByNamedList(ExtensionType.WebGLPipes,renderPipes$1);extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor,renderPipeAdaptors$1);extensions.add(...DefaultWebGLSystems,...DefaultWebGLPipes,...DefaultWebGLAdapters);class WebGLRenderer extends AbstractRenderer{constructor(){const ze={name:"webgl",type:RendererType.WEBGL,systems:systems$1,renderPipes:renderPipes$1,renderPipeAdaptors:renderPipeAdaptors$1};super(ze)}}const WebGLRenderer$1=Object.freeze(Object.defineProperty({__proto__:null,WebGLRenderer},Symbol.toStringTag,{value:"Module"}));class BindGroupSystem{constructor(ze){this._hash=Object.create(null),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_hash")}contextChange(ze){this._gpu=ze}getBindGroup(ze,Gr,Wr){return ze._updateKey(),this._hash[ze._key]||this._createBindGroup(ze,Gr,Wr)}_createBindGroup(ze,Gr,Wr){const Kr=this._gpu.device,Zr=Gr.layout[Wr],Qr=[],Jr=this._renderer;for(const ri in Zr){const ii=ze.resources[ri]??ze.resources[Zr[ri]];let si;if(ii._resourceType==="uniformGroup"){const ni=ii;Jr.ubo.updateUniformGroup(ni);const oi=ni.buffer;si={buffer:Jr.buffer.getGPUBuffer(oi),offset:0,size:oi.descriptor.size}}else if(ii._resourceType==="buffer"){const ni=ii;si={buffer:Jr.buffer.getGPUBuffer(ni),offset:0,size:ni.descriptor.size}}else if(ii._resourceType==="bufferResource"){const ni=ii;si={buffer:Jr.buffer.getGPUBuffer(ni.buffer),offset:ni.offset,size:ni.size}}else if(ii._resourceType==="textureSampler"){const ni=ii;si=Jr.texture.getGpuSampler(ni)}else if(ii._resourceType==="textureSource"){const ni=ii;si=Jr.texture.getGpuSource(ni).createView({})}Qr.push({binding:Zr[ri],resource:si})}const ei=Jr.shader.getProgramData(Gr).bindGroups[Wr],ti=Kr.createBindGroup({layout:ei,entries:Qr});return this._hash[ze._key]=ti,ti}destroy(){for(const ze of Object.keys(this._hash))this._hash[ze]=null;this._hash=null,this._renderer=null}}BindGroupSystem.extension={type:[ExtensionType.WebGPUSystem],name:"bindGroup"};class GpuBufferSystem{constructor(ze){this._gpuBuffers=Object.create(null),this._managedBuffers=[],ze.renderableGC.addManagedHash(this,"_gpuBuffers")}contextChange(ze){this._gpu=ze}getGPUBuffer(ze){return this._gpuBuffers[ze.uid]||this.createGPUBuffer(ze)}updateBuffer(ze){const Gr=this._gpuBuffers[ze.uid]||this.createGPUBuffer(ze),Wr=ze.data;return ze._updateID&&Wr&&(ze._updateID=0,this._gpu.device.queue.writeBuffer(Gr,0,Wr.buffer,0,(ze._updateSize||Wr.byteLength)+3&-4)),Gr}destroyAll(){for(const ze in this._gpuBuffers)this._gpuBuffers[ze].destroy();this._gpuBuffers={}}createGPUBuffer(ze){this._gpuBuffers[ze.uid]||(ze.on("update",this.updateBuffer,this),ze.on("change",this.onBufferChange,this),ze.on("destroy",this.onBufferDestroy,this),this._managedBuffers.push(ze));const Gr=this._gpu.device.createBuffer(ze.descriptor);return ze._updateID=0,ze.data&&(fastCopy(ze.data.buffer,Gr.getMappedRange()),Gr.unmap()),this._gpuBuffers[ze.uid]=Gr,Gr}onBufferChange(ze){this._gpuBuffers[ze.uid].destroy(),ze._updateID=0,this._gpuBuffers[ze.uid]=this.createGPUBuffer(ze)}onBufferDestroy(ze){this._managedBuffers.splice(this._managedBuffers.indexOf(ze),1),this._destroyBuffer(ze)}destroy(){this._managedBuffers.forEach(ze=>this._destroyBuffer(ze)),this._managedBuffers=null,this._gpuBuffers=null}_destroyBuffer(ze){this._gpuBuffers[ze.uid].destroy(),ze.off("update",this.updateBuffer,this),ze.off("change",this.onBufferChange,this),ze.off("destroy",this.onBufferDestroy,this),this._gpuBuffers[ze.uid]=null}}GpuBufferSystem.extension={type:[ExtensionType.WebGPUSystem],name:"buffer"};class UboBatch{constructor({minUniformOffsetAlignment:ze}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=ze,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(ze){if(ze>this._minUniformOffsetAlignment/4)throw new Error(`UniformBufferBatch: array is too large: ${ze*4}`);const Gr=this.byteIndex;let Wr=Gr+ze*4;if(Wr=Math.ceil(Wr/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,Wr>this.data.length*4)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=Wr,Gr}addGroup(ze){const Gr=this.addEmptyGroup(ze.length);for(let Wr=0;Wr<ze.length;Wr++)this.data[Gr/4+Wr]=ze[Wr];return Gr}destroy(){this.data=null}}class GpuColorMaskSystem{constructor(ze){this._colorMaskCache=15,this._renderer=ze}setMask(ze){this._colorMaskCache!==ze&&(this._colorMaskCache=ze,this._renderer.pipeline.setColorMask(ze))}destroy(){this._renderer=null,this._colorMaskCache=null}}GpuColorMaskSystem.extension={type:[ExtensionType.WebGPUSystem],name:"colorMask"};class GpuDeviceSystem{constructor(ze){this._renderer=ze}async init(ze){return this._initPromise?this._initPromise:(this._initPromise=this._createDeviceAndAdaptor(ze).then(Gr=>{this.gpu=Gr,this._renderer.runners.contextChange.emit(this.gpu)}),this._initPromise)}contextChange(ze){this._renderer.gpu=ze}async _createDeviceAndAdaptor(ze){const Gr=await DOMAdapter.get().getNavigator().gpu.requestAdapter({powerPreference:ze.powerPreference,forceFallbackAdapter:ze.forceFallbackAdapter}),Wr=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(Zr=>Gr.features.has(Zr)),Kr=await Gr.requestDevice({requiredFeatures:Wr});return{adapter:Gr,device:Kr}}destroy(){this.gpu=null,this._renderer=null}}GpuDeviceSystem.extension={type:[ExtensionType.WebGPUSystem],name:"device"};GpuDeviceSystem.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class GpuEncoderSystem{constructor(ze){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=ze}renderStart(){this.commandFinished=new Promise(ze=>{this._resolveCommandFinished=ze}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(ze){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(ze.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(ze){this.renderPassEncoder.setViewport(ze.x,ze.y,ze.width,ze.height,0,1)}setPipelineFromGeometryProgramAndState(ze,Gr,Wr,Kr){const Zr=this._renderer.pipeline.getPipeline(ze,Gr,Wr,Kr);this.setPipeline(Zr)}setPipeline(ze){this._boundPipeline!==ze&&(this._boundPipeline=ze,this.renderPassEncoder.setPipeline(ze))}_setVertexBuffer(ze,Gr){this._boundVertexBuffer[ze]!==Gr&&(this._boundVertexBuffer[ze]=Gr,this.renderPassEncoder.setVertexBuffer(ze,this._renderer.buffer.updateBuffer(Gr)))}_setIndexBuffer(ze){if(this._boundIndexBuffer===ze)return;this._boundIndexBuffer=ze;const Gr=ze.data.BYTES_PER_ELEMENT===2?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(ze),Gr)}resetBindGroup(ze){this._boundBindGroup[ze]=null}setBindGroup(ze,Gr,Wr){if(this._boundBindGroup[ze]===Gr)return;this._boundBindGroup[ze]=Gr,Gr._touch(this._renderer.textureGC.count);const Kr=this._renderer.bindGroup.getBindGroup(Gr,Wr,ze);this.renderPassEncoder.setBindGroup(ze,Kr)}setGeometry(ze,Gr){const Wr=this._renderer.pipeline.getBufferNamesToBind(ze,Gr);for(const Kr in Wr)this._setVertexBuffer(Kr,ze.attributes[Wr[Kr]].buffer);ze.indexBuffer&&this._setIndexBuffer(ze.indexBuffer)}_setShaderBindGroups(ze,Gr){for(const Wr in ze.groups){const Kr=ze.groups[Wr];Gr||this._syncBindGroup(Kr),this.setBindGroup(Wr,Kr,ze.gpuProgram)}}_syncBindGroup(ze){for(const Gr in ze.resources){const Wr=ze.resources[Gr];Wr.isUniformGroup&&this._renderer.ubo.updateUniformGroup(Wr)}}draw(ze){const{geometry:Gr,shader:Wr,state:Kr,topology:Zr,size:Qr,start:Jr,instanceCount:ei,skipSync:ti}=ze;this.setPipelineFromGeometryProgramAndState(Gr,Wr.gpuProgram,Kr,Zr),this.setGeometry(Gr,Wr.gpuProgram),this._setShaderBindGroups(Wr,ti),Gr.indexBuffer?this.renderPassEncoder.drawIndexed(Qr||Gr.indexBuffer.data.length,ei??Gr.instanceCount,Jr||0):this.renderPassEncoder.draw(Qr||Gr.getSize(),ei??Gr.instanceCount,Jr||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){const ze=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(ze);const Gr=this._boundPipeline,Wr={...this._boundVertexBuffer},Kr=this._boundIndexBuffer,Zr={...this._boundBindGroup};this._clearCache();const Qr=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(Qr.x,Qr.y,Qr.width,Qr.height,0,1),this.setPipeline(Gr);for(const Jr in Wr)this._setVertexBuffer(Jr,Wr[Jr]);for(const Jr in Zr)this.setBindGroup(Jr,Zr[Jr],null);this._setIndexBuffer(Kr)}_clearCache(){for(let ze=0;ze<16;ze++)this._boundBindGroup[ze]=null,this._boundVertexBuffer[ze]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(ze){this._gpu=ze}}GpuEncoderSystem.extension={type:[ExtensionType.WebGPUSystem],name:"encoder",priority:1};class GpuStencilSystem{constructor(ze){this._renderTargetStencilState=Object.create(null),this._renderer=ze,ze.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(ze){let Gr=this._renderTargetStencilState[ze.uid];Gr||(Gr=this._renderTargetStencilState[ze.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this._activeRenderTarget=ze,this.setStencilMode(Gr.stencilMode,Gr.stencilReference)}setStencilMode(ze,Gr){const Wr=this._renderTargetStencilState[this._activeRenderTarget.uid];Wr.stencilMode=ze,Wr.stencilReference=Gr;const Kr=this._renderer;Kr.pipeline.setStencilMode(ze),Kr.encoder.renderPassEncoder.setStencilReference(Gr)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}GpuStencilSystem.extension={type:[ExtensionType.WebGPUSystem],name:"stencil"};const WGSL_ALIGN_SIZE_DATA={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function createUboElementsWGSL(Yr){const ze=Yr.map(Wr=>({data:Wr,offset:0,size:0}));let Gr=0;for(let Wr=0;Wr<ze.length;Wr++){const Kr=ze[Wr];let Zr=WGSL_ALIGN_SIZE_DATA[Kr.data.type].size;const Qr=WGSL_ALIGN_SIZE_DATA[Kr.data.type].align;if(!WGSL_ALIGN_SIZE_DATA[Kr.data.type])throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${Kr.data.type}`);Kr.data.size>1&&(Zr=Math.max(Zr,Qr)*Kr.data.size),Gr=Math.ceil(Gr/Qr)*Qr,Kr.size=Zr,Kr.offset=Gr,Gr+=Zr}return Gr=Math.ceil(Gr/16)*16,{uboElements:ze,size:Gr}}function generateArraySyncWGSL(Yr,ze){const{size:Gr,align:Wr}=WGSL_ALIGN_SIZE_DATA[Yr.data.type],Kr=(Wr-Gr)/4,Zr=Yr.data.type.indexOf("i32")>=0?"dataInt32":"data";return`
         v = uv.${Yr.data.name};
         ${ze!==0?`offset += ${ze};`:""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${Yr.data.size*(Gr/4)}; i++)
         {
             for(var j = 0; j < ${Gr/4}; j++)
             {
                 ${Zr}[arrayOffset++] = v[t++];
             }
             ${Kr!==0?`arrayOffset += ${Kr};`:""}
         }
     `}function createUboSyncFunctionWGSL(Yr){return createUboSyncFunction(Yr,"uboWgsl",generateArraySyncWGSL,uboSyncFunctionsWGSL)}class GpuUboSystem extends UboSystem{constructor(){super({createUboElements:createUboElementsWGSL,generateUboSync:createUboSyncFunctionWGSL})}}GpuUboSystem.extension={type:[ExtensionType.WebGPUSystem],name:"ubo"};const minUniformOffsetAlignment=128;class GpuUniformBatchPipe{constructor(ze){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_bindGroupHash"),this._batchBuffer=new UboBatch({minUniformOffsetAlignment});const Gr=256/minUniformOffsetAlignment;for(let Wr=0;Wr<Gr;Wr++){let Kr=BufferUsage.UNIFORM|BufferUsage.COPY_DST;Wr===0&&(Kr|=BufferUsage.COPY_SRC),this._buffers.push(new Buffer({data:this._batchBuffer.data,usage:Kr}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(const ze in this._bindGroupHash)this._bindGroupHash[ze]=null;this._batchBuffer.clear()}getUniformBindGroup(ze,Gr){if(!Gr&&this._bindGroupHash[ze.uid])return this._bindGroupHash[ze.uid];this._renderer.ubo.ensureUniformGroup(ze);const Wr=ze.buffer.data,Kr=this._batchBuffer.addEmptyGroup(Wr.length);return this._renderer.ubo.syncUniformGroup(ze,this._batchBuffer.data,Kr/4),this._bindGroupHash[ze.uid]=this._getBindGroup(Kr/minUniformOffsetAlignment),this._bindGroupHash[ze.uid]}getUboResource(ze){this._renderer.ubo.updateUniformGroup(ze);const Gr=ze.buffer.data,Wr=this._batchBuffer.addGroup(Gr);return this._getBufferResource(Wr/minUniformOffsetAlignment)}getArrayBindGroup(ze){const Gr=this._batchBuffer.addGroup(ze);return this._getBindGroup(Gr/minUniformOffsetAlignment)}getArrayBufferResource(ze){const Wr=this._batchBuffer.addGroup(ze)/minUniformOffsetAlignment;return this._getBufferResource(Wr)}_getBufferResource(ze){if(!this._bufferResources[ze]){const Gr=this._buffers[ze%2];this._bufferResources[ze]=new BufferResource({buffer:Gr,offset:(ze/2|0)*256,size:minUniformOffsetAlignment})}return this._bufferResources[ze]}_getBindGroup(ze){if(!this._bindGroups[ze]){const Gr=new BindGroup({0:this._getBufferResource(ze)});this._bindGroups[ze]=Gr}return this._bindGroups[ze]}_uploadBindGroups(){const ze=this._renderer.buffer,Gr=this._buffers[0];Gr.update(this._batchBuffer.byteIndex),ze.updateBuffer(Gr);const Wr=this._renderer.gpu.device.createCommandEncoder();for(let Kr=1;Kr<this._buffers.length;Kr++){const Zr=this._buffers[Kr];Wr.copyBufferToBuffer(ze.getGPUBuffer(Gr),minUniformOffsetAlignment,ze.getGPUBuffer(Zr),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([Wr.finish()])}destroy(){for(let ze=0;ze<this._bindGroups.length;ze++)this._bindGroups[ze].destroy();this._bindGroups=null,this._bindGroupHash=null;for(let ze=0;ze<this._buffers.length;ze++)this._buffers[ze].destroy();this._buffers=null;for(let ze=0;ze<this._bufferResources.length;ze++)this._bufferResources[ze].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}}GpuUniformBatchPipe.extension={type:[ExtensionType.WebGPUPipes],name:"uniformBatch"};const topologyStringToId={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function getGraphicsStateKey(Yr,ze,Gr,Wr,Kr){return Yr<<24|ze<<16|Gr<<10|Wr<<5|Kr}function getGlobalStateKey(Yr,ze,Gr,Wr){return Gr<<6|Yr<<3|Wr<<1|ze}class PipelineSystem{constructor(ze){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._bindingNamesCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=ze}contextChange(ze){this._gpu=ze,this.setStencilMode(STENCIL_MODES.DISABLED),this._updatePipeHash()}setMultisampleCount(ze){this._multisampleCount!==ze&&(this._multisampleCount=ze,this._updatePipeHash())}setRenderTarget(ze){this._multisampleCount=ze.msaaSamples,this._depthStencilAttachment=ze.descriptor.depthStencilAttachment?1:0,this._updatePipeHash()}setColorMask(ze){this._colorMask!==ze&&(this._colorMask=ze,this._updatePipeHash())}setStencilMode(ze){this._stencilMode!==ze&&(this._stencilMode=ze,this._stencilState=GpuStencilModesToPixi[ze],this._updatePipeHash())}setPipeline(ze,Gr,Wr,Kr){const Zr=this.getPipeline(ze,Gr,Wr);Kr.setPipeline(Zr)}getPipeline(ze,Gr,Wr,Kr){ze._layoutKey||(ensureAttributes(ze,Gr.attributeData),this._generateBufferKey(ze)),Kr||(Kr=ze.topology);const Zr=getGraphicsStateKey(ze._layoutKey,Gr._layoutKey,Wr.data,Wr._blendModeId,topologyStringToId[Kr]);return this._pipeCache[Zr]?this._pipeCache[Zr]:(this._pipeCache[Zr]=this._createPipeline(ze,Gr,Wr,Kr),this._pipeCache[Zr])}_createPipeline(ze,Gr,Wr,Kr){const Zr=this._gpu.device,Qr=this._createVertexBufferLayouts(ze,Gr),Jr=this._renderer.state.getColorTargets(Wr);Jr[0].writeMask=this._stencilMode===STENCIL_MODES.RENDERING_MASK_ADD?0:this._colorMask;const ei=this._renderer.shader.getProgramData(Gr).pipeline,ti={vertex:{module:this._getModule(Gr.vertex.source),entryPoint:Gr.vertex.entryPoint,buffers:Qr},fragment:{module:this._getModule(Gr.fragment.source),entryPoint:Gr.fragment.entryPoint,targets:Jr},primitive:{topology:Kr,cullMode:Wr.cullMode},layout:ei,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};return this._depthStencilAttachment&&(ti.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:Wr.depthTest,depthCompare:Wr.depthTest?"less":"always"}),Zr.createRenderPipeline(ti)}_getModule(ze){return this._moduleCache[ze]||this._createModule(ze)}_createModule(ze){const Gr=this._gpu.device;return this._moduleCache[ze]=Gr.createShaderModule({code:ze}),this._moduleCache[ze]}_generateBufferKey(ze){const Gr=[];let Wr=0;const Kr=Object.keys(ze.attributes).sort();for(let Qr=0;Qr<Kr.length;Qr++){const Jr=ze.attributes[Kr[Qr]];Gr[Wr++]=Jr.offset,Gr[Wr++]=Jr.format,Gr[Wr++]=Jr.stride,Gr[Wr++]=Jr.instance}const Zr=Gr.join("|");return ze._layoutKey=createIdFromString(Zr,"geometry"),ze._layoutKey}_generateAttributeLocationsKey(ze){const Gr=[];let Wr=0;const Kr=Object.keys(ze.attributeData).sort();for(let Qr=0;Qr<Kr.length;Qr++){const Jr=ze.attributeData[Kr[Qr]];Gr[Wr++]=Jr.location}const Zr=Gr.join("|");return ze._attributeLocationsKey=createIdFromString(Zr,"programAttributes"),ze._attributeLocationsKey}getBufferNamesToBind(ze,Gr){const Wr=ze._layoutKey<<16|Gr._attributeLocationsKey;if(this._bindingNamesCache[Wr])return this._bindingNamesCache[Wr];const Kr=this._createVertexBufferLayouts(ze,Gr),Zr=Object.create(null),Qr=Gr.attributeData;for(let Jr=0;Jr<Kr.length;Jr++){const ti=Object.values(Kr[Jr].attributes)[0].shaderLocation;for(const ri in Qr)if(Qr[ri].location===ti){Zr[Jr]=ri;break}}return this._bindingNamesCache[Wr]=Zr,Zr}_createVertexBufferLayouts(ze,Gr){Gr._attributeLocationsKey||this._generateAttributeLocationsKey(Gr);const Wr=ze._layoutKey<<16|Gr._attributeLocationsKey;if(this._bufferLayoutsCache[Wr])return this._bufferLayoutsCache[Wr];const Kr=[];return ze.buffers.forEach(Zr=>{const Qr={arrayStride:0,stepMode:"vertex",attributes:[]},Jr=Qr.attributes;for(const ei in Gr.attributeData){const ti=ze.attributes[ei];(ti.divisor??1)!==1&&warn(`Attribute ${ei} has an invalid divisor value of '${ti.divisor}'. WebGPU only supports a divisor value of 1`),ti.buffer===Zr&&(Qr.arrayStride=ti.stride,Qr.stepMode=ti.instance?"instance":"vertex",Jr.push({shaderLocation:Gr.attributeData[ei].location,offset:ti.offset,format:ti.format}))}Jr.length&&Kr.push(Qr)}),this._bufferLayoutsCache[Wr]=Kr,Kr}_updatePipeHash(){const ze=getGlobalStateKey(this._stencilMode,this._multisampleCount,this._colorMask,this._depthStencilAttachment);this._pipeStateCaches[ze]||(this._pipeStateCaches[ze]=Object.create(null)),this._pipeCache=this._pipeStateCaches[ze]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}PipelineSystem.extension={type:[ExtensionType.WebGPUSystem],name:"pipeline"};class GpuRenderTarget{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class GpuRenderTargetAdaptor{init(ze,Gr){this._renderer=ze,this._renderTargetSystem=Gr}copyToTexture(ze,Gr,Wr,Kr,Zr){const Qr=this._renderer,Jr=this._getGpuColorTexture(ze),ei=Qr.texture.getGpuSource(Gr.source);return Qr.encoder.commandEncoder.copyTextureToTexture({texture:Jr,origin:Wr},{texture:ei,origin:Zr},Kr),Gr}startRenderPass(ze,Gr=!0,Wr,Kr){const Qr=this._renderTargetSystem.getGpuRenderTarget(ze),Jr=this.getDescriptor(ze,Gr,Wr);Qr.descriptor=Jr,this._renderer.pipeline.setRenderTarget(Qr),this._renderer.encoder.beginRenderPass(Qr),this._renderer.encoder.setViewport(Kr)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(ze){const Gr=this._renderTargetSystem.getGpuRenderTarget(ze);return Gr.contexts[0]?Gr.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(ze.colorTextures[0].source)}getDescriptor(ze,Gr,Wr){typeof Gr=="boolean"&&(Gr=Gr?CLEAR.ALL:CLEAR.NONE);const Kr=this._renderTargetSystem,Zr=Kr.getGpuRenderTarget(ze),Qr=ze.colorTextures.map((ti,ri)=>{const ii=Zr.contexts[ri];let si,ni;ii?si=ii.getCurrentTexture().createView():si=this._renderer.texture.getGpuSource(ti).createView({mipLevelCount:1}),Zr.msaaTextures[ri]&&(ni=si,si=this._renderer.texture.getTextureView(Zr.msaaTextures[ri]));const oi=Gr&CLEAR.COLOR?"clear":"load";return Wr??(Wr=Kr.defaultClearColor),{view:si,resolveTarget:ni,clearValue:Wr,storeOp:"store",loadOp:oi}});let Jr;if((ze.stencil||ze.depth)&&!ze.depthStencilTexture&&(ze.ensureDepthStencilTexture(),ze.depthStencilTexture.source.sampleCount=Zr.msaa?4:1),ze.depthStencilTexture){const ti=Gr&CLEAR.STENCIL?"clear":"load",ri=Gr&CLEAR.DEPTH?"clear":"load";Jr={view:this._renderer.texture.getGpuSource(ze.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:ti,depthClearValue:1,depthLoadOp:ri,depthStoreOp:"store"}}return{colorAttachments:Qr,depthStencilAttachment:Jr}}clear(ze,Gr=!0,Wr,Kr){if(!Gr)return;const{gpu:Zr,encoder:Qr}=this._renderer,Jr=Zr.device;if(Qr.commandEncoder===null){const ti=Jr.createCommandEncoder(),ri=this.getDescriptor(ze,Gr,Wr),ii=ti.beginRenderPass(ri);ii.setViewport(Kr.x,Kr.y,Kr.width,Kr.height,0,1),ii.end();const si=ti.finish();Jr.queue.submit([si])}else this.startRenderPass(ze,Gr,Wr,Kr)}initGpuRenderTarget(ze){ze.isRoot=!0;const Gr=new GpuRenderTarget;return ze.colorTextures.forEach((Wr,Kr)=>{if(CanvasSource.test(Wr.resource)){const Zr=Wr.resource.getContext("webgpu"),Qr=Wr.transparent?"premultiplied":"opaque";try{Zr.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:Qr})}catch(Jr){console.error(Jr)}Gr.contexts[Kr]=Zr}if(Gr.msaa=Wr.source.antialias,Wr.source.antialias){const Zr=new TextureSource({width:0,height:0,sampleCount:4});Gr.msaaTextures[Kr]=Zr}}),Gr.msaa&&(Gr.msaaSamples=4,ze.depthStencilTexture&&(ze.depthStencilTexture.source.sampleCount=4)),Gr}destroyGpuRenderTarget(ze){ze.contexts.forEach(Gr=>{Gr.unconfigure()}),ze.msaaTextures.forEach(Gr=>{Gr.destroy()}),ze.msaaTextures.length=0,ze.contexts.length=0}ensureDepthStencilTexture(ze){const Gr=this._renderTargetSystem.getGpuRenderTarget(ze);ze.depthStencilTexture&&Gr.msaa&&(ze.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(ze){const Gr=this._renderTargetSystem.getGpuRenderTarget(ze);Gr.width=ze.width,Gr.height=ze.height,Gr.msaa&&ze.colorTextures.forEach((Wr,Kr)=>{const Zr=Gr.msaaTextures[Kr];Zr==null||Zr.resize(Wr.source.width,Wr.source.height,Wr.source._resolution)})}}class GpuRenderTargetSystem extends RenderTargetSystem{constructor(ze){super(ze),this.adaptor=new GpuRenderTargetAdaptor,this.adaptor.init(ze,this)}}GpuRenderTargetSystem.extension={type:[ExtensionType.WebGPUSystem],name:"renderTarget"};class GpuShaderSystem{constructor(){this._gpuProgramData=Object.create(null)}contextChange(ze){this._gpu=ze,this.maxTextures=ze.device.limits.maxSampledTexturesPerShaderStage}getProgramData(ze){return this._gpuProgramData[ze._layoutKey]||this._createGPUProgramData(ze)}_createGPUProgramData(ze){const Gr=this._gpu.device,Wr=ze.gpuLayout.map(Zr=>Gr.createBindGroupLayout({entries:Zr})),Kr={bindGroupLayouts:Wr};return this._gpuProgramData[ze._layoutKey]={bindGroups:Wr,pipeline:Gr.createPipelineLayout(Kr)},this._gpuProgramData[ze._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}}GpuShaderSystem.extension={type:[ExtensionType.WebGPUSystem],name:"shader"};const GpuBlendModesToPixi={};GpuBlendModesToPixi.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}};GpuBlendModesToPixi.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}};GpuBlendModesToPixi.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}};GpuBlendModesToPixi.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}};GpuBlendModesToPixi["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}};GpuBlendModesToPixi["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}};GpuBlendModesToPixi["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.min={alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}};GpuBlendModesToPixi.max={alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}};class GpuStateSystem{constructor(){this.defaultState=new State,this.defaultState.blend=!0}contextChange(ze){this.gpu=ze}getColorTargets(ze){return[{format:"bgra8unorm",writeMask:0,blend:GpuBlendModesToPixi[ze.blendMode]||GpuBlendModesToPixi.normal}]}destroy(){this.gpu=null}}GpuStateSystem.extension={type:[ExtensionType.WebGPUSystem],name:"state"};const gpuUploadBufferImageResource={type:"image",upload(Yr,ze,Gr){const Wr=Yr.resource,Kr=(Yr.pixelWidth|0)*(Yr.pixelHeight|0),Zr=Wr.byteLength/Kr;Gr.device.queue.writeTexture({texture:ze},Wr,{offset:0,rowsPerImage:Yr.pixelHeight,bytesPerRow:Yr.pixelHeight*Zr},{width:Yr.pixelWidth,height:Yr.pixelHeight,depthOrArrayLayers:1})}},blockDataMap={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},defaultBlockData={blockBytes:4,blockWidth:1,blockHeight:1},gpuUploadCompressedTextureResource={type:"compressed",upload(Yr,ze,Gr){let Wr=Yr.pixelWidth,Kr=Yr.pixelHeight;const Zr=blockDataMap[Yr.format]||defaultBlockData;for(let Qr=0;Qr<Yr.resource.length;Qr++){const Jr=Yr.resource[Qr],ei=Math.ceil(Wr/Zr.blockWidth)*Zr.blockBytes;Gr.device.queue.writeTexture({texture:ze,mipLevel:Qr},Jr,{offset:0,bytesPerRow:ei},{width:Math.ceil(Wr/Zr.blockWidth)*Zr.blockWidth,height:Math.ceil(Kr/Zr.blockHeight)*Zr.blockHeight,depthOrArrayLayers:1}),Wr=Math.max(Wr>>1,1),Kr=Math.max(Kr>>1,1)}}},gpuUploadImageResource={type:"image",upload(Yr,ze,Gr){const Wr=Yr.resource;if(!Wr)return;const Kr=Math.min(ze.width,Yr.resourceWidth||Yr.pixelWidth),Zr=Math.min(ze.height,Yr.resourceHeight||Yr.pixelHeight),Qr=Yr.alphaMode==="premultiply-alpha-on-upload";Gr.device.queue.copyExternalImageToTexture({source:Wr},{texture:ze,premultipliedAlpha:Qr},{width:Kr,height:Zr})}},gpuUploadVideoResource={type:"video",upload(Yr,ze,Gr){gpuUploadImageResource.upload(Yr,ze,Gr)}};class GpuMipmapGenerator{constructor(ze){this.device=ze,this.sampler=ze.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(ze){let Gr=this.pipelines[ze];return Gr||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})),Gr=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:ze}]}}),this.pipelines[ze]=Gr),Gr}generateMipmap(ze){const Gr=this._getMipmapPipeline(ze.format);if(ze.dimension==="3d"||ze.dimension==="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let Wr=ze;const Kr=ze.depthOrArrayLayers||1,Zr=ze.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!Zr){const ei={size:{width:Math.ceil(ze.width/2),height:Math.ceil(ze.height/2),depthOrArrayLayers:Kr},format:ze.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:ze.mipLevelCount-1};Wr=this.device.createTexture(ei)}const Qr=this.device.createCommandEncoder({}),Jr=Gr.getBindGroupLayout(0);for(let ei=0;ei<Kr;++ei){let ti=ze.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:ei,arrayLayerCount:1}),ri=Zr?1:0;for(let ii=1;ii<ze.mipLevelCount;++ii){const si=Wr.createView({baseMipLevel:ri++,mipLevelCount:1,dimension:"2d",baseArrayLayer:ei,arrayLayerCount:1}),ni=Qr.beginRenderPass({colorAttachments:[{view:si,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),oi=this.device.createBindGroup({layout:Jr,entries:[{binding:0,resource:this.sampler},{binding:1,resource:ti}]});ni.setPipeline(Gr),ni.setBindGroup(0,oi),ni.draw(3,1,0,0),ni.end(),ti=si}}if(!Zr){const ei={width:Math.ceil(ze.width/2),height:Math.ceil(ze.height/2),depthOrArrayLayers:Kr};for(let ti=1;ti<ze.mipLevelCount;++ti)Qr.copyTextureToTexture({texture:Wr,mipLevel:ti-1},{texture:ze,mipLevel:ti},ei),ei.width=Math.ceil(ei.width/2),ei.height=Math.ceil(ei.height/2)}return this.device.queue.submit([Qr.finish()]),Zr||Wr.destroy(),ze}}class GpuTextureSystem{constructor(ze){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:gpuUploadImageResource,buffer:gpuUploadBufferImageResource,video:gpuUploadVideoResource,compressed:gpuUploadCompressedTextureResource},this._renderer=ze,ze.renderableGC.addManagedHash(this,"_gpuSources"),ze.renderableGC.addManagedHash(this,"_gpuSamplers"),ze.renderableGC.addManagedHash(this,"_bindGroupHash"),ze.renderableGC.addManagedHash(this,"_textureViewHash")}contextChange(ze){this._gpu=ze}initSource(ze){if(ze.autoGenerateMipmaps){const ei=Math.max(ze.pixelWidth,ze.pixelHeight);ze.mipLevelCount=Math.floor(Math.log2(ei))+1}let Gr=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;ze.uploadMethodId!=="compressed"&&(Gr|=GPUTextureUsage.RENDER_ATTACHMENT,Gr|=GPUTextureUsage.COPY_SRC);const Wr=blockDataMap[ze.format]||{blockWidth:1,blockHeight:1},Kr=Math.ceil(ze.pixelWidth/Wr.blockWidth)*Wr.blockWidth,Zr=Math.ceil(ze.pixelHeight/Wr.blockHeight)*Wr.blockHeight,Qr={label:ze.label,size:{width:Kr,height:Zr},format:ze.format,sampleCount:ze.sampleCount,mipLevelCount:ze.mipLevelCount,dimension:ze.dimension,usage:Gr},Jr=this._gpu.device.createTexture(Qr);return this._gpuSources[ze.uid]=Jr,this.managedTextures.includes(ze)||(ze.on("update",this.onSourceUpdate,this),ze.on("resize",this.onSourceResize,this),ze.on("destroy",this.onSourceDestroy,this),ze.on("unload",this.onSourceUnload,this),ze.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(ze)),this.onSourceUpdate(ze),Jr}onSourceUpdate(ze){const Gr=this.getGpuSource(ze);Gr&&(this._uploads[ze.uploadMethodId]&&this._uploads[ze.uploadMethodId].upload(ze,Gr,this._gpu),ze.autoGenerateMipmaps&&ze.mipLevelCount>1&&this.onUpdateMipmaps(ze))}onSourceUnload(ze){const Gr=this._gpuSources[ze.uid];Gr&&(this._gpuSources[ze.uid]=null,Gr.destroy())}onUpdateMipmaps(ze){this._mipmapGenerator||(this._mipmapGenerator=new GpuMipmapGenerator(this._gpu.device));const Gr=this.getGpuSource(ze);this._mipmapGenerator.generateMipmap(Gr)}onSourceDestroy(ze){ze.off("update",this.onSourceUpdate,this),ze.off("unload",this.onSourceUnload,this),ze.off("destroy",this.onSourceDestroy,this),ze.off("resize",this.onSourceResize,this),ze.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(ze),1),this.onSourceUnload(ze)}onSourceResize(ze){const Gr=this._gpuSources[ze.uid];Gr?(Gr.width!==ze.pixelWidth||Gr.height!==ze.pixelHeight)&&(this._textureViewHash[ze.uid]=null,this._bindGroupHash[ze.uid]=null,this.onSourceUnload(ze),this.initSource(ze)):this.initSource(ze)}_initSampler(ze){return this._gpuSamplers[ze._resourceId]=this._gpu.device.createSampler(ze),this._gpuSamplers[ze._resourceId]}getGpuSampler(ze){return this._gpuSamplers[ze._resourceId]||this._initSampler(ze)}getGpuSource(ze){return this._gpuSources[ze.uid]||this.initSource(ze)}getTextureBindGroup(ze){return this._bindGroupHash[ze.uid]??this._createTextureBindGroup(ze)}_createTextureBindGroup(ze){const Gr=ze.source;return this._bindGroupHash[ze.uid]=new BindGroup({0:Gr,1:Gr.style,2:new UniformGroup({uTextureMatrix:{type:"mat3x3<f32>",value:ze.textureMatrix.mapCoord}})}),this._bindGroupHash[ze.uid]}getTextureView(ze){const Gr=ze.source;return this._textureViewHash[Gr.uid]??this._createTextureView(Gr)}_createTextureView(ze){return this._textureViewHash[ze.uid]=this.getGpuSource(ze).createView(),this._textureViewHash[ze.uid]}generateCanvas(ze){const Gr=this._renderer,Wr=Gr.gpu.device.createCommandEncoder(),Kr=DOMAdapter.get().createCanvas();Kr.width=ze.source.pixelWidth,Kr.height=ze.source.pixelHeight;const Zr=Kr.getContext("webgpu");return Zr.configure({device:Gr.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),Wr.copyTextureToTexture({texture:Gr.texture.getGpuSource(ze.source),origin:{x:0,y:0}},{texture:Zr.getCurrentTexture()},{width:Kr.width,height:Kr.height}),Gr.gpu.device.queue.submit([Wr.finish()]),Kr}getPixels(ze){const Gr=this.generateCanvas(ze),Wr=CanvasPool.getOptimalCanvasAndContext(Gr.width,Gr.height),Kr=Wr.context;Kr.drawImage(Gr,0,0);const{width:Zr,height:Qr}=Gr,Jr=Kr.getImageData(0,0,Zr,Qr),ei=new Uint8ClampedArray(Jr.data.buffer);return CanvasPool.returnCanvasAndContext(Wr),{pixels:ei,width:Zr,height:Qr}}destroy(){this.managedTextures.slice().forEach(ze=>this.onSourceDestroy(ze)),this.managedTextures=null;for(const ze of Object.keys(this._bindGroupHash)){const Gr=Number(ze),Wr=this._bindGroupHash[Gr];Wr==null||Wr.destroy(),this._bindGroupHash[Gr]=null}this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}}GpuTextureSystem.extension={type:[ExtensionType.WebGPUSystem],name:"texture"};class GpuGraphicsAdaptor{init(){const ze=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),Gr=compileHighShaderGpuProgram({name:"graphics",bits:[colorBit,generateTextureBatchBit(getMaxTexturesPerBatch()),localUniformBitGroup2,roundPixelsBit]});this.shader=new Shader({gpuProgram:Gr,resources:{localUniforms:ze}})}execute(ze,Gr){const Wr=Gr.context,Kr=Wr.customShader||this.shader,Zr=ze.renderer,Qr=Zr.graphicsContext,{batcher:Jr,instructions:ei}=Qr.getContextRenderData(Wr),ti=Zr.encoder;ti.setGeometry(Jr.geometry,Kr.gpuProgram);const ri=Zr.globalUniforms.bindGroup;ti.setBindGroup(0,ri,Kr.gpuProgram);const ii=Zr.renderPipes.uniformBatch.getUniformBindGroup(Kr.resources.localUniforms,!0);ti.setBindGroup(2,ii,Kr.gpuProgram);const si=ei.instructions;let ni=null;for(let oi=0;oi<ei.instructionSize;oi++){const li=si[oi];if(li.topology!==ni&&(ni=li.topology,ti.setPipelineFromGeometryProgramAndState(Jr.geometry,Kr.gpuProgram,ze.state,li.topology)),Kr.groups[1]=li.bindGroup,!li.gpuBindGroup){const ai=li.textures;li.bindGroup=getTextureBatchBindGroup(ai.textures,ai.count),li.gpuBindGroup=Zr.bindGroup.getBindGroup(li.bindGroup,Kr.gpuProgram,1)}ti.setBindGroup(1,li.bindGroup,Kr.gpuProgram),ti.renderPassEncoder.drawIndexed(li.size,1,li.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}GpuGraphicsAdaptor.extension={type:[ExtensionType.WebGPUPipesAdaptor],name:"graphics"};class GpuMeshAdapter{init(){const ze=compileHighShaderGpuProgram({name:"mesh",bits:[localUniformBit,textureBit,roundPixelsBit]});this._shader=new Shader({gpuProgram:ze,resources:{uTexture:Texture.EMPTY._source,uSampler:Texture.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new Matrix}}}})}execute(ze,Gr){const Wr=ze.renderer;let Kr=Gr._shader;if(!Kr)Kr=this._shader,Kr.groups[2]=Wr.texture.getTextureBindGroup(Gr.texture);else if(!Kr.gpuProgram){warn("Mesh shader has no gpuProgram",Gr.shader);return}const Zr=Kr.gpuProgram;if(Zr.autoAssignGlobalUniforms&&(Kr.groups[0]=Wr.globalUniforms.bindGroup),Zr.autoAssignLocalUniforms){const Qr=ze.localUniforms;Kr.groups[1]=Wr.renderPipes.uniformBatch.getUniformBindGroup(Qr,!0)}Wr.encoder.draw({geometry:Gr._geometry,shader:Kr,state:Gr.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GpuMeshAdapter.extension={type:[ExtensionType.WebGPUPipesAdaptor],name:"mesh"};const DefaultWebGPUSystems=[...SharedSystems,GpuUboSystem,GpuEncoderSystem,GpuDeviceSystem,GpuBufferSystem,GpuTextureSystem,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,PipelineSystem,GpuColorMaskSystem,GpuStencilSystem,BindGroupSystem],DefaultWebGPUPipes=[...SharedRenderPipes,GpuUniformBatchPipe],DefaultWebGPUAdapters=[GpuBatchAdaptor,GpuMeshAdapter,GpuGraphicsAdaptor],systems=[],renderPipes=[],renderPipeAdaptors=[];extensions.handleByNamedList(ExtensionType.WebGPUSystem,systems);extensions.handleByNamedList(ExtensionType.WebGPUPipes,renderPipes);extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor,renderPipeAdaptors);extensions.add(...DefaultWebGPUSystems,...DefaultWebGPUPipes,...DefaultWebGPUAdapters);class WebGPURenderer extends AbstractRenderer{constructor(){const ze={name:"webgpu",type:RendererType.WEBGPU,systems,renderPipes,renderPipeAdaptors};super(ze)}}const WebGPURenderer$1=Object.freeze(Object.defineProperty({__proto__:null,WebGPURenderer},Symbol.toStringTag,{value:"Module"}));class GraphicsPipe{constructor(ze,Gr){this.state=State.for2d(),this._graphicsBatchesHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=ze,this._adaptor=Gr,this._adaptor.init(),this.renderer.renderableGC.addManagedHash(this,"_graphicsBatchesHash")}validateRenderable(ze){const Gr=ze.context,Wr=!!this._graphicsBatchesHash[ze.uid],Kr=this.renderer.graphicsContext.updateGpuContext(Gr);return!!(Kr.isBatchable||Wr!==Kr.isBatchable)}addRenderable(ze,Gr){const Wr=this.renderer.graphicsContext.updateGpuContext(ze.context);ze.didViewUpdate&&this._rebuild(ze),Wr.isBatchable?this._addToBatcher(ze,Gr):(this.renderer.renderPipes.batch.break(Gr),Gr.add(ze))}updateRenderable(ze){const Gr=this._graphicsBatchesHash[ze.uid];if(Gr)for(let Wr=0;Wr<Gr.length;Wr++){const Kr=Gr[Wr];Kr._batcher.updateElement(Kr)}}destroyRenderable(ze){this._graphicsBatchesHash[ze.uid]&&this._removeBatchForRenderable(ze.uid),ze.off("destroyed",this._destroyRenderableBound)}execute(ze){if(!ze.isRenderable)return;const Gr=this.renderer,Wr=ze.context;if(!Gr.graphicsContext.getGpuContext(Wr).batches.length)return;const Zr=Wr.customShader||this._adaptor.shader;this.state.blendMode=ze.groupBlendMode;const Qr=Zr.resources.localUniforms.uniforms;Qr.uTransformMatrix=ze.groupTransform,Qr.uRound=Gr._roundPixels|ze._roundPixels,color32BitToUniform(ze.groupColorAlpha,Qr.uColor,0),this._adaptor.execute(this,ze)}_rebuild(ze){const Gr=!!this._graphicsBatchesHash[ze.uid],Wr=this.renderer.graphicsContext.updateGpuContext(ze.context);Gr&&this._removeBatchForRenderable(ze.uid),Wr.isBatchable&&this._initBatchesForRenderable(ze),ze.batched=Wr.isBatchable}_addToBatcher(ze,Gr){const Wr=this.renderer.renderPipes.batch,Kr=this._getBatchesForRenderable(ze);for(let Zr=0;Zr<Kr.length;Zr++){const Qr=Kr[Zr];Wr.addToBatch(Qr,Gr)}}_getBatchesForRenderable(ze){return this._graphicsBatchesHash[ze.uid]||this._initBatchesForRenderable(ze)}_initBatchesForRenderable(ze){const Gr=ze.context,Wr=this.renderer.graphicsContext.getGpuContext(Gr),Kr=this.renderer._roundPixels|ze._roundPixels,Zr=Wr.batches.map(Qr=>{const Jr=BigPool.get(BatchableGraphics);return Qr.copyTo(Jr),Jr.renderable=ze,Jr.roundPixels=Kr,Jr});return this._graphicsBatchesHash[ze.uid]===void 0&&ze.on("destroyed",this._destroyRenderableBound),this._graphicsBatchesHash[ze.uid]=Zr,Zr}_removeBatchForRenderable(ze){this._graphicsBatchesHash[ze].forEach(Gr=>{BigPool.return(Gr)}),this._graphicsBatchesHash[ze]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const ze in this._graphicsBatchesHash)this._removeBatchForRenderable(ze);this._graphicsBatchesHash=null}}GraphicsPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"graphics"};const _PlaneGeometry=class Ls extends MeshGeometry{constructor(...ze){super({});let Gr=ze[0]??{};typeof Gr=="number"&&(deprecation(v8_0_0,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),Gr={width:Gr,height:ze[1],verticesX:ze[2],verticesY:ze[3]}),this.build(Gr)}build(ze){ze={...Ls.defaultOptions,...ze},this.verticesX=this.verticesX??ze.verticesX,this.verticesY=this.verticesY??ze.verticesY,this.width=this.width??ze.width,this.height=this.height??ze.height;const Gr=this.verticesX*this.verticesY,Wr=[],Kr=[],Zr=[],Qr=this.verticesX-1,Jr=this.verticesY-1,ei=this.width/Qr,ti=this.height/Jr;for(let ii=0;ii<Gr;ii++){const si=ii%this.verticesX,ni=ii/this.verticesX|0;Wr.push(si*ei,ni*ti),Kr.push(si/Qr,ni/Jr)}const ri=Qr*Jr;for(let ii=0;ii<ri;ii++){const si=ii%Qr,ni=ii/Qr|0,oi=ni*this.verticesX+si,li=ni*this.verticesX+si+1,ai=(ni+1)*this.verticesX+si,hi=(ni+1)*this.verticesX+si+1;Zr.push(oi,li,ai,li,hi,ai)}this.buffers[0].data=new Float32Array(Wr),this.buffers[1].data=new Float32Array(Kr),this.indexBuffer.data=new Uint32Array(Zr),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};_PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let PlaneGeometry=_PlaneGeometry;class BatchableMesh{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(ze){this._topology=ze}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(ze){this.texture!==ze&&(this.texture=ze,this._textureMatrixUpdateId=-1)}get uvs(){const Gr=this.geometry.getBuffer("aUV"),Wr=Gr.data;let Kr=Wr;const Zr=this.texture.textureMatrix;return Zr.isSimple||(Kr=this._transformedUvs,(this._textureMatrixUpdateId!==Zr._updateID||this._uvUpdateId!==Gr._updateID)&&((!Kr||Kr.length<Wr.length)&&(Kr=this._transformedUvs=new Float32Array(Wr.length)),this._textureMatrixUpdateId=Zr._updateID,this._uvUpdateId=Gr._updateID,Zr.multiplyUvs(Wr,Kr))),Kr}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}class MeshPipe{constructor(ze,Gr){this.localUniforms=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup({0:this.localUniforms}),this._meshDataHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=ze,this._adaptor=Gr,this._adaptor.init(),ze.renderableGC.addManagedHash(this,"_gpuBatchableMeshHash"),ze.renderableGC.addManagedHash(this,"_meshDataHash")}validateRenderable(ze){const Gr=this._getMeshData(ze),Wr=Gr.batched,Kr=ze.batched;if(Gr.batched=Kr,Wr!==Kr)return!0;if(Kr){const Zr=ze._geometry;if(Zr.indices.length!==Gr.indexSize||Zr.positions.length!==Gr.vertexSize)return Gr.indexSize=Zr.indices.length,Gr.vertexSize=Zr.positions.length,!0;const Qr=this._getBatchableMesh(ze);return Qr.texture.uid!==ze._texture.uid&&(Qr._textureMatrixUpdateId=-1),!Qr._batcher.checkAndUpdateTexture(Qr,ze._texture)}return!1}addRenderable(ze,Gr){const Wr=this.renderer.renderPipes.batch,{batched:Kr}=this._getMeshData(ze);if(Kr){const Zr=this._getBatchableMesh(ze);Zr.setTexture(ze._texture),Zr.geometry=ze._geometry,Wr.addToBatch(Zr,Gr)}else Wr.break(Gr),Gr.add(ze)}updateRenderable(ze){if(ze.batched){const Gr=this._gpuBatchableMeshHash[ze.uid];Gr.setTexture(ze._texture),Gr.geometry=ze._geometry,Gr._batcher.updateElement(Gr)}}destroyRenderable(ze){this._meshDataHash[ze.uid]=null;const Gr=this._gpuBatchableMeshHash[ze.uid];Gr&&(BigPool.return(Gr),this._gpuBatchableMeshHash[ze.uid]=null),ze.off("destroyed",this._destroyRenderableBound)}execute(ze){if(!ze.isRenderable)return;ze.state.blendMode=getAdjustedBlendModeBlend(ze.groupBlendMode,ze.texture._source);const Gr=this.localUniforms;Gr.uniforms.uTransformMatrix=ze.groupTransform,Gr.uniforms.uRound=this.renderer._roundPixels|ze._roundPixels,Gr.update(),color32BitToUniform(ze.groupColorAlpha,Gr.uniforms.uColor,0),this._adaptor.execute(this,ze)}_getMeshData(ze){return this._meshDataHash[ze.uid]||this._initMeshData(ze)}_initMeshData(ze){var Gr,Wr;return this._meshDataHash[ze.uid]={batched:ze.batched,indexSize:(Gr=ze._geometry.indices)==null?void 0:Gr.length,vertexSize:(Wr=ze._geometry.positions)==null?void 0:Wr.length},ze.on("destroyed",this._destroyRenderableBound),this._meshDataHash[ze.uid]}_getBatchableMesh(ze){return this._gpuBatchableMeshHash[ze.uid]||this._initBatchableMesh(ze)}_initBatchableMesh(ze){const Gr=BigPool.get(BatchableMesh);return Gr.renderable=ze,Gr.setTexture(ze._texture),Gr.transform=ze.groupTransform,Gr.roundPixels=this.renderer._roundPixels|ze._roundPixels,this._gpuBatchableMeshHash[ze.uid]=Gr,Gr}destroy(){for(const ze in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[ze]&&BigPool.return(this._gpuBatchableMeshHash[ze]);this._gpuBatchableMeshHash=null,this._meshDataHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"mesh"};class GlParticleContainerAdaptor{execute(ze,Gr){const Wr=ze.state,Kr=ze.renderer,Zr=Gr.shader||ze.defaultShader;Zr.resources.uTexture=Gr.texture._source,Zr.resources.uniforms=ze.localUniforms;const Qr=Kr.gl,Jr=ze.getBuffers(Gr);Kr.shader.bind(Zr),Kr.state.set(Wr),Kr.geometry.bind(Jr.geometry,Zr.glProgram);const ti=Jr.geometry.indexBuffer.data.BYTES_PER_ELEMENT===2?Qr.UNSIGNED_SHORT:Qr.UNSIGNED_INT;Qr.drawElements(Qr.TRIANGLES,Gr.particleChildren.length*6,ti,0)}}class GpuParticleContainerAdaptor{execute(ze,Gr){const Wr=ze.renderer,Kr=Gr.shader||ze.defaultShader;Kr.groups[0]=Wr.renderPipes.uniformBatch.getUniformBindGroup(ze.localUniforms,!0),Kr.groups[1]=Wr.texture.getTextureBindGroup(Gr.texture);const Zr=ze.state,Qr=ze.getBuffers(Gr);Wr.encoder.draw({geometry:Qr.geometry,shader:Gr.shader||ze.defaultShader,state:Zr,size:Gr.particleChildren.length*6})}}function createIndicesForQuads(Yr,ze=null){const Gr=Yr*6;if(Gr>65535?ze||(ze=new Uint32Array(Gr)):ze||(ze=new Uint16Array(Gr)),ze.length!==Gr)throw new Error(`Out buffer length is incorrect, got ${ze.length} and expected ${Gr}`);for(let Wr=0,Kr=0;Wr<Gr;Wr+=6,Kr+=4)ze[Wr+0]=Kr+0,ze[Wr+1]=Kr+1,ze[Wr+2]=Kr+2,ze[Wr+3]=Kr+0,ze[Wr+4]=Kr+2,ze[Wr+5]=Kr+3;return ze}function generateParticleUpdateFunction(Yr){return{dynamicUpdate:generateUpdateFunction(Yr,!0),staticUpdate:generateUpdateFunction(Yr,!1)}}function generateUpdateFunction(Yr,ze){const Gr=[];Gr.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);let Wr=0;for(const Zr in Yr){const Qr=Yr[Zr];if(ze!==Qr.dynamic)continue;Gr.push(`offset = index + ${Wr}`),Gr.push(Qr.code);const Jr=getAttributeInfoFromFormat(Qr.format);Wr+=Jr.stride/4}Gr.push(`
            index += stride * 4;
        }
    `),Gr.unshift(`
        var stride = ${Wr};
    `);const Kr=Gr.join(`
`);return new Function("ps","f32v","u32v",Kr)}class ParticleBuffer{constructor(ze){this._size=0,this._generateParticleUpdateCache={};const Gr=this._size=ze.size??1e3,Wr=ze.properties;let Kr=0,Zr=0;for(const ri in Wr){const ii=Wr[ri],si=getAttributeInfoFromFormat(ii.format);ii.dynamic?Zr+=si.stride:Kr+=si.stride}this._dynamicStride=Zr/4,this._staticStride=Kr/4,this.staticAttributeBuffer=new ViewableBuffer(Gr*4*Kr),this.dynamicAttributeBuffer=new ViewableBuffer(Gr*4*Zr),this.indexBuffer=createIndicesForQuads(Gr);const Qr=new Geometry;let Jr=0,ei=0;this._staticBuffer=new Buffer({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),this._dynamicBuffer=new Buffer({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST});for(const ri in Wr){const ii=Wr[ri],si=getAttributeInfoFromFormat(ii.format);ii.dynamic?(Qr.addAttribute(ii.attributeName,{buffer:this._dynamicBuffer,stride:this._dynamicStride*4,offset:Jr*4,format:ii.format}),Jr+=si.size):(Qr.addAttribute(ii.attributeName,{buffer:this._staticBuffer,stride:this._staticStride*4,offset:ei*4,format:ii.format}),ei+=si.size)}Qr.addIndex(this.indexBuffer);const ti=this.getParticleUpdate(Wr);this._dynamicUpload=ti.dynamicUpdate,this._staticUpload=ti.staticUpdate,this.geometry=Qr}getParticleUpdate(ze){const Gr=getParticleSyncKey(ze);return this._generateParticleUpdateCache[Gr]?this._generateParticleUpdateCache[Gr]:(this._generateParticleUpdateCache[Gr]=this.generateParticleUpdate(ze),this._generateParticleUpdateCache[Gr])}generateParticleUpdate(ze){return generateParticleUpdateFunction(ze)}update(ze,Gr){ze.length>this._size&&(Gr=!0,this._size=Math.max(ze.length,this._size*1.5|0),this.staticAttributeBuffer=new ViewableBuffer(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new ViewableBuffer(this._size*this._dynamicStride*4*4),this.indexBuffer=createIndicesForQuads(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const Wr=this.dynamicAttributeBuffer;if(this._dynamicUpload(ze,Wr.float32View,Wr.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,ze.length*this._dynamicStride*4,!0),Gr){const Kr=this.staticAttributeBuffer;this._staticUpload(ze,Kr.float32View,Kr.uint32View),this._staticBuffer.setDataWithSize(Kr.float32View,ze.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}function getParticleSyncKey(Yr){const ze=[];for(const Gr in Yr){const Wr=Yr[Gr];ze.push(Gr,Wr.code,Wr.dynamic?"d":"s")}return ze.join("_")}var fragment=`varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,vertex=`attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,wgsl=`
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;class ParticleShader extends Shader{constructor(){const ze=GlProgram.from({vertex,fragment}),Gr=GpuProgram.from({fragment:{source:wgsl,entryPoint:"mainFragment"},vertex:{source:wgsl,entryPoint:"mainVertex"}});super({glProgram:ze,gpuProgram:Gr,resources:{uTexture:Texture.WHITE.source,uSampler:new TextureStyle({}),uniforms:{uTranslationMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Color(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class ParticleContainerPipe{constructor(ze,Gr){this.state=State.for2d(),this._gpuBufferHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.localUniforms=new UniformGroup({uTranslationMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=ze,this.adaptor=Gr,this.defaultShader=new ParticleShader,this.state=State.for2d()}validateRenderable(ze){return!1}addRenderable(ze,Gr){this.renderer.renderPipes.batch.break(Gr),Gr.add(ze)}getBuffers(ze){return this._gpuBufferHash[ze.uid]||this._initBuffer(ze)}_initBuffer(ze){return this._gpuBufferHash[ze.uid]=new ParticleBuffer({size:ze.particleChildren.length,properties:ze._properties}),ze.on("destroyed",this._destroyRenderableBound),this._gpuBufferHash[ze.uid]}updateRenderable(ze){}destroyRenderable(ze){this._gpuBufferHash[ze.uid].destroy(),this._gpuBufferHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}execute(ze){const Gr=ze.particleChildren;if(Gr.length===0)return;const Wr=this.renderer,Kr=this.getBuffers(ze);ze.texture||(ze.texture=Gr[0].texture);const Zr=this.state;Kr.update(Gr,ze._childrenDirty),ze._childrenDirty=!1,Zr.blendMode=getAdjustedBlendModeBlend(ze.blendMode,ze.texture._source);const Qr=this.localUniforms.uniforms,Jr=Qr.uTranslationMatrix;ze.worldTransform.copyTo(Jr),Jr.prepend(Wr.globalUniforms.globalUniformData.projectionMatrix),Qr.uResolution=Wr.globalUniforms.globalUniformData.resolution,Qr.uRound=Wr._roundPixels|ze._roundPixels,color32BitToUniform(ze.groupColorAlpha,Qr.uColor,0),this.adaptor.execute(this,ze)}destroy(){this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class GlParticleContainerPipe extends ParticleContainerPipe{constructor(ze){super(ze,new GlParticleContainerAdaptor)}}GlParticleContainerPipe.extension={type:[ExtensionType.WebGLPipes],name:"particle"};class GpuParticleContainerPipe extends ParticleContainerPipe{constructor(ze){super(ze,new GpuParticleContainerAdaptor)}}GpuParticleContainerPipe.extension={type:[ExtensionType.WebGPUPipes],name:"particle"};const _NineSliceGeometry=class Ns extends PlaneGeometry{constructor(ze={}){ze={...Ns.defaultOptions,...ze},super({width:ze.width,height:ze.height,verticesX:4,verticesY:4}),this.update(ze)}update(ze){var Gr,Wr;this.width=ze.width??this.width,this.height=ze.height??this.height,this._originalWidth=ze.originalWidth??this._originalWidth,this._originalHeight=ze.originalHeight??this._originalHeight,this._leftWidth=ze.leftWidth??this._leftWidth,this._rightWidth=ze.rightWidth??this._rightWidth,this._topHeight=ze.topHeight??this._topHeight,this._bottomHeight=ze.bottomHeight??this._bottomHeight,this._anchorX=(Gr=ze.anchor)==null?void 0:Gr.x,this._anchorY=(Wr=ze.anchor)==null?void 0:Wr.y,this.updateUvs(),this.updatePositions()}updatePositions(){const ze=this.positions,{width:Gr,height:Wr,_leftWidth:Kr,_rightWidth:Zr,_topHeight:Qr,_bottomHeight:Jr,_anchorX:ei,_anchorY:ti}=this,ri=Kr+Zr,ii=Gr>ri?1:Gr/ri,si=Qr+Jr,ni=Wr>si?1:Wr/si,oi=Math.min(ii,ni),li=ei*Gr,ai=ti*Wr;ze[0]=ze[8]=ze[16]=ze[24]=-li,ze[2]=ze[10]=ze[18]=ze[26]=Kr*oi-li,ze[4]=ze[12]=ze[20]=ze[28]=Gr-Zr*oi-li,ze[6]=ze[14]=ze[22]=ze[30]=Gr-li,ze[1]=ze[3]=ze[5]=ze[7]=-ai,ze[9]=ze[11]=ze[13]=ze[15]=Qr*oi-ai,ze[17]=ze[19]=ze[21]=ze[23]=Wr-Jr*oi-ai,ze[25]=ze[27]=ze[29]=ze[31]=Wr-ai,this.getBuffer("aPosition").update()}updateUvs(){const ze=this.uvs;ze[0]=ze[8]=ze[16]=ze[24]=0,ze[1]=ze[3]=ze[5]=ze[7]=0,ze[6]=ze[14]=ze[22]=ze[30]=1,ze[25]=ze[27]=ze[29]=ze[31]=1;const Gr=1/this._originalWidth,Wr=1/this._originalHeight;ze[2]=ze[10]=ze[18]=ze[26]=Gr*this._leftWidth,ze[9]=ze[11]=ze[13]=ze[15]=Wr*this._topHeight,ze[4]=ze[12]=ze[20]=ze[28]=1-Gr*this._rightWidth,ze[17]=ze[19]=ze[21]=ze[23]=1-Wr*this._bottomHeight,this.getBuffer("aUV").update()}};_NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let NineSliceGeometry=_NineSliceGeometry;class NineSliceSpritePipe{constructor(ze){this._gpuSpriteHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuSpriteHash")}addRenderable(ze,Gr){const Wr=this._getGpuSprite(ze);ze.didViewUpdate&&this._updateBatchableSprite(ze,Wr),this._renderer.renderPipes.batch.addToBatch(Wr,Gr)}updateRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];ze.didViewUpdate&&this._updateBatchableSprite(ze,Gr),Gr._batcher.updateElement(Gr)}validateRenderable(ze){const Gr=this._getGpuSprite(ze);return!Gr._batcher.checkAndUpdateTexture(Gr,ze._texture)}destroyRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];BigPool.return(Gr.geometry),BigPool.return(Gr),this._gpuSpriteHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(ze,Gr){Gr.geometry.update(ze),Gr.setTexture(ze._texture)}_getGpuSprite(ze){return this._gpuSpriteHash[ze.uid]||this._initGPUSprite(ze)}_initGPUSprite(ze){const Gr=BigPool.get(BatchableMesh);return Gr.geometry=BigPool.get(NineSliceGeometry),Gr.renderable=ze,Gr.transform=ze.groupTransform,Gr.texture=ze._texture,Gr.roundPixels=this._renderer._roundPixels|ze._roundPixels,this._gpuSpriteHash[ze.uid]=Gr,ze.didViewUpdate||this._updateBatchableSprite(ze,Gr),ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuSpriteHash)this._gpuSpriteHash[ze].geometry.destroy();this._gpuSpriteHash=null,this._renderer=null}}NineSliceSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"nineSliceSprite"};const tilingBit={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},tilingBitGl={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `}};let gpuProgram$1,glProgram$1;class TilingSpriteShader extends Shader{constructor(){gpuProgram$1??(gpuProgram$1=compileHighShaderGpuProgram({name:"tiling-sprite-shader",bits:[localUniformBit,tilingBit,roundPixelsBit]})),glProgram$1??(glProgram$1=compileHighShaderGlProgram({name:"tiling-sprite-shader",bits:[localUniformBitGl,tilingBitGl,roundPixelsBitGl]}));const ze=new UniformGroup({uMapCoord:{value:new Matrix,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:glProgram$1,gpuProgram:gpuProgram$1,resources:{localUniforms:new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:ze,uTexture:Texture.EMPTY.source,uSampler:Texture.EMPTY.source.style}})}updateUniforms(ze,Gr,Wr,Kr,Zr,Qr){const Jr=this.resources.tilingUniforms,ei=Qr.width,ti=Qr.height,ri=Qr.textureMatrix,ii=Jr.uniforms.uTextureTransform;ii.set(Wr.a*ei/ze,Wr.b*ei/Gr,Wr.c*ti/ze,Wr.d*ti/Gr,Wr.tx/ze,Wr.ty/Gr),ii.invert(),Jr.uniforms.uMapCoord=ri.mapCoord,Jr.uniforms.uClampFrame=ri.uClampFrame,Jr.uniforms.uClampOffset=ri.uClampOffset,Jr.uniforms.uTextureTransform=ii,Jr.uniforms.uSizeAnchor[0]=ze,Jr.uniforms.uSizeAnchor[1]=Gr,Jr.uniforms.uSizeAnchor[2]=Kr,Jr.uniforms.uSizeAnchor[3]=Zr,Qr&&(this.resources.uTexture=Qr.source,this.resources.uSampler=Qr.source.style)}}class QuadGeometry extends MeshGeometry{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}function setPositions(Yr,ze){const Gr=Yr.anchor.x,Wr=Yr.anchor.y;ze[0]=-Gr*Yr.width,ze[1]=-Wr*Yr.height,ze[2]=(1-Gr)*Yr.width,ze[3]=-Wr*Yr.height,ze[4]=(1-Gr)*Yr.width,ze[5]=(1-Wr)*Yr.height,ze[6]=-Gr*Yr.width,ze[7]=(1-Wr)*Yr.height}function applyMatrix(Yr,ze,Gr,Wr){let Kr=0;const Zr=Yr.length/ze,Qr=Wr.a,Jr=Wr.b,ei=Wr.c,ti=Wr.d,ri=Wr.tx,ii=Wr.ty;for(Gr*=ze;Kr<Zr;){const si=Yr[Gr],ni=Yr[Gr+1];Yr[Gr]=Qr*si+ei*ni+ri,Yr[Gr+1]=Jr*si+ti*ni+ii,Gr+=ze,Kr++}}function setUvs(Yr,ze){const Gr=Yr.texture,Wr=Gr.frame.width,Kr=Gr.frame.height;let Zr=0,Qr=0;Yr.applyAnchorToTexture&&(Zr=Yr.anchor.x,Qr=Yr.anchor.y),ze[0]=ze[6]=-Zr,ze[2]=ze[4]=1-Zr,ze[1]=ze[3]=-Qr,ze[5]=ze[7]=1-Qr;const Jr=Matrix.shared;Jr.copyFrom(Yr._tileTransform.matrix),Jr.tx/=Yr.width,Jr.ty/=Yr.height,Jr.invert(),Jr.scale(Yr.width/Wr,Yr.height/Kr),applyMatrix(ze,2,0,Jr)}const sharedQuad=new QuadGeometry;class TilingSpritePipe{constructor(ze){this._state=State.default2d,this._tilingSpriteDataHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_tilingSpriteDataHash")}validateRenderable(ze){const Gr=this._getTilingSpriteData(ze),Wr=Gr.canBatch;this._updateCanBatch(ze);const Kr=Gr.canBatch;if(Kr&&Kr===Wr){const{batchableMesh:Zr}=Gr;return!Zr._batcher.checkAndUpdateTexture(Zr,ze.texture)}return Wr!==Kr}addRenderable(ze,Gr){const Wr=this._renderer.renderPipes.batch;this._updateCanBatch(ze);const Kr=this._getTilingSpriteData(ze),{geometry:Zr,canBatch:Qr}=Kr;if(Qr){Kr.batchableMesh||(Kr.batchableMesh=new BatchableMesh);const Jr=Kr.batchableMesh;ze.didViewUpdate&&(this._updateBatchableMesh(ze),Jr.geometry=Zr,Jr.renderable=ze,Jr.transform=ze.groupTransform,Jr.setTexture(ze._texture)),Jr.roundPixels=this._renderer._roundPixels|ze._roundPixels,Wr.addToBatch(Jr,Gr)}else Wr.break(Gr),Kr.shader||(Kr.shader=new TilingSpriteShader),this.updateRenderable(ze),Gr.add(ze)}execute(ze){const{shader:Gr}=this._tilingSpriteDataHash[ze.uid];Gr.groups[0]=this._renderer.globalUniforms.bindGroup;const Wr=Gr.resources.localUniforms.uniforms;Wr.uTransformMatrix=ze.groupTransform,Wr.uRound=this._renderer._roundPixels|ze._roundPixels,color32BitToUniform(ze.groupColorAlpha,Wr.uColor,0),this._state.blendMode=getAdjustedBlendModeBlend(ze.groupBlendMode,ze.texture._source),this._renderer.encoder.draw({geometry:sharedQuad,shader:Gr,state:this._state})}updateRenderable(ze){const Gr=this._getTilingSpriteData(ze),{canBatch:Wr}=Gr;if(Wr){const{batchableMesh:Kr}=Gr;ze.didViewUpdate&&this._updateBatchableMesh(ze),Kr._batcher.updateElement(Kr)}else if(ze.didViewUpdate){const{shader:Kr}=Gr;Kr.updateUniforms(ze.width,ze.height,ze._tileTransform.matrix,ze.anchor.x,ze.anchor.y,ze.texture)}}destroyRenderable(ze){var Wr;const Gr=this._getTilingSpriteData(ze);Gr.batchableMesh=null,(Wr=Gr.shader)==null||Wr.destroy(),this._tilingSpriteDataHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}_getTilingSpriteData(ze){return this._tilingSpriteDataHash[ze.uid]||this._initTilingSpriteData(ze)}_initTilingSpriteData(ze){const Gr=new MeshGeometry({indices:sharedQuad.indices,positions:sharedQuad.positions.slice(),uvs:sharedQuad.uvs.slice()});return this._tilingSpriteDataHash[ze.uid]={canBatch:!0,renderable:ze,geometry:Gr},ze.on("destroyed",this._destroyRenderableBound),this._tilingSpriteDataHash[ze.uid]}_updateBatchableMesh(ze){const Gr=this._getTilingSpriteData(ze),{geometry:Wr}=Gr,Kr=ze.texture.source.style;Kr.addressMode!=="repeat"&&(Kr.addressMode="repeat",Kr.update()),setUvs(ze,Wr.uvs),setPositions(ze,Wr.positions)}destroy(){for(const ze in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[ze].renderable);this._tilingSpriteDataHash=null,this._renderer=null}_updateCanBatch(ze){const Gr=this._getTilingSpriteData(ze),Wr=ze.texture;let Kr=!0;return this._renderer.type===RendererType.WEBGL&&(Kr=this._renderer.context.supports.nonPowOf2wrapping),Gr.canBatch=Wr.textureMatrix.isSimple&&(Kr||Wr.source.isPowerOfTwo),Gr.canBatch}}TilingSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"tilingSprite"};const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `}},mSDFBit={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `}},mSDFBitGl={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `}};let gpuProgram,glProgram;class SdfShader extends Shader{constructor(){const ze=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),Gr=getMaxTexturesPerBatch();gpuProgram??(gpuProgram=compileHighShaderGpuProgram({name:"sdf-shader",bits:[colorBit,generateTextureBatchBit(Gr),localUniformMSDFBit,mSDFBit,roundPixelsBit]})),glProgram??(glProgram=compileHighShaderGlProgram({name:"sdf-shader",bits:[colorBitGl,generateTextureBatchBitGl(Gr),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBitGl]})),super({glProgram,gpuProgram,resources:{localUniforms:ze,batchSamplers:getBatchSamplersUniformGroup(Gr)}})}}class BitmapTextPipe{constructor(ze){this._gpuBitmapText={},this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuBitmapText")}validateRenderable(ze){const Gr=this._getGpuBitmapText(ze);return ze._didTextUpdate&&(ze._didTextUpdate=!1,this._updateContext(ze,Gr)),this._renderer.renderPipes.graphics.validateRenderable(Gr)}addRenderable(ze,Gr){const Wr=this._getGpuBitmapText(ze);syncWithProxy(ze,Wr),ze._didTextUpdate&&(ze._didTextUpdate=!1,this._updateContext(ze,Wr)),this._renderer.renderPipes.graphics.addRenderable(Wr,Gr),Wr.context.customShader&&this._updateDistanceField(ze)}destroyRenderable(ze){ze.off("destroyed",this._destroyRenderableBound),this._destroyRenderableByUid(ze.uid)}_destroyRenderableByUid(ze){const Gr=this._gpuBitmapText[ze].context;Gr.customShader&&(BigPool.return(Gr.customShader),Gr.customShader=null),BigPool.return(this._gpuBitmapText[ze]),this._gpuBitmapText[ze]=null}updateRenderable(ze){const Gr=this._getGpuBitmapText(ze);syncWithProxy(ze,Gr),this._renderer.renderPipes.graphics.updateRenderable(Gr),Gr.context.customShader&&this._updateDistanceField(ze)}_updateContext(ze,Gr){const{context:Wr}=Gr,Kr=BitmapFontManager.getFont(ze.text,ze._style);Wr.clear(),Kr.distanceField.type!=="none"&&(Wr.customShader||(Wr.customShader=BigPool.get(SdfShader)));const Zr=Array.from(ze.text),Qr=ze._style;let Jr=Kr.baseLineOffset;const ei=getBitmapTextLayout(Zr,Qr,Kr,!0);let ti=0;const ri=Qr.padding,ii=ei.scale;let si=ei.width,ni=ei.height+ei.offsetY;Qr._stroke&&(si+=Qr._stroke.width/ii,ni+=Qr._stroke.width/ii),Wr.translate(-ze._anchor._x*si-ri,-ze._anchor._y*ni-ri).scale(ii,ii);const oi=Kr.applyFillAsTint?Qr._fill.color:16777215;for(let li=0;li<ei.lines.length;li++){const ai=ei.lines[li];for(let hi=0;hi<ai.charPositions.length;hi++){const fi=Zr[ti++],pi=Kr.chars[fi];pi!=null&&pi.texture&&Wr.texture(pi.texture,oi||"black",Math.round(ai.charPositions[hi]+pi.xOffset),Math.round(Jr+pi.yOffset))}Jr+=Kr.lineHeight}}_getGpuBitmapText(ze){return this._gpuBitmapText[ze.uid]||this.initGpuText(ze)}initGpuText(ze){const Gr=BigPool.get(Graphics);return this._gpuBitmapText[ze.uid]=Gr,this._updateContext(ze,Gr),ze.on("destroyed",this._destroyRenderableBound),this._gpuBitmapText[ze.uid]}_updateDistanceField(ze){const Gr=this._getGpuBitmapText(ze).context,Wr=ze._style.fontFamily,Kr=Cache.get(`${Wr}-bitmap`),{a:Zr,b:Qr,c:Jr,d:ei}=ze.groupTransform,ti=Math.sqrt(Zr*Zr+Qr*Qr),ri=Math.sqrt(Jr*Jr+ei*ei),ii=(Math.abs(ti)+Math.abs(ri))/2,si=Kr.baseRenderedFontSize/ze._style.fontSize,ni=ii*Kr.distanceField.range*(1/si);Gr.customShader.resources.localUniforms.uniforms.uDistance=ni}destroy(){for(const ze in this._gpuBitmapText)this._destroyRenderableByUid(ze);this._gpuBitmapText=null,this._renderer=null}}BitmapTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"bitmapText"};function syncWithProxy(Yr,ze){ze.groupTransform=Yr.groupTransform,ze.groupColorAlpha=Yr.groupColorAlpha,ze.groupColor=Yr.groupColor,ze.groupBlendMode=Yr.groupBlendMode,ze.globalDisplayStatus=Yr.globalDisplayStatus,ze.groupTransform=Yr.groupTransform,ze.localDisplayStatus=Yr.localDisplayStatus,ze.groupAlpha=Yr.groupAlpha,ze._roundPixels=Yr._roundPixels}function updateTextBounds(Yr,ze){const{texture:Gr,bounds:Wr}=Yr;updateQuadBounds(Wr,ze._anchor,Gr);const Kr=ze._style.padding;Wr.minX-=Kr,Wr.minY-=Kr,Wr.maxX-=Kr,Wr.maxY-=Kr}class HTMLTextPipe{constructor(ze){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.runners.resolutionChange.add(this),this._renderer.renderableGC.addManagedHash(this,"_gpuText")}resolutionChange(){for(const ze in this._gpuText){const Gr=this._gpuText[ze];if(!Gr)continue;const Wr=Gr.batchableSprite.renderable;Wr._autoResolution&&(Wr._resolution=this._renderer.resolution,Wr.onViewUpdate())}}validateRenderable(ze){const Gr=this._getGpuText(ze),Wr=ze._getKey();return Gr.textureNeedsUploading?(Gr.textureNeedsUploading=!1,!0):Gr.currentKey!==Wr}addRenderable(ze,Gr){const Kr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),this._renderer.renderPipes.batch.addToBatch(Kr,Gr)}updateRenderable(ze){const Wr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),Wr._batcher.updateElement(Wr)}destroyRenderable(ze){ze.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(ze.uid)}_destroyRenderableById(ze){const Gr=this._gpuText[ze];this._renderer.htmlText.decreaseReferenceCount(Gr.currentKey),BigPool.return(Gr.batchableSprite),this._gpuText[ze]=null}_updateText(ze){const Gr=ze._getKey(),Wr=this._getGpuText(ze),Kr=Wr.batchableSprite;Wr.currentKey!==Gr&&this._updateGpuText(ze).catch(Zr=>{console.error(Zr)}),ze._didTextUpdate=!1,updateTextBounds(Kr,ze)}async _updateGpuText(ze){ze._didTextUpdate=!1;const Gr=this._getGpuText(ze);if(Gr.generatingTexture)return;const Wr=ze._getKey();this._renderer.htmlText.decreaseReferenceCount(Gr.currentKey),Gr.generatingTexture=!0,Gr.currentKey=Wr;const Kr=ze.resolution??this._renderer.resolution,Zr=await this._renderer.htmlText.getManagedTexture(ze.text,Kr,ze._style,ze._getKey()),Qr=Gr.batchableSprite;Qr.texture=Gr.texture=Zr,Gr.generatingTexture=!1,Gr.textureNeedsUploading=!0,ze.onViewUpdate(),updateTextBounds(Qr,ze)}_getGpuText(ze){return this._gpuText[ze.uid]||this.initGpuText(ze)}initGpuText(ze){const Gr={texture:Texture.EMPTY,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite),textureNeedsUploading:!1,generatingTexture:!1},Wr=Gr.batchableSprite;return Wr.renderable=ze,Wr.transform=ze.groupTransform,Wr.texture=Texture.EMPTY,Wr.bounds={minX:0,maxX:1,minY:0,maxY:0},Wr.roundPixels=this._renderer._roundPixels|ze._roundPixels,ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution,this._gpuText[ze.uid]=Gr,ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuText)this._destroyRenderableById(ze);this._gpuText=null,this._renderer=null}}HTMLTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"htmlText"};function isSafari(){const{userAgent:Yr}=DOMAdapter.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(Yr)}const tempBounds=new Bounds;function getPo2TextureFromSource(Yr,ze,Gr,Wr){const Kr=tempBounds;Kr.minX=0,Kr.minY=0,Kr.maxX=Yr.width/Wr|0,Kr.maxY=Yr.height/Wr|0;const Zr=TexturePool.getOptimalTexture(Kr.width,Kr.height,Wr,!1);return Zr.source.uploadMethodId="image",Zr.source.resource=Yr,Zr.source.alphaMode="premultiply-alpha-on-upload",Zr.frame.width=ze/Wr,Zr.frame.height=Gr/Wr,Zr.source.emit("update",Zr.source),Zr.updateUvs(),Zr}function extractFontFamilies(Yr,ze){const Gr=ze.fontFamily,Wr=[],Kr={},Zr=/font-family:([^;"\s]+)/g,Qr=Yr.match(Zr);function Jr(ei){Kr[ei]||(Wr.push(ei),Kr[ei]=!0)}if(Array.isArray(Gr))for(let ei=0;ei<Gr.length;ei++)Jr(Gr[ei]);else Jr(Gr);Qr&&Qr.forEach(ei=>{const ti=ei.split(":")[1].trim();Jr(ti)});for(const ei in ze.tagStyles){const ti=ze.tagStyles[ei].fontFamily;Jr(ti)}return Wr}async function loadFontAsBase64(Yr){const Gr=await(await DOMAdapter.get().fetch(Yr)).blob(),Wr=new FileReader;return await new Promise((Zr,Qr)=>{Wr.onloadend=()=>Zr(Wr.result),Wr.onerror=Qr,Wr.readAsDataURL(Gr)})}async function loadFontCSS(Yr,ze){const Gr=await loadFontAsBase64(ze);return`@font-face {
        font-family: "${Yr.fontFamily}";
        src: url('${Gr}');
        font-weight: ${Yr.fontWeight};
        font-style: ${Yr.fontStyle};
    }`}const FontStylePromiseCache=new Map;async function getFontCss(Yr,ze,Gr){const Wr=Yr.filter(Kr=>Cache.has(`${Kr}-and-url`)).map((Kr,Zr)=>{if(!FontStylePromiseCache.has(Kr)){const{url:Qr}=Cache.get(`${Kr}-and-url`);Zr===0?FontStylePromiseCache.set(Kr,loadFontCSS({fontWeight:ze.fontWeight,fontStyle:ze.fontStyle,fontFamily:Kr},Qr)):FontStylePromiseCache.set(Kr,loadFontCSS({fontWeight:Gr.fontWeight,fontStyle:Gr.fontStyle,fontFamily:Kr},Qr))}return FontStylePromiseCache.get(Kr)});return(await Promise.all(Wr)).join(`
<<<<<<<< HEAD:public/index-YljAjz_N.js
`)}function getSVGUrl(Yr,ze,Gr,Wr,Kr){const{domElement:Zr,styleElement:Qr,svgRoot:Jr}=Kr;Zr.innerHTML=`<style>${ze.cssStyle}</style><div style='padding:0;'>${Yr}</div>`,Zr.setAttribute("style",`transform: scale(${Gr});transform-origin: top left; display: inline-block`),Qr.textContent=Wr;const{width:ei,height:ti}=Kr.image;return Jr.setAttribute("width",ei.toString()),Jr.setAttribute("height",ti.toString()),new XMLSerializer().serializeToString(Jr)}function getTemporaryCanvasFromImage(Yr,ze){const Gr=CanvasPool.getOptimalCanvasAndContext(Yr.width,Yr.height,ze),{context:Wr}=Gr;return Wr.clearRect(0,0,Yr.width,Yr.height),Wr.drawImage(Yr,0,0),Gr}function loadSVGImage(Yr,ze,Gr){return new Promise(async Wr=>{Gr&&await new Promise(Kr=>setTimeout(Kr,100)),Yr.onload=()=>{Wr()},Yr.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(ze)}`,Yr.crossOrigin="anonymous"})}class HTMLTextSystem{constructor(ze){this._activeTextures={},this._renderer=ze,this._createCanvas=ze.type===RendererType.WEBGPU}getTexture(ze){return this._buildTexturePromise(ze.text,ze.resolution,ze.style)}getManagedTexture(ze,Gr,Wr,Kr){if(this._activeTextures[Kr])return this._increaseReferenceCount(Kr),this._activeTextures[Kr].promise;const Zr=this._buildTexturePromise(ze,Gr,Wr).then(Qr=>(this._activeTextures[Kr].texture=Qr,Qr));return this._activeTextures[Kr]={texture:null,promise:Zr,usageCount:1},Zr}async _buildTexturePromise(ze,Gr,Wr){const Kr=BigPool.get(HTMLTextRenderData),Zr=extractFontFamilies(ze,Wr),Qr=await getFontCss(Zr,Wr,HTMLTextStyle.defaultTextStyle),Jr=measureHtmlText(ze,Wr,Qr,Kr),ei=Math.ceil(Math.ceil(Math.max(1,Jr.width)+Wr.padding*2)*Gr),ti=Math.ceil(Math.ceil(Math.max(1,Jr.height)+Wr.padding*2)*Gr),ri=Kr.image,ii=2;ri.width=(ei|0)+ii,ri.height=(ti|0)+ii;const si=getSVGUrl(ze,Wr,Gr,Qr,Kr);await loadSVGImage(ri,si,isSafari()&&Zr.length>0);const ni=ri;let oi;this._createCanvas&&(oi=getTemporaryCanvasFromImage(ri,Gr));const li=getPo2TextureFromSource(oi?oi.canvas:ni,ri.width-ii,ri.height-ii,Gr);return this._createCanvas&&(this._renderer.texture.initSource(li.source),CanvasPool.returnCanvasAndContext(oi)),BigPool.return(Kr),li}_increaseReferenceCount(ze){this._activeTextures[ze].usageCount++}decreaseReferenceCount(ze){const Gr=this._activeTextures[ze];Gr&&(Gr.usageCount--,Gr.usageCount===0&&(Gr.texture?this._cleanUp(Gr):Gr.promise.then(Wr=>{Gr.texture=Wr,this._cleanUp(Gr)}).catch(()=>{warn("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[ze]=null))}_cleanUp(ze){TexturePool.returnTexture(ze.texture),ze.texture.source.resource=null,ze.texture.source.uploadMethodId="unknown"}getReferenceCount(ze){return this._activeTextures[ze].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"htmlText"};HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"};class CanvasTextPipe{constructor(ze){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.runners.resolutionChange.add(this),this._renderer.renderableGC.addManagedHash(this,"_gpuText")}resolutionChange(){for(const ze in this._gpuText){const Gr=this._gpuText[ze];if(!Gr)continue;const Wr=Gr.batchableSprite.renderable;Wr._autoResolution&&(Wr._resolution=this._renderer.resolution,Wr.onViewUpdate())}}validateRenderable(ze){const Gr=this._getGpuText(ze),Wr=ze._getKey();return Gr.currentKey!==Wr}addRenderable(ze,Gr){const Kr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),this._renderer.renderPipes.batch.addToBatch(Kr,Gr)}updateRenderable(ze){const Wr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),Wr._batcher.updateElement(Wr)}destroyRenderable(ze){ze.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(ze.uid)}_destroyRenderableById(ze){const Gr=this._gpuText[ze];this._renderer.canvasText.decreaseReferenceCount(Gr.currentKey),BigPool.return(Gr.batchableSprite),this._gpuText[ze]=null}_updateText(ze){const Gr=ze._getKey(),Wr=this._getGpuText(ze),Kr=Wr.batchableSprite;Wr.currentKey!==Gr&&this._updateGpuText(ze),ze._didTextUpdate=!1,updateTextBounds(Kr,ze)}_updateGpuText(ze){const Gr=this._getGpuText(ze),Wr=Gr.batchableSprite;Gr.texture&&this._renderer.canvasText.decreaseReferenceCount(Gr.currentKey),Gr.texture=Wr.texture=this._renderer.canvasText.getManagedTexture(ze),Gr.currentKey=ze._getKey(),Wr.texture=Gr.texture}_getGpuText(ze){return this._gpuText[ze.uid]||this.initGpuText(ze)}initGpuText(ze){const Gr={texture:null,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite)};return Gr.batchableSprite.renderable=ze,Gr.batchableSprite.transform=ze.groupTransform,Gr.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},Gr.batchableSprite.roundPixels=this._renderer._roundPixels|ze._roundPixels,this._gpuText[ze.uid]=Gr,ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution,this._updateText(ze),ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuText)this._destroyRenderableById(ze);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"text"};function checkRow(Yr,ze,Gr){for(let Wr=0,Kr=4*Gr*ze;Wr<ze;++Wr,Kr+=4)if(Yr[Kr+3]!==0)return!1;return!0}function checkColumn(Yr,ze,Gr,Wr,Kr){const Zr=4*ze;for(let Qr=Wr,Jr=Wr*Zr+4*Gr;Qr<=Kr;++Qr,Jr+=Zr)if(Yr[Jr+3]!==0)return!1;return!0}function getCanvasBoundingBox(Yr,ze=1){const{width:Gr,height:Wr}=Yr,Kr=Yr.getContext("2d",{willReadFrequently:!0});if(Kr===null)throw new TypeError("Failed to get canvas 2D context");const Qr=Kr.getImageData(0,0,Gr,Wr).data;let Jr=0,ei=0,ti=Gr-1,ri=Wr-1;for(;ei<Wr&&checkRow(Qr,Gr,ei);)++ei;if(ei===Wr)return Rectangle.EMPTY;for(;checkRow(Qr,Gr,ri);)--ri;for(;checkColumn(Qr,Gr,Jr,ei,ri);)++Jr;for(;checkColumn(Qr,Gr,ti,ei,ri);)--ti;return++ti,++ri,new Rectangle(Jr/ze,ei/ze,(ti-Jr)/ze,(ri-ei)/ze)}class CanvasTextSystem{constructor(ze){this._activeTextures={},this._renderer=ze}getTextureSize(ze,Gr,Wr){const Kr=CanvasTextMetrics.measureText(ze||" ",Wr);let Zr=Math.ceil(Math.ceil(Math.max(1,Kr.width)+Wr.padding*2)*Gr),Qr=Math.ceil(Math.ceil(Math.max(1,Kr.height)+Wr.padding*2)*Gr);return Zr=Math.ceil(Zr-1e-6),Qr=Math.ceil(Qr-1e-6),Zr=nextPow2(Zr),Qr=nextPow2(Qr),{width:Zr,height:Qr}}getTexture(ze,Gr,Wr,Kr){typeof ze=="string"&&(deprecation("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),ze={text:ze,style:Wr,resolution:Gr}),ze.style instanceof TextStyle||(ze.style=new TextStyle(ze.style));const{texture:Zr,canvasAndContext:Qr}=this.createTextureAndCanvas(ze);return this._renderer.texture.initSource(Zr._source),CanvasPool.returnCanvasAndContext(Qr),Zr}createTextureAndCanvas(ze){const{text:Gr,style:Wr}=ze,Kr=ze.resolution??this._renderer.resolution,Zr=CanvasTextMetrics.measureText(Gr||" ",Wr),Qr=Math.ceil(Math.ceil(Math.max(1,Zr.width)+Wr.padding*2)*Kr),Jr=Math.ceil(Math.ceil(Math.max(1,Zr.height)+Wr.padding*2)*Kr),ei=CanvasPool.getOptimalCanvasAndContext(Qr,Jr),{canvas:ti}=ei;this.renderTextToCanvas(Gr,Wr,Kr,ei);const ri=getPo2TextureFromSource(ti,Qr,Jr,Kr);if(Wr.trim){const ii=getCanvasBoundingBox(ti,Kr);ri.frame.copyFrom(ii),ri.updateUvs()}return{texture:ri,canvasAndContext:ei}}getManagedTexture(ze){ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution;const Gr=ze._getKey();if(this._activeTextures[Gr])return this._increaseReferenceCount(Gr),this._activeTextures[Gr].texture;const{texture:Wr,canvasAndContext:Kr}=this.createTextureAndCanvas(ze);return this._activeTextures[Gr]={canvasAndContext:Kr,texture:Wr,usageCount:1},Wr}_increaseReferenceCount(ze){this._activeTextures[ze].usageCount++}returnTexture(ze){const Gr=ze.source;Gr.resource=null,Gr.uploadMethodId="unknown",Gr.alphaMode="no-premultiply-alpha",TexturePool.returnTexture(ze)}decreaseReferenceCount(ze){const Gr=this._activeTextures[ze];Gr.usageCount--,Gr.usageCount===0&&(CanvasPool.returnCanvasAndContext(Gr.canvasAndContext),this.returnTexture(Gr.texture),this._activeTextures[ze]=null)}getReferenceCount(ze){return this._activeTextures[ze].usageCount}renderTextToCanvas(ze,Gr,Wr,Kr){var fi,pi,mi,Ti;const{canvas:Zr,context:Qr}=Kr,Jr=fontStringFromTextStyle(Gr),ei=CanvasTextMetrics.measureText(ze||" ",Gr),ti=ei.lines,ri=ei.lineHeight,ii=ei.lineWidths,si=ei.maxLineWidth,ni=ei.fontProperties,oi=Zr.height;if(Qr.resetTransform(),Qr.scale(Wr,Wr),Qr.textBaseline=Gr.textBaseline,(fi=Gr._stroke)!=null&&fi.width){const yi=Gr._stroke;Qr.lineWidth=yi.width,Qr.miterLimit=yi.miterLimit,Qr.lineJoin=yi.join,Qr.lineCap=yi.cap}Qr.font=Jr;let li,ai;const hi=Gr.dropShadow?2:1;for(let yi=0;yi<hi;++yi){const _i=Gr.dropShadow&&yi===0,Ai=_i?Math.ceil(Math.max(1,oi)+Gr.padding*2):0,Ri=Ai*Wr;if(_i){Qr.fillStyle="black",Qr.strokeStyle="black";const Bi=Gr.dropShadow,ki=Bi.color,Wi=Bi.alpha;Qr.shadowColor=Color.shared.setValue(ki).setAlpha(Wi).toRgbaString();const Li=Bi.blur*Wr,ci=Bi.distance*Wr;Qr.shadowBlur=Li,Qr.shadowOffsetX=Math.cos(Bi.angle)*ci,Qr.shadowOffsetY=Math.sin(Bi.angle)*ci+Ri}else{if(Qr.fillStyle=Gr._fill?getCanvasFillStyle(Gr._fill,Qr,ei):null,(pi=Gr._stroke)!=null&&pi.width){const Bi=Gr._stroke.width*Gr._stroke.alignment;Qr.strokeStyle=getCanvasFillStyle(Gr._stroke,Qr,ei,Bi)}Qr.shadowColor="black"}let Pi=(ri-ni.fontSize)/2;ri-ni.fontSize<0&&(Pi=0);const Si=((mi=Gr._stroke)==null?void 0:mi.width)??0;for(let Bi=0;Bi<ti.length;Bi++)li=Si/2,ai=Si/2+Bi*ri+ni.ascent+Pi,Gr.align==="right"?li+=si-ii[Bi]:Gr.align==="center"&&(li+=(si-ii[Bi])/2),(Ti=Gr._stroke)!=null&&Ti.width&&this._drawLetterSpacing(ti[Bi],Gr,Kr,li+Gr.padding,ai+Gr.padding-Ai,!0),Gr._fill!==void 0&&this._drawLetterSpacing(ti[Bi],Gr,Kr,li+Gr.padding,ai+Gr.padding-Ai)}}_drawLetterSpacing(ze,Gr,Wr,Kr,Zr,Qr=!1){const{context:Jr}=Wr,ei=Gr.letterSpacing;let ti=!1;if(CanvasTextMetrics.experimentalLetterSpacingSupported&&(CanvasTextMetrics.experimentalLetterSpacing?(Jr.letterSpacing=`${ei}px`,Jr.textLetterSpacing=`${ei}px`,ti=!0):(Jr.letterSpacing="0px",Jr.textLetterSpacing="0px")),ei===0||ti){Qr?Jr.strokeText(ze,Kr,Zr):Jr.fillText(ze,Kr,Zr);return}let ri=Kr;const ii=CanvasTextMetrics.graphemeSegmenter(ze);let si=Jr.measureText(ze).width,ni=0;for(let oi=0;oi<ii.length;++oi){const li=ii[oi];Qr?Jr.strokeText(li,ri,Zr):Jr.fillText(li,ri,Zr);let ai="";for(let hi=oi+1;hi<ii.length;++hi)ai+=ii[hi];ni=Jr.measureText(ai).width,ri+=si-ni+ei,si=ni}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"canvasText"};extensions.add(browserExt,webworkerExt);const CGA_CYAN_DARK_BG="#012C2C",CGA_CYAN="#00FBFB",CGA_PINK="#FF55FE",CGA_PINK_DARK="#6b1156",CGA_BLACK="#101010",CGA_CYAN_DARK="#023C3C",CGA_WHITE="#ffffff",TILESIZE=32,PLAYERSPEED=.1,TILEMAP=[[15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,4,3,3,3,0,0,0,0,0,0,0,0,0,1,0,-1,-1,-1,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,5,4,3,3,3,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],GRIDWIDTH=TILEMAP[0].length,GRIDHEIGHT=TILEMAP.length;class Point{constructor(ze,Gr){Ci(this,"asCartesian");Ci(this,"asIsometric");this.asCartesian={x:ze,y:Gr},this.asIsometric={x:ze*TILESIZE-Gr*TILESIZE,y:ze*TILESIZE/2+Gr*TILESIZE/2}}update(ze){this.asCartesian=ze,this.asIsometric={x:ze.x*TILESIZE-ze.y*TILESIZE,y:ze.x*TILESIZE/2+ze.y*TILESIZE/2}}add(ze){this.asIsometric={x:this.asIsometric.x+ze.x,y:this.asIsometric.y+ze.y}}}var MessageType=(Yr=>(Yr.Connect="connect",Yr.Disconnect="disconnect",Yr.Transition="transition",Yr.RoomChat="room_chat",Yr.PersonalChat="personal_chat",Yr.GameInvite="game_invite",Yr))(MessageType||{}),RoomType=(Yr=>(Yr.Cluster="cluster",Yr.Server="server",Yr.Game="game",Yr.Bocal="bocal",Yr.Hall="hall",Yr.Toilet="toilet",Yr))(RoomType||{}),CameraMode=(Yr=>(Yr[Yr.Locked=0]="Locked",Yr[Yr.Free=1]="Free",Yr))(CameraMode||{}),PongState=(Yr=>(Yr[Yr.Waiting=0]="Waiting",Yr[Yr.PlayerNearby=1]="PlayerNearby",Yr[Yr.PlayerReady=2]="PlayerReady",Yr[Yr.InProgress=3]="InProgress",Yr[Yr.Enrolling=4]="Enrolling",Yr[Yr.Announcing=5]="Announcing",Yr))(PongState||{}),TournamentState=(Yr=>(Yr.Enrolling="Enrolling",Yr.Scheduling="Scheduling",Yr.Announcing="Announcing",Yr.Playing="Playing",Yr.Concluding="Concluding",Yr))(TournamentState||{});function createDirectionalAnimatedSprite(Yr,ze){const Gr={},Wr=Object.keys(Yr);for(const Qr of ze){const Jr=[];for(let ei=Qr.from;ei<=Qr.to;ei++){const ti=Wr[ei];ti&&Yr[ti]&&Jr.push(Yr[ti])}Gr[Qr.name]=Jr}const Kr=Gr.idle??Object.values(Gr)[0],Zr=new AnimatedSprite(Kr);return Zr.animations=Gr,Zr.animationSpeed=.05,Zr.loop=!0,Zr.play(),Zr.setAnimation=function(Qr){if(this.currentAnimation===Qr)return;Qr==="idle"?Zr.animationSpeed=.05:Zr.animationSpeed=.1;const Jr=this.animations[Qr];Jr&&(this.textures=Jr,this.currentAnimation=Qr,this.play())},Zr}class Player{constructor(ze,Gr,Wr,Kr){Ci(this,"id");Ci(this,"position");Ci(this,"username");Ci(this,"avatar");Ci(this,"region",RoomType.Hall);Ci(this,"shadow");Ci(this,"container");Ci(this,"animation");this.id=ze,this.position=new Point(Kr.x,Kr.y),this.username=Gr,this.avatar=Wr;const Zr=Assets.get("player_spritesheet");this.animation=createDirectionalAnimatedSprite(Zr.textures,Zr.data.meta.frameTags),this.animation.anchor.set(.5),this.shadow=new Graphics().circle(0,this.animation.height*2,10).fill("#000000"),this.shadow.scale.y=.25,this.shadow.alpha=.25,this.shadow.zIndex=5e3,this.container=new Container,this.container.addChild(this.animation),this.container.addChild(this.shadow),this.container.x=this.position.asIsometric.x,this.container.y=this.position.asIsometric.y,this.container.zIndex=this.position.asIsometric.y+7.5}setRegion(ze){this.region=ze}getRegion(){return this.region}updatePosition(ze){ze.x-this.position.asCartesian.x<0?this.animation.setAnimation("west"):ze.x-this.position.asCartesian.x>0?this.animation.setAnimation("east"):ze.y-this.position.asCartesian.y>0?this.animation.setAnimation("south"):ze.y-this.position.asCartesian.y<0&&this.animation.setAnimation("north"),this.position.update(ze),this.container.zIndex=this.position.asIsometric.y+7.5,this.container.x=this.position.asIsometric.x,this.container.y=this.position.asIsometric.y;let Gr=this.position.asCartesian;setTimeout(()=>{Gr.x===this.getPosition().x&&Gr.y===this.getPosition().y&&this.animation.setAnimation("idle")},50)}setAnimation(ze){this.animation.setAnimation(ze)}getId(){return this.id}getAvatar(){return this.avatar}getUsername(){return this.username}getPoint(){return this.position}getPosition(){return this.position.asCartesian}getIsometricPosition(){return this.position.asIsometric}destroy(){this.animation.destroy(),this.shadow.destroy(),this.container.destroy()}getContext(){return this.container}}class TextBox{constructor(ze,Gr,Wr,Kr){Ci(this,"container");Ci(this,"graphics");Ci(this,"position");Ci(this,"text");Ci(this,"textSize");Ci(this,"height");Ci(this,"width");Ci(this,"backgroundColor",CGA_BLACK);Ci(this,"strokeColor",CGA_PINK);Ci(this,"textColor",CGA_PINK);this.container=new Container,this.textSize=Gr;const Zr=new TextStyle({fill:this.textColor,fontSize:this.textSize});this.text=new Text({text:ze,style:Zr}),this.height=this.textSize*2,this.width=this.text.width+this.textSize,this.position={x:Wr,y:Kr},this.text.x=Wr+this.textSize/2,this.text.y=Kr+this.textSize/2,this.graphics=new Graphics().roundRect(Wr,Kr,this.width,this.height,5).fill(this.backgroundColor).stroke(this.strokeColor),this.container.addChild(this.graphics),this.container.addChild(this.text)}update(){this.width=this.text.width+this.textSize,this.text.style.fill=this.textColor,this.graphics.clear(),this.graphics.roundRect(this.position.x,this.position.y,this.width,this.height,5).fill(this.backgroundColor).stroke(this.strokeColor)}destroy(){this.container.parent&&this.container.parent.removeChild(this.container),this.container.destroy()}setPosition(ze,Gr){this.container.x=ze,this.container.y=Gr}setText(ze){this.text.text=ze}setBackgroundColor(ze){this.backgroundColor=ze}setTextColor(ze){this.textColor=ze}setStrokeColor(ze){this.strokeColor=ze}getContainer(){return this.container}getGraphics(){return this.graphics}}function lerpPosition(Yr,ze,Gr){return{x:Yr.x+(ze.x-Yr.x)*Gr,y:ze.y+(ze.y-ze.y)*Gr}}function lerpNumber(Yr,ze,Gr){return Yr+(ze-Yr)*Gr}class Invitation extends TextBox{constructor(Gr,Wr){super(`${Gr.getUsername()} wants to play a game!`,20,0,0);Ci(this,"mouseHoveredOn",!1);Ci(this,"lifeTimeExceeded",!1);Ci(this,"fadeSpeed",.05);Ci(this,"time",0);Ci(this,"moveSpeed",.1);this.setTextColor("#ffffff"),this.setBackgroundColor("#000000"),this.setStrokeColor("#ffffff"),this.update(),this.container.interactive=!0,this.container.x=-100,this.container.y=Wr*this.container.height,this.container.on("pointerover",()=>{this.mouseHoveredOn=!0})}fade(Gr){this.time+=Gr.deltaTime*this.fadeSpeed;const Wr=lerpNumber(1,0,this.time);this.container.alpha=Wr,this.container.alpha<=0&&(this.lifeTimeExceeded=!0)}isRead(){return this.mouseHoveredOn}animate(Gr){if(this.container.x<0){const Wr=lerpPosition({x:this.container.x,y:this.container.y},{x:0,y:this.container.y},Gr.deltaTime*this.moveSpeed);this.container.position.set(Wr.x,Wr.y)}this.isRead()&&this.fade(Gr)}dead(){return this.lifeTimeExceeded}}let mouse={x:0,y:0},keyIsPressed={},keyWasPressed={};window.addEventListener("keydown",Yr=>{keyIsPressed[Yr.code]||(keyWasPressed[Yr.code]=!0),keyIsPressed[Yr.code]=!0});window.addEventListener("keyup",Yr=>{keyIsPressed[Yr.code]=!1});function resetKeyStates(Yr){for(const ze in Yr)Yr[ze]=!1}window.addEventListener("pointermove",Yr=>{mouse.x=Yr.clientX,mouse.y=Yr.clientY});function movePlayer(Yr,ze,Gr){if(!Gr)return;let Wr={x:Yr.position.asCartesian.x,y:Yr.position.asCartesian.y};keyIsPressed.KeyW?(Wr.y-=PLAYERSPEED*ze,Yr.setAnimation("north")):keyIsPressed.KeyS?(Wr.y+=PLAYERSPEED*ze,Yr.setAnimation("south")):keyIsPressed.KeyA?(Wr.x-=PLAYERSPEED*ze,Yr.setAnimation("west")):keyIsPressed.KeyD&&(Wr.x+=PLAYERSPEED*ze,Yr.setAnimation("east"));let Kr=Math.ceil(Wr.x),Zr=Math.ceil(Wr.y);return Kr>=0&&Kr<GRIDWIDTH&&Zr>=0&&Zr<GRIDHEIGHT&&TILEMAP[Zr][Kr]===0&&Yr.updatePosition(Wr),Yr.position}function switchCameraMode(Yr){return Yr===CameraMode.Locked?CameraMode.Free:CameraMode.Locked}function initializeWebsocket(Yr,ze,Gr){return Yr?(console.log("Succesfully connected with the server"),new WebSocket(`ws://${Yr}:${ze}/${Gr}`)):(console.warn("Server address not defined... this may cause issues with the websocket connection"),new WebSocket(""))}function sendToServer(Yr,ze){Yr.readyState==WebSocket.OPEN&&Yr.send(JSON.stringify(ze))}async function getUserInfo(Yr){try{const ze=await fetch(`/game/userinfo/${Yr}`),{user:Gr}=await ze.json();return Gr}catch{return console.log("We don't got the user :("),{id:420,username:"testUser",password:"",email:"",avatar:"",status:!1,wins:0,losses:0,player:{id:420,userId:420,x:0,y:0}}}}function initializeLocalPlayer(Yr,ze){let Gr={x:Yr.player.x,y:Yr.player.y};Gr.x===0&&Gr.y===0&&(Gr={x:36,y:20});const Wr=playerManager.initLocalPlayer(Yr.id,Yr.username,Yr.avatar,Gr);if(Wr)return ze.addPlayer(Wr),Wr}let gameSocket,localUser;function initializePlayers(Yr,ze){for(const[Gr,Wr]of Yr)if(console.log(`Player ${Gr} is at (${Wr.x}, ${Wr.y})`),!isLocalPlayer(Gr)){console.log("Adding player: ",Gr,Wr);const Kr=playerManager.addPlayer(Gr,Wr.username,Wr.avatar,{x:Wr.x,y:Wr.y});Kr&&ze.addPlayer(Kr)}}function isLocalPlayer(Yr){return Yr==window.__USER_ID__}async function runConnectionManager(Yr){gameSocket=initializeWebsocket(window.__GAMESERVER_URL__,"8003","ws-gameserver"),localUser=await getUserInfo(window.__USER_ID__);const ze=initializeLocalPlayer(localUser,Yr);ze&&sendToServer(gameSocket,{type:"new_connection",id:localUser.id,username:localUser.username,avatar:localUser.avatar,position:ze.getPosition()}),gameSocket.onmessage=Gr=>{const Wr=JSON.parse(Gr.data);if(Wr.type==="new_player"&&!isLocalPlayer(Wr.id)){const Kr=playerManager.addPlayer(Wr.id,Wr.username,Wr.avatar,Wr.position);Kr&&Yr.addPlayer(Kr)}if(Wr.type=="initialize_players"&&initializePlayers(Wr.players,Yr),Wr.type=="initialize_pong"){const Kr=playerManager.pongTable;if(Kr){const Zr=Wr.left||Wr.right,Qr=playerManager.getPlayer(Zr.id);if(Zr&&Qr){const Jr=Zr.side;Kr.setPlayerReady(Qr,Jr)}}}if(Wr.type=="disconnect_player"&&!isLocalPlayer(Wr.id)){console.log("Disconnecting player ",Wr.id);const Kr=Yr.getContainer(),Zr=playerManager.getPlayer(Wr.id);Zr&&(Zr.destroy(),Kr.removeChild(Zr.getContext())),playerManager.removePlayer(Wr.id)}if(Wr.type=="player_move"&&!isLocalPlayer(Wr.id)){const Kr=playerManager.getPlayer(Wr.id);if(Kr){const Zr=Yr.getMapRegion(Kr.getPosition()),Qr=Yr.getMapRegion(Wr.position);Zr!=Qr&&(Yr.removeFromRoomContainer(Zr,Kr.getContext()),Yr.addToRoomContainer(Qr,Kr.getContext())),Kr.updatePosition(Wr.position)}}if(Wr.type=="confirm_pong_player"&&isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getLocalPlayer(),Zr=playerManager.pongTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="player_joined_pong"&&!isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getPlayer(Wr.pongPlayer.id),Zr=playerManager.pongTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="leave_pong"){const Kr=playerManager.pongTable;Kr&&Kr.removePlayer(Wr.pongPlayer.side)}if(Wr.type=="countdown_pong"){const Kr=playerManager.pongTable;Kr&&Kr.setCountdownTimer(Number(Wr.timer))}if(Wr.type=="start_pong_game"){const Kr=playerManager.pongTable;Kr&&Kr.startGame()}if(Wr.type=="pong_update"){const Kr=playerManager.pongTable;Kr&&(Kr.updatePaddle("left",Wr.pongState.paddles.left),Kr.updatePaddle("right",Wr.pongState.paddles.right))}if(Wr.type=="player_disconnected_pong"){const Kr=playerManager.pongTable;Kr&&Kr.stopGame()}if(Wr.type=="score_update"){const Kr=playerManager.pongTable;Kr&&(console.log("Data: ",Wr),Kr.updateScore(Wr.side,Wr.score))}if(Wr.type=="ball_move"){const Kr=playerManager.pongTable;if(Kr){let Zr={x:Wr.ball.x,y:Wr.ball.y};Kr.updateBall(Zr)}}if(Wr.type=="finish_game"){const Kr=playerManager.pongTable;Kr&&Kr.finishGame(Wr.winnerId,!1)}if(Wr.type=="game_invite"&&isLocalPlayer(Wr.id)){const Kr=Wr,Zr=playerManager.addInvite(Kr);Zr&&uiContainer.addChild(Zr.container)}if(Wr.type=="announce_match"){console.log(`(left) ${Wr.players.left.username} is playing against (right) ${Wr.players.right.username}. Time left to ready up: ${Wr.seconds}`);const Kr=playerManager.tournamentTable;if(Kr){const Zr=playerManager.getPlayer(Wr.players.left.id),Qr=playerManager.getPlayer(Wr.players.right.id);Zr&&Qr&&Kr.setExpectedTournamentPlayers(Zr,Qr)}}if(Wr.type=="confirm_pong_player_tournament"&&isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getLocalPlayer(),Zr=playerManager.tournamentTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="player_joined_pong_tournament"&&!isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getPlayer(Wr.pongPlayer.id),Zr=playerManager.tournamentTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="leave_pong_tournament"){const Kr=playerManager.tournamentTable;Kr&&Kr.removePlayer(Wr.pongPlayer.side)}if(Wr.type=="countdown_pong_tournament"){console.log("seconds: ",Wr.timer);const Kr=playerManager.tournamentTable;Kr&&Kr.setCountdownTimer(Number(Wr.timer))}if(Wr.type=="ball_move_tournament"){const Kr=playerManager.tournamentTable;if(Kr){let Zr={x:Wr.ball.x,y:Wr.ball.y};Kr.updateBall(Zr)}}if(Wr.type=="pong_update_tournament"){const Kr=playerManager.tournamentTable;Kr&&(Kr.updatePaddle("left",Wr.pongState.paddles.left),Kr.updatePaddle("right",Wr.pongState.paddles.right))}if(Wr.type=="score_update_tournament"){const Kr=playerManager.tournamentTable;Kr&&(console.log("Data: ",Wr),Kr.updateScore(Wr.side,Wr.score))}if(Wr.type=="finish_game_tournament"){const Kr=playerManager.tournamentTable;Kr&&Kr.finishGame(Wr.winnerId,Wr.finals)}gameSocket.onclose=Kr=>{if(console.log("Close event: ",Kr),gameSocket.readyState==WebSocket.OPEN){const Zr=playerManager.getLocalPlayer();let Qr={x:0,y:0};Zr&&(Qr=Zr.position.asCartesian,sendToServer(gameSocket,{type:"disconnection",id:localUser.id,position:Qr}))}}},window.addEventListener("beforeunload",()=>{if(gameSocket.readyState==WebSocket.OPEN){const Gr=playerManager.getLocalPlayer();let Wr={x:0,y:0};Gr&&(Wr=Gr.position.asCartesian,sendToServer(gameSocket,{type:"disconnection",id:localUser.id,position:Wr}))}}),gameSocket.onerror=Gr=>{console.log("Websocket error: ",Gr)}}__vitePreload(()=>Promise.resolve().then(()=>htmx_min$1),void 0);const playerInfoBox=document.getElementById("pixi-player-info");var ts;const Qi=class Qi{constructor(){Ci(this,"players",new Map);Ci(this,"localPlayer",null);Ci(this,"pongTable",null);Ci(this,"tournamentTable",null);Ci(this,"invites",[])}static get instance(){return is(Qi,ts)||ls(Qi,ts,new Qi),is(Qi,ts)}addInvite(ze){const Gr=this.getPlayer(ze.id);if(Gr){const Wr=new Invitation(Gr,this.invites.length);return this.invites.push(Wr),Wr}}removeInvite(ze){const Gr=this.invites.indexOf(ze);this.invites.splice(Gr,1)}getInvites(){return this.invites}isLocalPlayerInitialized(){return!!this.localPlayer}initLocalPlayer(ze,Gr,Wr,Kr){return this.localPlayer=new Player(ze,Gr,Wr,Kr),this.localPlayer}initPongTable(ze){this.pongTable=ze}initTournamentTable(ze){this.tournamentTable=ze}addPlayer(ze,Gr,Wr,Kr){const Zr=new Player(ze,Gr,Wr,Kr),Qr=Zr.getContext(),Jr=new ColorMatrixFilter;return Qr.interactive=!0,Qr.on("pointerover",()=>{console.log(`Player: ${ze}`),Qr.blendMode="color-dodge";const{matrix:ei}=Jr;ei[1]=1,ei[2]=1,ei[3]=1,Qr.filters=[Jr]}),Qr.on("pointerleave",()=>{Qr.filters=[]}),Qr.on("pointerdown",async()=>{if(playerInfoBox){playerInfoBox.style.display="block",playerInfoBox.style.top=`${mouse.y+10}px`,playerInfoBox.style.left=`${mouse.x+10}px`;try{const ei=await fetch(`/game/userinfo/${ze}`),ri=await(await fetch(`/areFriends/${ze}/${window.__USER_ID__}`)).json(),{user:ii}=await ei.json(),si=document.getElementById("infoUsername"),ni=document.getElementById("infoAvatar"),oi=document.getElementById("winsAndLosses"),li=document.getElementById("status"),ai=document.getElementById("friends");oi&&li&&ai&&(oi.textContent=`Wins: ${ii.wins} | Losses: ${ii.losses}`,ii.status?li.textContent="Online":li.textContent="Offline",ri.status!==null?ai.textContent=`Friends: ${ri.status}`:ai.textContent=""),console.log("friendStatus",ri),si&&(si.textContent=`${ii.username}`),ni&&(ni.outerHTML=`<img id="infoAvatar" src="/images/avatars/${ii.avatar}" class="w-12 h-12 rounded-full" />`);const hi=document.getElementById("friendRequest");if(hi&&ri.friend==!1){hi.style.display="block";const fi=document.getElementById("friendReqBtn");if(fi)fi&&(fi.innerHTML="Send friend request");else{const mi=document.createElement("button");mi.setAttribute("id","friendReqBtn"),mi.setAttribute("type","button"),mi.setAttribute("class","bg-[#FF55FE] text-white rounded-md p-2"),mi.setAttribute("hx-post",`sendReq/${ze}/${window.__USER_ID__}`),mi.innerHTML="Send friend request",hi.appendChild(mi)}const pi=document.getElementById("gameInviteBtn");pi&&(pi.onclick=()=>{const mi={type:MessageType.GameInvite,id:ii.id};gameSocket.send(JSON.stringify(mi))}),window.htmx.process(document.body)}else hi&&ri.friend&&(hi.style.display="none")}catch(ei){console.error("Failed to fetch player info",ei)}}}),this.players.set(ze,Zr),this.players.get(ze)}getLocalPlayer(){if(this.localPlayer)return this.localPlayer}getPlayer(ze){return this.localPlayer&&ze===this.localPlayer.id?this.localPlayer:this.players.get(ze)}getUsernameById(ze){const Gr=this.players.get(ze);return Gr?Gr.getUsername():""}getId(ze){for(const[Gr,Wr]of this.players)if(Wr.getUsername()===ze)return console.log(Gr),Wr.getId();return-1}getPlayers(){return this.players}updatePlayer(ze,Gr){const Wr=this.players.get(ze);Wr&&Wr.updatePosition(Gr)}removePlayer(ze){this.players.delete(ze)}};ts=new WeakMap,as(Qi,ts);let PlayerManager=Qi,playerManager=PlayerManager.instance;class MapRegion{constructor(ze,Gr,Wr){Ci(this,"start");Ci(this,"end");Ci(this,"container",new Container);this.container.sortableChildren=!0,this.start={x:ze.x,y:ze.y},this.end={x:this.start.x+Gr,y:this.start.y+Wr}}isInRegion(ze){return ze.x>=this.start.x&&ze.x<=this.end.x&&ze.y>=this.start.y&&ze.y<=this.end.y}addToContainer(ze){this.container.addChild(ze)}getContainer(){return this.container}}var rs;const Ji=class Ji{constructor(ze,Gr,Wr){Ci(this,"container");Ci(this,"graphicsContext");Ci(this,"rows");Ci(this,"cols");Ci(this,"tileSize");Ci(this,"mapRegions",new Map);this.container=new Container({isRenderGroup:!0}),this.container.sortableChildren=!0,this.graphicsContext=new Graphics,this.container.addChild(this.graphicsContext),this.rows=ze,this.cols=Gr,this.tileSize=Wr,this.initMapRegions()}static get instance(){return is(Ji,rs)||ls(Ji,rs,new Ji(GRIDHEIGHT,GRIDWIDTH,TILESIZE)),is(Ji,rs)}initMapRegions(){const ze=new MapRegion({x:52,y:0},12,24),Gr=new MapRegion({x:22,y:15},12,9),Wr=new MapRegion({x:0,y:0},16,23),Kr=new MapRegion({x:21,y:0},3,5),Zr=new MapRegion({x:0,y:0},0,0),Qr=new MapRegion({x:16,y:0},4,5);this.mapRegions.set(RoomType.Bocal,ze),this.mapRegions.set(RoomType.Game,Gr),this.mapRegions.set(RoomType.Cluster,Wr),this.mapRegions.set(RoomType.Server,Kr),this.mapRegions.set(RoomType.Hall,Zr),this.mapRegions.set(RoomType.Toilet,Qr)}getMapRegion(ze){for(const[Gr,Wr]of this.mapRegions)if(Wr.isInRegion(ze))return Gr;return RoomType.Hall}drawIsometricTile(ze,Gr,Wr,Kr,Zr){ze.poly([Gr.x,Gr.y,Gr.x+Wr,Gr.y+Kr/2,Gr.x,Gr.y+Kr,Gr.x-Wr,Gr.y+Kr/2,Gr.x,Gr.y]),Zr?(ze.fill(CGA_PINK_DARK),ze.stroke({color:CGA_BLACK})):(ze.fill(CGA_CYAN_DARK),ze.stroke({color:CGA_BLACK}))}async createGraphicsGrid(ze){for(let Gr=0;Gr<this.rows;Gr++)for(let Wr=0;Wr<this.cols;Wr++){const Kr=new Graphics;let Zr=new Point(Wr,Gr);const Qr=this.getMapRegion(Zr.asCartesian),Jr=this.mapRegions.get(Qr),ei=this.getHeightOffset(Wr,Gr,ze);if(Zr.asIsometric.y-=ei,ze[Gr][Wr]===1.01&&Qr===RoomType.Hall){Kr.zIndex=Zr.asIsometric.y,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!0),Jr==null||Jr.addToContainer(Kr);continue}if(ze[Gr][Wr]===1.02&&Qr===RoomType.Hall){Kr.zIndex=Zr.asIsometric.y,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!1),Jr==null||Jr.addToContainer(Kr);continue}if(ze[Gr][Wr]==-1){const ti=Texture.from("cardboard_blackhole"),ri=Math.random()*3;for(let ii=0;ii<ri;ii++){const si=new Sprite(ti);si.x=Zr.asIsometric.x-32,si.y=Zr.asIsometric.y-24-ii*16,si.scale=.5,si.zIndex=1e3,Jr==null||Jr.addToContainer(si)}ze[Gr][Wr]=0}{const ti=new Point(Wr,Gr+1),ri=new Point(Wr,Gr+1),ii=new Point(Wr+1,Gr+1),si=new Point(Wr+1,Gr+1);ti.asIsometric.y-=ei,si.asIsometric.y-=ei,Kr.poly([ti.asIsometric.x,ti.asIsometric.y,ri.asIsometric.x,ri.asIsometric.y,ii.asIsometric.x,ii.asIsometric.y,si.asIsometric.x,si.asIsometric.y]).stroke(CGA_BLACK).fill(CGA_BLACK)}{const ti=new Point(Wr+1,Gr+1),ri=new Point(Wr+1,Gr+1),ii=new Point(Wr+1,Gr),si=new Point(Wr+1,Gr);ti.asIsometric.y-=ei,si.asIsometric.y-=ei,Kr.poly([ti.asIsometric.x,ti.asIsometric.y,ri.asIsometric.x,ri.asIsometric.y,ii.asIsometric.x,ii.asIsometric.y,si.asIsometric.x,si.asIsometric.y]).stroke(CGA_BLACK).fill(CGA_CYAN)}ze[Gr][Wr]!=0?(Kr.zIndex=Zr.asIsometric.y,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!0)):(Kr.zIndex=-100,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!1)),Jr==null||Jr.addToContainer(Kr)}for(const[Gr,Wr]of this.mapRegions){console.log(Gr);const Kr=Wr.getContainer();Gr!==RoomType.Hall&&(Kr.renderable=!1),this.container.addChild(Kr)}}setRegionOpacity(ze,Gr){const Wr=this.mapRegions.get(ze);Wr&&(Wr.getContainer().alpha=Gr)}setRegionRenderable(ze,Gr){const Wr=this.mapRegions.get(ze);Wr&&(Wr.getContainer().renderable=Gr)}addPlayer(ze){var Wr;const Gr=this.getMapRegion(ze.getPosition());(Wr=this.mapRegions.get(Gr))==null||Wr.addToContainer(ze.getContext())}getHeightOffset(ze,Gr,Wr){return Wr[Gr][ze]*this.tileSize/4}moveMap(ze){this.container.x+=ze.x,this.container.y+=ze.y}getContainer(){return this.container}getRoomContainer(ze){var Gr;return(Gr=this.mapRegions.get(ze))==null?void 0:Gr.getContainer()}addToContainer(ze){this.container.addChild(ze)}removeFromRoomContainer(ze,Gr){const Wr=this.mapRegions.get(ze);Wr&&Wr.getContainer().removeChild(Gr)}addToRoomContainer(ze,Gr){const Wr=this.mapRegions.get(ze);Wr==null||Wr.addToContainer(Gr)}};rs=new WeakMap,as(Ji,rs);let GameMap=Ji;function addGameMap(Yr){let ze=GameMap.instance;const Gr=ze.getContainer();return ze.createGraphicsGrid(TILEMAP),Yr.stage.addChild(Gr),ze}function moveMapWithMouse(Yr,ze,Gr){if(!Gr)return;let Wr=window.innerWidth*.1,Kr=window.innerHeight*.1,Zr={x:0,y:0},Qr=5;if(Yr.x>=window.innerWidth-Wr){let Jr=(Yr.x-(window.innerWidth-Wr))/Wr;Zr.x-=Jr*Qr}if(Yr.x<=Wr){let Jr=(Wr-Yr.x)/Wr;Zr.x+=Jr*Qr}if(Yr.y<=Kr){let Jr=(Kr-Yr.y)/Kr;Zr.y+=Jr*Qr}if(Yr.y>=window.innerHeight-Kr){let Jr=(Yr.y-(window.innerHeight-Kr))/Kr;Zr.y-=Jr*Qr}ze.moveMap(Zr)}function setupMapZoom(){pixiApp.stage.scale=2.5,window.addEventListener("wheel",Yr=>{let ze=.05,Gr=2,Wr=4,Kr=Yr.deltaY/Math.abs(Yr.deltaY),Zr;(ti=>{ti[ti.Up=-1]="Up",ti[ti.Down=1]="Down"})(Zr||(Zr={}));let Qr=pixiApp.stage,Jr=localPlayerPos.asCartesian.x+pixiApp.screen.width/2,ei=localPlayerPos.asCartesian.y+pixiApp.screen.height/2;if(Kr==-1&&Qr.scale.x<Wr){const ti=1-Qr.scale.x/(Qr.scale.x+ze);Qr.scale.x+=ze,Qr.scale.y+=ze,Qr.x-=(Jr-Qr.x)*ti,Qr.y-=(ei-Qr.y)*ti}else if(Kr==1&&Qr.scale.x>Gr){const ti=1-Qr.scale.x/(Qr.scale.x+ze);Qr.scale.x-=ze,Qr.scale.y-=ze,Qr.x+=(Jr-Qr.x)*ti,Qr.y+=(ei-Qr.y)*ti}})}const messageHandlers={connect:(Yr,ze)=>{const Gr=Yr;Gr?console.log("Sucessfully created a session on the chat server",Gr):console.log("Couldn't create a session on the chat server :("),ze.send("Yep")},confirm:(Yr,ze)=>{console.log(Yr.type),console.log(ze.url),console.log(`Succesfully connected to the chat server ${ze.url}`)},room_chat:(Yr,ze)=>{console.log(`RoomChat message from ${ze.url}`);const Gr=Yr;chat.createChatBubble(Gr.message,Gr.id,playerManager,gameMap.container),chat.RendermsgHTML(Gr.message,playerManager.getUsernameById(Gr.id)),console.log(Gr)},personal_chat:(Yr,ze)=>{console.log(`RoomChat message from ${ze.url}`);const Gr=Yr;chat.createChatBubble(Gr.message,Gr.toId,playerManager,gameMap.container),chat.RendermsgHTML(Gr.message,playerManager.getUsernameById(Gr.fromId)),console.log(Gr)}};class ChatBubble extends TextBox{constructor(Gr,Wr,Kr){super(`${Gr.getUsername()}: ${Wr}`,Kr,Gr.getIsometricPosition().x,Gr.getIsometricPosition().y-Gr.getContext().height);Ci(this,"lifetimeExceeded",!1);this.setTextColor("#000000"),this.setBackgroundColor("#ffffff"),this.setStrokeColor("#000000"),this.update()}float(Gr){this.container.y-=Gr.deltaTime*.25,this.container.alpha-=Gr.deltaTime*.001,this.container.alpha<=0&&(this.lifetimeExceeded=!0)}dead(){return this.lifetimeExceeded}}class Chat{constructor(ze,Gr){Ci(this,"textInput");Ci(this,"sendButton");Ci(this,"chatDisplay",null);Ci(this,"chatBubbles",[]);Ci(this,"socket",null);Ci(this,"bubbleSize",20);this.textInput=document.getElementById(ze),this.textInput===null&&console.error("Couldn't get textInput for Chat"),this.sendButton=document.getElementById(Gr),this.sendButton===null&&console.error("Couldn't get sendButton for Chat")}getTextInput(){if(this.textInput)return this.textInput.value}sendIfWhisper(ze,Gr,Wr,Kr){if(console.log("entered whisper func"),ze.charAt(0)!="@"||ze.length<2)return!1;let Zr=ze.indexOf(" ");if(Zr===-1)return!1;const Qr=ze.slice(1,Zr),Jr=Wr.getId(Qr);if(Jr===-1)return console.log("Can't find user: ",Qr),!1;console.log(`${Qr}'s id: ${Jr}`);const ei=ze.slice(Zr),ti={type:MessageType.PersonalChat,fromId:Gr.getId(),toId:Jr,message:ei,timestamp:new Date().toLocaleString()};this.socket.send(JSON.stringify(ti));//! cause socket existence gets checked in parent func, should i keep check in case of dc?
const ri=new ChatBubble(Gr,"pst pst",10);return this.chatBubbles.push(ri),Kr.addChild(ri.getContainer()),console.log("%cwhisper send!","color: purple"),this.RendermsgHTML(ei,Gr.getUsername()),!0}RendermsgHTML(ze,Gr){this.chatDisplay=document.getElementById("chat-message-display"),this.chatDisplay===null&&console.error("Couldn't get chatDisplay for Chat");const Wr=document.createElement("div");Wr.setAttribute("class","bg-white rounded p-2"),Wr.innerHTML=`${Gr}: ${ze}`,this.chatDisplay.appendChild(Wr)}handleTextInput(ze,Gr){const Wr=this.getTextInput();if(Wr){const Kr=ze.getLocalPlayer();if(Kr&&this.socket&&!this.sendIfWhisper(Wr,Kr,ze,Gr)){const Zr={type:MessageType.RoomChat,id:Kr.getId(),message:Wr,timestamp:new Date().toLocaleString(),room:Kr.getRegion()};this.socket.send(JSON.stringify(Zr));const Qr=new ChatBubble(Kr,Wr,this.bubbleSize);this.chatBubbles.push(Qr),Gr.addChild(Qr.getContainer()),this.RendermsgHTML(Wr,Kr.getUsername()),console.log("We pushing")}}this.textInput.value=""}bind(ze,Gr,Wr){this.socket=ze,this.sendButton.addEventListener("click",()=>{this.handleTextInput(Gr,Wr)}),document.addEventListener("keydown",Kr=>{Kr.key==="Enter"&&this.handleTextInput(Gr,Wr)})}createChatBubble(ze,Gr,Wr,Kr){const Zr=Wr.getPlayer(Gr);if(Zr){const Qr=new ChatBubble(Zr,ze,this.bubbleSize);this.chatBubbles.push(Qr),Kr.addChild(Qr.getContainer())}}getChatBubbles(){return this.chatBubbles}destroyBubble(ze){const Gr=this.chatBubbles.indexOf(ze);Gr!==-1&&(ze.destroy(),this.chatBubbles.splice(Gr,1))}availableChatBubbles(){return this.chatBubbles.length>0}popChatBubble(){return this.chatBubbles.pop()}}const chat=new Chat("text-input-chat","send-button-chat");let chatSocket;function runChatConnectionManager(Yr){chatSocket=initializeWebsocket(window.__GAMESERVER_URL__,"8004","ws-chatserver"),chat&&(console.log("Initialized Chat object"),chat.bind(chatSocket,playerManager,Yr.container)),chatSocket.onopen=ze=>{console.log("onopen message: ",ze);const Gr=playerManager.getLocalPlayer();if(Gr){const Wr=Gr.getRegion(),Kr={type:MessageType.Connect,user:localUser,room:Wr};chatSocket.send(JSON.stringify(Kr)),console.log("We're sending the connectmessage: ",Kr)}},chatSocket.onmessage=ze=>{try{const Gr=JSON.parse(ze.data);console.log("Message: ",Gr);const Wr=messageHandlers[Gr.type];Wr?Wr(Gr,chatSocket):console.error(`Unhandled message type: ${Gr.type}`)}catch(Gr){console.error("Failed to process message: ",Gr)}},window.addEventListener("beforeunload",()=>{console.log("Beforeunload: ")}),chatSocket.onerror=ze=>{console.log("Websocket error: ",ze)}}const velocityMultiplier=1.2;class Ball{constructor(ze){Ci(this,"position");Ci(this,"graphics");Ci(this,"direction");Ci(this,"speed");this.graphics=new Graphics,this.position=new Point(ze.x,ze.y),this.speed=.05,this.direction={x:(Math.random()*2-1)*velocityMultiplier,y:(Math.random()*2-1)*velocityMultiplier},this.graphics.circle(0,0,3.5).fill(12303291),this.graphics.zIndex=100,this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}move(ze){let Gr=this.position.asCartesian,Wr={x:Gr.x+this.direction.x*this.speed*ze,y:Gr.y+this.direction.y*this.speed*ze};this.position.update(Wr),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}update(ze){this.position.update({x:ze.x,y:ze.y}),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}bounceX(){this.direction.x=-this.direction.x}bounceY(){this.direction.y=-this.direction.y}getContext(){return this.graphics}getPoint(){return this.position}}class Paddle{constructor(ze,Gr,Wr){Ci(this,"position");Ci(this,"graphics");Ci(this,"sprite");Ci(this,"paddleHeight");Ci(this,"paddleSpeed");this.position=new Point(ze.x,ze.y),this.paddleHeight=Gr,this.paddleSpeed=Wr;let Kr=new Point(0,ze.y-Gr/2),Zr=new Point(0,ze.y+Gr/2);this.graphics=new Graphics().moveTo(Kr.asIsometric.x,Kr.asIsometric.y).lineTo(Zr.asIsometric.x,Zr.asIsometric.y).stroke(16777215);const Qr=Texture.from("floppy_paddle");this.sprite=new Sprite(Qr),this.sprite.anchor.set(.5),this.sprite.x=this.position.asIsometric.x,this.sprite.y=this.position.asIsometric.y}move(ze,Gr){let Wr={x:this.position.asCartesian.x,y:this.position.asCartesian.y};Wr.y+=this.paddleSpeed*ze*Gr,this.position.update(Wr),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y,this.sprite.x=this.position.asIsometric.x,this.sprite.y=this.position.asIsometric.y}update(ze){this.position.update({x:this.position.asCartesian.x,y:ze}),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y,this.sprite.x=this.position.asIsometric.x,this.sprite.y=this.position.asIsometric.y}getPaddleHeight(){return this.paddleHeight}getPoint(){return this.position}getGraphics(){return this.sprite}}class PongInfo{constructor(ze,Gr,Wr){Ci(this,"box");Ci(this,"state");Ci(this,"score");Ci(this,"username");this.box=new TextBox("",ze,Gr,Wr),this.score=0,this.username="",this.state=PongState.Waiting}setPongPlayer(ze){ze&&(this.score=ze.score,this.username=ze.username)}setScore(ze){this.score=ze}setState(ze){ze===PongState.Waiting&&(this.score=0,this.username=""),this.state=ze}getState(){return this.state}display(){switch(this.state){case PongState.Waiting:this.box.setText("Waiting for player"),this.box.setTextColor(CGA_PINK);break;case PongState.PlayerNearby:this.box.setText("Press 'E'"),this.box.setTextColor(CGA_CYAN);break;case PongState.PlayerReady:this.box.setText(`${this.username} is ready!`),this.box.setTextColor(CGA_CYAN);break;case PongState.InProgress:this.box.setText(`${this.username} Score: ${this.score}`),this.box.setTextColor(CGA_PINK);break;case PongState.Enrolling:this.box.setText("Waiting for tournament to fill up..."),this.box.setTextColor(CGA_PINK);break;case PongState.Announcing:this.username===""?(this.box.setText("Waiting for tournament to fill up..."),this.box.setTextColor(CGA_PINK)):(this.box.setText(`${this.username}, please ready up!`),this.box.setTextColor(CGA_PINK));break}this.box.update()}getContainer(){return this.box.getContainer()}}function slice2DArray(Yr,ze,Gr,Wr,Kr){return Yr.slice(Wr,Kr).map(Qr=>Qr.slice(ze,Gr))}function isWithinRange(Yr,ze,Gr){return Math.abs(Yr-ze)<=Gr}class PongTable{constructor(ze,Gr,Wr){Ci(this,"container",new Container);Ci(this,"worldPosition");Ci(this,"tableGrid",[]);Ci(this,"ball");Ci(this,"paddles",{left:new Paddle({x:0,y:0},.5,.05),right:new Paddle({x:4,y:0},.5,.05)});Ci(this,"players",{left:null,right:null});Ci(this,"indicators",{left:new PongInfo(12,0,0),right:new PongInfo(12,TILESIZE*4,TILESIZE*2)});Ci(this,"countdownTimer",new TextBox("3",24,TILESIZE*2,0));Ci(this,"net");Ci(this,"inProgress",!1);Ci(this,"isTournament",!1);Ci(this,"state",TournamentState.Enrolling);Ci(this,"expectedTournamentPlayers",{left:null,right:null});this.isTournament=Wr,this.worldPosition=ze;let Kr=Math.round(ze.x),Zr=Math.round(ze.y);this.tableGrid=slice2DArray(Gr,Kr,Kr+4,Zr,Zr+2),this.ball=new Ball({x:2,y:1});let Qr=new Point(this.worldPosition.x,this.worldPosition.y);const Jr=this.getHeightOffset(0,0,this.tableGrid,TILESIZE);this.container.y-=Jr*2,this.container.zIndex=Qr.asIsometric.y+Jr,this.container.x+=Qr.asIsometric.x,this.container.y+=Qr.asIsometric.y;const ei=Texture.from("pong_net");this.net=new Sprite(ei),this.net.x-=16,this.net.y+=32,this.countdownTimer.container.renderable=!1,this.container.addChild(this.net),this.container.addChild(this.ball.getContext()),this.container.addChild(this.indicators.left.getContainer()),this.container.addChild(this.indicators.right.getContainer()),this.container.addChild(this.countdownTimer.getContainer()),this.container.addChild(this.paddles.left.getGraphics()),this.container.addChild(this.paddles.right.getGraphics())}getHeightOffset(ze,Gr,Wr,Kr){return Wr[Gr][ze]*Kr/4}drawIsometricTile(ze,Gr,Wr,Kr,Zr){ze.poly([Gr.x,Gr.y,Gr.x+Wr,Gr.y+Kr/2,Gr.x,Gr.y+Kr,Gr.x-Wr,Gr.y+Kr/2,Gr.x,Gr.y]),Zr?(ze.fill(CGA_PINK_DARK),ze.stroke({color:CGA_BLACK})):(ze.fill(CGA_CYAN_DARK),ze.stroke({color:CGA_BLACK}))}transitionTo(ze){console.log(`Transitioning from ${this.state} to ${ze}`),this.state=ze}setCountdownTimer(ze){ze===-1?this.countdownTimer.container.renderable=!1:(this.countdownTimer.container.renderable=!0,this.countdownTimer.setText(`Starting in: ${ze}`),this.countdownTimer.setTextColor(CGA_WHITE),this.countdownTimer.update())}isPlayerAtLeft(ze){let Gr={x:Math.ceil(ze.x),y:Math.ceil(ze.y)};return Gr.x===Math.ceil(this.worldPosition.x-1)&&Gr.y===Math.ceil(this.worldPosition.y)||Gr.x===Math.ceil(this.worldPosition.x-1)&&Gr.y===Math.ceil(this.worldPosition.y+1)}isPlayerAtRight(ze){let Gr={x:Math.ceil(ze.x),y:Math.ceil(ze.y)};return Gr.x===Math.ceil(this.worldPosition.x+4)&&Gr.y===Math.ceil(this.worldPosition.y)||Gr.x===Math.ceil(this.worldPosition.x+4)&&Gr.y===Math.ceil(this.worldPosition.y+1)}setPlayerReady(ze,Gr){this.players[Gr]||(this.players[Gr]={id:ze.getId(),username:ze.getUsername(),paddleY:32,ready:!0,score:0,side:Gr},this.indicators[Gr].setPongPlayer(this.players[Gr]),this.indicators[Gr].setState(PongState.PlayerReady))}setExpectedTournamentPlayers(ze,Gr){this.expectedTournamentPlayers.left={id:ze.getId(),username:ze.getUsername(),paddleY:32,ready:!1,score:0,side:"left"},this.expectedTournamentPlayers.right={id:Gr.getId(),username:Gr.getUsername(),paddleY:32,ready:!1,score:0,side:"right"},this.indicators.left.setPongPlayer(this.expectedTournamentPlayers.left),this.indicators.right.setPongPlayer(this.expectedTournamentPlayers.right),this.players.left||this.indicators.left.setState(PongState.Announcing),this.players.right||this.indicators.right.setState(PongState.Announcing)}isExpectedTournamentPlayer(ze,Gr){return this.expectedTournamentPlayers[Gr]?ze.getId()===this.expectedTournamentPlayers[Gr].id:!1}setIndicator(ze,Gr){ze!==null&&this.indicators[ze].setState(Gr)}displayPongState(){this.indicators.left.display(),this.indicators.right.display()}startGame(){this.inProgress||(this.indicators.left.setState(PongState.InProgress),this.indicators.right.setState(PongState.InProgress)),this.inProgress=!0}stopGame(){this.inProgress&&(this.indicators.left.setState(PongState.Waiting),this.indicators.right.setState(PongState.Waiting)),this.players.left=null,this.players.right=null,this.inProgress=!1,this.countdownTimer.container.renderable=!1}finishGame(ze,Gr){if(this.countdownTimer.container.renderable=!0,this.players.left&&this.players.right){const Wr=Math.min(this.players.left.score,this.players.right.score),Kr=Math.max(this.players.left.score,this.players.right.score);this.players.left.id===ze?(this.countdownTimer.setTextColor(CGA_WHITE),Gr?this.countdownTimer.setText(`${this.players.left.username} has won the tournament!`):this.countdownTimer.setText(`${this.players.left.username} has won with ${Kr} - ${Wr}!`)):(this.countdownTimer.setTextColor(CGA_WHITE),Gr?this.countdownTimer.setText(`${this.players.right.username} has won the tournament!`):this.countdownTimer.setText(`${this.players.right.username} has won with ${Kr} - ${Wr}!`)),this.countdownTimer.update(),setTimeout(()=>{this.countdownTimer.container.renderable=!1},2e3)}this.players.left=null,this.players.right=null,this.expectedTournamentPlayers.left=null,this.expectedTournamentPlayers.right=null,this.inProgress=!1}isInProgress(){return this.inProgress}updateScore(ze,Gr){console.log("Updating score on side: ",ze),console.log("This concerns player: ",this.players[ze]),this.players[ze]&&(this.players[ze].score=Gr,this.indicators[ze].setPongPlayer(this.players[ze]))}removePlayer(ze){this.players[ze]&&(this.players.left=null,this.players.right=null,this.indicators.left.setState(PongState.Waiting),this.indicators.right.setState(PongState.Waiting),this.inProgress=!1,this.countdownTimer.container.renderable=!1)}sendPaddleUpdate(ze,Gr){Gr!==null&&ze.ArrowUp&&(console.log("We are sending up"),sendToServer(gameSocket,{type:"paddle_move",side:Gr,direction:"up",tournament:this.isTournament})),Gr!==null&&ze.ArrowDown&&(console.log("We are sending down"),sendToServer(gameSocket,{type:"paddle_move",side:Gr,direction:"down",tournament:this.isTournament}))}isSideReady(ze){if(this.players[ze])return this.players[ze].ready}isPlayerReady(ze){return this.players.left&&this.players.left.id===ze?this.players.left.ready:this.players.right&&this.players.right.id===ze?this.players.right.ready:!1}getPongPlayer(ze){return this.players[ze]?this.players[ze]:null}getPlayerSide(ze){let Gr=ze.getPosition();return this.isPlayerAtLeft(Gr)?"left":this.isPlayerAtRight(Gr)?"right":null}collidesWithPaddle(ze){let Gr=this.getLocalBallPosition(this.ball),Wr=this.getLocalPaddlePosition(this.paddles[ze]),Kr=this.paddles[ze].getPaddleHeight()/2*TILESIZE,Zr=Wr.y-Kr,Qr=Wr.y+Kr,Jr=0;return ze==="right"&&(Jr=TILESIZE*4),!!(Gr.y>Zr&&Gr.y<Qr&&isWithinRange(Jr,Gr.x,1.5))}updateBall(ze){this.ball.update(ze)}updatePaddle(ze,Gr){ze!==null&&(this.paddles[ze].update(Gr),console.log("updatePaddleY client: ",this.paddles[ze].getPaddleHeight()))}getLocalBallPosition(ze){let Gr=ze.getPoint().asCartesian;return{x:Gr.x*TILESIZE,y:Gr.y*TILESIZE}}getLocalPaddlePosition(ze){let Gr=ze.getPoint().asCartesian;return{x:Gr.x*TILESIZE,y:Gr.y*TILESIZE}}getContainer(){return this.container}getBallContext(){return this.ball.getContext()}}__vitePreload(()=>Promise.resolve().then(()=>htmx_min$1),void 0);const tournamentInfoBox=document.getElementById("pixi-tournament-info"),subscribeBtn=document.getElementById("joinTournamentBtn"),unsubscribeBtn=document.getElementById("leaveTournamentBtn");class TournamentSubscription{constructor(ze,Gr,Wr,Kr,Zr){Ci(this,"subscriptionBox");Ci(this,"server");Ci(this,"localPlayer");this.subscriptionBox=new Sprite(Zr),this.server=Wr,this.localPlayer=Kr,this.subscriptionBox.interactive=!0,this.subscriptionBox.on("pointerdown",async()=>{if(tournamentInfoBox){tournamentInfoBox.style.display="block",tournamentInfoBox.style.top=`${mouse.y+10}px`,tournamentInfoBox.style.left=`${mouse.x+10}px`;const Jr=document.getElementById("infoCardTournament");Jr&&window.htmx.trigger(Jr,"customEvent",null)}});let Qr=new Point(ze,Gr);this.subscriptionBox.x=Qr.asIsometric.x-32,this.subscriptionBox.y=Qr.asIsometric.y-32*2,subscribeBtn&&subscribeBtn.addEventListener("click",()=>{this.subscribe()}),unsubscribeBtn&&unsubscribeBtn.addEventListener("click",()=>{this.unsubscribe()})}subscribe(){this.server.send(JSON.stringify({type:"tournament_join",tournamentPlayer:this.localPlayer}))}unsubscribe(){this.server.send(JSON.stringify({type:"tournament_leave",tournamentPlayer:this.localPlayer}))}getContext(){return this.subscriptionBox}}const vertexShader=`
========
`)}function getSVGUrl(Yr,ze,Gr,Wr,Kr){const{domElement:Zr,styleElement:Qr,svgRoot:Jr}=Kr;Zr.innerHTML=`<style>${ze.cssStyle}</style><div style='padding:0;'>${Yr}</div>`,Zr.setAttribute("style",`transform: scale(${Gr});transform-origin: top left; display: inline-block`),Qr.textContent=Wr;const{width:ei,height:ti}=Kr.image;return Jr.setAttribute("width",ei.toString()),Jr.setAttribute("height",ti.toString()),new XMLSerializer().serializeToString(Jr)}function getTemporaryCanvasFromImage(Yr,ze){const Gr=CanvasPool.getOptimalCanvasAndContext(Yr.width,Yr.height,ze),{context:Wr}=Gr;return Wr.clearRect(0,0,Yr.width,Yr.height),Wr.drawImage(Yr,0,0),Gr}function loadSVGImage(Yr,ze,Gr){return new Promise(async Wr=>{Gr&&await new Promise(Kr=>setTimeout(Kr,100)),Yr.onload=()=>{Wr()},Yr.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(ze)}`,Yr.crossOrigin="anonymous"})}class HTMLTextSystem{constructor(ze){this._activeTextures={},this._renderer=ze,this._createCanvas=ze.type===RendererType.WEBGPU}getTexture(ze){return this._buildTexturePromise(ze.text,ze.resolution,ze.style)}getManagedTexture(ze,Gr,Wr,Kr){if(this._activeTextures[Kr])return this._increaseReferenceCount(Kr),this._activeTextures[Kr].promise;const Zr=this._buildTexturePromise(ze,Gr,Wr).then(Qr=>(this._activeTextures[Kr].texture=Qr,Qr));return this._activeTextures[Kr]={texture:null,promise:Zr,usageCount:1},Zr}async _buildTexturePromise(ze,Gr,Wr){const Kr=BigPool.get(HTMLTextRenderData),Zr=extractFontFamilies(ze,Wr),Qr=await getFontCss(Zr,Wr,HTMLTextStyle.defaultTextStyle),Jr=measureHtmlText(ze,Wr,Qr,Kr),ei=Math.ceil(Math.ceil(Math.max(1,Jr.width)+Wr.padding*2)*Gr),ti=Math.ceil(Math.ceil(Math.max(1,Jr.height)+Wr.padding*2)*Gr),ri=Kr.image,ii=2;ri.width=(ei|0)+ii,ri.height=(ti|0)+ii;const si=getSVGUrl(ze,Wr,Gr,Qr,Kr);await loadSVGImage(ri,si,isSafari()&&Zr.length>0);const ni=ri;let oi;this._createCanvas&&(oi=getTemporaryCanvasFromImage(ri,Gr));const li=getPo2TextureFromSource(oi?oi.canvas:ni,ri.width-ii,ri.height-ii,Gr);return this._createCanvas&&(this._renderer.texture.initSource(li.source),CanvasPool.returnCanvasAndContext(oi)),BigPool.return(Kr),li}_increaseReferenceCount(ze){this._activeTextures[ze].usageCount++}decreaseReferenceCount(ze){const Gr=this._activeTextures[ze];Gr&&(Gr.usageCount--,Gr.usageCount===0&&(Gr.texture?this._cleanUp(Gr):Gr.promise.then(Wr=>{Gr.texture=Wr,this._cleanUp(Gr)}).catch(()=>{warn("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[ze]=null))}_cleanUp(ze){TexturePool.returnTexture(ze.texture),ze.texture.source.resource=null,ze.texture.source.uploadMethodId="unknown"}getReferenceCount(ze){return this._activeTextures[ze].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"htmlText"};HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"};class CanvasTextPipe{constructor(ze){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.runners.resolutionChange.add(this),this._renderer.renderableGC.addManagedHash(this,"_gpuText")}resolutionChange(){for(const ze in this._gpuText){const Gr=this._gpuText[ze];if(!Gr)continue;const Wr=Gr.batchableSprite.renderable;Wr._autoResolution&&(Wr._resolution=this._renderer.resolution,Wr.onViewUpdate())}}validateRenderable(ze){const Gr=this._getGpuText(ze),Wr=ze._getKey();return Gr.currentKey!==Wr}addRenderable(ze,Gr){const Kr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),this._renderer.renderPipes.batch.addToBatch(Kr,Gr)}updateRenderable(ze){const Wr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),Wr._batcher.updateElement(Wr)}destroyRenderable(ze){ze.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(ze.uid)}_destroyRenderableById(ze){const Gr=this._gpuText[ze];this._renderer.canvasText.decreaseReferenceCount(Gr.currentKey),BigPool.return(Gr.batchableSprite),this._gpuText[ze]=null}_updateText(ze){const Gr=ze._getKey(),Wr=this._getGpuText(ze),Kr=Wr.batchableSprite;Wr.currentKey!==Gr&&this._updateGpuText(ze),ze._didTextUpdate=!1,updateTextBounds(Kr,ze)}_updateGpuText(ze){const Gr=this._getGpuText(ze),Wr=Gr.batchableSprite;Gr.texture&&this._renderer.canvasText.decreaseReferenceCount(Gr.currentKey),Gr.texture=Wr.texture=this._renderer.canvasText.getManagedTexture(ze),Gr.currentKey=ze._getKey(),Wr.texture=Gr.texture}_getGpuText(ze){return this._gpuText[ze.uid]||this.initGpuText(ze)}initGpuText(ze){const Gr={texture:null,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite)};return Gr.batchableSprite.renderable=ze,Gr.batchableSprite.transform=ze.groupTransform,Gr.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},Gr.batchableSprite.roundPixels=this._renderer._roundPixels|ze._roundPixels,this._gpuText[ze.uid]=Gr,ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution,this._updateText(ze),ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuText)this._destroyRenderableById(ze);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"text"};function checkRow(Yr,ze,Gr){for(let Wr=0,Kr=4*Gr*ze;Wr<ze;++Wr,Kr+=4)if(Yr[Kr+3]!==0)return!1;return!0}function checkColumn(Yr,ze,Gr,Wr,Kr){const Zr=4*ze;for(let Qr=Wr,Jr=Wr*Zr+4*Gr;Qr<=Kr;++Qr,Jr+=Zr)if(Yr[Jr+3]!==0)return!1;return!0}function getCanvasBoundingBox(Yr,ze=1){const{width:Gr,height:Wr}=Yr,Kr=Yr.getContext("2d",{willReadFrequently:!0});if(Kr===null)throw new TypeError("Failed to get canvas 2D context");const Qr=Kr.getImageData(0,0,Gr,Wr).data;let Jr=0,ei=0,ti=Gr-1,ri=Wr-1;for(;ei<Wr&&checkRow(Qr,Gr,ei);)++ei;if(ei===Wr)return Rectangle.EMPTY;for(;checkRow(Qr,Gr,ri);)--ri;for(;checkColumn(Qr,Gr,Jr,ei,ri);)++Jr;for(;checkColumn(Qr,Gr,ti,ei,ri);)--ti;return++ti,++ri,new Rectangle(Jr/ze,ei/ze,(ti-Jr)/ze,(ri-ei)/ze)}class CanvasTextSystem{constructor(ze){this._activeTextures={},this._renderer=ze}getTextureSize(ze,Gr,Wr){const Kr=CanvasTextMetrics.measureText(ze||" ",Wr);let Zr=Math.ceil(Math.ceil(Math.max(1,Kr.width)+Wr.padding*2)*Gr),Qr=Math.ceil(Math.ceil(Math.max(1,Kr.height)+Wr.padding*2)*Gr);return Zr=Math.ceil(Zr-1e-6),Qr=Math.ceil(Qr-1e-6),Zr=nextPow2(Zr),Qr=nextPow2(Qr),{width:Zr,height:Qr}}getTexture(ze,Gr,Wr,Kr){typeof ze=="string"&&(deprecation("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),ze={text:ze,style:Wr,resolution:Gr}),ze.style instanceof TextStyle||(ze.style=new TextStyle(ze.style));const{texture:Zr,canvasAndContext:Qr}=this.createTextureAndCanvas(ze);return this._renderer.texture.initSource(Zr._source),CanvasPool.returnCanvasAndContext(Qr),Zr}createTextureAndCanvas(ze){const{text:Gr,style:Wr}=ze,Kr=ze.resolution??this._renderer.resolution,Zr=CanvasTextMetrics.measureText(Gr||" ",Wr),Qr=Math.ceil(Math.ceil(Math.max(1,Zr.width)+Wr.padding*2)*Kr),Jr=Math.ceil(Math.ceil(Math.max(1,Zr.height)+Wr.padding*2)*Kr),ei=CanvasPool.getOptimalCanvasAndContext(Qr,Jr),{canvas:ti}=ei;this.renderTextToCanvas(Gr,Wr,Kr,ei);const ri=getPo2TextureFromSource(ti,Qr,Jr,Kr);if(Wr.trim){const ii=getCanvasBoundingBox(ti,Kr);ri.frame.copyFrom(ii),ri.updateUvs()}return{texture:ri,canvasAndContext:ei}}getManagedTexture(ze){ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution;const Gr=ze._getKey();if(this._activeTextures[Gr])return this._increaseReferenceCount(Gr),this._activeTextures[Gr].texture;const{texture:Wr,canvasAndContext:Kr}=this.createTextureAndCanvas(ze);return this._activeTextures[Gr]={canvasAndContext:Kr,texture:Wr,usageCount:1},Wr}_increaseReferenceCount(ze){this._activeTextures[ze].usageCount++}returnTexture(ze){const Gr=ze.source;Gr.resource=null,Gr.uploadMethodId="unknown",Gr.alphaMode="no-premultiply-alpha",TexturePool.returnTexture(ze)}decreaseReferenceCount(ze){const Gr=this._activeTextures[ze];Gr.usageCount--,Gr.usageCount===0&&(CanvasPool.returnCanvasAndContext(Gr.canvasAndContext),this.returnTexture(Gr.texture),this._activeTextures[ze]=null)}getReferenceCount(ze){return this._activeTextures[ze].usageCount}renderTextToCanvas(ze,Gr,Wr,Kr){var fi,pi,mi,Ti;const{canvas:Zr,context:Qr}=Kr,Jr=fontStringFromTextStyle(Gr),ei=CanvasTextMetrics.measureText(ze||" ",Gr),ti=ei.lines,ri=ei.lineHeight,ii=ei.lineWidths,si=ei.maxLineWidth,ni=ei.fontProperties,oi=Zr.height;if(Qr.resetTransform(),Qr.scale(Wr,Wr),Qr.textBaseline=Gr.textBaseline,(fi=Gr._stroke)!=null&&fi.width){const yi=Gr._stroke;Qr.lineWidth=yi.width,Qr.miterLimit=yi.miterLimit,Qr.lineJoin=yi.join,Qr.lineCap=yi.cap}Qr.font=Jr;let li,ai;const hi=Gr.dropShadow?2:1;for(let yi=0;yi<hi;++yi){const _i=Gr.dropShadow&&yi===0,Ai=_i?Math.ceil(Math.max(1,oi)+Gr.padding*2):0,Ri=Ai*Wr;if(_i){Qr.fillStyle="black",Qr.strokeStyle="black";const Bi=Gr.dropShadow,ki=Bi.color,Wi=Bi.alpha;Qr.shadowColor=Color.shared.setValue(ki).setAlpha(Wi).toRgbaString();const Li=Bi.blur*Wr,ci=Bi.distance*Wr;Qr.shadowBlur=Li,Qr.shadowOffsetX=Math.cos(Bi.angle)*ci,Qr.shadowOffsetY=Math.sin(Bi.angle)*ci+Ri}else{if(Qr.fillStyle=Gr._fill?getCanvasFillStyle(Gr._fill,Qr,ei):null,(pi=Gr._stroke)!=null&&pi.width){const Bi=Gr._stroke.width*Gr._stroke.alignment;Qr.strokeStyle=getCanvasFillStyle(Gr._stroke,Qr,ei,Bi)}Qr.shadowColor="black"}let Pi=(ri-ni.fontSize)/2;ri-ni.fontSize<0&&(Pi=0);const Si=((mi=Gr._stroke)==null?void 0:mi.width)??0;for(let Bi=0;Bi<ti.length;Bi++)li=Si/2,ai=Si/2+Bi*ri+ni.ascent+Pi,Gr.align==="right"?li+=si-ii[Bi]:Gr.align==="center"&&(li+=(si-ii[Bi])/2),(Ti=Gr._stroke)!=null&&Ti.width&&this._drawLetterSpacing(ti[Bi],Gr,Kr,li+Gr.padding,ai+Gr.padding-Ai,!0),Gr._fill!==void 0&&this._drawLetterSpacing(ti[Bi],Gr,Kr,li+Gr.padding,ai+Gr.padding-Ai)}}_drawLetterSpacing(ze,Gr,Wr,Kr,Zr,Qr=!1){const{context:Jr}=Wr,ei=Gr.letterSpacing;let ti=!1;if(CanvasTextMetrics.experimentalLetterSpacingSupported&&(CanvasTextMetrics.experimentalLetterSpacing?(Jr.letterSpacing=`${ei}px`,Jr.textLetterSpacing=`${ei}px`,ti=!0):(Jr.letterSpacing="0px",Jr.textLetterSpacing="0px")),ei===0||ti){Qr?Jr.strokeText(ze,Kr,Zr):Jr.fillText(ze,Kr,Zr);return}let ri=Kr;const ii=CanvasTextMetrics.graphemeSegmenter(ze);let si=Jr.measureText(ze).width,ni=0;for(let oi=0;oi<ii.length;++oi){const li=ii[oi];Qr?Jr.strokeText(li,ri,Zr):Jr.fillText(li,ri,Zr);let ai="";for(let hi=oi+1;hi<ii.length;++hi)ai+=ii[hi];ni=Jr.measureText(ai).width,ri+=si-ni+ei,si=ni}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"canvasText"};extensions.add(browserExt,webworkerExt);const CGA_CYAN_DARK_BG="#012C2C",CGA_CYAN="#00FBFB",CGA_PINK="#FF55FE",CGA_PINK_DARK="#6b1156",CGA_BLACK="#101010",CGA_CYAN_DARK="#023C3C",CGA_WHITE="#ffffff",TILESIZE=32,PLAYERSPEED=.1,TILEMAP=[[15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,4,3,3,3,0,0,0,0,0,0,0,0,0,1,0,-1,-1,-1,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,5,4,3,3,3,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,15,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1.01,1.01,1.02,1.02,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,15,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[15,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,15,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],GRIDWIDTH=TILEMAP[0].length,GRIDHEIGHT=TILEMAP.length;class Point{constructor(ze,Gr){Ci(this,"asCartesian");Ci(this,"asIsometric");this.asCartesian={x:ze,y:Gr},this.asIsometric={x:ze*TILESIZE-Gr*TILESIZE,y:ze*TILESIZE/2+Gr*TILESIZE/2}}update(ze){this.asCartesian=ze,this.asIsometric={x:ze.x*TILESIZE-ze.y*TILESIZE,y:ze.x*TILESIZE/2+ze.y*TILESIZE/2}}add(ze){this.asIsometric={x:this.asIsometric.x+ze.x,y:this.asIsometric.y+ze.y}}}var MessageType=(Yr=>(Yr.Connect="connect",Yr.Disconnect="disconnect",Yr.Transition="transition",Yr.RoomChat="room_chat",Yr.PersonalChat="personal_chat",Yr.GameInvite="game_invite",Yr))(MessageType||{}),RoomType=(Yr=>(Yr.Cluster="cluster",Yr.Server="server",Yr.Game="game",Yr.Bocal="bocal",Yr.Hall="hall",Yr.Toilet="toilet",Yr))(RoomType||{}),CameraMode=(Yr=>(Yr[Yr.Locked=0]="Locked",Yr[Yr.Free=1]="Free",Yr))(CameraMode||{}),PongState=(Yr=>(Yr[Yr.Waiting=0]="Waiting",Yr[Yr.PlayerNearby=1]="PlayerNearby",Yr[Yr.PlayerReady=2]="PlayerReady",Yr[Yr.InProgress=3]="InProgress",Yr[Yr.Enrolling=4]="Enrolling",Yr[Yr.Announcing=5]="Announcing",Yr))(PongState||{}),TournamentState=(Yr=>(Yr.Enrolling="Enrolling",Yr.Scheduling="Scheduling",Yr.Announcing="Announcing",Yr.Playing="Playing",Yr.Concluding="Concluding",Yr))(TournamentState||{});function createDirectionalAnimatedSprite(Yr,ze){const Gr={},Wr=Object.keys(Yr);for(const Qr of ze){const Jr=[];for(let ei=Qr.from;ei<=Qr.to;ei++){const ti=Wr[ei];ti&&Yr[ti]&&Jr.push(Yr[ti])}Gr[Qr.name]=Jr}const Kr=Gr.idle??Object.values(Gr)[0],Zr=new AnimatedSprite(Kr);return Zr.animations=Gr,Zr.animationSpeed=.05,Zr.loop=!0,Zr.play(),Zr.setAnimation=function(Qr){if(this.currentAnimation===Qr)return;Qr==="idle"?Zr.animationSpeed=.05:Zr.animationSpeed=.1;const Jr=this.animations[Qr];Jr&&(this.textures=Jr,this.currentAnimation=Qr,this.play())},Zr}class Player{constructor(ze,Gr,Wr,Kr){Ci(this,"id");Ci(this,"position");Ci(this,"username");Ci(this,"avatar");Ci(this,"region",RoomType.Hall);Ci(this,"shadow");Ci(this,"container");Ci(this,"animation");this.id=ze,this.position=new Point(Kr.x,Kr.y),this.username=Gr,this.avatar=Wr;const Zr=Assets.get("player_spritesheet");this.animation=createDirectionalAnimatedSprite(Zr.textures,Zr.data.meta.frameTags),this.animation.anchor.set(.5),this.shadow=new Graphics().circle(0,this.animation.height*2,10).fill("#000000"),this.shadow.scale.y=.25,this.shadow.alpha=.25,this.shadow.zIndex=5e3,this.container=new Container,this.container.addChild(this.animation),this.container.addChild(this.shadow),this.container.x=this.position.asIsometric.x,this.container.y=this.position.asIsometric.y,this.container.zIndex=this.position.asIsometric.y+7.5}setRegion(ze){this.region=ze}getRegion(){return this.region}updatePosition(ze){ze.x-this.position.asCartesian.x<0?this.animation.setAnimation("west"):ze.x-this.position.asCartesian.x>0?this.animation.setAnimation("east"):ze.y-this.position.asCartesian.y>0?this.animation.setAnimation("south"):ze.y-this.position.asCartesian.y<0&&this.animation.setAnimation("north"),this.position.update(ze),this.container.zIndex=this.position.asIsometric.y+7.5,this.container.x=this.position.asIsometric.x,this.container.y=this.position.asIsometric.y;let Gr=this.position.asCartesian;setTimeout(()=>{Gr.x===this.getPosition().x&&Gr.y===this.getPosition().y&&this.animation.setAnimation("idle")},50)}setAnimation(ze){this.animation.setAnimation(ze)}getId(){return this.id}getAvatar(){return this.avatar}getUsername(){return this.username}getPoint(){return this.position}getPosition(){return this.position.asCartesian}getIsometricPosition(){return this.position.asIsometric}destroy(){this.animation.destroy(),this.shadow.destroy(),this.container.destroy()}getContext(){return this.container}}class TextBox{constructor(ze,Gr,Wr,Kr){Ci(this,"container");Ci(this,"graphics");Ci(this,"position");Ci(this,"text");Ci(this,"textSize");Ci(this,"height");Ci(this,"width");Ci(this,"backgroundColor",CGA_BLACK);Ci(this,"strokeColor",CGA_PINK);Ci(this,"textColor",CGA_PINK);this.container=new Container,this.textSize=Gr;const Zr=new TextStyle({fill:this.textColor,fontSize:this.textSize});this.text=new Text({text:ze,style:Zr}),this.height=this.textSize*2,this.width=this.text.width+this.textSize,this.position={x:Wr,y:Kr},this.text.x=Wr+this.textSize/2,this.text.y=Kr+this.textSize/2,this.graphics=new Graphics().roundRect(Wr,Kr,this.width,this.height,5).fill(this.backgroundColor).stroke(this.strokeColor),this.container.addChild(this.graphics),this.container.addChild(this.text)}update(){this.width=this.text.width+this.textSize,this.text.style.fill=this.textColor,this.graphics.clear(),this.graphics.roundRect(this.position.x,this.position.y,this.width,this.height,5).fill(this.backgroundColor).stroke(this.strokeColor)}destroy(){this.container.parent&&this.container.parent.removeChild(this.container),this.container.destroy()}setPosition(ze,Gr){this.container.x=ze,this.container.y=Gr}setText(ze){this.text.text=ze}setBackgroundColor(ze){this.backgroundColor=ze}setTextColor(ze){this.textColor=ze}setStrokeColor(ze){this.strokeColor=ze}getContainer(){return this.container}getGraphics(){return this.graphics}}function lerpPosition(Yr,ze,Gr){return{x:Yr.x+(ze.x-Yr.x)*Gr,y:ze.y+(ze.y-ze.y)*Gr}}function lerpNumber(Yr,ze,Gr){return Yr+(ze-Yr)*Gr}class Invitation extends TextBox{constructor(Gr,Wr){super(`${Gr.getUsername()} wants to play a game!`,20,0,0);Ci(this,"mouseHoveredOn",!1);Ci(this,"lifeTimeExceeded",!1);Ci(this,"fadeSpeed",.05);Ci(this,"time",0);Ci(this,"moveSpeed",.1);this.setTextColor("#ffffff"),this.setBackgroundColor("#000000"),this.setStrokeColor("#ffffff"),this.update(),this.container.interactive=!0,this.container.x=-100,this.container.y=Wr*this.container.height,this.container.on("pointerover",()=>{this.mouseHoveredOn=!0})}fade(Gr){this.time+=Gr.deltaTime*this.fadeSpeed;const Wr=lerpNumber(1,0,this.time);this.container.alpha=Wr,this.container.alpha<=0&&(this.lifeTimeExceeded=!0)}isRead(){return this.mouseHoveredOn}animate(Gr){if(this.container.x<0){const Wr=lerpPosition({x:this.container.x,y:this.container.y},{x:0,y:this.container.y},Gr.deltaTime*this.moveSpeed);this.container.position.set(Wr.x,Wr.y)}this.isRead()&&this.fade(Gr)}dead(){return this.lifeTimeExceeded}}let mouse={x:0,y:0},keyIsPressed={},keyWasPressed={};window.addEventListener("keydown",Yr=>{keyIsPressed[Yr.code]||(keyWasPressed[Yr.code]=!0),keyIsPressed[Yr.code]=!0});window.addEventListener("keyup",Yr=>{keyIsPressed[Yr.code]=!1});function resetKeyStates(Yr){for(const ze in Yr)Yr[ze]=!1}window.addEventListener("pointermove",Yr=>{mouse.x=Yr.clientX,mouse.y=Yr.clientY});function movePlayer(Yr,ze,Gr){if(!Gr)return;let Wr={x:Yr.position.asCartesian.x,y:Yr.position.asCartesian.y};keyIsPressed.KeyW?(Wr.y-=PLAYERSPEED*ze,Yr.setAnimation("north")):keyIsPressed.KeyS?(Wr.y+=PLAYERSPEED*ze,Yr.setAnimation("south")):keyIsPressed.KeyA?(Wr.x-=PLAYERSPEED*ze,Yr.setAnimation("west")):keyIsPressed.KeyD&&(Wr.x+=PLAYERSPEED*ze,Yr.setAnimation("east"));let Kr=Math.ceil(Wr.x),Zr=Math.ceil(Wr.y);return Kr>=0&&Kr<GRIDWIDTH&&Zr>=0&&Zr<GRIDHEIGHT&&TILEMAP[Zr][Kr]===0&&Yr.updatePosition(Wr),Yr.position}function switchCameraMode(Yr){return Yr===CameraMode.Locked?CameraMode.Free:CameraMode.Locked}function initializeWebsocket(Yr,ze,Gr){return Yr?new WebSocket(`ws://${Yr}:${ze}/${Gr}`):(console.warn("Server address not defined... this may cause issues with the websocket connection"),new WebSocket(""))}function sendToServer(Yr,ze){Yr.readyState==WebSocket.OPEN&&Yr.send(JSON.stringify(ze))}async function getUserInfo(Yr){try{const ze=await fetch(`/game/userinfo/${Yr}`),{user:Gr}=await ze.json();return Gr}catch{return console.log("We don't got the user :("),{id:420,username:"testUser",password:"",email:"",avatar:"",status:!1,wins:0,losses:0,player:{id:420,userId:420,x:0,y:0}}}}function initializeLocalPlayer(Yr,ze){let Gr={x:Yr.player.x,y:Yr.player.y};Gr.x===0&&Gr.y===0&&(Gr={x:36,y:20});const Wr=playerManager.initLocalPlayer(Yr.id,Yr.username,Yr.avatar,Gr);if(Wr)return ze.addPlayer(Wr),Wr}let gameSocket,localUser;function initializePlayers(Yr,ze){for(const[Gr,Wr]of Yr)if(console.log(`Player ${Gr} is at (${Wr.x}, ${Wr.y})`),!isLocalPlayer(Gr)){console.log("Adding player: ",Gr,Wr);const Kr=playerManager.addPlayer(Gr,Wr.username,Wr.avatar,{x:Wr.x,y:Wr.y});Kr&&ze.addPlayer(Kr)}}function isLocalPlayer(Yr){return Yr==window.__USER_ID__}async function runConnectionManager(Yr){gameSocket=initializeWebsocket(window.__GAMESERVER_URL__,"8003","ws-gameserver"),gameSocket&&console.info(`Sucessfully connected to the game server ${gameSocket.url}`),localUser=await getUserInfo(window.__USER_ID__);const ze=initializeLocalPlayer(localUser,Yr);ze&&sendToServer(gameSocket,{type:"new_connection",id:localUser.id,username:localUser.username,avatar:localUser.avatar,position:ze.getPosition()}),gameSocket.onmessage=Gr=>{const Wr=JSON.parse(Gr.data);if(Wr.type==="new_player"&&!isLocalPlayer(Wr.id)){const Kr=playerManager.addPlayer(Wr.id,Wr.username,Wr.avatar,Wr.position);Kr&&Yr.addPlayer(Kr)}if(Wr.type=="initialize_players"&&initializePlayers(Wr.players,Yr),Wr.type=="initialize_pong"){const Kr=playerManager.pongTable;if(Kr){const Zr=Wr.left||Wr.right,Qr=playerManager.getPlayer(Zr.id);if(Zr&&Qr){const Jr=Zr.side;Kr.setPlayerReady(Qr,Jr)}}}if(Wr.type=="disconnect_player"&&!isLocalPlayer(Wr.id)){console.log("Disconnecting player ",Wr.id);const Kr=Yr.getContainer(),Zr=playerManager.getPlayer(Wr.id);Zr&&(Zr.destroy(),Kr.removeChild(Zr.getContext())),playerManager.removePlayer(Wr.id)}if(Wr.type=="player_move"&&!isLocalPlayer(Wr.id)){const Kr=playerManager.getPlayer(Wr.id);if(Kr){const Zr=Yr.getMapRegion(Kr.getPosition()),Qr=Yr.getMapRegion(Wr.position);Zr!=Qr&&(Yr.removeFromRoomContainer(Zr,Kr.getContext()),Yr.addToRoomContainer(Qr,Kr.getContext())),Kr.updatePosition(Wr.position)}}if(Wr.type=="confirm_pong_player"&&isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getLocalPlayer(),Zr=playerManager.pongTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="player_joined_pong"&&!isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getPlayer(Wr.pongPlayer.id),Zr=playerManager.pongTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="leave_pong"){const Kr=playerManager.pongTable;Kr&&Kr.removePlayer(Wr.pongPlayer.side)}if(Wr.type=="countdown_pong"){const Kr=playerManager.pongTable;Kr&&Kr.setCountdownTimer(Number(Wr.timer))}if(Wr.type=="start_pong_game"){const Kr=playerManager.pongTable;Kr&&Kr.startGame()}if(Wr.type=="pong_update"){const Kr=playerManager.pongTable;Kr&&(Kr.updatePaddle("left",Wr.pongState.paddles.left),Kr.updatePaddle("right",Wr.pongState.paddles.right))}if(Wr.type=="player_disconnected_pong"){const Kr=playerManager.pongTable;Kr&&Kr.stopGame()}if(Wr.type=="score_update"){const Kr=playerManager.pongTable;Kr&&(console.log("Data: ",Wr),Kr.updateScore(Wr.side,Wr.score))}if(Wr.type=="ball_move"){const Kr=playerManager.pongTable;if(Kr){let Zr={x:Wr.ball.x,y:Wr.ball.y};Kr.updateBall(Zr)}}if(Wr.type=="finish_game"){const Kr=playerManager.pongTable;Kr&&Kr.finishGame(Wr.winnerId,!1)}if(Wr.type=="game_invite"&&isLocalPlayer(Wr.id)){const Kr=Wr,Zr=playerManager.addInvite(Kr);Zr&&uiContainer.addChild(Zr.container)}if(Wr.type=="announce_match"){console.log(`(left) ${Wr.players.left.username} is playing against (right) ${Wr.players.right.username}. Time left to ready up: ${Wr.seconds}`);const Kr=playerManager.tournamentTable;if(Kr){const Zr=playerManager.getPlayer(Wr.players.left.id),Qr=playerManager.getPlayer(Wr.players.right.id);Zr&&Qr&&Kr.setExpectedTournamentPlayers(Zr,Qr)}}if(Wr.type=="confirm_pong_player_tournament"&&isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getLocalPlayer(),Zr=playerManager.tournamentTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="player_joined_pong_tournament"&&!isLocalPlayer(Wr.pongPlayer.id)){const Kr=playerManager.getPlayer(Wr.pongPlayer.id),Zr=playerManager.tournamentTable;Zr&&Kr&&(console.log(Wr.pongPlayer.side),Zr.setPlayerReady(Kr,Wr.pongPlayer.side),Zr.updatePaddle(Wr.pongPlayer.side,Wr.pongPlayer.paddleY))}if(Wr.type=="leave_pong_tournament"){const Kr=playerManager.tournamentTable;Kr&&Kr.removePlayer(Wr.pongPlayer.side)}if(Wr.type=="countdown_pong_tournament"){console.log("seconds: ",Wr.timer);const Kr=playerManager.tournamentTable;Kr&&Kr.setCountdownTimer(Number(Wr.timer))}if(Wr.type=="ball_move_tournament"){const Kr=playerManager.tournamentTable;if(Kr){let Zr={x:Wr.ball.x,y:Wr.ball.y};Kr.updateBall(Zr)}}if(Wr.type=="pong_update_tournament"){const Kr=playerManager.tournamentTable;Kr&&(Kr.updatePaddle("left",Wr.pongState.paddles.left),Kr.updatePaddle("right",Wr.pongState.paddles.right))}if(Wr.type=="score_update_tournament"){const Kr=playerManager.tournamentTable;Kr&&(console.log("Data: ",Wr),Kr.updateScore(Wr.side,Wr.score))}if(Wr.type=="finish_game_tournament"){const Kr=playerManager.tournamentTable;Kr&&Kr.finishGame(Wr.winnerId,Wr.finals)}gameSocket.onclose=Kr=>{if(console.log("Close event: ",Kr),gameSocket.readyState==WebSocket.OPEN){const Zr=playerManager.getLocalPlayer();let Qr={x:0,y:0};Zr&&(Qr=Zr.position.asCartesian,sendToServer(gameSocket,{type:"disconnection",id:localUser.id,position:Qr}))}}},window.addEventListener("beforeunload",()=>{if(gameSocket.readyState==WebSocket.OPEN){const Gr=playerManager.getLocalPlayer();let Wr={x:0,y:0};Gr&&(Wr=Gr.position.asCartesian,sendToServer(gameSocket,{type:"disconnection",id:localUser.id,position:Wr}))}}),gameSocket.onerror=Gr=>{console.log("Websocket error: ",Gr)}}__vitePreload(()=>Promise.resolve().then(()=>htmx_min$1),void 0);const playerInfoBox=document.getElementById("pixi-player-info");var ts;const Qi=class Qi{constructor(){Ci(this,"players",new Map);Ci(this,"localPlayer",null);Ci(this,"pongTable",null);Ci(this,"tournamentTable",null);Ci(this,"invites",[])}static get instance(){return is(Qi,ts)||ls(Qi,ts,new Qi),is(Qi,ts)}addInvite(ze){const Gr=this.getPlayer(ze.id);if(Gr){const Wr=new Invitation(Gr,this.invites.length);return this.invites.push(Wr),Wr}}removeInvite(ze){const Gr=this.invites.indexOf(ze);this.invites.splice(Gr,1)}getInvites(){return this.invites}isLocalPlayerInitialized(){return!!this.localPlayer}initLocalPlayer(ze,Gr,Wr,Kr){return this.localPlayer=new Player(ze,Gr,Wr,Kr),this.localPlayer}initPongTable(ze){this.pongTable=ze}initTournamentTable(ze){this.tournamentTable=ze}addPlayer(ze,Gr,Wr,Kr){const Zr=new Player(ze,Gr,Wr,Kr),Qr=Zr.getContext(),Jr=new ColorMatrixFilter;return Qr.interactive=!0,Qr.on("pointerover",()=>{console.log(`Player: ${ze}`),Qr.blendMode="color-dodge";const{matrix:ei}=Jr;ei[1]=1,ei[2]=1,ei[3]=1,Qr.filters=[Jr]}),Qr.on("pointerleave",()=>{Qr.filters=[]}),Qr.on("pointerdown",async()=>{if(playerInfoBox){playerInfoBox.style.display="block",playerInfoBox.style.top=`${mouse.y+10}px`,playerInfoBox.style.left=`${mouse.x+10}px`;try{const ei=await fetch(`/game/userinfo/${ze}`),ri=await(await fetch(`/areFriends/${ze}/${window.__USER_ID__}`)).json(),{user:ii}=await ei.json(),si=document.getElementById("infoUsername"),ni=document.getElementById("infoAvatar"),oi=document.getElementById("winsAndLosses"),li=document.getElementById("status"),ai=document.getElementById("friends");oi&&li&&ai&&(oi.textContent=`Wins: ${ii.wins} | Losses: ${ii.losses}`,ii.status?li.textContent="Online":li.textContent="Offline",ri.status!==null?ai.textContent=`Friends: ${ri.status}`:ai.textContent=""),console.log("friendStatus",ri),si&&(si.textContent=`${ii.username}`),ni&&(ni.outerHTML=`<img id="infoAvatar" src="/images/avatars/${ii.avatar}" class="w-12 h-12 rounded-full" />`);const hi=document.getElementById("friendRequest");if(hi&&ri.friend==!1){hi.style.display="block";const fi=document.getElementById("friendReqBtn");if(fi)fi&&(fi.innerHTML="Send friend request");else{const mi=document.createElement("button");mi.setAttribute("id","friendReqBtn"),mi.setAttribute("type","button"),mi.setAttribute("class","bg-[--color-secondary] text-[--color-text] hover:bg-[--color-accent] rounded-md p-2"),mi.setAttribute("hx-post",`sendReq/${ze}/${window.__USER_ID__}`),mi.innerHTML="Send friend request",hi.appendChild(mi)}const pi=document.getElementById("gameInviteBtn");pi&&(pi.onclick=()=>{const mi={type:MessageType.GameInvite,id:ii.id};gameSocket.send(JSON.stringify(mi))}),window.htmx.process(document.body)}else hi&&ri.friend&&(hi.style.display="none")}catch(ei){console.error("Failed to fetch player info",ei)}}}),this.players.set(ze,Zr),this.players.get(ze)}getLocalPlayer(){if(this.localPlayer)return this.localPlayer}getPlayer(ze){return this.localPlayer&&ze===this.localPlayer.id?this.localPlayer:this.players.get(ze)}getPlayers(){return this.players}updatePlayer(ze,Gr){const Wr=this.players.get(ze);Wr&&Wr.updatePosition(Gr)}removePlayer(ze){this.players.delete(ze)}};ts=new WeakMap,as(Qi,ts);let PlayerManager=Qi,playerManager=PlayerManager.instance;class MapRegion{constructor(ze,Gr,Wr){Ci(this,"start");Ci(this,"end");Ci(this,"container",new Container);this.container.sortableChildren=!0,this.start={x:ze.x,y:ze.y},this.end={x:this.start.x+Gr,y:this.start.y+Wr}}isInRegion(ze){return ze.x>=this.start.x&&ze.x<=this.end.x&&ze.y>=this.start.y&&ze.y<=this.end.y}addToContainer(ze){this.container.addChild(ze)}getContainer(){return this.container}}var rs;const Ji=class Ji{constructor(ze,Gr,Wr){Ci(this,"container");Ci(this,"graphicsContext");Ci(this,"rows");Ci(this,"cols");Ci(this,"tileSize");Ci(this,"mapRegions",new Map);this.container=new Container({isRenderGroup:!0}),this.container.sortableChildren=!0,this.graphicsContext=new Graphics,this.container.addChild(this.graphicsContext),this.rows=ze,this.cols=Gr,this.tileSize=Wr,this.initMapRegions()}static get instance(){return is(Ji,rs)||ls(Ji,rs,new Ji(GRIDHEIGHT,GRIDWIDTH,TILESIZE)),is(Ji,rs)}initMapRegions(){const ze=new MapRegion({x:52,y:0},12,24),Gr=new MapRegion({x:22,y:15},12,9),Wr=new MapRegion({x:0,y:0},16,23),Kr=new MapRegion({x:21,y:0},3,5),Zr=new MapRegion({x:0,y:0},0,0),Qr=new MapRegion({x:16,y:0},4,5);this.mapRegions.set(RoomType.Bocal,ze),this.mapRegions.set(RoomType.Game,Gr),this.mapRegions.set(RoomType.Cluster,Wr),this.mapRegions.set(RoomType.Server,Kr),this.mapRegions.set(RoomType.Hall,Zr),this.mapRegions.set(RoomType.Toilet,Qr)}getMapRegion(ze){for(const[Gr,Wr]of this.mapRegions)if(Wr.isInRegion(ze))return Gr;return RoomType.Hall}drawIsometricTile(ze,Gr,Wr,Kr,Zr){ze.poly([Gr.x,Gr.y,Gr.x+Wr,Gr.y+Kr/2,Gr.x,Gr.y+Kr,Gr.x-Wr,Gr.y+Kr/2,Gr.x,Gr.y]),Zr?(ze.fill(CGA_PINK_DARK),ze.stroke({color:CGA_BLACK})):(ze.fill(CGA_CYAN_DARK),ze.stroke({color:CGA_BLACK}))}async createGraphicsGrid(ze){for(let Gr=0;Gr<this.rows;Gr++)for(let Wr=0;Wr<this.cols;Wr++){const Kr=new Graphics;let Zr=new Point(Wr,Gr);const Qr=this.getMapRegion(Zr.asCartesian),Jr=this.mapRegions.get(Qr),ei=this.getHeightOffset(Wr,Gr,ze);if(Zr.asIsometric.y-=ei,ze[Gr][Wr]===1.01&&Qr===RoomType.Hall){Kr.zIndex=Zr.asIsometric.y,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!0),Jr==null||Jr.addToContainer(Kr);continue}if(ze[Gr][Wr]===1.02&&Qr===RoomType.Hall){Kr.zIndex=Zr.asIsometric.y,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!1),Jr==null||Jr.addToContainer(Kr);continue}if(ze[Gr][Wr]==-1){const ti=Texture.from("cardboard_blackhole"),ri=Math.random()*3;for(let ii=0;ii<ri;ii++){const si=new Sprite(ti);si.x=Zr.asIsometric.x-32,si.y=Zr.asIsometric.y-24-ii*16,si.scale=.5,si.zIndex=1e3,Jr==null||Jr.addToContainer(si)}ze[Gr][Wr]=0}{const ti=new Point(Wr,Gr+1),ri=new Point(Wr,Gr+1),ii=new Point(Wr+1,Gr+1),si=new Point(Wr+1,Gr+1);ti.asIsometric.y-=ei,si.asIsometric.y-=ei,Kr.poly([ti.asIsometric.x,ti.asIsometric.y,ri.asIsometric.x,ri.asIsometric.y,ii.asIsometric.x,ii.asIsometric.y,si.asIsometric.x,si.asIsometric.y]).stroke(CGA_BLACK).fill(CGA_BLACK)}{const ti=new Point(Wr+1,Gr+1),ri=new Point(Wr+1,Gr+1),ii=new Point(Wr+1,Gr),si=new Point(Wr+1,Gr);ti.asIsometric.y-=ei,si.asIsometric.y-=ei,Kr.poly([ti.asIsometric.x,ti.asIsometric.y,ri.asIsometric.x,ri.asIsometric.y,ii.asIsometric.x,ii.asIsometric.y,si.asIsometric.x,si.asIsometric.y]).stroke(CGA_BLACK).fill(CGA_CYAN)}ze[Gr][Wr]!=0?(Kr.zIndex=Zr.asIsometric.y,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!0)):(Kr.zIndex=-100,this.drawIsometricTile(Kr,Zr.asIsometric,this.tileSize,this.tileSize,!1)),Jr==null||Jr.addToContainer(Kr)}for(const[Gr,Wr]of this.mapRegions){const Kr=Wr.getContainer();Gr!==RoomType.Hall&&(Kr.renderable=!1),this.container.addChild(Kr)}}setRegionOpacity(ze,Gr){const Wr=this.mapRegions.get(ze);Wr&&(Wr.getContainer().alpha=Gr)}setRegionRenderable(ze,Gr){const Wr=this.mapRegions.get(ze);Wr&&(Wr.getContainer().renderable=Gr)}addPlayer(ze){var Wr;const Gr=this.getMapRegion(ze.getPosition());(Wr=this.mapRegions.get(Gr))==null||Wr.addToContainer(ze.getContext())}getHeightOffset(ze,Gr,Wr){return Wr[Gr][ze]*this.tileSize/4}moveMap(ze){this.container.x+=ze.x,this.container.y+=ze.y}getContainer(){return this.container}getRoomContainer(ze){var Gr;return(Gr=this.mapRegions.get(ze))==null?void 0:Gr.getContainer()}addToContainer(ze){this.container.addChild(ze)}removeFromRoomContainer(ze,Gr){const Wr=this.mapRegions.get(ze);Wr&&Wr.getContainer().removeChild(Gr)}addToRoomContainer(ze,Gr){const Wr=this.mapRegions.get(ze);Wr==null||Wr.addToContainer(Gr)}};rs=new WeakMap,as(Ji,rs);let GameMap=Ji;function addGameMap(Yr){let ze=GameMap.instance;const Gr=ze.getContainer();return ze.createGraphicsGrid(TILEMAP),Yr.stage.addChild(Gr),ze}function moveMapWithMouse(Yr,ze,Gr){if(!Gr)return;let Wr=window.innerWidth*.1,Kr=window.innerHeight*.1,Zr={x:0,y:0},Qr=5;if(Yr.x>=window.innerWidth-Wr){let Jr=(Yr.x-(window.innerWidth-Wr))/Wr;Zr.x-=Jr*Qr}if(Yr.x<=Wr){let Jr=(Wr-Yr.x)/Wr;Zr.x+=Jr*Qr}if(Yr.y<=Kr){let Jr=(Kr-Yr.y)/Kr;Zr.y+=Jr*Qr}if(Yr.y>=window.innerHeight-Kr){let Jr=(Yr.y-(window.innerHeight-Kr))/Kr;Zr.y-=Jr*Qr}ze.moveMap(Zr)}function setupMapZoom(){pixiApp.stage.scale=2.5,window.addEventListener("wheel",Yr=>{let ze=.05,Gr=2,Wr=4,Kr=Yr.deltaY/Math.abs(Yr.deltaY),Zr;(ti=>{ti[ti.Up=-1]="Up",ti[ti.Down=1]="Down"})(Zr||(Zr={}));let Qr=pixiApp.stage,Jr=localPlayerPos.asCartesian.x+pixiApp.screen.width/2,ei=localPlayerPos.asCartesian.y+pixiApp.screen.height/2;if(Kr==-1&&Qr.scale.x<Wr){const ti=1-Qr.scale.x/(Qr.scale.x+ze);Qr.scale.x+=ze,Qr.scale.y+=ze,Qr.x-=(Jr-Qr.x)*ti,Qr.y-=(ei-Qr.y)*ti}else if(Kr==1&&Qr.scale.x>Gr){const ti=1-Qr.scale.x/(Qr.scale.x+ze);Qr.scale.x-=ze,Qr.scale.y-=ze,Qr.x+=(Jr-Qr.x)*ti,Qr.y+=(ei-Qr.y)*ti}})}const messageHandlers={connect:(Yr,ze)=>{const Gr=Yr;Gr?console.log("Sucessfully created a session on the chat server",Gr):console.log("Couldn't create a session on the chat server :("),ze.send(`${ze.url} connected`)},confirm:(Yr,ze)=>{console.log(`MessageHandler: ${Yr.type}, from ${ze.url}`)},room_chat:(Yr,ze)=>{console.log(`RoomChat message from ${ze.url}`);const Gr=Yr;chat.createChatBubble(Gr,playerManager,gameMap.container),console.log(Gr)}};class ChatBubble extends TextBox{constructor(Gr,Wr,Kr){super(`${Gr.getUsername()}: ${Wr}`,Kr,Gr.getIsometricPosition().x,Gr.getIsometricPosition().y-Gr.getContext().height);Ci(this,"lifetimeExceeded",!1);this.setTextColor("#000000"),this.setBackgroundColor("#ffffff"),this.setStrokeColor("#000000"),this.update()}float(Gr){this.container.y-=Gr.deltaTime*.25,this.container.alpha-=Gr.deltaTime*.001,this.container.alpha<=0&&(this.lifetimeExceeded=!0)}dead(){return this.lifetimeExceeded}}class Chat{constructor(ze,Gr){Ci(this,"textInput");Ci(this,"sendButton");Ci(this,"chatBubbles",[]);Ci(this,"socket",null);Ci(this,"bubbleSize",20);this.textInput=document.getElementById(ze),this.textInput===null&&console.error("Couldn't get textInput for Chat"),this.sendButton=document.getElementById(Gr),this.sendButton===null&&console.error("Couldn't get sendButton for Chat")}getTextInput(){if(this.textInput)return this.textInput.value}handleTextInput(ze,Gr){const Wr=this.getTextInput();if(Wr){const Kr=ze.getLocalPlayer();if(Kr&&this.socket){const Zr={type:MessageType.RoomChat,id:Kr.getId(),message:Wr,timestamp:new Date().toLocaleString(),room:Kr.getRegion()};this.socket.send(JSON.stringify(Zr));const Qr=new ChatBubble(Kr,Wr,this.bubbleSize);this.chatBubbles.push(Qr),Gr.addChild(Qr.getContainer()),console.log("We pushing")}}this.textInput.value=""}bind(ze,Gr,Wr){this.socket=ze,this.sendButton.addEventListener("click",()=>{this.handleTextInput(Gr,Wr)}),document.addEventListener("keydown",Kr=>{Kr.key==="Enter"&&this.handleTextInput(Gr,Wr)})}createChatBubble(ze,Gr,Wr){const Kr=Gr.getPlayer(ze.id);if(Kr){const Zr=new ChatBubble(Kr,ze.message,this.bubbleSize);this.chatBubbles.push(Zr),Wr.addChild(Zr.getContainer())}}getChatBubbles(){return this.chatBubbles}destroyBubble(ze){const Gr=this.chatBubbles.indexOf(ze);Gr!==-1&&(ze.destroy(),this.chatBubbles.splice(Gr,1))}availableChatBubbles(){return this.chatBubbles.length>0}popChatBubble(){return this.chatBubbles.pop()}}const chat=new Chat("text-input-chat","send-button-chat");let chatSocket;function runChatConnectionManager(Yr){chatSocket=initializeWebsocket(window.__GAMESERVER_URL__,"8004","ws-chatserver"),chatSocket&&console.info(`Sucessfully connected to the chat server ${chatSocket.url}`),chat&&chat.bind(chatSocket,playerManager,Yr.container),chatSocket.onopen=ze=>{console.log(ze);const Gr=playerManager.getLocalPlayer();if(Gr){const Wr=Gr.getRegion(),Kr={type:MessageType.Connect,user:localUser,room:Wr};chatSocket.send(JSON.stringify(Kr))}},chatSocket.onmessage=ze=>{try{const Gr=JSON.parse(ze.data),Wr=messageHandlers[Gr.type];Wr?Wr(Gr,chatSocket):console.error(`Unhandled message type: ${Gr.type}`)}catch(Gr){console.error("Failed to process message: ",Gr)}},window.addEventListener("beforeunload",()=>{console.log("Beforeunload: ")}),chatSocket.onerror=ze=>{console.log("Websocket error: ",ze)}}const velocityMultiplier=1.2;class Ball{constructor(ze){Ci(this,"position");Ci(this,"graphics");Ci(this,"direction");Ci(this,"speed");this.graphics=new Graphics,this.position=new Point(ze.x,ze.y),this.speed=.05,this.direction={x:(Math.random()*2-1)*velocityMultiplier,y:(Math.random()*2-1)*velocityMultiplier},this.graphics.circle(0,0,3.5).fill(12303291),this.graphics.zIndex=100,this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}move(ze){let Gr=this.position.asCartesian,Wr={x:Gr.x+this.direction.x*this.speed*ze,y:Gr.y+this.direction.y*this.speed*ze};this.position.update(Wr),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}update(ze){this.position.update({x:ze.x,y:ze.y}),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}bounceX(){this.direction.x=-this.direction.x}bounceY(){this.direction.y=-this.direction.y}getContext(){return this.graphics}getPoint(){return this.position}}class Paddle{constructor(ze,Gr,Wr){Ci(this,"position");Ci(this,"graphics");Ci(this,"sprite");Ci(this,"paddleHeight");Ci(this,"paddleSpeed");this.position=new Point(ze.x,ze.y),this.paddleHeight=Gr,this.paddleSpeed=Wr;let Kr=new Point(0,ze.y-Gr/2),Zr=new Point(0,ze.y+Gr/2);this.graphics=new Graphics().moveTo(Kr.asIsometric.x,Kr.asIsometric.y).lineTo(Zr.asIsometric.x,Zr.asIsometric.y).stroke(16777215);const Qr=Texture.from("floppy_paddle");this.sprite=new Sprite(Qr),this.sprite.anchor.set(.5),this.sprite.x=this.position.asIsometric.x,this.sprite.y=this.position.asIsometric.y}move(ze,Gr){let Wr={x:this.position.asCartesian.x,y:this.position.asCartesian.y};Wr.y+=this.paddleSpeed*ze*Gr,this.position.update(Wr),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y,this.sprite.x=this.position.asIsometric.x,this.sprite.y=this.position.asIsometric.y}update(ze){this.position.update({x:this.position.asCartesian.x,y:ze}),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y,this.sprite.x=this.position.asIsometric.x,this.sprite.y=this.position.asIsometric.y}getPaddleHeight(){return this.paddleHeight}getPoint(){return this.position}getGraphics(){return this.sprite}}class PongInfo{constructor(ze,Gr,Wr){Ci(this,"box");Ci(this,"state");Ci(this,"score");Ci(this,"username");this.box=new TextBox("",ze,Gr,Wr),this.score=0,this.username="",this.state=PongState.Waiting}setPongPlayer(ze){ze&&(this.score=ze.score,this.username=ze.username)}setScore(ze){this.score=ze}setState(ze){ze===PongState.Waiting&&(this.score=0,this.username=""),this.state=ze}getState(){return this.state}display(){switch(this.state){case PongState.Waiting:this.box.setText("Waiting for player"),this.box.setTextColor(CGA_PINK);break;case PongState.PlayerNearby:this.box.setText("Press 'E'"),this.box.setTextColor(CGA_CYAN);break;case PongState.PlayerReady:this.box.setText(`${this.username} is ready!`),this.box.setTextColor(CGA_CYAN);break;case PongState.InProgress:this.box.setText(`${this.username} Score: ${this.score}`),this.box.setTextColor(CGA_PINK);break;case PongState.Enrolling:this.box.setText("Waiting for tournament to fill up..."),this.box.setTextColor(CGA_PINK);break;case PongState.Announcing:this.username===""?(this.box.setText("Waiting for tournament to fill up..."),this.box.setTextColor(CGA_PINK)):(this.box.setText(`${this.username}, please ready up!`),this.box.setTextColor(CGA_PINK));break}this.box.update()}getContainer(){return this.box.getContainer()}}function slice2DArray(Yr,ze,Gr,Wr,Kr){return Yr.slice(Wr,Kr).map(Qr=>Qr.slice(ze,Gr))}function isWithinRange(Yr,ze,Gr){return Math.abs(Yr-ze)<=Gr}class PongTable{constructor(ze,Gr,Wr){Ci(this,"container",new Container);Ci(this,"worldPosition");Ci(this,"tableGrid",[]);Ci(this,"ball");Ci(this,"paddles",{left:new Paddle({x:0,y:0},.5,.05),right:new Paddle({x:4,y:0},.5,.05)});Ci(this,"players",{left:null,right:null});Ci(this,"indicators",{left:new PongInfo(12,0,0),right:new PongInfo(12,TILESIZE*4,TILESIZE*2)});Ci(this,"countdownTimer",new TextBox("3",24,TILESIZE*2,0));Ci(this,"net");Ci(this,"inProgress",!1);Ci(this,"isTournament",!1);Ci(this,"state",TournamentState.Enrolling);Ci(this,"expectedTournamentPlayers",{left:null,right:null});this.isTournament=Wr,this.worldPosition=ze;let Kr=Math.round(ze.x),Zr=Math.round(ze.y);this.tableGrid=slice2DArray(Gr,Kr,Kr+4,Zr,Zr+2),this.ball=new Ball({x:2,y:1});let Qr=new Point(this.worldPosition.x,this.worldPosition.y);const Jr=this.getHeightOffset(0,0,this.tableGrid,TILESIZE);this.container.y-=Jr*2,this.container.zIndex=Qr.asIsometric.y+Jr,this.container.x+=Qr.asIsometric.x,this.container.y+=Qr.asIsometric.y;const ei=Texture.from("pong_net");this.net=new Sprite(ei),this.net.x-=16,this.net.y+=32,this.countdownTimer.container.renderable=!1,this.container.addChild(this.net),this.container.addChild(this.ball.getContext()),this.container.addChild(this.indicators.left.getContainer()),this.container.addChild(this.indicators.right.getContainer()),this.container.addChild(this.countdownTimer.getContainer()),this.container.addChild(this.paddles.left.getGraphics()),this.container.addChild(this.paddles.right.getGraphics())}getHeightOffset(ze,Gr,Wr,Kr){return Wr[Gr][ze]*Kr/4}drawIsometricTile(ze,Gr,Wr,Kr,Zr){ze.poly([Gr.x,Gr.y,Gr.x+Wr,Gr.y+Kr/2,Gr.x,Gr.y+Kr,Gr.x-Wr,Gr.y+Kr/2,Gr.x,Gr.y]),Zr?(ze.fill(CGA_PINK_DARK),ze.stroke({color:CGA_BLACK})):(ze.fill(CGA_CYAN_DARK),ze.stroke({color:CGA_BLACK}))}transitionTo(ze){console.log(`Transitioning from ${this.state} to ${ze}`),this.state=ze}setCountdownTimer(ze){ze===-1?this.countdownTimer.container.renderable=!1:(this.countdownTimer.container.renderable=!0,this.countdownTimer.setText(`Starting in: ${ze}`),this.countdownTimer.setTextColor(CGA_WHITE),this.countdownTimer.update())}isPlayerAtLeft(ze){let Gr={x:Math.ceil(ze.x),y:Math.ceil(ze.y)};return Gr.x===Math.ceil(this.worldPosition.x-1)&&Gr.y===Math.ceil(this.worldPosition.y)||Gr.x===Math.ceil(this.worldPosition.x-1)&&Gr.y===Math.ceil(this.worldPosition.y+1)}isPlayerAtRight(ze){let Gr={x:Math.ceil(ze.x),y:Math.ceil(ze.y)};return Gr.x===Math.ceil(this.worldPosition.x+4)&&Gr.y===Math.ceil(this.worldPosition.y)||Gr.x===Math.ceil(this.worldPosition.x+4)&&Gr.y===Math.ceil(this.worldPosition.y+1)}setPlayerReady(ze,Gr){this.players[Gr]||(this.players[Gr]={id:ze.getId(),username:ze.getUsername(),paddleY:32,ready:!0,score:0,side:Gr},this.indicators[Gr].setPongPlayer(this.players[Gr]),this.indicators[Gr].setState(PongState.PlayerReady))}setExpectedTournamentPlayers(ze,Gr){this.expectedTournamentPlayers.left={id:ze.getId(),username:ze.getUsername(),paddleY:32,ready:!1,score:0,side:"left"},this.expectedTournamentPlayers.right={id:Gr.getId(),username:Gr.getUsername(),paddleY:32,ready:!1,score:0,side:"right"},this.indicators.left.setPongPlayer(this.expectedTournamentPlayers.left),this.indicators.right.setPongPlayer(this.expectedTournamentPlayers.right),this.players.left||this.indicators.left.setState(PongState.Announcing),this.players.right||this.indicators.right.setState(PongState.Announcing)}isExpectedTournamentPlayer(ze,Gr){return this.expectedTournamentPlayers[Gr]?ze.getId()===this.expectedTournamentPlayers[Gr].id:!1}setIndicator(ze,Gr){ze!==null&&this.indicators[ze].setState(Gr)}displayPongState(){this.indicators.left.display(),this.indicators.right.display()}startGame(){this.inProgress||(this.indicators.left.setState(PongState.InProgress),this.indicators.right.setState(PongState.InProgress)),this.inProgress=!0}stopGame(){this.inProgress&&(this.indicators.left.setState(PongState.Waiting),this.indicators.right.setState(PongState.Waiting)),this.players.left=null,this.players.right=null,this.inProgress=!1,this.countdownTimer.container.renderable=!1}finishGame(ze,Gr){if(this.countdownTimer.container.renderable=!0,this.players.left&&this.players.right){const Wr=Math.min(this.players.left.score,this.players.right.score),Kr=Math.max(this.players.left.score,this.players.right.score);this.players.left.id===ze?(this.countdownTimer.setTextColor(CGA_WHITE),Gr?this.countdownTimer.setText(`${this.players.left.username} has won the tournament!`):this.countdownTimer.setText(`${this.players.left.username} has won with ${Kr} - ${Wr}!`)):(this.countdownTimer.setTextColor(CGA_WHITE),Gr?this.countdownTimer.setText(`${this.players.right.username} has won the tournament!`):this.countdownTimer.setText(`${this.players.right.username} has won with ${Kr} - ${Wr}!`)),this.countdownTimer.update(),setTimeout(()=>{this.countdownTimer.container.renderable=!1},2e3)}this.players.left=null,this.players.right=null,this.expectedTournamentPlayers.left=null,this.expectedTournamentPlayers.right=null,this.inProgress=!1}isInProgress(){return this.inProgress}updateScore(ze,Gr){console.log("Updating score on side: ",ze),console.log("This concerns player: ",this.players[ze]),this.players[ze]&&(this.players[ze].score=Gr,this.indicators[ze].setPongPlayer(this.players[ze]))}removePlayer(ze){this.players[ze]&&(this.players.left=null,this.players.right=null,this.indicators.left.setState(PongState.Waiting),this.indicators.right.setState(PongState.Waiting),this.inProgress=!1,this.countdownTimer.container.renderable=!1)}sendPaddleUpdate(ze,Gr){Gr!==null&&ze.ArrowUp&&(console.log("We are sending up"),sendToServer(gameSocket,{type:"paddle_move",side:Gr,direction:"up",tournament:this.isTournament})),Gr!==null&&ze.ArrowDown&&(console.log("We are sending down"),sendToServer(gameSocket,{type:"paddle_move",side:Gr,direction:"down",tournament:this.isTournament}))}isSideReady(ze){if(this.players[ze])return this.players[ze].ready}isPlayerReady(ze){return this.players.left&&this.players.left.id===ze?this.players.left.ready:this.players.right&&this.players.right.id===ze?this.players.right.ready:!1}getPongPlayer(ze){return this.players[ze]?this.players[ze]:null}getPlayerSide(ze){let Gr=ze.getPosition();return this.isPlayerAtLeft(Gr)?"left":this.isPlayerAtRight(Gr)?"right":null}collidesWithPaddle(ze){let Gr=this.getLocalBallPosition(this.ball),Wr=this.getLocalPaddlePosition(this.paddles[ze]),Kr=this.paddles[ze].getPaddleHeight()/2*TILESIZE,Zr=Wr.y-Kr,Qr=Wr.y+Kr,Jr=0;return ze==="right"&&(Jr=TILESIZE*4),!!(Gr.y>Zr&&Gr.y<Qr&&isWithinRange(Jr,Gr.x,1.5))}updateBall(ze){this.ball.update(ze)}updatePaddle(ze,Gr){ze!==null&&(this.paddles[ze].update(Gr),console.log("updatePaddleY client: ",this.paddles[ze].getPaddleHeight()))}getLocalBallPosition(ze){let Gr=ze.getPoint().asCartesian;return{x:Gr.x*TILESIZE,y:Gr.y*TILESIZE}}getLocalPaddlePosition(ze){let Gr=ze.getPoint().asCartesian;return{x:Gr.x*TILESIZE,y:Gr.y*TILESIZE}}getContainer(){return this.container}getBallContext(){return this.ball.getContext()}}__vitePreload(()=>Promise.resolve().then(()=>htmx_min$1),void 0);const tournamentInfoBox=document.getElementById("pixi-tournament-info"),subscribeBtn=document.getElementById("joinTournamentBtn"),unsubscribeBtn=document.getElementById("leaveTournamentBtn");class TournamentSubscription{constructor(ze,Gr,Wr,Kr,Zr){Ci(this,"subscriptionBox");Ci(this,"server");Ci(this,"localPlayer");this.subscriptionBox=new Sprite(Zr),this.server=Wr,this.localPlayer=Kr,this.subscriptionBox.interactive=!0,this.subscriptionBox.on("pointerdown",async()=>{if(tournamentInfoBox){tournamentInfoBox.style.display="block",tournamentInfoBox.style.top=`${mouse.y+10}px`,tournamentInfoBox.style.left=`${mouse.x+10}px`;const Jr=document.getElementById("infoCardTournament");Jr&&window.htmx.trigger(Jr,"customEvent",null)}});let Qr=new Point(ze,Gr);this.subscriptionBox.x=Qr.asIsometric.x-32,this.subscriptionBox.y=Qr.asIsometric.y-32*2,subscribeBtn&&subscribeBtn.addEventListener("click",()=>{this.subscribe()}),unsubscribeBtn&&unsubscribeBtn.addEventListener("click",()=>{this.unsubscribe()})}subscribe(){this.server.send(JSON.stringify({type:"tournament_join",tournamentPlayer:this.localPlayer}))}unsubscribe(){this.server.send(JSON.stringify({type:"tournament_leave",tournamentPlayer:this.localPlayer}))}getContext(){return this.subscriptionBox}}const vertexShader=`
>>>>>>>> 805be3c9e9327b40fd0eae7fd197944b511f20d2:public/index-BCxO-gOx.js
  in vec2 aPosition;
  out vec2 vTextureCoord;

  uniform vec4 uInputSize;
  uniform vec4 uOutputFrame;
  uniform vec4 uOutputTexture;

  vec4 filterVertexPosition( void )
  {
      vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

      position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
      position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

      return vec4(position, 0.0, 1.0);
  }

  vec2 filterTextureCoord( void )
  {
      return aPosition * (uOutputFrame.zw * uInputSize.zw);
  }

  void main(void)
  {
      gl_Position = filterVertexPosition();
      vTextureCoord = filterTextureCoord();
  }
`,fragmentShader=`

in vec2 vTextureCoord;
in vec4 vColor;
uniform sampler2D uTexture;
uniform float uWidth;
uniform float uHeight;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

float getDistanceFromCenter(vec2 uv) {
    float distance = distance(uv.xy, vec2(0.5, 0.5));
    return distance;
}

// vec2 applyCurvature(vec2 uv) {
//     // Center the coordinates
//     vec2 centered = uv - 0.5;
//
//     // Apply barrel distortion
//     float distortion = 0.1; // Adjust strength
//     float r2 = dot(centered, centered);
//     vec2 curved = centered * (1.0 + distortion * r2);
//
//     // Return to 0-1 range
//     return curved + 0.5;
// }
//
// TRIPPY
//
vec2 applyCurvature(vec2 uv) {

    vec2 centered = (uv - 0.5) * 2.0; // -1 to 1 range

    float curvature = 0.1;
    float r = length(centered);
    float distortion = 0.5 + curvature * r * r;

    return (centered * distortion) * 0.5 + 0.5;
}

// vec2 applyCurvature(vec2 uv) {
//     vec2 centered = uv - 0.5;
//
//     // Account for aspect ratio
//     // float aspect = uWidth / uHeight;
//     // centered.x *= aspect;
//
//     float distortion = 0.1;
//     float r2 = dot(centered, centered);
//     vec2 curved = centered * (1.0 + distortion * r2);
//
//     // curved.x /= aspect;
//     return curved + 0.5;
// }

// Simple 2x2 dither pattern
float dither2x2(vec2 pos) {
    int x = int(mod(pos.x, 2.0));
    int y = int(mod(pos.y, 2.0));
    
    if (x == 0 && y == 0) return 0.25;
    if (x == 1 && y == 0) return 0.75;
    if (x == 0 && y == 1) return 1.0;
    return 0.5; // x == 1 && y == 1
}

// 3x3 dither pattern
float dither3x3(vec2 pos) {
    int x = int(mod(pos.x, 3.0));
    int y = int(mod(pos.y, 3.0));
    
    if (x == 0) {
        if (y == 0) return 0.111; // 1/9
        if (y == 1) return 0.778; // 7/9
        return 0.444; // 4/9
    }
    if (x == 1) {
        if (y == 0) return 0.556; // 5/9
        if (y == 1) return 0.222; // 2/
        return 0.889; // 8/9
    }
    // x == 2
    if (y == 0) return 0.333; // 3/9
    if (y == 1) return 1.0;   // 9/9
    return 0.667; // 6/9
}

// Classic 4x4 Bayer matrix
float dither4x4(vec2 pos) {
    int x = int(mod(pos.x, 4.0));
    int y = int(mod(pos.y, 4.0));
    
    if (x == 0) {
        if (y == 0) return 0.0625;  // 1/16
        if (y == 1) return 0.5625;  // 9/16
        if (y == 2) return 0.1875;  // 3/16
        return 0.6875; // 11/16
    }
    if (x == 1) {
        if (y == 0) return 0.8125;  // 13/16
        if (y == 1) return 0.3125;  // 5/16
        if (y == 2) return 0.9375;  // 15/16
        return 0.4375; // 7/16
    }
    if (x == 2) {
        if (y == 0) return 0.25;    // 4/16
        if (y == 1) return 0.75;    // 12/16
        if (y == 2) return 0.125;   // 2/16
        return 0.625; // 10/16
    }
    // x == 3
    if (y == 0) return 1.0;     // 16/16
    if (y == 1) return 0.5;     // 8/16
    if (y == 2) return 0.875;   // 14/16
    return 0.375; // 6/16
}

void main(void) {

    // CURVATURE
    // vec2 curvedUV = applyCurvature(vTextureCoord);

    // if (curvedUV.x < 0.0 || curvedUV.x > 1.0 || curvedUV.y < 0.0 || curvedUV.y > 1.0) {
    //     gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black outside
    //     return;
    // } 
    // vec4 fg = texture2D(uTexture, curvedUV);
    vec4 fg = texture2D(uTexture, vTextureCoord);

    // NOISE
    // float noise = random(vTextureCoord.xy) * 1.25;
    // fg.r *= noise;
    
    // DITHERING
    // float ditherValue = dither2x2(gl_FragCoord.xy);  // Sharp, chunky
    // float ditherValue = dither3x3(gl_FragCoord.xy);  // Medium detail
    float ditherValue = dither4x4(gl_FragCoord.xy);     // Classic Bayer
    fg.rgb = step(ditherValue, fg.rgb);

    // CRT
    float scanline = sin(gl_FragCoord.y * 3.14159 * 0.25) * 0.1 + 0.9;
    fg.rgb *= scanline;

      // FADE
      float d = getDistanceFromCenter(vTextureCoord);
      fg.rgb -= d * 0.3;
      gl_FragColor = fg;
}
`,pixiApp=new Application;let prevPos={x:0,y:0},localPlayerPos=new Point(0,0),isGameFocused=!0,screenShake=!1,cameraMode=CameraMode.Locked,uiContainer=new Container;async function preload(){const Yr=[{alias:"player_spritesheet",src:"/assets/player_spritesheet.json"},{alias:"floppy_paddle",src:"/assets/floppy_paddle.png"},{alias:"pong_net",src:"/assets/pong_net.png"},{alias:"cardboard_blackhole",src:"/assets/cardboard_blackhole.png"},{alias:"tv_tournament",src:"/assets/tv_tournament.png"},{alias:"overlay",src:"/assets/overlay.png"},{alias:"block_empty_black",src:"/assets/block_empty_black.png"},{alias:"block_empty_white",src:"/assets/block_empty_white.png"},{alias:"block_opaque_coloured",src:"/assets/block_opaque_coloured.png"},{alias:"block_opaque_white",src:"/assets/block_opaque_white.png"},{alias:"block_half_opaque_coloured",src:"/assets/block_half_opaque_coloured.png"}];await Assets.load(Yr)}async function setup(){const Yr=document.getElementById("pixi-container");if(Yr){const Gr=document.getElementById("pixi-canvas");Gr&&Gr.remove(),await pixiApp.init({background:CGA_BLACK,resizeTo:Yr}),Yr.appendChild(pixiApp.canvas),pixiApp.canvas.setAttribute("id","pixi-canvas")}pixiApp.stage.eventMode="static",pixiApp.stage.hitArea=pixiApp.screen;const ze=document.getElementById("text-input-chat");ze&&(ze.addEventListener("blur",()=>{isGameFocused=!0}),ze.addEventListener("focus",()=>{isGameFocused=!1})),setupMapZoom(),uiContainer.position.set(0,0),uiContainer.zIndex=1e5,uiContainer.label="ui",pixiApp.stage.addChild(uiContainer),console.log("Pixi app initialized:",pixiApp)}function joinOrLeavePongTable(Yr,ze){const Gr=ze.getPlayerSide(Yr);if(Gr!==null){const Wr={id:Yr.getId(),username:Yr.getUsername(),paddleY:1,ready:!1,score:0,side:Gr};if(!ze.isSideReady(Gr))sendToServer(gameSocket,{type:"join_pong",pongPlayer:Wr});else{const Kr=ze.getPongPlayer(Gr);Kr&&Kr.id!==Yr.id?alert("There's already another player at the table!"):Kr&&sendToServer(gameSocket,{type:"leave_pong",pongPlayer:Kr})}}}function joinOrLeaveTournamentTable(Yr,ze){const Gr=Yr.getPlayerSide(ze);if(Gr!==null&&Yr.isExpectedTournamentPlayer(ze,Gr)){const Wr={id:ze.getId(),username:ze.getUsername(),paddleY:1,ready:!1,score:0,side:Gr};if(!Yr.isSideReady(Gr))sendToServer(gameSocket,{type:"join_pong_tournament",pongPlayer:Wr});else{const Kr=Yr.getPongPlayer(Gr);Kr&&Kr.id!==ze.id?alert("There's already another player at the table!"):Kr&&sendToServer(gameSocket,{type:"leave_pong_tournament",pongPlayer:Kr})}}}function handlePongUI(Yr,ze){Yr.isInProgress()?(Yr.setIndicator("left",PongState.InProgress),Yr.setIndicator("right",PongState.InProgress)):Yr.isPlayerReady(ze.id)||(Yr.isPlayerAtLeft(ze.getPosition())&&!Yr.isSideReady("left")?Yr.setIndicator("left",PongState.PlayerNearby):Yr.isSideReady("left")||Yr.setIndicator("left",PongState.Waiting),Yr.isPlayerAtRight(ze.getPosition())&&!Yr.isSideReady("right")?Yr.setIndicator("right",PongState.PlayerNearby):Yr.isSideReady("right")||Yr.setIndicator("right",PongState.Waiting)),keyWasPressed.KeyE&&joinOrLeavePongTable(ze,Yr),Yr.displayPongState()}function handleTournamentUI(Yr,ze){Yr.isInProgress()?(Yr.setIndicator("left",PongState.InProgress),Yr.setIndicator("right",PongState.InProgress)):Yr.isPlayerReady(ze.id)||(Yr.isPlayerAtLeft(ze.getPosition())&&!Yr.isSideReady("left")?Yr.setIndicator("left",PongState.PlayerNearby):Yr.isSideReady("left")||Yr.setIndicator("left",PongState.Announcing),Yr.isPlayerAtRight(ze.getPosition())&&!Yr.isSideReady("right")?Yr.setIndicator("right",PongState.PlayerNearby):Yr.isSideReady("right")||Yr.setIndicator("right",PongState.Announcing)),keyWasPressed.KeyE&&joinOrLeaveTournamentTable(Yr,ze),Yr.displayPongState()}function handleCamera(Yr,ze){if(cameraMode===CameraMode.Locked){let Gr=Yr.getPoint();localPlayerPos.update({x:Gr.asCartesian.x,y:Gr.asCartesian.y});const Wr=pixiApp.stage.scale.x,Kr=(pixiApp.screen.width/2-pixiApp.stage.x)/Wr,Zr=(pixiApp.screen.height/2-pixiApp.stage.y)/Wr;ze.container.x=-Gr.asIsometric.x+Kr,ze.container.y=-Gr.asIsometric.y+Zr}else moveMapWithMouse(mouse,ze,isGameFocused);keyWasPressed.KeyC&&isGameFocused&&(cameraMode=switchCameraMode(cameraMode))}function handleChatBubbles(Yr){const ze=chat.getChatBubbles();for(const Gr of ze)Gr.dead()?chat.destroyBubble(Gr):Gr.float(Yr)}function handleScreenshake(Yr,ze,Gr){Yr.isInProgress()&&(Yr.collidesWithPaddle(ze)&&!screenShake&&(screenShake=!0,setTimeout(()=>{screenShake=!1},200)),screenShake&&(pixiApp.stage.x+=Math.sin(Gr)))}function playerHasMoved(Yr,ze){return Yr.x!=ze.x||Yr.y!=ze.y}let transitionTimer=0,fade=!1,previousRoom=null,currentRoom=null;function fadeRoom(Yr){if(fade&&previousRoom!==null&&currentRoom!==null){transitionTimer+=Yr.deltaTime*.05;const ze=lerpNumber(0,1,transitionTimer);gameMap.setRegionOpacity(currentRoom,ze),gameMap.setRegionOpacity(previousRoom,1-ze),ze>=1&&(fade=!1,transitionTimer=0,previousRoom=null,currentRoom=null)}}function broadcastPositionUpdates(Yr){const ze=Yr.getPosition(),Gr=Yr.getId();if(playerHasMoved(prevPos,ze)){const Wr=gameMap.getMapRegion(ze),Kr=Yr.getRegion();if(Kr!=Wr&&(currentRoom=Wr,previousRoom=Kr,gameMap.setRegionRenderable(Kr,!1),gameMap.setRegionRenderable(Wr,!0),gameMap.setRegionOpacity(Kr,1),gameMap.setRegionOpacity(Wr,0),gameMap.removeFromRoomContainer(Kr,Yr.getContext()),gameMap.addToRoomContainer(Wr,Yr.getContext()),fade=!0,Yr.setRegion(Wr),!window.__DEV__)){const Zr={type:MessageType.Transition,id:Gr,from:Kr,to:Wr};(chatSocket.readyState===1||chatSocket.readyState===WebSocket.OPEN)&&chatSocket.send(JSON.stringify(Zr))}window.__DEV__||sendToServer(gameSocket,{type:"player_move",id:Yr.getId(),position:Yr.getPosition()})}}function isAtTable(Yr,ze){return ze.getPongPlayer("left")&&ze.getPongPlayer("right")?ze.getPongPlayer("left").id===Yr||ze.getPongPlayer("right").id===Yr:!1}function handleInvites(Yr,ze){for(const Gr of ze)Gr.dead()?(Gr.destroy(),playerManager.removeInvite(Gr)):Gr.animate(Yr)}let gameMap;(async()=>{await setup(),await preload();const Yr=new Filter({glProgram:new GlProgram({fragment:fragmentShader,vertex:vertexShader}),resources:{timeUniforms:{uWidth:{value:pixiApp.screen.width,type:"f32"},uHeight:{value:pixiApp.screen.height,type:"f32"}}}});if(pixiApp.stage.filters=[Yr],pixiApp.stage.addChild(new Graphics().rect(-500,-500,3500,3500).fill(CGA_CYAN_DARK_BG)),gameMap=addGameMap(pixiApp),gameMap.container.cullable=!0,gameMap.container.cullableChildren=!0,window.__USER_ID__&&!window.__DEV__){await runConnectionManager(gameMap),runChatConnectionManager(gameMap);let Jr=playerManager.getLocalPlayer();if(Jr){const ti=new TournamentSubscription(28.5,1,gameSocket,{id:Jr.id,username:Jr.getUsername(),avatar:Jr.getAvatar(),wins:0,losses:0,local:!1},Texture.from("tv_tournament")).getContext();ti.zIndex=1e4,gameMap.addToRoomContainer(RoomType.Hall,ti);const ri=gameMap.getMapRegion(Jr.getPosition());gameMap.setRegionRenderable(ri,!0),gameMap.setRegionOpacity(ri,1)}}else initializeLocalPlayer({id:420,username:"dev",avatar:"none",player:{id:420,userId:420,x:37,y:18}},gameMap);let ze=new PongTable({x:37,y:15},TILEMAP,!1);const Gr=ze.getContainer();Gr.zIndex=1e4,gameMap.addToRoomContainer(RoomType.Hall,Gr),playerManager.initPongTable(ze);let Wr=new PongTable({x:27,y:2},TILEMAP,!0);const Kr=Wr.getContainer();Kr.zIndex=1e4,gameMap.addToRoomContainer(RoomType.Hall,Kr),playerManager.initTournamentTable(Wr);const Zr=playerManager.getLocalPlayer();let Qr=0;pixiApp.ticker.add(Jr=>{if(Yr.resources.timeUniforms.uniforms.uWidth=pixiApp.screen.width,Yr.resources.timeUniforms.uniforms.uHeight=pixiApp.screen.height,Zr){if(fadeRoom(Jr),handleCamera(Zr,gameMap),handlePongUI(ze,Zr),handleTournamentUI(Wr,Zr),handleChatBubbles(Jr),handleInvites(Jr,playerManager.getInvites()),!ze.isPlayerReady(Zr.id)&&!Wr.isPlayerReady(Zr.id))movePlayer(Zr,Jr.deltaTime,isGameFocused),broadcastPositionUpdates(Zr);else if(isAtTable(Zr.id,Wr)){const ei=Wr.getPlayerSide(Zr);Wr.sendPaddleUpdate(keyIsPressed,ei),handleScreenshake(Wr,ei,Qr)}else{const ei=ze.getPlayerSide(Zr);ze.sendPaddleUpdate(keyIsPressed,ei),handleScreenshake(ze,ei,Qr)}prevPos=Zr.getPosition()}Qr+=Jr.deltaTime,resetKeyStates(keyWasPressed)})})();extensions.add(AccessibilitySystem);extensions.mixin(Container,accessibilityTarget);extensions.add(ResizePlugin);extensions.add(TickerPlugin);extensions.add(EventSystem);extensions.mixin(Container,FederatedContainer);extensions.add(DOMPipe);extensions.add(GraphicsPipe);extensions.add(GraphicsContextSystem);extensions.add(MeshPipe);extensions.add(GlParticleContainerPipe);extensions.add(GpuParticleContainerPipe);extensions.add(CanvasTextSystem);extensions.add(CanvasTextPipe);extensions.add(BitmapTextPipe);extensions.add(HTMLTextSystem);extensions.add(HTMLTextPipe);extensions.add(TilingSpritePipe);extensions.add(NineSliceSpritePipe);extensions.add(FilterSystem);extensions.add(FilterPipe);const browserAll=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"})),webworkerAll=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));var htmx_min$3={exports:{}},htmx_min$2=htmx_min$3.exports,hasRequiredHtmx_min;function requireHtmx_min(){return hasRequiredHtmx_min||(hasRequiredHtmx_min=1,function(module){(function(Yr,ze){module.exports?module.exports=ze():Yr.htmx=Yr.htmx||ze()})(typeof self<"u"?self:htmx_min$2,function(){return function(){var Q={onLoad:F,process:zt,on:de,off:ge,trigger:ce,ajax:Nr,find:C,findAll:f,closest:v,values:function(Yr,ze){var Gr=dr(Yr,ze||"post");return Gr.values},remove:_,addClass:z,removeClass:n,toggleClass:$,takeClass:W,defineExtension:Ur,removeExtension:Br,logAll:V,logNone:j,logger:null,config:{historyEnabled:!0,historyCacheSize:10,refreshOnHistoryMiss:!1,defaultSwapStyle:"innerHTML",defaultSwapDelay:0,defaultSettleDelay:20,includeIndicatorStyles:!0,indicatorClass:"htmx-indicator",requestClass:"htmx-request",addedClass:"htmx-added",settlingClass:"htmx-settling",swappingClass:"htmx-swapping",allowEval:!0,allowScriptTags:!0,inlineScriptNonce:"",attributesToSettle:["class","style","width","height"],withCredentials:!1,timeout:0,wsReconnectDelay:"full-jitter",wsBinaryType:"blob",disableSelector:"[hx-disable], [data-hx-disable]",useTemplateFragments:!1,scrollBehavior:"smooth",defaultFocusScroll:!1,getCacheBusterParam:!1,globalViewTransitions:!1,methodsThatUseUrlParams:["get"],selfRequestsOnly:!1,ignoreTitle:!1,scrollIntoViewOnBoost:!0,triggerSpecsCache:null},parseInterval:d,_:t,createEventSource:function(Yr){return new EventSource(Yr,{withCredentials:!0})},createWebSocket:function(Yr){var ze=new WebSocket(Yr,[]);return ze.binaryType=Q.config.wsBinaryType,ze},version:"1.9.12"},r={addTriggerHandler:Lt,bodyContains:se,canAccessLocalStorage:U,findThisElement:xe,filterValues:yr,hasAttribute:o,getAttributeValue:te,getClosestAttributeValue:ne,getClosestMatch:c,getExpressionVars:Hr,getHeaders:xr,getInputValues:dr,getInternalData:ae,getSwapSpecification:wr,getTriggerSpecs:it,getTarget:ye,makeFragment:l,mergeObjects:le,makeSettleInfo:T,oobSwap:Ee,querySelectorExt:ue,selectAndSwap:je,settleImmediately:nr,shouldCancel:ut,triggerEvent:ce,triggerErrorEvent:fe,withExtensions:R},w=["get","post","put","delete","patch"],i=w.map(function(Yr){return"[hx-"+Yr+"], [data-hx-"+Yr+"]"}).join(", "),S=e("head"),q=e("title"),H=e("svg",!0);function e(Yr,ze){return new RegExp("<"+Yr+"(\\s[^>]*>|>)([\\s\\S]*?)<\\/"+Yr+">",ze?"gim":"im")}function d(Yr){if(Yr==null)return;let ze=NaN;return Yr.slice(-2)=="ms"?ze=parseFloat(Yr.slice(0,-2)):Yr.slice(-1)=="s"?ze=parseFloat(Yr.slice(0,-1))*1e3:Yr.slice(-1)=="m"?ze=parseFloat(Yr.slice(0,-1))*1e3*60:ze=parseFloat(Yr),isNaN(ze)?void 0:ze}function ee(Yr,ze){return Yr.getAttribute&&Yr.getAttribute(ze)}function o(Yr,ze){return Yr.hasAttribute&&(Yr.hasAttribute(ze)||Yr.hasAttribute("data-"+ze))}function te(Yr,ze){return ee(Yr,ze)||ee(Yr,"data-"+ze)}function u(Yr){return Yr.parentElement}function re(){return document}function c(Yr,ze){for(;Yr&&!ze(Yr);)Yr=u(Yr);return Yr||null}function L(Yr,ze,Gr){var Wr=te(ze,Gr),Kr=te(ze,"hx-disinherit");return Yr!==ze&&Kr&&(Kr==="*"||Kr.split(" ").indexOf(Gr)>=0)?"unset":Wr}function ne(Yr,ze){var Gr=null;if(c(Yr,function(Wr){return Gr=L(Yr,Wr,ze)}),Gr!=="unset")return Gr}function h(Yr,ze){var Gr=Yr.matches||Yr.matchesSelector||Yr.msMatchesSelector||Yr.mozMatchesSelector||Yr.webkitMatchesSelector||Yr.oMatchesSelector;return Gr&&Gr.call(Yr,ze)}function A(Yr){var ze=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,Gr=ze.exec(Yr);return Gr?Gr[1].toLowerCase():""}function s(Yr,ze){for(var Gr=new DOMParser,Wr=Gr.parseFromString(Yr,"text/html"),Kr=Wr.body;ze>0;)ze--,Kr=Kr.firstChild;return Kr==null&&(Kr=re().createDocumentFragment()),Kr}function N(Yr){return/<body/.test(Yr)}function l(Yr){var ze=!N(Yr),Gr=A(Yr),Wr=Yr;if(Gr==="head"&&(Wr=Wr.replace(S,"")),Q.config.useTemplateFragments&&ze){var Kr=s("<body><template>"+Wr+"</template></body>",0),Zr=Kr.querySelector("template").content;return Q.config.allowScriptTags?oe(Zr.querySelectorAll("script"),function(Qr){Q.config.inlineScriptNonce&&(Qr.nonce=Q.config.inlineScriptNonce),Qr.htmxExecuted=navigator.userAgent.indexOf("Firefox")===-1}):oe(Zr.querySelectorAll("script"),function(Qr){_(Qr)}),Zr}switch(Gr){case"thead":case"tbody":case"tfoot":case"colgroup":case"caption":return s("<table>"+Wr+"</table>",1);case"col":return s("<table><colgroup>"+Wr+"</colgroup></table>",2);case"tr":return s("<table><tbody>"+Wr+"</tbody></table>",2);case"td":case"th":return s("<table><tbody><tr>"+Wr+"</tr></tbody></table>",3);case"script":case"style":return s("<div>"+Wr+"</div>",1);default:return s(Wr,0)}}function ie(Yr){Yr&&Yr()}function I(Yr,ze){return Object.prototype.toString.call(Yr)==="[object "+ze+"]"}function k(Yr){return I(Yr,"Function")}function P(Yr){return I(Yr,"Object")}function ae(Yr){var ze="htmx-internal-data",Gr=Yr[ze];return Gr||(Gr=Yr[ze]={}),Gr}function M(Yr){var ze=[];if(Yr)for(var Gr=0;Gr<Yr.length;Gr++)ze.push(Yr[Gr]);return ze}function oe(Yr,ze){if(Yr)for(var Gr=0;Gr<Yr.length;Gr++)ze(Yr[Gr])}function X(Yr){var ze=Yr.getBoundingClientRect(),Gr=ze.top,Wr=ze.bottom;return Gr<window.innerHeight&&Wr>=0}function se(Yr){return Yr.getRootNode&&Yr.getRootNode()instanceof window.ShadowRoot?re().body.contains(Yr.getRootNode().host):re().body.contains(Yr)}function D(Yr){return Yr.trim().split(/\s+/)}function le(Yr,ze){for(var Gr in ze)ze.hasOwnProperty(Gr)&&(Yr[Gr]=ze[Gr]);return Yr}function E(Yr){try{return JSON.parse(Yr)}catch(ze){return b(ze),null}}function U(){var Yr="htmx:localStorageTest";try{return localStorage.setItem(Yr,Yr),localStorage.removeItem(Yr),!0}catch{return!1}}function B(Yr){try{var ze=new URL(Yr);return ze&&(Yr=ze.pathname+ze.search),/^\/$/.test(Yr)||(Yr=Yr.replace(/\/+$/,"")),Yr}catch{return Yr}}function t(e){return Tr(re().body,function(){return eval(e)})}function F(Yr){var ze=Q.on("htmx:load",function(Gr){Yr(Gr.detail.elt)});return ze}function V(){Q.logger=function(Yr,ze,Gr){console&&console.log(ze,Yr,Gr)}}function j(){Q.logger=null}function C(Yr,ze){return ze?Yr.querySelector(ze):C(re(),Yr)}function f(Yr,ze){return ze?Yr.querySelectorAll(ze):f(re(),Yr)}function _(Yr,ze){Yr=p(Yr),ze?setTimeout(function(){_(Yr),Yr=null},ze):Yr.parentElement.removeChild(Yr)}function z(Yr,ze,Gr){Yr=p(Yr),Gr?setTimeout(function(){z(Yr,ze),Yr=null},Gr):Yr.classList&&Yr.classList.add(ze)}function n(Yr,ze,Gr){Yr=p(Yr),Gr?setTimeout(function(){n(Yr,ze),Yr=null},Gr):Yr.classList&&(Yr.classList.remove(ze),Yr.classList.length===0&&Yr.removeAttribute("class"))}function $(Yr,ze){Yr=p(Yr),Yr.classList.toggle(ze)}function W(Yr,ze){Yr=p(Yr),oe(Yr.parentElement.children,function(Gr){n(Gr,ze)}),z(Yr,ze)}function v(Yr,ze){if(Yr=p(Yr),Yr.closest)return Yr.closest(ze);do if(Yr==null||h(Yr,ze))return Yr;while(Yr=Yr&&u(Yr));return null}function g(Yr,ze){return Yr.substring(0,ze.length)===ze}function G(Yr,ze){return Yr.substring(Yr.length-ze.length)===ze}function J(Yr){var ze=Yr.trim();return g(ze,"<")&&G(ze,"/>")?ze.substring(1,ze.length-2):ze}function Z(Yr,ze){return ze.indexOf("closest ")===0?[v(Yr,J(ze.substr(8)))]:ze.indexOf("find ")===0?[C(Yr,J(ze.substr(5)))]:ze==="next"?[Yr.nextElementSibling]:ze.indexOf("next ")===0?[K(Yr,J(ze.substr(5)))]:ze==="previous"?[Yr.previousElementSibling]:ze.indexOf("previous ")===0?[Y(Yr,J(ze.substr(9)))]:ze==="document"?[document]:ze==="window"?[window]:ze==="body"?[document.body]:re().querySelectorAll(J(ze))}var K=function(Yr,ze){for(var Gr=re().querySelectorAll(ze),Wr=0;Wr<Gr.length;Wr++){var Kr=Gr[Wr];if(Kr.compareDocumentPosition(Yr)===Node.DOCUMENT_POSITION_PRECEDING)return Kr}},Y=function(Yr,ze){for(var Gr=re().querySelectorAll(ze),Wr=Gr.length-1;Wr>=0;Wr--){var Kr=Gr[Wr];if(Kr.compareDocumentPosition(Yr)===Node.DOCUMENT_POSITION_FOLLOWING)return Kr}};function ue(Yr,ze){return ze?Z(Yr,ze)[0]:Z(re().body,Yr)[0]}function p(Yr){return I(Yr,"String")?C(Yr):Yr}function ve(Yr,ze,Gr){return k(ze)?{target:re().body,event:Yr,listener:ze}:{target:p(Yr),event:ze,listener:Gr}}function de(Yr,ze,Gr){jr(function(){var Kr=ve(Yr,ze,Gr);Kr.target.addEventListener(Kr.event,Kr.listener)});var Wr=k(ze);return Wr?ze:Gr}function ge(Yr,ze,Gr){return jr(function(){var Wr=ve(Yr,ze,Gr);Wr.target.removeEventListener(Wr.event,Wr.listener)}),k(ze)?ze:Gr}var pe=re().createElement("output");function me(Yr,ze){var Gr=ne(Yr,ze);if(Gr){if(Gr==="this")return[xe(Yr,ze)];var Wr=Z(Yr,Gr);return Wr.length===0?(b('The selector "'+Gr+'" on '+ze+" returned no matches!"),[pe]):Wr}}function xe(Yr,ze){return c(Yr,function(Gr){return te(Gr,ze)!=null})}function ye(Yr){var ze=ne(Yr,"hx-target");if(ze)return ze==="this"?xe(Yr,"hx-target"):ue(Yr,ze);var Gr=ae(Yr);return Gr.boosted?re().body:Yr}function be(Yr){for(var ze=Q.config.attributesToSettle,Gr=0;Gr<ze.length;Gr++)if(Yr===ze[Gr])return!0;return!1}function we(Yr,ze){oe(Yr.attributes,function(Gr){!ze.hasAttribute(Gr.name)&&be(Gr.name)&&Yr.removeAttribute(Gr.name)}),oe(ze.attributes,function(Gr){be(Gr.name)&&Yr.setAttribute(Gr.name,Gr.value)})}function Se(Yr,ze){for(var Gr=Fr(ze),Wr=0;Wr<Gr.length;Wr++){var Kr=Gr[Wr];try{if(Kr.isInlineSwap(Yr))return!0}catch(Zr){b(Zr)}}return Yr==="outerHTML"}function Ee(Yr,ze,Gr){var Wr="#"+ee(ze,"id"),Kr="outerHTML";Yr==="true"||(Yr.indexOf(":")>0?(Kr=Yr.substr(0,Yr.indexOf(":")),Wr=Yr.substr(Yr.indexOf(":")+1,Yr.length)):Kr=Yr);var Zr=re().querySelectorAll(Wr);return Zr?(oe(Zr,function(Qr){var Jr,ei=ze.cloneNode(!0);Jr=re().createDocumentFragment(),Jr.appendChild(ei),Se(Kr,Qr)||(Jr=ei);var ti={shouldSwap:!0,target:Qr,fragment:Jr};ce(Qr,"htmx:oobBeforeSwap",ti)&&(Qr=ti.target,ti.shouldSwap&&Fe(Kr,Qr,Qr,Jr,Gr),oe(Gr.elts,function(ri){ce(ri,"htmx:oobAfterSwap",ti)}))}),ze.parentNode.removeChild(ze)):(ze.parentNode.removeChild(ze),fe(re().body,"htmx:oobErrorNoTarget",{content:ze})),Yr}function Ce(Yr,ze,Gr){var Wr=ne(Yr,"hx-select-oob");if(Wr)for(var Kr=Wr.split(","),Zr=0;Zr<Kr.length;Zr++){var Qr=Kr[Zr].split(":",2),Jr=Qr[0].trim();Jr.indexOf("#")===0&&(Jr=Jr.substring(1));var ei=Qr[1]||"true",ti=ze.querySelector("#"+Jr);ti&&Ee(ei,ti,Gr)}oe(f(ze,"[hx-swap-oob], [data-hx-swap-oob]"),function(ri){var ii=te(ri,"hx-swap-oob");ii!=null&&Ee(ii,ri,Gr)})}function Re(Yr){oe(f(Yr,"[hx-preserve], [data-hx-preserve]"),function(ze){var Gr=te(ze,"id"),Wr=re().getElementById(Gr);Wr!=null&&ze.parentNode.replaceChild(Wr,ze)})}function Te(Yr,ze,Gr){oe(ze.querySelectorAll("[id]"),function(Wr){var Kr=ee(Wr,"id");if(Kr&&Kr.length>0){var Zr=Kr.replace("'","\\'"),Qr=Wr.tagName.replace(":","\\:"),Jr=Yr.querySelector(Qr+"[id='"+Zr+"']");if(Jr&&Jr!==Yr){var ei=Wr.cloneNode();we(Wr,Jr),Gr.tasks.push(function(){we(Wr,ei)})}}})}function Oe(Yr){return function(){n(Yr,Q.config.addedClass),zt(Yr),Nt(Yr),qe(Yr),ce(Yr,"htmx:load")}}function qe(Yr){var ze="[autofocus]",Gr=h(Yr,ze)?Yr:Yr.querySelector(ze);Gr!=null&&Gr.focus()}function a(Yr,ze,Gr,Wr){for(Te(Yr,Gr,Wr);Gr.childNodes.length>0;){var Kr=Gr.firstChild;z(Kr,Q.config.addedClass),Yr.insertBefore(Kr,ze),Kr.nodeType!==Node.TEXT_NODE&&Kr.nodeType!==Node.COMMENT_NODE&&Wr.tasks.push(Oe(Kr))}}function He(Yr,ze){for(var Gr=0;Gr<Yr.length;)ze=(ze<<5)-ze+Yr.charCodeAt(Gr++)|0;return ze}function Le(Yr){var ze=0;if(Yr.attributes)for(var Gr=0;Gr<Yr.attributes.length;Gr++){var Wr=Yr.attributes[Gr];Wr.value&&(ze=He(Wr.name,ze),ze=He(Wr.value,ze))}return ze}function Ae(Yr){var ze=ae(Yr);if(ze.onHandlers){for(var Gr=0;Gr<ze.onHandlers.length;Gr++){const Wr=ze.onHandlers[Gr];Yr.removeEventListener(Wr.event,Wr.listener)}delete ze.onHandlers}}function Ne(Yr){var ze=ae(Yr);ze.timeout&&clearTimeout(ze.timeout),ze.webSocket&&ze.webSocket.close(),ze.sseEventSource&&ze.sseEventSource.close(),ze.listenerInfos&&oe(ze.listenerInfos,function(Gr){Gr.on&&Gr.on.removeEventListener(Gr.trigger,Gr.listener)}),Ae(Yr),oe(Object.keys(ze),function(Gr){delete ze[Gr]})}function m(Yr){ce(Yr,"htmx:beforeCleanupElement"),Ne(Yr),Yr.children&&oe(Yr.children,function(ze){m(ze)})}function Ie(Yr,ze,Gr){if(Yr.tagName==="BODY")return Ue(Yr,ze,Gr);var Wr,Kr=Yr.previousSibling;for(a(u(Yr),Yr,ze,Gr),Kr==null?Wr=u(Yr).firstChild:Wr=Kr.nextSibling,Gr.elts=Gr.elts.filter(function(Zr){return Zr!=Yr});Wr&&Wr!==Yr;)Wr.nodeType===Node.ELEMENT_NODE&&Gr.elts.push(Wr),Wr=Wr.nextElementSibling;m(Yr),u(Yr).removeChild(Yr)}function ke(Yr,ze,Gr){return a(Yr,Yr.firstChild,ze,Gr)}function Pe(Yr,ze,Gr){return a(u(Yr),Yr,ze,Gr)}function Me(Yr,ze,Gr){return a(Yr,null,ze,Gr)}function Xe(Yr,ze,Gr){return a(u(Yr),Yr.nextSibling,ze,Gr)}function De(Yr,ze,Gr){return m(Yr),u(Yr).removeChild(Yr)}function Ue(Yr,ze,Gr){var Wr=Yr.firstChild;if(a(Yr,Wr,ze,Gr),Wr){for(;Wr.nextSibling;)m(Wr.nextSibling),Yr.removeChild(Wr.nextSibling);m(Wr),Yr.removeChild(Wr)}}function Be(Yr,ze,Gr){var Wr=Gr||ne(Yr,"hx-select");if(Wr){var Kr=re().createDocumentFragment();oe(ze.querySelectorAll(Wr),function(Zr){Kr.appendChild(Zr)}),ze=Kr}return ze}function Fe(Yr,ze,Gr,Wr,Kr){switch(Yr){case"none":return;case"outerHTML":Ie(Gr,Wr,Kr);return;case"afterbegin":ke(Gr,Wr,Kr);return;case"beforebegin":Pe(Gr,Wr,Kr);return;case"beforeend":Me(Gr,Wr,Kr);return;case"afterend":Xe(Gr,Wr,Kr);return;case"delete":De(Gr);return;default:for(var Zr=Fr(ze),Qr=0;Qr<Zr.length;Qr++){var Jr=Zr[Qr];try{var ei=Jr.handleSwap(Yr,Gr,Wr,Kr);if(ei){if(typeof ei.length<"u")for(var ti=0;ti<ei.length;ti++){var ri=ei[ti];ri.nodeType!==Node.TEXT_NODE&&ri.nodeType!==Node.COMMENT_NODE&&Kr.tasks.push(Oe(ri))}return}}catch(ii){b(ii)}}Yr==="innerHTML"?Ue(Gr,Wr,Kr):Fe(Q.config.defaultSwapStyle,ze,Gr,Wr,Kr)}}function Ve(Yr){if(Yr.indexOf("<title")>-1){var ze=Yr.replace(H,""),Gr=ze.match(q);if(Gr)return Gr[2]}}function je(Yr,ze,Gr,Wr,Kr,Zr){Kr.title=Ve(Wr);var Qr=l(Wr);if(Qr)return Ce(Gr,Qr,Kr),Qr=Be(Gr,Qr,Zr),Re(Qr),Fe(Yr,Gr,ze,Qr,Kr)}function _e(Yr,ze,Gr){var Wr=Yr.getResponseHeader(ze);if(Wr.indexOf("{")===0){var Kr=E(Wr);for(var Zr in Kr)if(Kr.hasOwnProperty(Zr)){var Qr=Kr[Zr];P(Qr)||(Qr={value:Qr}),ce(Gr,Zr,Qr)}}else for(var Jr=Wr.split(","),ei=0;ei<Jr.length;ei++)ce(Gr,Jr[ei].trim(),[])}var x=/[\s,]/,$e=/[_$a-zA-Z]/,We=/[_$a-zA-Z0-9]/,Ge=['"',"'","/"],Je=/[^\s]/,Ze=/[{(]/,Ke=/[})]/;function Ye(Yr){for(var ze=[],Gr=0;Gr<Yr.length;){if($e.exec(Yr.charAt(Gr))){for(var Wr=Gr;We.exec(Yr.charAt(Gr+1));)Gr++;ze.push(Yr.substr(Wr,Gr-Wr+1))}else if(Ge.indexOf(Yr.charAt(Gr))!==-1){var Kr=Yr.charAt(Gr),Wr=Gr;for(Gr++;Gr<Yr.length&&Yr.charAt(Gr)!==Kr;)Yr.charAt(Gr)==="\\"&&Gr++,Gr++;ze.push(Yr.substr(Wr,Gr-Wr+1))}else{var Zr=Yr.charAt(Gr);ze.push(Zr)}Gr++}return ze}function Qe(Yr,ze,Gr){return $e.exec(Yr.charAt(0))&&Yr!=="true"&&Yr!=="false"&&Yr!=="this"&&Yr!==Gr&&ze!=="."}function et(Yr,ze,Gr){if(ze[0]==="["){ze.shift();for(var Wr=1,Kr=" return (function("+Gr+"){ return (",Zr=null;ze.length>0;){var Qr=ze[0];if(Qr==="]"){if(Wr--,Wr===0){Zr===null&&(Kr=Kr+"true"),ze.shift(),Kr+=")})";try{var Jr=Tr(Yr,function(){return Function(Kr)()},function(){return!0});return Jr.source=Kr,Jr}catch(ei){return fe(re().body,"htmx:syntax:error",{error:ei,source:Kr}),null}}}else Qr==="["&&Wr++;Qe(Qr,Zr,Gr)?Kr+="(("+Gr+"."+Qr+") ? ("+Gr+"."+Qr+") : (window."+Qr+"))":Kr=Kr+Qr,Zr=ze.shift()}}}function y(Yr,ze){for(var Gr="";Yr.length>0&&!ze.test(Yr[0]);)Gr+=Yr.shift();return Gr}function tt(Yr){var ze;return Yr.length>0&&Ze.test(Yr[0])?(Yr.shift(),ze=y(Yr,Ke).trim(),Yr.shift()):ze=y(Yr,x),ze}var rt="input, textarea, select";function nt(Yr,ze,Gr){var Wr=[],Kr=Ye(ze);do{y(Kr,Je);var Zr=Kr.length,Qr=y(Kr,/[,\[\s]/);if(Qr!=="")if(Qr==="every"){var Jr={trigger:"every"};y(Kr,Je),Jr.pollInterval=d(y(Kr,/[,\[\s]/)),y(Kr,Je);var ei=et(Yr,Kr,"event");ei&&(Jr.eventFilter=ei),Wr.push(Jr)}else if(Qr.indexOf("sse:")===0)Wr.push({trigger:"sse",sseEvent:Qr.substr(4)});else{var ti={trigger:Qr},ei=et(Yr,Kr,"event");for(ei&&(ti.eventFilter=ei);Kr.length>0&&Kr[0]!==",";){y(Kr,Je);var ri=Kr.shift();if(ri==="changed")ti.changed=!0;else if(ri==="once")ti.once=!0;else if(ri==="consume")ti.consume=!0;else if(ri==="delay"&&Kr[0]===":")Kr.shift(),ti.delay=d(y(Kr,x));else if(ri==="from"&&Kr[0]===":"){if(Kr.shift(),Ze.test(Kr[0]))var ii=tt(Kr);else{var ii=y(Kr,x);if(ii==="closest"||ii==="find"||ii==="next"||ii==="previous"){Kr.shift();var si=tt(Kr);si.length>0&&(ii+=" "+si)}}ti.from=ii}else ri==="target"&&Kr[0]===":"?(Kr.shift(),ti.target=tt(Kr)):ri==="throttle"&&Kr[0]===":"?(Kr.shift(),ti.throttle=d(y(Kr,x))):ri==="queue"&&Kr[0]===":"?(Kr.shift(),ti.queue=y(Kr,x)):ri==="root"&&Kr[0]===":"?(Kr.shift(),ti[ri]=tt(Kr)):ri==="threshold"&&Kr[0]===":"?(Kr.shift(),ti[ri]=y(Kr,x)):fe(Yr,"htmx:syntax:error",{token:Kr.shift()})}Wr.push(ti)}Kr.length===Zr&&fe(Yr,"htmx:syntax:error",{token:Kr.shift()}),y(Kr,Je)}while(Kr[0]===","&&Kr.shift());return Gr&&(Gr[ze]=Wr),Wr}function it(Yr){var ze=te(Yr,"hx-trigger"),Gr=[];if(ze){var Wr=Q.config.triggerSpecsCache;Gr=Wr&&Wr[ze]||nt(Yr,ze,Wr)}return Gr.length>0?Gr:h(Yr,"form")?[{trigger:"submit"}]:h(Yr,'input[type="button"], input[type="submit"]')?[{trigger:"click"}]:h(Yr,rt)?[{trigger:"change"}]:[{trigger:"click"}]}function at(Yr){ae(Yr).cancelled=!0}function ot(Yr,ze,Gr){var Wr=ae(Yr);Wr.timeout=setTimeout(function(){se(Yr)&&Wr.cancelled!==!0&&(ct(Gr,Yr,Wt("hx:poll:trigger",{triggerSpec:Gr,target:Yr}))||ze(Yr),ot(Yr,ze,Gr))},Gr.pollInterval)}function st(Yr){return location.hostname===Yr.hostname&&ee(Yr,"href")&&ee(Yr,"href").indexOf("#")!==0}function lt(Yr,ze,Gr){if(Yr.tagName==="A"&&st(Yr)&&(Yr.target===""||Yr.target==="_self")||Yr.tagName==="FORM"){ze.boosted=!0;var Wr,Kr;if(Yr.tagName==="A")Wr="get",Kr=ee(Yr,"href");else{var Zr=ee(Yr,"method");Wr=Zr?Zr.toLowerCase():"get",Kr=ee(Yr,"action")}Gr.forEach(function(Qr){ht(Yr,function(Jr,ei){if(v(Jr,Q.config.disableSelector)){m(Jr);return}he(Wr,Kr,Jr,ei)},ze,Qr,!0)})}}function ut(Yr,ze){return!!((Yr.type==="submit"||Yr.type==="click")&&(ze.tagName==="FORM"||h(ze,'input[type="submit"], button')&&v(ze,"form")!==null||ze.tagName==="A"&&ze.href&&(ze.getAttribute("href")==="#"||ze.getAttribute("href").indexOf("#")!==0)))}function ft(Yr,ze){return ae(Yr).boosted&&Yr.tagName==="A"&&ze.type==="click"&&(ze.ctrlKey||ze.metaKey)}function ct(Yr,ze,Gr){var Wr=Yr.eventFilter;if(Wr)try{return Wr.call(ze,Gr)!==!0}catch(Kr){return fe(re().body,"htmx:eventFilter:error",{error:Kr,source:Wr.source}),!0}return!1}function ht(Yr,ze,Gr,Wr,Kr){var Zr=ae(Yr),Qr;Wr.from?Qr=Z(Yr,Wr.from):Qr=[Yr],Wr.changed&&Qr.forEach(function(Jr){var ei=ae(Jr);ei.lastValue=Jr.value}),oe(Qr,function(Jr){var ei=function(ti){if(!se(Yr)){Jr.removeEventListener(Wr.trigger,ei);return}if(!ft(Yr,ti)&&((Kr||ut(ti,Yr))&&ti.preventDefault(),!ct(Wr,Yr,ti))){var ri=ae(ti);if(ri.triggerSpec=Wr,ri.handledFor==null&&(ri.handledFor=[]),ri.handledFor.indexOf(Yr)<0){if(ri.handledFor.push(Yr),Wr.consume&&ti.stopPropagation(),Wr.target&&ti.target&&!h(ti.target,Wr.target))return;if(Wr.once){if(Zr.triggeredOnce)return;Zr.triggeredOnce=!0}if(Wr.changed){var ii=ae(Jr);if(ii.lastValue===Jr.value)return;ii.lastValue=Jr.value}if(Zr.delayed&&clearTimeout(Zr.delayed),Zr.throttle)return;Wr.throttle>0?Zr.throttle||(ze(Yr,ti),Zr.throttle=setTimeout(function(){Zr.throttle=null},Wr.throttle)):Wr.delay>0?Zr.delayed=setTimeout(function(){ze(Yr,ti)},Wr.delay):(ce(Yr,"htmx:trigger"),ze(Yr,ti))}}};Gr.listenerInfos==null&&(Gr.listenerInfos=[]),Gr.listenerInfos.push({trigger:Wr.trigger,listener:ei,on:Jr}),Jr.addEventListener(Wr.trigger,ei)})}var vt=!1,dt=null;function gt(){dt||(dt=function(){vt=!0},window.addEventListener("scroll",dt),setInterval(function(){vt&&(vt=!1,oe(re().querySelectorAll("[hx-trigger='revealed'],[data-hx-trigger='revealed']"),function(Yr){pt(Yr)}))},200))}function pt(Yr){if(!o(Yr,"data-hx-revealed")&&X(Yr)){Yr.setAttribute("data-hx-revealed","true");var ze=ae(Yr);ze.initHash?ce(Yr,"revealed"):Yr.addEventListener("htmx:afterProcessNode",function(Gr){ce(Yr,"revealed")},{once:!0})}}function mt(Yr,ze,Gr){for(var Wr=D(Gr),Kr=0;Kr<Wr.length;Kr++){var Zr=Wr[Kr].split(/:(.+)/);Zr[0]==="connect"&&xt(Yr,Zr[1],0),Zr[0]==="send"&&bt(Yr)}}function xt(Yr,ze,Gr){if(se(Yr)){if(ze.indexOf("/")==0){var Wr=location.hostname+(location.port?":"+location.port:"");location.protocol=="https:"?ze="wss://"+Wr+ze:location.protocol=="http:"&&(ze="ws://"+Wr+ze)}var Kr=Q.createWebSocket(ze);Kr.onerror=function(Zr){fe(Yr,"htmx:wsError",{error:Zr,socket:Kr}),yt(Yr)},Kr.onclose=function(Zr){if([1006,1012,1013].indexOf(Zr.code)>=0){var Qr=wt(Gr);setTimeout(function(){xt(Yr,ze,Gr+1)},Qr)}},Kr.onopen=function(Zr){Gr=0},ae(Yr).webSocket=Kr,Kr.addEventListener("message",function(Zr){if(!yt(Yr)){var Qr=Zr.data;R(Yr,function(si){Qr=si.transformResponse(Qr,null,Yr)});for(var Jr=T(Yr),ei=l(Qr),ti=M(ei.children),ri=0;ri<ti.length;ri++){var ii=ti[ri];Ee(te(ii,"hx-swap-oob")||"true",ii,Jr)}nr(Jr.tasks)}})}}function yt(Yr){if(!se(Yr))return ae(Yr).webSocket.close(),!0}function bt(Yr){var ze=c(Yr,function(Gr){return ae(Gr).webSocket!=null});ze?Yr.addEventListener(it(Yr)[0].trigger,function(Gr){var Wr=ae(ze).webSocket,Kr=xr(Yr,ze),Zr=dr(Yr,"post"),Qr=Zr.errors,Jr=Zr.values,ei=Hr(Yr),ti=le(Jr,ei),ri=yr(ti,Yr);if(ri.HEADERS=Kr,Qr&&Qr.length>0){ce(Yr,"htmx:validation:halted",Qr);return}Wr.send(JSON.stringify(ri)),ut(Gr,Yr)&&Gr.preventDefault()}):fe(Yr,"htmx:noWebSocketSourceError")}function wt(Yr){var ze=Q.config.wsReconnectDelay;if(typeof ze=="function")return ze(Yr);if(ze==="full-jitter"){var Gr=Math.min(Yr,6),Wr=1e3*Math.pow(2,Gr);return Wr*Math.random()}b('htmx.config.wsReconnectDelay must either be a function or the string "full-jitter"')}function St(Yr,ze,Gr){for(var Wr=D(Gr),Kr=0;Kr<Wr.length;Kr++){var Zr=Wr[Kr].split(/:(.+)/);Zr[0]==="connect"&&Et(Yr,Zr[1]),Zr[0]==="swap"&&Ct(Yr,Zr[1])}}function Et(Yr,ze){var Gr=Q.createEventSource(ze);Gr.onerror=function(Wr){fe(Yr,"htmx:sseError",{error:Wr,source:Gr}),Tt(Yr)},ae(Yr).sseEventSource=Gr}function Ct(Yr,ze){var Gr=c(Yr,Ot);if(Gr){var Wr=ae(Gr).sseEventSource,Kr=function(Zr){if(!Tt(Gr)){if(!se(Yr)){Wr.removeEventListener(ze,Kr);return}var Qr=Zr.data;R(Yr,function(ri){Qr=ri.transformResponse(Qr,null,Yr)});var Jr=wr(Yr),ei=ye(Yr),ti=T(Yr);je(Jr.swapStyle,ei,Yr,Qr,ti),nr(ti.tasks),ce(Yr,"htmx:sseMessage",Zr)}};ae(Yr).sseListener=Kr,Wr.addEventListener(ze,Kr)}else fe(Yr,"htmx:noSSESourceError")}function Rt(Yr,ze,Gr){var Wr=c(Yr,Ot);if(Wr){var Kr=ae(Wr).sseEventSource,Zr=function(){Tt(Wr)||(se(Yr)?ze(Yr):Kr.removeEventListener(Gr,Zr))};ae(Yr).sseListener=Zr,Kr.addEventListener(Gr,Zr)}else fe(Yr,"htmx:noSSESourceError")}function Tt(Yr){if(!se(Yr))return ae(Yr).sseEventSource.close(),!0}function Ot(Yr){return ae(Yr).sseEventSource!=null}function qt(Yr,ze,Gr,Wr){var Kr=function(){Gr.loaded||(Gr.loaded=!0,ze(Yr))};Wr>0?setTimeout(Kr,Wr):Kr()}function Ht(Yr,ze,Gr){var Wr=!1;return oe(w,function(Kr){if(o(Yr,"hx-"+Kr)){var Zr=te(Yr,"hx-"+Kr);Wr=!0,ze.path=Zr,ze.verb=Kr,Gr.forEach(function(Qr){Lt(Yr,Qr,ze,function(Jr,ei){if(v(Jr,Q.config.disableSelector)){m(Jr);return}he(Kr,Zr,Jr,ei)})})}}),Wr}function Lt(Yr,ze,Gr,Wr){if(ze.sseEvent)Rt(Yr,Wr,ze.sseEvent);else if(ze.trigger==="revealed")gt(),ht(Yr,Wr,Gr,ze),pt(Yr);else if(ze.trigger==="intersect"){var Kr={};ze.root&&(Kr.root=ue(Yr,ze.root)),ze.threshold&&(Kr.threshold=parseFloat(ze.threshold));var Zr=new IntersectionObserver(function(Qr){for(var Jr=0;Jr<Qr.length;Jr++){var ei=Qr[Jr];if(ei.isIntersecting){ce(Yr,"intersect");break}}},Kr);Zr.observe(Yr),ht(Yr,Wr,Gr,ze)}else ze.trigger==="load"?ct(ze,Yr,Wt("load",{elt:Yr}))||qt(Yr,Wr,Gr,ze.delay):ze.pollInterval>0?(Gr.polling=!0,ot(Yr,Wr,ze)):ht(Yr,Wr,Gr,ze)}function At(Yr){if(!Yr.htmxExecuted&&Q.config.allowScriptTags&&(Yr.type==="text/javascript"||Yr.type==="module"||Yr.type==="")){var ze=re().createElement("script");oe(Yr.attributes,function(Wr){ze.setAttribute(Wr.name,Wr.value)}),ze.textContent=Yr.textContent,ze.async=!1,Q.config.inlineScriptNonce&&(ze.nonce=Q.config.inlineScriptNonce);var Gr=Yr.parentElement;try{Gr.insertBefore(ze,Yr)}catch(Wr){b(Wr)}finally{Yr.parentElement&&Yr.parentElement.removeChild(Yr)}}}function Nt(Yr){h(Yr,"script")&&At(Yr),oe(f(Yr,"script"),function(ze){At(ze)})}function It(Yr){var ze=Yr.attributes;if(!ze)return!1;for(var Gr=0;Gr<ze.length;Gr++){var Wr=ze[Gr].name;if(g(Wr,"hx-on:")||g(Wr,"data-hx-on:")||g(Wr,"hx-on-")||g(Wr,"data-hx-on-"))return!0}return!1}function kt(Yr){var ze=null,Gr=[];if(It(Yr)&&Gr.push(Yr),document.evaluate)for(var Wr=document.evaluate('.//*[@*[ starts-with(name(), "hx-on:") or starts-with(name(), "data-hx-on:") or starts-with(name(), "hx-on-") or starts-with(name(), "data-hx-on-") ]]',Yr);ze=Wr.iterateNext();)Gr.push(ze);else if(typeof Yr.getElementsByTagName=="function")for(var Kr=Yr.getElementsByTagName("*"),Zr=0;Zr<Kr.length;Zr++)It(Kr[Zr])&&Gr.push(Kr[Zr]);return Gr}function Pt(Yr){if(Yr.querySelectorAll){var ze=", [hx-boost] a, [data-hx-boost] a, a[hx-boost], a[data-hx-boost]",Gr=Yr.querySelectorAll(i+ze+", form, [type='submit'], [hx-sse], [data-hx-sse], [hx-ws], [data-hx-ws], [hx-ext], [data-hx-ext], [hx-trigger], [data-hx-trigger], [hx-on], [data-hx-on]");return Gr}else return[]}function Mt(Yr){var ze=v(Yr.target,"button, input[type='submit']"),Gr=Dt(Yr);Gr&&(Gr.lastButtonClicked=ze)}function Xt(Yr){var ze=Dt(Yr);ze&&(ze.lastButtonClicked=null)}function Dt(Yr){var ze=v(Yr.target,"button, input[type='submit']");if(ze){var Gr=p("#"+ee(ze,"form"))||v(ze,"form");if(Gr)return ae(Gr)}}function Ut(Yr){Yr.addEventListener("click",Mt),Yr.addEventListener("focusin",Mt),Yr.addEventListener("focusout",Xt)}function Bt(Yr){for(var ze=Ye(Yr),Gr=0,Wr=0;Wr<ze.length;Wr++){const Kr=ze[Wr];Kr==="{"?Gr++:Kr==="}"&&Gr--}return Gr}function Ft(Yr,ze,Gr){var Wr=ae(Yr);Array.isArray(Wr.onHandlers)||(Wr.onHandlers=[]);var Kr,Zr=function(Qr){return Tr(Yr,function(){Kr||(Kr=new Function("event",Gr)),Kr.call(Yr,Qr)})};Yr.addEventListener(ze,Zr),Wr.onHandlers.push({event:ze,listener:Zr})}function Vt(Yr){var ze=te(Yr,"hx-on");if(ze){for(var Gr={},Wr=ze.split(`
`),Kr=null,Zr=0;Wr.length>0;){var Qr=Wr.shift(),Jr=Qr.match(/^\s*([a-zA-Z:\-\.]+:)(.*)/);Zr===0&&Jr?(Qr.split(":"),Kr=Jr[1].slice(0,-1),Gr[Kr]=Jr[2]):Gr[Kr]+=Qr,Zr+=Bt(Qr)}for(var ei in Gr)Ft(Yr,ei,Gr[ei])}}function jt(Yr){Ae(Yr);for(var ze=0;ze<Yr.attributes.length;ze++){var Gr=Yr.attributes[ze].name,Wr=Yr.attributes[ze].value;if(g(Gr,"hx-on")||g(Gr,"data-hx-on")){var Kr=Gr.indexOf("-on")+3,Zr=Gr.slice(Kr,Kr+1);if(Zr==="-"||Zr===":"){var Qr=Gr.slice(Kr+1);g(Qr,":")?Qr="htmx"+Qr:g(Qr,"-")?Qr="htmx:"+Qr.slice(1):g(Qr,"htmx-")&&(Qr="htmx:"+Qr.slice(5)),Ft(Yr,Qr,Wr)}}}}function _t(Yr){if(v(Yr,Q.config.disableSelector)){m(Yr);return}var ze=ae(Yr);if(ze.initHash!==Le(Yr)){Ne(Yr),ze.initHash=Le(Yr),Vt(Yr),ce(Yr,"htmx:beforeProcessNode"),Yr.value&&(ze.lastValue=Yr.value);var Gr=it(Yr),Wr=Ht(Yr,ze,Gr);Wr||(ne(Yr,"hx-boost")==="true"?lt(Yr,ze,Gr):o(Yr,"hx-trigger")&&Gr.forEach(function(Qr){Lt(Yr,Qr,ze,function(){})})),(Yr.tagName==="FORM"||ee(Yr,"type")==="submit"&&o(Yr,"form"))&&Ut(Yr);var Kr=te(Yr,"hx-sse");Kr&&St(Yr,ze,Kr);var Zr=te(Yr,"hx-ws");Zr&&mt(Yr,ze,Zr),ce(Yr,"htmx:afterProcessNode")}}function zt(Yr){if(Yr=p(Yr),v(Yr,Q.config.disableSelector)){m(Yr);return}_t(Yr),oe(Pt(Yr),function(ze){_t(ze)}),oe(kt(Yr),jt)}function $t(Yr){return Yr.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()}function Wt(Yr,ze){var Gr;return window.CustomEvent&&typeof window.CustomEvent=="function"?Gr=new CustomEvent(Yr,{bubbles:!0,cancelable:!0,detail:ze}):(Gr=re().createEvent("CustomEvent"),Gr.initCustomEvent(Yr,!0,!0,ze)),Gr}function fe(Yr,ze,Gr){ce(Yr,ze,le({error:ze},Gr))}function Gt(Yr){return Yr==="htmx:afterProcessNode"}function R(Yr,ze){oe(Fr(Yr),function(Gr){try{ze(Gr)}catch(Wr){b(Wr)}})}function b(Yr){console.error?console.error(Yr):console.log&&console.log("ERROR: ",Yr)}function ce(Yr,ze,Gr){Yr=p(Yr),Gr==null&&(Gr={}),Gr.elt=Yr;var Wr=Wt(ze,Gr);Q.logger&&!Gt(ze)&&Q.logger(Yr,ze,Gr),Gr.error&&(b(Gr.error),ce(Yr,"htmx:error",{errorInfo:Gr}));var Kr=Yr.dispatchEvent(Wr),Zr=$t(ze);if(Kr&&Zr!==ze){var Qr=Wt(Zr,Wr.detail);Kr=Kr&&Yr.dispatchEvent(Qr)}return R(Yr,function(Jr){Kr=Kr&&Jr.onEvent(ze,Wr)!==!1&&!Wr.defaultPrevented}),Kr}var Jt=location.pathname+location.search;function Zt(){var Yr=re().querySelector("[hx-history-elt],[data-hx-history-elt]");return Yr||re().body}function Kt(Yr,ze,Gr,Wr){if(U()){if(Q.config.historyCacheSize<=0){localStorage.removeItem("htmx-history-cache");return}Yr=B(Yr);for(var Kr=E(localStorage.getItem("htmx-history-cache"))||[],Zr=0;Zr<Kr.length;Zr++)if(Kr[Zr].url===Yr){Kr.splice(Zr,1);break}var Qr={url:Yr,content:ze,title:Gr,scroll:Wr};for(ce(re().body,"htmx:historyItemCreated",{item:Qr,cache:Kr}),Kr.push(Qr);Kr.length>Q.config.historyCacheSize;)Kr.shift();for(;Kr.length>0;)try{localStorage.setItem("htmx-history-cache",JSON.stringify(Kr));break}catch(Jr){fe(re().body,"htmx:historyCacheError",{cause:Jr,cache:Kr}),Kr.shift()}}}function Yt(Yr){if(!U())return null;Yr=B(Yr);for(var ze=E(localStorage.getItem("htmx-history-cache"))||[],Gr=0;Gr<ze.length;Gr++)if(ze[Gr].url===Yr)return ze[Gr];return null}function Qt(Yr){var ze=Q.config.requestClass,Gr=Yr.cloneNode(!0);return oe(f(Gr,"."+ze),function(Wr){n(Wr,ze)}),Gr.innerHTML}function er(){var Yr=Zt(),ze=Jt||location.pathname+location.search,Gr;try{Gr=re().querySelector('[hx-history="false" i],[data-hx-history="false" i]')}catch{Gr=re().querySelector('[hx-history="false"],[data-hx-history="false"]')}Gr||(ce(re().body,"htmx:beforeHistorySave",{path:ze,historyElt:Yr}),Kt(ze,Qt(Yr),re().title,window.scrollY)),Q.config.historyEnabled&&history.replaceState({htmx:!0},re().title,window.location.href)}function tr(Yr){Q.config.getCacheBusterParam&&(Yr=Yr.replace(/org\.htmx\.cache-buster=[^&]*&?/,""),(G(Yr,"&")||G(Yr,"?"))&&(Yr=Yr.slice(0,-1))),Q.config.historyEnabled&&history.pushState({htmx:!0},"",Yr),Jt=Yr}function rr(Yr){Q.config.historyEnabled&&history.replaceState({htmx:!0},"",Yr),Jt=Yr}function nr(Yr){oe(Yr,function(ze){ze.call()})}function ir(Yr){var ze=new XMLHttpRequest,Gr={path:Yr,xhr:ze};ce(re().body,"htmx:historyCacheMiss",Gr),ze.open("GET",Yr,!0),ze.setRequestHeader("HX-Request","true"),ze.setRequestHeader("HX-History-Restore-Request","true"),ze.setRequestHeader("HX-Current-URL",re().location.href),ze.onload=function(){if(this.status>=200&&this.status<400){ce(re().body,"htmx:historyCacheMissLoad",Gr);var Wr=l(this.response);Wr=Wr.querySelector("[hx-history-elt],[data-hx-history-elt]")||Wr;var Kr=Zt(),Zr=T(Kr),Qr=Ve(this.response);if(Qr){var Jr=C("title");Jr?Jr.innerHTML=Qr:window.document.title=Qr}Ue(Kr,Wr,Zr),nr(Zr.tasks),Jt=Yr,ce(re().body,"htmx:historyRestore",{path:Yr,cacheMiss:!0,serverResponse:this.response})}else fe(re().body,"htmx:historyCacheMissLoadError",Gr)},ze.send()}function ar(Yr){er(),Yr=Yr||location.pathname+location.search;var ze=Yt(Yr);if(ze){var Gr=l(ze.content),Wr=Zt(),Kr=T(Wr);Ue(Wr,Gr,Kr),nr(Kr.tasks),document.title=ze.title,setTimeout(function(){window.scrollTo(0,ze.scroll)},0),Jt=Yr,ce(re().body,"htmx:historyRestore",{path:Yr,item:ze})}else Q.config.refreshOnHistoryMiss?window.location.reload(!0):ir(Yr)}function or(Yr){var ze=me(Yr,"hx-indicator");return ze==null&&(ze=[Yr]),oe(ze,function(Gr){var Wr=ae(Gr);Wr.requestCount=(Wr.requestCount||0)+1,Gr.classList.add.call(Gr.classList,Q.config.requestClass)}),ze}function sr(Yr){var ze=me(Yr,"hx-disabled-elt");return ze==null&&(ze=[]),oe(ze,function(Gr){var Wr=ae(Gr);Wr.requestCount=(Wr.requestCount||0)+1,Gr.setAttribute("disabled","")}),ze}function lr(Yr,ze){oe(Yr,function(Gr){var Wr=ae(Gr);Wr.requestCount=(Wr.requestCount||0)-1,Wr.requestCount===0&&Gr.classList.remove.call(Gr.classList,Q.config.requestClass)}),oe(ze,function(Gr){var Wr=ae(Gr);Wr.requestCount=(Wr.requestCount||0)-1,Wr.requestCount===0&&Gr.removeAttribute("disabled")})}function ur(Yr,ze){for(var Gr=0;Gr<Yr.length;Gr++){var Wr=Yr[Gr];if(Wr.isSameNode(ze))return!0}return!1}function fr(Yr){return Yr.name===""||Yr.name==null||Yr.disabled||v(Yr,"fieldset[disabled]")||Yr.type==="button"||Yr.type==="submit"||Yr.tagName==="image"||Yr.tagName==="reset"||Yr.tagName==="file"?!1:Yr.type==="checkbox"||Yr.type==="radio"?Yr.checked:!0}function cr(Yr,ze,Gr){if(Yr!=null&&ze!=null){var Wr=Gr[Yr];Wr===void 0?Gr[Yr]=ze:Array.isArray(Wr)?Array.isArray(ze)?Gr[Yr]=Wr.concat(ze):Wr.push(ze):Array.isArray(ze)?Gr[Yr]=[Wr].concat(ze):Gr[Yr]=[Wr,ze]}}function hr(Yr,ze,Gr,Wr,Kr){if(!(Wr==null||ur(Yr,Wr))){if(Yr.push(Wr),fr(Wr)){var Zr=ee(Wr,"name"),Qr=Wr.value;Wr.multiple&&Wr.tagName==="SELECT"&&(Qr=M(Wr.querySelectorAll("option:checked")).map(function(ei){return ei.value})),Wr.files&&(Qr=M(Wr.files)),cr(Zr,Qr,ze),Kr&&vr(Wr,Gr)}if(h(Wr,"form")){var Jr=Wr.elements;oe(Jr,function(ei){hr(Yr,ze,Gr,ei,Kr)})}}}function vr(Yr,ze){Yr.willValidate&&(ce(Yr,"htmx:validation:validate"),Yr.checkValidity()||(ze.push({elt:Yr,message:Yr.validationMessage,validity:Yr.validity}),ce(Yr,"htmx:validation:failed",{message:Yr.validationMessage,validity:Yr.validity})))}function dr(Yr,ze){var Gr=[],Wr={},Kr={},Zr=[],Qr=ae(Yr);Qr.lastButtonClicked&&!se(Qr.lastButtonClicked)&&(Qr.lastButtonClicked=null);var Jr=h(Yr,"form")&&Yr.noValidate!==!0||te(Yr,"hx-validate")==="true";if(Qr.lastButtonClicked&&(Jr=Jr&&Qr.lastButtonClicked.formNoValidate!==!0),ze!=="get"&&hr(Gr,Kr,Zr,v(Yr,"form"),Jr),hr(Gr,Wr,Zr,Yr,Jr),Qr.lastButtonClicked||Yr.tagName==="BUTTON"||Yr.tagName==="INPUT"&&ee(Yr,"type")==="submit"){var ei=Qr.lastButtonClicked||Yr,ti=ee(ei,"name");cr(ti,ei.value,Kr)}var ri=me(Yr,"hx-include");return oe(ri,function(ii){hr(Gr,Wr,Zr,ii,Jr),h(ii,"form")||oe(ii.querySelectorAll(rt),function(si){hr(Gr,Wr,Zr,si,Jr)})}),Wr=le(Wr,Kr),{errors:Zr,values:Wr}}function gr(Yr,ze,Gr){Yr!==""&&(Yr+="&"),String(Gr)==="[object Object]"&&(Gr=JSON.stringify(Gr));var Wr=encodeURIComponent(Gr);return Yr+=encodeURIComponent(ze)+"="+Wr,Yr}function pr(Yr){var ze="";for(var Gr in Yr)if(Yr.hasOwnProperty(Gr)){var Wr=Yr[Gr];Array.isArray(Wr)?oe(Wr,function(Kr){ze=gr(ze,Gr,Kr)}):ze=gr(ze,Gr,Wr)}return ze}function mr(Yr){var ze=new FormData;for(var Gr in Yr)if(Yr.hasOwnProperty(Gr)){var Wr=Yr[Gr];Array.isArray(Wr)?oe(Wr,function(Kr){ze.append(Gr,Kr)}):ze.append(Gr,Wr)}return ze}function xr(Yr,ze,Gr){var Wr={"HX-Request":"true","HX-Trigger":ee(Yr,"id"),"HX-Trigger-Name":ee(Yr,"name"),"HX-Target":te(ze,"id"),"HX-Current-URL":re().location.href};return Rr(Yr,"hx-headers",!1,Wr),Gr!==void 0&&(Wr["HX-Prompt"]=Gr),ae(Yr).boosted&&(Wr["HX-Boosted"]="true"),Wr}function yr(Yr,ze){var Gr=ne(ze,"hx-params");if(Gr){if(Gr==="none")return{};if(Gr==="*")return Yr;if(Gr.indexOf("not ")===0)return oe(Gr.substr(4).split(","),function(Kr){Kr=Kr.trim(),delete Yr[Kr]}),Yr;var Wr={};return oe(Gr.split(","),function(Kr){Kr=Kr.trim(),Wr[Kr]=Yr[Kr]}),Wr}else return Yr}function br(Yr){return ee(Yr,"href")&&ee(Yr,"href").indexOf("#")>=0}function wr(Yr,ze){var Gr=ze||ne(Yr,"hx-swap"),Wr={swapStyle:ae(Yr).boosted?"innerHTML":Q.config.defaultSwapStyle,swapDelay:Q.config.defaultSwapDelay,settleDelay:Q.config.defaultSettleDelay};if(Q.config.scrollIntoViewOnBoost&&ae(Yr).boosted&&!br(Yr)&&(Wr.show="top"),Gr){var Kr=D(Gr);if(Kr.length>0)for(var Zr=0;Zr<Kr.length;Zr++){var Qr=Kr[Zr];if(Qr.indexOf("swap:")===0)Wr.swapDelay=d(Qr.substr(5));else if(Qr.indexOf("settle:")===0)Wr.settleDelay=d(Qr.substr(7));else if(Qr.indexOf("transition:")===0)Wr.transition=Qr.substr(11)==="true";else if(Qr.indexOf("ignoreTitle:")===0)Wr.ignoreTitle=Qr.substr(12)==="true";else if(Qr.indexOf("scroll:")===0){var Jr=Qr.substr(7),ei=Jr.split(":"),ti=ei.pop(),ri=ei.length>0?ei.join(":"):null;Wr.scroll=ti,Wr.scrollTarget=ri}else if(Qr.indexOf("show:")===0){var ii=Qr.substr(5),ei=ii.split(":"),si=ei.pop(),ri=ei.length>0?ei.join(":"):null;Wr.show=si,Wr.showTarget=ri}else if(Qr.indexOf("focus-scroll:")===0){var ni=Qr.substr(13);Wr.focusScroll=ni=="true"}else Zr==0?Wr.swapStyle=Qr:b("Unknown modifier in hx-swap: "+Qr)}}return Wr}function Sr(Yr){return ne(Yr,"hx-encoding")==="multipart/form-data"||h(Yr,"form")&&ee(Yr,"enctype")==="multipart/form-data"}function Er(Yr,ze,Gr){var Wr=null;return R(ze,function(Kr){Wr==null&&(Wr=Kr.encodeParameters(Yr,Gr,ze))}),Wr??(Sr(ze)?mr(Gr):pr(Gr))}function T(Yr){return{tasks:[],elts:[Yr]}}function Cr(Yr,ze){var Gr=Yr[0],Wr=Yr[Yr.length-1];if(ze.scroll){var Kr=null;ze.scrollTarget&&(Kr=ue(Gr,ze.scrollTarget)),ze.scroll==="top"&&(Gr||Kr)&&(Kr=Kr||Gr,Kr.scrollTop=0),ze.scroll==="bottom"&&(Wr||Kr)&&(Kr=Kr||Wr,Kr.scrollTop=Kr.scrollHeight)}if(ze.show){var Kr=null;if(ze.showTarget){var Zr=ze.showTarget;ze.showTarget==="window"&&(Zr="body"),Kr=ue(Gr,Zr)}ze.show==="top"&&(Gr||Kr)&&(Kr=Kr||Gr,Kr.scrollIntoView({block:"start",behavior:Q.config.scrollBehavior})),ze.show==="bottom"&&(Wr||Kr)&&(Kr=Kr||Wr,Kr.scrollIntoView({block:"end",behavior:Q.config.scrollBehavior}))}}function Rr(Yr,ze,Gr,Wr){if(Wr==null&&(Wr={}),Yr==null)return Wr;var Kr=te(Yr,ze);if(Kr){var Zr=Kr.trim(),Qr=Gr;if(Zr==="unset")return null;Zr.indexOf("javascript:")===0?(Zr=Zr.substr(11),Qr=!0):Zr.indexOf("js:")===0&&(Zr=Zr.substr(3),Qr=!0),Zr.indexOf("{")!==0&&(Zr="{"+Zr+"}");var Jr;Qr?Jr=Tr(Yr,function(){return Function("return ("+Zr+")")()},{}):Jr=E(Zr);for(var ei in Jr)Jr.hasOwnProperty(ei)&&Wr[ei]==null&&(Wr[ei]=Jr[ei])}return Rr(u(Yr),ze,Gr,Wr)}function Tr(Yr,ze,Gr){return Q.config.allowEval?ze():(fe(Yr,"htmx:evalDisallowedError"),Gr)}function Or(Yr,ze){return Rr(Yr,"hx-vars",!0,ze)}function qr(Yr,ze){return Rr(Yr,"hx-vals",!1,ze)}function Hr(Yr){return le(Or(Yr),qr(Yr))}function Lr(Yr,ze,Gr){if(Gr!==null)try{Yr.setRequestHeader(ze,Gr)}catch{Yr.setRequestHeader(ze,encodeURIComponent(Gr)),Yr.setRequestHeader(ze+"-URI-AutoEncoded","true")}}function Ar(Yr){if(Yr.responseURL&&typeof URL<"u")try{var ze=new URL(Yr.responseURL);return ze.pathname+ze.search}catch{fe(re().body,"htmx:badResponseUrl",{url:Yr.responseURL})}}function O(Yr,ze){return ze.test(Yr.getAllResponseHeaders())}function Nr(Yr,ze,Gr){return Yr=Yr.toLowerCase(),Gr?Gr instanceof Element||I(Gr,"String")?he(Yr,ze,null,null,{targetOverride:p(Gr),returnPromise:!0}):he(Yr,ze,p(Gr.source),Gr.event,{handler:Gr.handler,headers:Gr.headers,values:Gr.values,targetOverride:p(Gr.target),swapOverride:Gr.swap,select:Gr.select,returnPromise:!0}):he(Yr,ze,null,null,{returnPromise:!0})}function Ir(Yr){for(var ze=[];Yr;)ze.push(Yr),Yr=Yr.parentElement;return ze}function kr(Yr,ze,Gr){var Wr,Kr;if(typeof URL=="function"){Kr=new URL(ze,document.location.href);var Zr=document.location.origin;Wr=Zr===Kr.origin}else Kr=ze,Wr=g(ze,document.location.origin);return Q.config.selfRequestsOnly&&!Wr?!1:ce(Yr,"htmx:validateUrl",le({url:Kr,sameHost:Wr},Gr))}function he(Yr,ze,Gr,Wr,Kr,Zr){var Qr=null,Jr=null;if(Kr=Kr??{},Kr.returnPromise&&typeof Promise<"u")var ei=new Promise(function(ji,qi){Qr=ji,Jr=qi});Gr==null&&(Gr=re().body);var ti=Kr.handler||Mr,ri=Kr.select||null;if(!se(Gr))return ie(Qr),ei;var ii=Kr.targetOverride||ye(Gr);if(ii==null||ii==pe)return fe(Gr,"htmx:targetError",{target:te(Gr,"hx-target")}),ie(Jr),ei;var si=ae(Gr),ni=si.lastButtonClicked;if(ni){var oi=ee(ni,"formaction");oi!=null&&(ze=oi);var li=ee(ni,"formmethod");li!=null&&li.toLowerCase()!=="dialog"&&(Yr=li)}var ai=ne(Gr,"hx-confirm");if(Zr===void 0){var hi=function(ji){return he(Yr,ze,Gr,Wr,Kr,!!ji)},fi={target:ii,elt:Gr,path:ze,verb:Yr,triggeringEvent:Wr,etc:Kr,issueRequest:hi,question:ai};if(ce(Gr,"htmx:confirm",fi)===!1)return ie(Qr),ei}var pi=Gr,mi=ne(Gr,"hx-sync"),Ti=null,yi=!1;if(mi){var _i=mi.split(":"),Ai=_i[0].trim();if(Ai==="this"?pi=xe(Gr,"hx-sync"):pi=ue(Gr,Ai),mi=(_i[1]||"drop").trim(),si=ae(pi),mi==="drop"&&si.xhr&&si.abortable!==!0)return ie(Qr),ei;if(mi==="abort"){if(si.xhr)return ie(Qr),ei;yi=!0}else if(mi==="replace")ce(pi,"htmx:abort");else if(mi.indexOf("queue")===0){var Ri=mi.split(" ");Ti=(Ri[1]||"last").trim()}}if(si.xhr)if(si.abortable)ce(pi,"htmx:abort");else{if(Ti==null){if(Wr){var Pi=ae(Wr);Pi&&Pi.triggerSpec&&Pi.triggerSpec.queue&&(Ti=Pi.triggerSpec.queue)}Ti==null&&(Ti="last")}return si.queuedRequests==null&&(si.queuedRequests=[]),Ti==="first"&&si.queuedRequests.length===0?si.queuedRequests.push(function(){he(Yr,ze,Gr,Wr,Kr)}):Ti==="all"?si.queuedRequests.push(function(){he(Yr,ze,Gr,Wr,Kr)}):Ti==="last"&&(si.queuedRequests=[],si.queuedRequests.push(function(){he(Yr,ze,Gr,Wr,Kr)})),ie(Qr),ei}var Si=new XMLHttpRequest;si.xhr=Si,si.abortable=yi;var Bi=function(){if(si.xhr=null,si.abortable=!1,si.queuedRequests!=null&&si.queuedRequests.length>0){var ji=si.queuedRequests.shift();ji()}},ki=ne(Gr,"hx-prompt");if(ki){var Wi=prompt(ki);if(Wi===null||!ce(Gr,"htmx:prompt",{prompt:Wi,target:ii}))return ie(Qr),Bi(),ei}if(ai&&!Zr&&!confirm(ai))return ie(Qr),Bi(),ei;var Li=xr(Gr,ii,Wi);Yr!=="get"&&!Sr(Gr)&&(Li["Content-Type"]="application/x-www-form-urlencoded"),Kr.headers&&(Li=le(Li,Kr.headers));var ci=dr(Gr,Yr),ui=ci.errors,di=ci.values;Kr.values&&(di=le(di,Kr.values));var gi=Hr(Gr),xi=le(di,gi),bi=yr(xi,Gr);Q.config.getCacheBusterParam&&Yr==="get"&&(bi["org.htmx.cache-buster"]=ee(ii,"id")||"true"),(ze==null||ze==="")&&(ze=re().location.href);var vi=Rr(Gr,"hx-request"),Ei=ae(Gr).boosted,Ii=Q.config.methodsThatUseUrlParams.indexOf(Yr)>=0,wi={boosted:Ei,useUrlParams:Ii,parameters:bi,unfilteredParameters:xi,headers:Li,target:ii,verb:Yr,errors:ui,withCredentials:Kr.credentials||vi.credentials||Q.config.withCredentials,timeout:Kr.timeout||vi.timeout||Q.config.timeout,path:ze,triggeringEvent:Wr};if(!ce(Gr,"htmx:configRequest",wi))return ie(Qr),Bi(),ei;if(ze=wi.path,Yr=wi.verb,Li=wi.headers,bi=wi.parameters,ui=wi.errors,Ii=wi.useUrlParams,ui&&ui.length>0)return ce(Gr,"htmx:validation:halted",wi),ie(Qr),Bi(),ei;var Di=ze.split("#"),Ni=Di[0],Fi=Di[1],Hi=ze;if(Ii){Hi=Ni;var Oi=Object.keys(bi).length!==0;Oi&&(Hi.indexOf("?")<0?Hi+="?":Hi+="&",Hi+=pr(bi),Fi&&(Hi+="#"+Fi))}if(!kr(Gr,Hi,wi))return fe(Gr,"htmx:invalidPath",wi),ie(Jr),ei;if(Si.open(Yr.toUpperCase(),Hi,!0),Si.overrideMimeType("text/html"),Si.withCredentials=wi.withCredentials,Si.timeout=wi.timeout,!vi.noHeaders){for(var Xi in Li)if(Li.hasOwnProperty(Xi)){var Vi=Li[Xi];Lr(Si,Xi,Vi)}}var zi={xhr:Si,target:ii,requestConfig:wi,etc:Kr,boosted:Ei,select:ri,pathInfo:{requestPath:ze,finalRequestPath:Hi,anchor:Fi}};if(Si.onload=function(){try{var ji=Ir(Gr);if(zi.pathInfo.responsePath=Ar(Si),ti(Gr,zi),lr($i,Gi),ce(Gr,"htmx:afterRequest",zi),ce(Gr,"htmx:afterOnLoad",zi),!se(Gr)){for(var qi=null;ji.length>0&&qi==null;){var Zi=ji.shift();se(Zi)&&(qi=Zi)}qi&&(ce(qi,"htmx:afterRequest",zi),ce(qi,"htmx:afterOnLoad",zi))}ie(Qr),Bi()}catch(gs){throw fe(Gr,"htmx:onLoadError",le({error:gs},zi)),gs}},Si.onerror=function(){lr($i,Gi),fe(Gr,"htmx:afterRequest",zi),fe(Gr,"htmx:sendError",zi),ie(Jr),Bi()},Si.onabort=function(){lr($i,Gi),fe(Gr,"htmx:afterRequest",zi),fe(Gr,"htmx:sendAbort",zi),ie(Jr),Bi()},Si.ontimeout=function(){lr($i,Gi),fe(Gr,"htmx:afterRequest",zi),fe(Gr,"htmx:timeout",zi),ie(Jr),Bi()},!ce(Gr,"htmx:beforeRequest",zi))return ie(Qr),Bi(),ei;var $i=or(Gr),Gi=sr(Gr);oe(["loadstart","loadend","progress","abort"],function(ji){oe([Si,Si.upload],function(qi){qi.addEventListener(ji,function(Zi){ce(Gr,"htmx:xhr:"+ji,{lengthComputable:Zi.lengthComputable,loaded:Zi.loaded,total:Zi.total})})})}),ce(Gr,"htmx:beforeSend",zi);var Ui=Ii?null:Er(Si,Gr,bi);return Si.send(Ui),ei}function Pr(Yr,ze){var Gr=ze.xhr,Wr=null,Kr=null;if(O(Gr,/HX-Push:/i)?(Wr=Gr.getResponseHeader("HX-Push"),Kr="push"):O(Gr,/HX-Push-Url:/i)?(Wr=Gr.getResponseHeader("HX-Push-Url"),Kr="push"):O(Gr,/HX-Replace-Url:/i)&&(Wr=Gr.getResponseHeader("HX-Replace-Url"),Kr="replace"),Wr)return Wr==="false"?{}:{type:Kr,path:Wr};var Zr=ze.pathInfo.finalRequestPath,Qr=ze.pathInfo.responsePath,Jr=ne(Yr,"hx-push-url"),ei=ne(Yr,"hx-replace-url"),ti=ae(Yr).boosted,ri=null,ii=null;return Jr?(ri="push",ii=Jr):ei?(ri="replace",ii=ei):ti&&(ri="push",ii=Qr||Zr),ii?ii==="false"?{}:(ii==="true"&&(ii=Qr||Zr),ze.pathInfo.anchor&&ii.indexOf("#")===-1&&(ii=ii+"#"+ze.pathInfo.anchor),{type:ri,path:ii}):{}}function Mr(Yr,ze){var Gr=ze.xhr,Wr=ze.target,Kr=ze.etc;ze.requestConfig;var Zr=ze.select;if(ce(Yr,"htmx:beforeOnLoad",ze)){if(O(Gr,/HX-Trigger:/i)&&_e(Gr,"HX-Trigger",Yr),O(Gr,/HX-Location:/i)){er();var Qr=Gr.getResponseHeader("HX-Location"),Jr;Qr.indexOf("{")===0&&(Jr=E(Qr),Qr=Jr.path,delete Jr.path),Nr("GET",Qr,Jr).then(function(){tr(Qr)});return}var ei=O(Gr,/HX-Refresh:/i)&&Gr.getResponseHeader("HX-Refresh")==="true";if(O(Gr,/HX-Redirect:/i)){location.href=Gr.getResponseHeader("HX-Redirect"),ei&&location.reload();return}if(ei){location.reload();return}O(Gr,/HX-Retarget:/i)&&(Gr.getResponseHeader("HX-Retarget")==="this"?ze.target=Yr:ze.target=ue(Yr,Gr.getResponseHeader("HX-Retarget")));var ti=Pr(Yr,ze),ri=Gr.status>=200&&Gr.status<400&&Gr.status!==204,ii=Gr.response,si=Gr.status>=400,ni=Q.config.ignoreTitle,oi=le({shouldSwap:ri,serverResponse:ii,isError:si,ignoreTitle:ni},ze);if(ce(Wr,"htmx:beforeSwap",oi)){if(Wr=oi.target,ii=oi.serverResponse,si=oi.isError,ni=oi.ignoreTitle,ze.target=Wr,ze.failed=si,ze.successful=!si,oi.shouldSwap){Gr.status===286&&at(Yr),R(Yr,function(_i){ii=_i.transformResponse(ii,Gr,Yr)}),ti.type&&er();var li=Kr.swapOverride;O(Gr,/HX-Reswap:/i)&&(li=Gr.getResponseHeader("HX-Reswap"));var Jr=wr(Yr,li);Jr.hasOwnProperty("ignoreTitle")&&(ni=Jr.ignoreTitle),Wr.classList.add(Q.config.swappingClass);var ai=null,hi=null,fi=function(){try{var _i=document.activeElement,Ai={};try{Ai={elt:_i,start:_i?_i.selectionStart:null,end:_i?_i.selectionEnd:null}}catch{}var Ri;Zr&&(Ri=Zr),O(Gr,/HX-Reselect:/i)&&(Ri=Gr.getResponseHeader("HX-Reselect")),ti.type&&(ce(re().body,"htmx:beforeHistoryUpdate",le({history:ti},ze)),ti.type==="push"?(tr(ti.path),ce(re().body,"htmx:pushedIntoHistory",{path:ti.path})):(rr(ti.path),ce(re().body,"htmx:replacedInHistory",{path:ti.path})));var Pi=T(Wr);if(je(Jr.swapStyle,Wr,Yr,ii,Pi,Ri),Ai.elt&&!se(Ai.elt)&&ee(Ai.elt,"id")){var Si=document.getElementById(ee(Ai.elt,"id")),Bi={preventScroll:Jr.focusScroll!==void 0?!Jr.focusScroll:!Q.config.defaultFocusScroll};if(Si){if(Ai.start&&Si.setSelectionRange)try{Si.setSelectionRange(Ai.start,Ai.end)}catch{}Si.focus(Bi)}}if(Wr.classList.remove(Q.config.swappingClass),oe(Pi.elts,function(Li){Li.classList&&Li.classList.add(Q.config.settlingClass),ce(Li,"htmx:afterSwap",ze)}),O(Gr,/HX-Trigger-After-Swap:/i)){var ki=Yr;se(Yr)||(ki=re().body),_e(Gr,"HX-Trigger-After-Swap",ki)}var Wi=function(){if(oe(Pi.tasks,function(di){di.call()}),oe(Pi.elts,function(di){di.classList&&di.classList.remove(Q.config.settlingClass),ce(di,"htmx:afterSettle",ze)}),ze.pathInfo.anchor){var Li=re().getElementById(ze.pathInfo.anchor);Li&&Li.scrollIntoView({block:"start",behavior:"auto"})}if(Pi.title&&!ni){var ci=C("title");ci?ci.innerHTML=Pi.title:window.document.title=Pi.title}if(Cr(Pi.elts,Jr),O(Gr,/HX-Trigger-After-Settle:/i)){var ui=Yr;se(Yr)||(ui=re().body),_e(Gr,"HX-Trigger-After-Settle",ui)}ie(ai)};Jr.settleDelay>0?setTimeout(Wi,Jr.settleDelay):Wi()}catch(Li){throw fe(Yr,"htmx:swapError",ze),ie(hi),Li}},pi=Q.config.globalViewTransitions;if(Jr.hasOwnProperty("transition")&&(pi=Jr.transition),pi&&ce(Yr,"htmx:beforeTransition",ze)&&typeof Promise<"u"&&document.startViewTransition){var mi=new Promise(function(_i,Ai){ai=_i,hi=Ai}),Ti=fi;fi=function(){document.startViewTransition(function(){return Ti(),mi})}}Jr.swapDelay>0?setTimeout(fi,Jr.swapDelay):fi()}si&&fe(Yr,"htmx:responseError",le({error:"Response Status Error Code "+Gr.status+" from "+ze.pathInfo.requestPath},ze))}}}var Xr={};function Dr(){return{init:function(Yr){return null},onEvent:function(Yr,ze){return!0},transformResponse:function(Yr,ze,Gr){return Yr},isInlineSwap:function(Yr){return!1},handleSwap:function(Yr,ze,Gr,Wr){return!1},encodeParameters:function(Yr,ze,Gr){return null}}}function Ur(Yr,ze){ze.init&&ze.init(r),Xr[Yr]=le(Dr(),ze)}function Br(Yr){delete Xr[Yr]}function Fr(Yr,ze,Gr){if(Yr==null)return ze;ze==null&&(ze=[]),Gr==null&&(Gr=[]);var Wr=te(Yr,"hx-ext");return Wr&&oe(Wr.split(","),function(Kr){if(Kr=Kr.replace(/ /g,""),Kr.slice(0,7)=="ignore:"){Gr.push(Kr.slice(7));return}if(Gr.indexOf(Kr)<0){var Zr=Xr[Kr];Zr&&ze.indexOf(Zr)<0&&ze.push(Zr)}}),Fr(u(Yr),ze,Gr)}var Vr=!1;re().addEventListener("DOMContentLoaded",function(){Vr=!0});function jr(Yr){Vr||re().readyState==="complete"?Yr():re().addEventListener("DOMContentLoaded",Yr)}function _r(){Q.config.includeIndicatorStyles!==!1&&re().head.insertAdjacentHTML("beforeend","<style>                      ."+Q.config.indicatorClass+"{opacity:0}                      ."+Q.config.requestClass+" ."+Q.config.indicatorClass+"{opacity:1; transition: opacity 200ms ease-in;}                      ."+Q.config.requestClass+"."+Q.config.indicatorClass+"{opacity:1; transition: opacity 200ms ease-in;}                    </style>")}function zr(){var Yr=re().querySelector('meta[name="htmx-config"]');return Yr?E(Yr.content):null}function $r(){var Yr=zr();Yr&&(Q.config=le(Q.config,Yr))}return jr(function(){$r(),_r();var Yr=re().body;zt(Yr);var ze=re().querySelectorAll("[hx-trigger='restored'],[data-hx-trigger='restored']");Yr.addEventListener("htmx:abort",function(Wr){var Kr=Wr.target,Zr=ae(Kr);Zr&&Zr.xhr&&Zr.xhr.abort()});const Gr=window.onpopstate?window.onpopstate.bind(window):null;window.onpopstate=function(Wr){Wr.state&&Wr.state.htmx?(ar(),oe(ze,function(Kr){ce(Kr,"htmx:restored",{document:re(),triggerEvent:ce})})):Gr&&Gr(Wr)},setTimeout(function(){ce(Yr,"htmx:load",{}),Yr=null},0)}),Q}()})}(htmx_min$3)),htmx_min$3.exports}var htmx_minExports=requireHtmx_min();const htmx_min=getDefaultExportFromCjs(htmx_minExports),htmx_min$1=_mergeNamespaces({__proto__:null,default:htmx_min},[htmx_minExports]);
