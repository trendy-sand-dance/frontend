var _c = Object.defineProperty; var xc = (s, e, t) => e in s ? _c(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t; var Me = (s, e, t) => xc(s, typeof e != "symbol" ? e + "" : e, t); (function() { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const n of i) if (n.type === "childList") for (const a of n.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a) }).observe(document, { childList: !0, subtree: !0 }); function t(i) { const n = {}; return i.integrity && (n.integrity = i.integrity), i.referrerPolicy && (n.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? n.credentials = "include" : i.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin", n } function r(i) { if (i.ep) return; i.ep = !0; const n = t(i); fetch(i.href, n) } })(); const yc = "modulepreload", bc = function(s) { return "/" + s }, cn = {}, Fr = function(e, t, r) { let i = Promise.resolve(); if (t && t.length > 0) { document.getElementsByTagName("link"); const a = document.querySelector("meta[property=csp-nonce]"), o = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce")); i = Promise.allSettled(t.map(h => { if (h = bc(h), h in cn) return; cn[h] = !0; const l = h.endsWith(".css"), c = l ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${h}"]${c}`)) return; const u = document.createElement("link"); if (u.rel = l ? "stylesheet" : yc, l || (u.as = "script"), u.crossOrigin = "", u.href = h, o && u.setAttribute("nonce", o), document.head.appendChild(u), l) return new Promise((d, f) => { u.addEventListener("load", d), u.addEventListener("error", () => f(new Error(`Unable to preload CSS for ${h}`))) }) })) } function n(a) { const o = new Event("vite:preloadError", { cancelable: !0 }); if (o.payload = a, window.dispatchEvent(o), !o.defaultPrevented) throw a } return i.then(a => { for (const o of a || []) o.status === "rejected" && n(o.reason); return e().catch(n) }) }; var b = (s => (s.Application = "application", s.WebGLPipes = "webgl-pipes", s.WebGLPipesAdaptor = "webgl-pipes-adaptor", s.WebGLSystem = "webgl-system", s.WebGPUPipes = "webgpu-pipes", s.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", s.WebGPUSystem = "webgpu-system", s.CanvasSystem = "canvas-system", s.CanvasPipesAdaptor = "canvas-pipes-adaptor", s.CanvasPipes = "canvas-pipes", s.Asset = "asset", s.LoadParser = "load-parser", s.ResolveParser = "resolve-parser", s.CacheParser = "cache-parser", s.DetectionParser = "detection-parser", s.MaskEffect = "mask-effect", s.BlendMode = "blend-mode", s.TextureSource = "texture-source", s.Environment = "environment", s.ShapeBuilder = "shape-builder", s.Batcher = "batcher", s))(b || {}); const Ns = s => { if (typeof s == "function" || typeof s == "object" && s.extension) { if (!s.extension) throw new Error("Extension class must have an extension object"); s = { ...typeof s.extension != "object" ? { type: s.extension } : s.extension, ref: s } } if (typeof s == "object") s = { ...s }; else throw new Error("Invalid extension type"); return typeof s.type == "string" && (s.type = [s.type]), s }, cr = (s, e) => Ns(s).priority ?? e, z = { _addHandlers: {}, _removeHandlers: {}, _queue: {}, remove(...s) { return s.map(Ns).forEach(e => { e.type.forEach(t => { var r, i; return (i = (r = this._removeHandlers)[t]) == null ? void 0 : i.call(r, e) }) }), this }, add(...s) { return s.map(Ns).forEach(e => { e.type.forEach(t => { var n, a; const r = this._addHandlers, i = this._queue; r[t] ? (a = r[t]) == null || a.call(r, e) : (i[t] = i[t] || [], (n = i[t]) == null || n.push(e)) }) }), this }, handle(s, e, t) { var a; const r = this._addHandlers, i = this._removeHandlers; if (r[s] || i[s]) throw new Error(`Extension type ${s} already has a handler`); r[s] = e, i[s] = t; const n = this._queue; return n[s] && ((a = n[s]) == null || a.forEach(o => e(o)), delete n[s]), this }, handleByMap(s, e) { return this.handle(s, t => { t.name && (e[t.name] = t.ref) }, t => { t.name && delete e[t.name] }) }, handleByNamedList(s, e, t = -1) { return this.handle(s, r => { e.findIndex(n => n.name === r.name) >= 0 || (e.push({ name: r.name, value: r.ref }), e.sort((n, a) => cr(a.value, t) - cr(n.value, t))) }, r => { const i = e.findIndex(n => n.name === r.name); i !== -1 && e.splice(i, 1) }) }, handleByList(s, e, t = -1) { return this.handle(s, r => { e.includes(r.ref) || (e.push(r.ref), e.sort((i, n) => cr(n, t) - cr(i, t))) }, r => { const i = e.indexOf(r.ref); i !== -1 && e.splice(i, 1) }) }, mixin(s, ...e) { for (const t of e) Object.defineProperties(s.prototype, Object.getOwnPropertyDescriptors(t)) } }, vc = { extension: { type: b.Environment, name: "browser", priority: -1 }, test: () => !0, load: async () => { await Fr(() => Promise.resolve().then(() => S_), void 0) } }, Tc = { extension: { type: b.Environment, name: "webworker", priority: 0 }, test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0, load: async () => { await Fr(() => Promise.resolve().then(() => w_), void 0) } }; class me { constructor(e, t, r) { this._x = t || 0, this._y = r || 0, this._observer = e } clone(e) { return new me(e ?? this._observer, this._x, this._y) } set(e = 0, t = e) { return (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this._observer._onUpdate(this)), this } copyFrom(e) { return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this } copyTo(e) { return e.set(this._x, this._y), e } equals(e) { return e.x === this._x && e.y === this._y } toString() { return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]` } get x() { return this._x } set x(e) { this._x !== e && (this._x = e, this._observer._onUpdate(this)) } get y() { return this._y } set y(e) { this._y !== e && (this._y = e, this._observer._onUpdate(this)) } } function pi(s) { return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s } var Qr = { exports: {} }, un; function Sc() { return un || (un = 1, function(s) { var e = Object.prototype.hasOwnProperty, t = "~"; function r() { } Object.create && (r.prototype = Object.create(null), new r().__proto__ || (t = !1)); function i(h, l, c) { this.fn = h, this.context = l, this.once = c || !1 } function n(h, l, c, u, d) { if (typeof c != "function") throw new TypeError("The listener must be a function"); var f = new i(c, u || h, d), p = t ? t + l : l; return h._events[p] ? h._events[p].fn ? h._events[p] = [h._events[p], f] : h._events[p].push(f) : (h._events[p] = f, h._eventsCount++), h } function a(h, l) { --h._eventsCount === 0 ? h._events = new r : delete h._events[l] } function o() { this._events = new r, this._eventsCount = 0 } o.prototype.eventNames = function() { var l = [], c, u; if (this._eventsCount === 0) return l; for (u in c = this._events) e.call(c, u) && l.push(t ? u.slice(1) : u); return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l }, o.prototype.listeners = function(l) { var c = t ? t + l : l, u = this._events[c]; if (!u) return []; if (u.fn) return [u.fn]; for (var d = 0, f = u.length, p = new Array(f); d < f; d++)p[d] = u[d].fn; return p }, o.prototype.listenerCount = function(l) { var c = t ? t + l : l, u = this._events[c]; return u ? u.fn ? 1 : u.length : 0 }, o.prototype.emit = function(l, c, u, d, f, p) { var g = t ? t + l : l; if (!this._events[g]) return !1; var m = this._events[g], y = arguments.length, T, S; if (m.fn) { switch (m.once && this.removeListener(l, m.fn, void 0, !0), y) { case 1: return m.fn.call(m.context), !0; case 2: return m.fn.call(m.context, c), !0; case 3: return m.fn.call(m.context, c, u), !0; case 4: return m.fn.call(m.context, c, u, d), !0; case 5: return m.fn.call(m.context, c, u, d, f), !0; case 6: return m.fn.call(m.context, c, u, d, f, p), !0 }for (S = 1, T = new Array(y - 1); S < y; S++)T[S - 1] = arguments[S]; m.fn.apply(m.context, T) } else { var A = m.length, R; for (S = 0; S < A; S++)switch (m[S].once && this.removeListener(l, m[S].fn, void 0, !0), y) { case 1: m[S].fn.call(m[S].context); break; case 2: m[S].fn.call(m[S].context, c); break; case 3: m[S].fn.call(m[S].context, c, u); break; case 4: m[S].fn.call(m[S].context, c, u, d); break; default: if (!T) for (R = 1, T = new Array(y - 1); R < y; R++)T[R - 1] = arguments[R]; m[S].fn.apply(m[S].context, T) } } return !0 }, o.prototype.on = function(l, c, u) { return n(this, l, c, u, !1) }, o.prototype.once = function(l, c, u) { return n(this, l, c, u, !0) }, o.prototype.removeListener = function(l, c, u, d) { var f = t ? t + l : l; if (!this._events[f]) return this; if (!c) return a(this, f), this; var p = this._events[f]; if (p.fn) p.fn === c && (!d || p.once) && (!u || p.context === u) && a(this, f); else { for (var g = 0, m = [], y = p.length; g < y; g++)(p[g].fn !== c || d && !p[g].once || u && p[g].context !== u) && m.push(p[g]); m.length ? this._events[f] = m.length === 1 ? m[0] : m : a(this, f) } return this }, o.prototype.removeAllListeners = function(l) { var c; return l ? (c = t ? t + l : l, this._events[c] && a(this, c)) : (this._events = new r, this._eventsCount = 0), this }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = t, o.EventEmitter = o, s.exports = o }(Qr)), Qr.exports } var wc = Sc(); const Ce = pi(wc), Ac = Math.PI * 2, Pc = 180 / Math.PI, Ec = Math.PI / 180; let oe = class Za { constructor(e = 0, t = 0) { this.x = 0, this.y = 0, this.x = e, this.y = t } clone() { return new Za(this.x, this.y) } copyFrom(e) { return this.set(e.x, e.y), this } copyTo(e) { return e.set(this.x, this.y), e } equals(e) { return e.x === this.x && e.y === this.y } set(e = 0, t = e) { return this.x = e, this.y = t, this } toString() { return `[pixi.js/math:Point x=${this.x} y=${this.y}]` } static get shared() { return Jr.x = 0, Jr.y = 0, Jr } }; const Jr = new oe; class D { constructor(e = 1, t = 0, r = 0, i = 1, n = 0, a = 0) { this.array = null, this.a = e, this.b = t, this.c = r, this.d = i, this.tx = n, this.ty = a } fromArray(e) { this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5] } set(e, t, r, i, n, a) { return this.a = e, this.b = t, this.c = r, this.d = i, this.tx = n, this.ty = a, this } toArray(e, t) { this.array || (this.array = new Float32Array(9)); const r = t || this.array; return e ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r } apply(e, t) { t = t || new oe; const r = e.x, i = e.y; return t.x = this.a * r + this.c * i + this.tx, t.y = this.b * r + this.d * i + this.ty, t } applyInverse(e, t) { t = t || new oe; const r = this.a, i = this.b, n = this.c, a = this.d, o = this.tx, h = this.ty, l = 1 / (r * a + n * -i), c = e.x, u = e.y; return t.x = a * l * c + -n * l * u + (h * n - o * a) * l, t.y = r * l * u + -i * l * c + (-h * r + o * i) * l, t } translate(e, t) { return this.tx += e, this.ty += t, this } scale(e, t) { return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this } rotate(e) { const t = Math.cos(e), r = Math.sin(e), i = this.a, n = this.c, a = this.tx; return this.a = i * t - this.b * r, this.b = i * r + this.b * t, this.c = n * t - this.d * r, this.d = n * r + this.d * t, this.tx = a * t - this.ty * r, this.ty = a * r + this.ty * t, this } append(e) { const t = this.a, r = this.b, i = this.c, n = this.d; return this.a = e.a * t + e.b * i, this.b = e.a * r + e.b * n, this.c = e.c * t + e.d * i, this.d = e.c * r + e.d * n, this.tx = e.tx * t + e.ty * i + this.tx, this.ty = e.tx * r + e.ty * n + this.ty, this } appendFrom(e, t) { const r = e.a, i = e.b, n = e.c, a = e.d, o = e.tx, h = e.ty, l = t.a, c = t.b, u = t.c, d = t.d; return this.a = r * l + i * u, this.b = r * c + i * d, this.c = n * l + a * u, this.d = n * c + a * d, this.tx = o * l + h * u + t.tx, this.ty = o * c + h * d + t.ty, this } setTransform(e, t, r, i, n, a, o, h, l) { return this.a = Math.cos(o + l) * n, this.b = Math.sin(o + l) * n, this.c = -Math.sin(o - h) * a, this.d = Math.cos(o - h) * a, this.tx = e - (r * this.a + i * this.c), this.ty = t - (r * this.b + i * this.d), this } prepend(e) { const t = this.tx; if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) { const r = this.a, i = this.c; this.a = r * e.a + this.b * e.c, this.b = r * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d } return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this } decompose(e) { const t = this.a, r = this.b, i = this.c, n = this.d, a = e.pivot, o = -Math.atan2(-i, n), h = Math.atan2(r, t), l = Math.abs(o + h); return l < 1e-5 || Math.abs(Ac - l) < 1e-5 ? (e.rotation = h, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = o, e.skew.y = h), e.scale.x = Math.sqrt(t * t + r * r), e.scale.y = Math.sqrt(i * i + n * n), e.position.x = this.tx + (a.x * t + a.y * i), e.position.y = this.ty + (a.x * r + a.y * n), e } invert() { const e = this.a, t = this.b, r = this.c, i = this.d, n = this.tx, a = e * i - t * r; return this.a = i / a, this.b = -t / a, this.c = -r / a, this.d = e / a, this.tx = (r * this.ty - i * n) / a, this.ty = -(e * this.ty - t * n) / a, this } isIdentity() { return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0 } identity() { return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this } clone() { const e = new D; return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e } copyTo(e) { return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e } copyFrom(e) { return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this } equals(e) { return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty } toString() { return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]` } static get IDENTITY() { return Mc.identity() } static get shared() { return Cc.identity() } } const Cc = new D, Mc = new D, ht = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], lt = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], ct = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], ut = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], Hs = [], Qa = [], ur = Math.sign; function Bc() { for (let s = 0; s < 16; s++) { const e = []; Hs.push(e); for (let t = 0; t < 16; t++) { const r = ur(ht[s] * ht[t] + ct[s] * lt[t]), i = ur(lt[s] * ht[t] + ut[s] * lt[t]), n = ur(ht[s] * ct[t] + ct[s] * ut[t]), a = ur(lt[s] * ct[t] + ut[s] * ut[t]); for (let o = 0; o < 16; o++)if (ht[o] === r && lt[o] === i && ct[o] === n && ut[o] === a) { e.push(o); break } } } for (let s = 0; s < 16; s++) { const e = new D; e.set(ht[s], lt[s], ct[s], ut[s], 0, 0), Qa.push(e) } } Bc(); const le = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: s => ht[s], uY: s => lt[s], vX: s => ct[s], vY: s => ut[s], inv: s => s & 8 ? s & 15 : -s & 7, add: (s, e) => Hs[s][e], sub: (s, e) => Hs[s][le.inv(e)], rotate180: s => s ^ 4, isVertical: s => (s & 3) === 2, byDirection: (s, e) => Math.abs(s) * 2 <= Math.abs(e) ? e >= 0 ? le.S : le.N : Math.abs(e) * 2 <= Math.abs(s) ? s > 0 ? le.E : le.W : e > 0 ? s > 0 ? le.SE : le.SW : s > 0 ? le.NE : le.NW, matrixAppendRotationInv: (s, e, t = 0, r = 0) => { const i = Qa[le.inv(e)]; i.tx = t, i.ty = r, s.append(i) } }, dr = [new oe, new oe, new oe, new oe]; class ne { constructor(e = 0, t = 0, r = 0, i = 0) { this.type = "rectangle", this.x = Number(e), this.y = Number(t), this.width = Number(r), this.height = Number(i) } get left() { return this.x } get right() { return this.x + this.width } get top() { return this.y } get bottom() { return this.y + this.height } isEmpty() { return this.left === this.right || this.top === this.bottom } static get EMPTY() { return new ne(0, 0, 0, 0) } clone() { return new ne(this.x, this.y, this.width, this.height) } copyFromBounds(e) { return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this } copyFrom(e) { return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this } copyTo(e) { return e.copyFrom(this), e } contains(e, t) { return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height } strokeContains(e, t, r, i = .5) { const { width: n, height: a } = this; if (n <= 0 || a <= 0) return !1; const o = this.x, h = this.y, l = r * (1 - i), c = r - l, u = o - l, d = o + n + l, f = h - l, p = h + a + l, g = o + c, m = o + n - c, y = h + c, T = h + a - c; return e >= u && e <= d && t >= f && t <= p && !(e > g && e < m && t > y && t < T) } intersects(e, t) { if (!t) { const L = this.x < e.x ? e.x : this.x; if ((this.right > e.right ? e.right : this.right) <= L) return !1; const G = this.y < e.y ? e.y : this.y; return (this.bottom > e.bottom ? e.bottom : this.bottom) > G } const r = this.left, i = this.right, n = this.top, a = this.bottom; if (i <= r || a <= n) return !1; const o = dr[0].set(e.left, e.top), h = dr[1].set(e.left, e.bottom), l = dr[2].set(e.right, e.top), c = dr[3].set(e.right, e.bottom); if (l.x <= o.x || h.y <= o.y) return !1; const u = Math.sign(t.a * t.d - t.b * t.c); if (u === 0 || (t.apply(o, o), t.apply(h, h), t.apply(l, l), t.apply(c, c), Math.max(o.x, h.x, l.x, c.x) <= r || Math.min(o.x, h.x, l.x, c.x) >= i || Math.max(o.y, h.y, l.y, c.y) <= n || Math.min(o.y, h.y, l.y, c.y) >= a)) return !1; const d = u * (h.y - o.y), f = u * (o.x - h.x), p = d * r + f * n, g = d * i + f * n, m = d * r + f * a, y = d * i + f * a; if (Math.max(p, g, m, y) <= d * o.x + f * o.y || Math.min(p, g, m, y) >= d * c.x + f * c.y) return !1; const T = u * (o.y - l.y), S = u * (l.x - o.x), A = T * r + S * n, R = T * i + S * n, E = T * r + S * a, C = T * i + S * a; return !(Math.max(A, R, E, C) <= T * o.x + S * o.y || Math.min(A, R, E, C) >= T * c.x + S * c.y) } pad(e = 0, t = e) { return this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this } fit(e) { const t = Math.max(this.x, e.x), r = Math.min(this.x + this.width, e.x + e.width), i = Math.max(this.y, e.y), n = Math.min(this.y + this.height, e.y + e.height); return this.x = t, this.width = Math.max(r - t, 0), this.y = i, this.height = Math.max(n - i, 0), this } ceil(e = 1, t = .001) { const r = Math.ceil((this.x + this.width - t) * e) / e, i = Math.ceil((this.y + this.height - t) * e) / e; return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = r - this.x, this.height = i - this.y, this } enlarge(e) { const t = Math.min(this.x, e.x), r = Math.max(this.x + this.width, e.x + e.width), i = Math.min(this.y, e.y), n = Math.max(this.y + this.height, e.y + e.height); return this.x = t, this.width = r - t, this.y = i, this.height = n - i, this } getBounds(e) { return e || (e = new ne), e.copyFrom(this), e } containsRect(e) { if (this.width <= 0 || this.height <= 0) return !1; const t = e.x, r = e.y, i = e.x + e.width, n = e.y + e.height; return t >= this.x && t < this.x + this.width && r >= this.y && r < this.y + this.height && i >= this.x && i < this.x + this.width && n >= this.y && n < this.y + this.height } toString() { return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]` } } const es = { default: -1 }; function he(s = "default") { return es[s] === void 0 && (es[s] = -1), ++es[s] } const dn = {}, ee = "8.0.0", Rc = "8.3.4"; function X(s, e, t = 3) {
  if (dn[e]) return; let r = new Error().stack; typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${s}`) : (r = r.split(`
`).splice(t).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${s}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${s}`), console.warn(r))), dn[e] = !0
} const Ja = () => { }; function Et(s) { return s += s === 0 ? 1 : 0, --s, s |= s >>> 1, s |= s >>> 2, s |= s >>> 4, s |= s >>> 8, s |= s >>> 16, s + 1 } function fn(s) { return !(s & s - 1) && !!s } function eo(s) { const e = {}; for (const t in s) s[t] !== void 0 && (e[t] = s[t]); return e } const pn = Object.create(null); function kc(s) { const e = pn[s]; return e === void 0 && (pn[s] = he("resource")), e } const to = class ro extends Ce { constructor(e = {}) { super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, e = { ...ro.defaultOptions, ...e }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ?? this.addressModeU, this.addressModeV = e.addressModeV ?? this.addressModeV, this.addressModeW = e.addressModeW ?? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ?? this.magFilter, this.minFilter = e.minFilter ?? this.minFilter, this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ?? 1 } set addressMode(e) { this.addressModeU = e, this.addressModeV = e, this.addressModeW = e } get addressMode() { return this.addressModeU } set wrapMode(e) { X(ee, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e } get wrapMode() { return this.addressMode } set scaleMode(e) { this.magFilter = e, this.minFilter = e, this.mipmapFilter = e } get scaleMode() { return this.magFilter } set maxAnisotropy(e) { this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear") } get maxAnisotropy() { return this._maxAnisotropy } get _resourceId() { return this._sharedResourceId || this._generateResourceId() } update() { this.emit("change", this), this._sharedResourceId = null } _generateResourceId() { const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`; return this._sharedResourceId = kc(e), this._resourceId } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners() } }; to.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" }; let so = to; const io = class no extends Ce { constructor(e = {}) { super(), this.options = e, this.uid = he("textureSource"), this._resourceType = "textureSource", this._resourceId = he("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = { ...no.defaultOptions, ...e }, this.label = e.label ?? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new so(eo(e)), this.destroyed = !1, this._refreshPOT() } get source() { return this } get style() { return this._style } set style(e) { var t, r; this.style !== e && ((t = this._style) == null || t.off("change", this._onStyleChange, this), this._style = e, (r = this._style) == null || r.on("change", this._onStyleChange, this), this._onStyleChange()) } get addressMode() { return this._style.addressMode } set addressMode(e) { this._style.addressMode = e } get repeatMode() { return this._style.addressMode } set repeatMode(e) { this._style.addressMode = e } get magFilter() { return this._style.magFilter } set magFilter(e) { this._style.magFilter = e } get minFilter() { return this._style.minFilter } set minFilter(e) { this._style.minFilter = e } get mipmapFilter() { return this._style.mipmapFilter } set mipmapFilter(e) { this._style.mipmapFilter = e } get lodMinClamp() { return this._style.lodMinClamp } set lodMinClamp(e) { this._style.lodMinClamp = e } get lodMaxClamp() { return this._style.lodMaxClamp } set lodMaxClamp(e) { this._style.lodMaxClamp = e } _onStyleChange() { this.emit("styleChange", this) } update() { if (this.resource) { const e = this._resolution; if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return } this.emit("update", this) } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners() } unload() { this._resourceId = he("resource"), this.emit("change", this), this.emit("unload", this) } get resourceWidth() { const { resource: e } = this; return e.naturalWidth || e.videoWidth || e.displayWidth || e.width } get resourceHeight() { const { resource: e } = this; return e.naturalHeight || e.videoHeight || e.displayHeight || e.height } get resolution() { return this._resolution } set resolution(e) { this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e) } resize(e, t, r) { r || (r = this._resolution), e || (e = this.width), t || (t = this.height); const i = Math.round(e * r), n = Math.round(t * r); return this.width = i / r, this.height = n / r, this._resolution = r, this.pixelWidth === i && this.pixelHeight === n ? !1 : (this._refreshPOT(), this.pixelWidth = i, this.pixelHeight = n, this.emit("resize", this), this._resourceId = he("resource"), this.emit("change", this), !0) } updateMipmaps() { this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this) } set wrapMode(e) { this._style.wrapMode = e } get wrapMode() { return this._style.wrapMode } set scaleMode(e) { this._style.scaleMode = e } get scaleMode() { return this._style.scaleMode } _refreshPOT() { this.isPowerOfTwo = fn(this.pixelWidth) && fn(this.pixelHeight) } static test(e) { throw new Error("Unimplemented") } }; io.defaultOptions = { resolution: 1, format: "bgra8unorm", alphaMode: "premultiply-alpha-on-upload", dimensions: "2d", mipLevelCount: 1, autoGenerateMipmaps: !1, sampleCount: 1, antialias: !1, autoGarbageCollect: !1 }; let ge = io; class mi extends ge { constructor(e) { const t = e.resource || new Float32Array(e.width * e.height * 4); let r = e.format; r || (t instanceof Float32Array ? r = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? r = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? r = "rgba16uint" : (t instanceof Int8Array, r = "bgra8unorm")), super({ ...e, resource: t, format: r }), this.uploadMethodId = "buffer" } static test(e) { return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array } } mi.extension = b.TextureSource; const mn = new D; class ao { constructor(e, t) { this.mapCoord = new D, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : .5 : this.clampMargin = t, this.isSimple = !1, this.texture = e } get texture() { return this._texture } set texture(e) { var t; this.texture !== e && ((t = this._texture) == null || t.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update()) } multiplyUvs(e, t) { t === void 0 && (t = e); const r = this.mapCoord; for (let i = 0; i < e.length; i += 2) { const n = e[i], a = e[i + 1]; t[i] = n * r.a + a * r.c + r.tx, t[i + 1] = n * r.b + a * r.d + r.ty } return t } update() { const e = this._texture; this._updateID++; const t = e.uvs; this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0); const r = e.orig, i = e.trim; i && (mn.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(mn)); const n = e.source, a = this.uClampFrame, o = this.clampMargin / n._resolution, h = this.clampOffset / n._resolution; return a[0] = (e.frame.x + o + h) / n.width, a[1] = (e.frame.y + o + h) / n.height, a[2] = (e.frame.x + e.frame.width - o + h) / n.width, a[3] = (e.frame.y + e.frame.height - o + h) / n.height, this.uClampOffset[0] = this.clampOffset / n.pixelWidth, this.uClampOffset[1] = this.clampOffset / n.pixelHeight, this.isSimple = e.frame.width === n.width && e.frame.height === n.height && e.rotate === 0, !0 } } class F extends Ce { constructor({ source: e, label: t, frame: r, orig: i, trim: n, defaultAnchor: a, defaultBorders: o, rotate: h, dynamic: l } = {}) { if (super(), this.uid = he("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new ne, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = t, this.source = (e == null ? void 0 : e.source) ?? new ge, this.noFrame = !r, r) this.frame.copyFrom(r); else { const { width: c, height: u } = this._source; this.frame.width = c, this.frame.height = u } this.orig = i || this.frame, this.trim = n, this.rotate = h ?? 0, this.defaultAnchor = a, this.defaultBorders = o, this.destroyed = !1, this.dynamic = l || !1, this.updateUvs() } set source(e) { this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this) } get source() { return this._source } get textureMatrix() { return this._textureMatrix || (this._textureMatrix = new ao(this)), this._textureMatrix } get width() { return this.orig.width } get height() { return this.orig.height } updateUvs() { const { uvs: e, frame: t } = this, { width: r, height: i } = this._source, n = t.x / r, a = t.y / i, o = t.width / r, h = t.height / i; let l = this.rotate; if (l) { const c = o / 2, u = h / 2, d = n + c, f = a + u; l = le.add(l, le.NW), e.x0 = d + c * le.uX(l), e.y0 = f + u * le.uY(l), l = le.add(l, 2), e.x1 = d + c * le.uX(l), e.y1 = f + u * le.uY(l), l = le.add(l, 2), e.x2 = d + c * le.uX(l), e.y2 = f + u * le.uY(l), l = le.add(l, 2), e.x3 = d + c * le.uX(l), e.y3 = f + u * le.uY(l) } else e.x0 = n, e.y0 = a, e.x1 = n + o, e.y1 = a, e.x2 = n + o, e.y2 = a + h, e.x3 = n, e.y3 = a + h } destroy(e = !1) { this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners() } update() { this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this) } get baseTexture() { return X(ee, "Texture.baseTexture is now Texture.source"), this._source } } F.EMPTY = new F({ label: "EMPTY", source: new ge({ label: "EMPTY" }) }); F.EMPTY.destroy = Ja; F.WHITE = new F({ source: new mi({ resource: new Uint8Array([255, 255, 255, 255]), width: 1, height: 1, alphaMode: "premultiply-alpha-on-upload", label: "WHITE" }), label: "WHITE" }); F.WHITE.destroy = Ja; function oo(s, e, t) { const { width: r, height: i } = t.orig, n = t.trim; if (n) { const a = n.width, o = n.height; s.minX = n.x - e._x * r, s.maxX = s.minX + a, s.minY = n.y - e._y * i, s.maxY = s.minY + o } else s.minX = -e._x * r, s.maxX = s.minX + r, s.minY = -e._y * i, s.maxY = s.minY + i } const gn = new D; class xe { constructor(e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0) { this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = gn, this.minX = e, this.minY = t, this.maxX = r, this.maxY = i } isEmpty() { return this.minX > this.maxX || this.minY > this.maxY } get rectangle() { this._rectangle || (this._rectangle = new ne); const e = this._rectangle; return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e } clear() { return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = gn, this } set(e, t, r, i) { this.minX = e, this.minY = t, this.maxX = r, this.maxY = i } addFrame(e, t, r, i, n) { n || (n = this.matrix); const a = n.a, o = n.b, h = n.c, l = n.d, c = n.tx, u = n.ty; let d = this.minX, f = this.minY, p = this.maxX, g = this.maxY, m = a * e + h * t + c, y = o * e + l * t + u; m < d && (d = m), y < f && (f = y), m > p && (p = m), y > g && (g = y), m = a * r + h * t + c, y = o * r + l * t + u, m < d && (d = m), y < f && (f = y), m > p && (p = m), y > g && (g = y), m = a * e + h * i + c, y = o * e + l * i + u, m < d && (d = m), y < f && (f = y), m > p && (p = m), y > g && (g = y), m = a * r + h * i + c, y = o * r + l * i + u, m < d && (d = m), y < f && (f = y), m > p && (p = m), y > g && (g = y), this.minX = d, this.minY = f, this.maxX = p, this.maxY = g } addRect(e, t) { this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t) } addBounds(e, t) { this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t) } addBoundsMask(e) { this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY } applyMatrix(e) { const t = this.minX, r = this.minY, i = this.maxX, n = this.maxY, { a, b: o, c: h, d: l, tx: c, ty: u } = e; let d = a * t + h * r + c, f = o * t + l * r + u; this.minX = d, this.minY = f, this.maxX = d, this.maxY = f, d = a * i + h * r + c, f = o * i + l * r + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = a * t + h * n + c, f = o * t + l * n + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = a * i + h * n + c, f = o * i + l * n + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY } fit(e) { return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this } fitBounds(e, t, r, i) { return this.minX < e && (this.minX = e), this.maxX > t && (this.maxX = t), this.minY < r && (this.minY = r), this.maxY > i && (this.maxY = i), this } pad(e, t = e) { return this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t, this } ceil() { return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this } clone() { return new xe(this.minX, this.minY, this.maxX, this.maxY) } scale(e, t = e) { return this.minX *= e, this.minY *= t, this.maxX *= e, this.maxY *= t, this } get x() { return this.minX } set x(e) { const t = this.maxX - this.minX; this.minX = e, this.maxX = e + t } get y() { return this.minY } set y(e) { const t = this.maxY - this.minY; this.minY = e, this.maxY = e + t } get width() { return this.maxX - this.minX } set width(e) { this.maxX = this.minX + e } get height() { return this.maxY - this.minY } set height(e) { this.maxY = this.minY + e } get left() { return this.minX } get right() { return this.maxX } get top() { return this.minY } get bottom() { return this.maxY } get isPositive() { return this.maxX - this.minX > 0 && this.maxY - this.minY > 0 } get isValid() { return this.minX + this.minY !== 1 / 0 } addVertexData(e, t, r, i) { let n = this.minX, a = this.minY, o = this.maxX, h = this.maxY; i || (i = this.matrix); const l = i.a, c = i.b, u = i.c, d = i.d, f = i.tx, p = i.ty; for (let g = t; g < r; g += 2) { const m = e[g], y = e[g + 1], T = l * m + u * y + f, S = c * m + d * y + p; n = T < n ? T : n, a = S < a ? S : a, o = T > o ? T : o, h = S > h ? S : h } this.minX = n, this.minY = a, this.maxX = o, this.maxY = h } containsPoint(e, t) { return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t } toString() { return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]` } copyFrom(e) { return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this } } var Ic = { grad: .9, turn: 360, rad: 360 / (2 * Math.PI) }, Xe = function(s) { return typeof s == "string" ? s.length > 0 : typeof s == "number" }, pe = function(s, e, t) { return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * s) / t + 0 }, Re = function(s, e, t) { return e === void 0 && (e = 0), t === void 0 && (t = 1), s > t ? t : s > e ? s : e }, ho = function(s) { return (s = isFinite(s) ? s % 360 : 0) > 0 ? s : s + 360 }, _n = function(s) { return { r: Re(s.r, 0, 255), g: Re(s.g, 0, 255), b: Re(s.b, 0, 255), a: Re(s.a) } }, ts = function(s) { return { r: pe(s.r), g: pe(s.g), b: pe(s.b), a: pe(s.a, 3) } }, Gc = /^#([0-9a-f]{3,8})$/i, fr = function(s) { var e = s.toString(16); return e.length < 2 ? "0" + e : e }, lo = function(s) { var e = s.r, t = s.g, r = s.b, i = s.a, n = Math.max(e, t, r), a = n - Math.min(e, t, r), o = a ? n === e ? (t - r) / a : n === t ? 2 + (r - e) / a : 4 + (e - t) / a : 0; return { h: 60 * (o < 0 ? o + 6 : o), s: n ? a / n * 100 : 0, v: n / 255 * 100, a: i } }, co = function(s) { var e = s.h, t = s.s, r = s.v, i = s.a; e = e / 360 * 6, t /= 100, r /= 100; var n = Math.floor(e), a = r * (1 - t), o = r * (1 - (e - n) * t), h = r * (1 - (1 - e + n) * t), l = n % 6; return { r: 255 * [r, o, a, a, h, r][l], g: 255 * [h, r, r, o, a, a][l], b: 255 * [a, a, h, r, r, o][l], a: i } }, xn = function(s) { return { h: ho(s.h), s: Re(s.s, 0, 100), l: Re(s.l, 0, 100), a: Re(s.a) } }, yn = function(s) { return { h: pe(s.h), s: pe(s.s), l: pe(s.l), a: pe(s.a, 3) } }, bn = function(s) { return co((t = (e = s).s, { h: e.h, s: (t *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * t / (r + t) * 100 : 0, v: r + t, a: e.a })); var e, t, r }, Xt = function(s) { return { h: (e = lo(s)).h, s: (i = (200 - (t = e.s)) * (r = e.v) / 100) > 0 && i < 200 ? t * r / 100 / (i <= 100 ? i : 200 - i) * 100 : 0, l: i / 2, a: e.a }; var e, t, r, i }, Fc = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Uc = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Dc = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Oc = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, zs = { string: [[function(s) { var e = Gc.exec(s); return e ? (s = e[1]).length <= 4 ? { r: parseInt(s[0] + s[0], 16), g: parseInt(s[1] + s[1], 16), b: parseInt(s[2] + s[2], 16), a: s.length === 4 ? pe(parseInt(s[3] + s[3], 16) / 255, 2) : 1 } : s.length === 6 || s.length === 8 ? { r: parseInt(s.substr(0, 2), 16), g: parseInt(s.substr(2, 2), 16), b: parseInt(s.substr(4, 2), 16), a: s.length === 8 ? pe(parseInt(s.substr(6, 2), 16) / 255, 2) : 1 } : null : null }, "hex"], [function(s) { var e = Dc.exec(s) || Oc.exec(s); return e ? e[2] !== e[4] || e[4] !== e[6] ? null : _n({ r: Number(e[1]) / (e[2] ? 100 / 255 : 1), g: Number(e[3]) / (e[4] ? 100 / 255 : 1), b: Number(e[5]) / (e[6] ? 100 / 255 : 1), a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1) }) : null }, "rgb"], [function(s) { var e = Fc.exec(s) || Uc.exec(s); if (!e) return null; var t, r, i = xn({ h: (t = e[1], r = e[2], r === void 0 && (r = "deg"), Number(t) * (Ic[r] || 1)), s: Number(e[3]), l: Number(e[4]), a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1) }); return bn(i) }, "hsl"]], object: [[function(s) { var e = s.r, t = s.g, r = s.b, i = s.a, n = i === void 0 ? 1 : i; return Xe(e) && Xe(t) && Xe(r) ? _n({ r: Number(e), g: Number(t), b: Number(r), a: Number(n) }) : null }, "rgb"], [function(s) { var e = s.h, t = s.s, r = s.l, i = s.a, n = i === void 0 ? 1 : i; if (!Xe(e) || !Xe(t) || !Xe(r)) return null; var a = xn({ h: Number(e), s: Number(t), l: Number(r), a: Number(n) }); return bn(a) }, "hsl"], [function(s) { var e = s.h, t = s.s, r = s.v, i = s.a, n = i === void 0 ? 1 : i; if (!Xe(e) || !Xe(t) || !Xe(r)) return null; var a = function(o) { return { h: ho(o.h), s: Re(o.s, 0, 100), v: Re(o.v, 0, 100), a: Re(o.a) } }({ h: Number(e), s: Number(t), v: Number(r), a: Number(n) }); return co(a) }, "hsv"]] }, vn = function(s, e) { for (var t = 0; t < e.length; t++) { var r = e[t][0](s); if (r) return [r, e[t][1]] } return [null, void 0] }, Lc = function(s) { return typeof s == "string" ? vn(s.trim(), zs.string) : typeof s == "object" && s !== null ? vn(s, zs.object) : [null, void 0] }, rs = function(s, e) { var t = Xt(s); return { h: t.h, s: Re(t.s + 100 * e, 0, 100), l: t.l, a: t.a } }, ss = function(s) { return (299 * s.r + 587 * s.g + 114 * s.b) / 1e3 / 255 }, Tn = function(s, e) { var t = Xt(s); return { h: t.h, s: t.s, l: Re(t.l + 100 * e, 0, 100), a: t.a } }, Ws = function() { function s(e) { this.parsed = Lc(e)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 } } return s.prototype.isValid = function() { return this.parsed !== null }, s.prototype.brightness = function() { return pe(ss(this.rgba), 2) }, s.prototype.isDark = function() { return ss(this.rgba) < .5 }, s.prototype.isLight = function() { return ss(this.rgba) >= .5 }, s.prototype.toHex = function() { return e = ts(this.rgba), t = e.r, r = e.g, i = e.b, a = (n = e.a) < 1 ? fr(pe(255 * n)) : "", "#" + fr(t) + fr(r) + fr(i) + a; var e, t, r, i, n, a }, s.prototype.toRgb = function() { return ts(this.rgba) }, s.prototype.toRgbString = function() { return e = ts(this.rgba), t = e.r, r = e.g, i = e.b, (n = e.a) < 1 ? "rgba(" + t + ", " + r + ", " + i + ", " + n + ")" : "rgb(" + t + ", " + r + ", " + i + ")"; var e, t, r, i, n }, s.prototype.toHsl = function() { return yn(Xt(this.rgba)) }, s.prototype.toHslString = function() { return e = yn(Xt(this.rgba)), t = e.h, r = e.s, i = e.l, (n = e.a) < 1 ? "hsla(" + t + ", " + r + "%, " + i + "%, " + n + ")" : "hsl(" + t + ", " + r + "%, " + i + "%)"; var e, t, r, i, n }, s.prototype.toHsv = function() { return e = lo(this.rgba), { h: pe(e.h), s: pe(e.s), v: pe(e.v), a: pe(e.a, 3) }; var e }, s.prototype.invert = function() { return ze({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a }); var e }, s.prototype.saturate = function(e) { return e === void 0 && (e = .1), ze(rs(this.rgba, e)) }, s.prototype.desaturate = function(e) { return e === void 0 && (e = .1), ze(rs(this.rgba, -e)) }, s.prototype.grayscale = function() { return ze(rs(this.rgba, -1)) }, s.prototype.lighten = function(e) { return e === void 0 && (e = .1), ze(Tn(this.rgba, e)) }, s.prototype.darken = function(e) { return e === void 0 && (e = .1), ze(Tn(this.rgba, -e)) }, s.prototype.rotate = function(e) { return e === void 0 && (e = 15), this.hue(this.hue() + e) }, s.prototype.alpha = function(e) { return typeof e == "number" ? ze({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e }) : pe(this.rgba.a, 3); var t }, s.prototype.hue = function(e) { var t = Xt(this.rgba); return typeof e == "number" ? ze({ h: e, s: t.s, l: t.l, a: t.a }) : pe(t.h) }, s.prototype.isEqual = function(e) { return this.toHex() === ze(e).toHex() }, s }(), ze = function(s) { return s instanceof Ws ? s : new Ws(s) }, Sn = [], Nc = function(s) { s.forEach(function(e) { Sn.indexOf(e) < 0 && (e(Ws, zs), Sn.push(e)) }) }; function Hc(s, e) { var t = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r = {}; for (var i in t) r[t[i]] = i; var n = {}; s.prototype.toName = function(a) { if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent"; var o, h, l = r[this.toHex()]; if (l) return l; if (a != null && a.closest) { var c = this.toRgb(), u = 1 / 0, d = "black"; if (!n.length) for (var f in t) n[f] = new s(t[f]).toRgb(); for (var p in t) { var g = (o = c, h = n[p], Math.pow(o.r - h.r, 2) + Math.pow(o.g - h.g, 2) + Math.pow(o.b - h.b, 2)); g < u && (u = g, d = p) } return d } }, e.string.push([function(a) { var o = a.toLowerCase(), h = o === "transparent" ? "#0000" : t[o]; return h ? new s(h).toRgb() : null }, "name"]) } Nc([Hc]); const Ct = class zt { constructor(e = 16777215) { this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e } get red() { return this._components[0] } get green() { return this._components[1] } get blue() { return this._components[2] } get alpha() { return this._components[3] } setValue(e) { return this.value = e, this } set value(e) { if (e instanceof zt) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components); else { if (e === null) throw new Error("Cannot set Color#value to null"); (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value)) } } get value() { return this._value } _cloneSource(e) { return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? { ...e } : e } _isSourceEqual(e, t) { const r = typeof e; if (r !== typeof t) return !1; if (r === "number" || r === "string" || e instanceof Number) return e === t; if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) return e.length !== t.length ? !1 : e.every((n, a) => n === t[a]); if (e !== null && t !== null) { const n = Object.keys(e), a = Object.keys(t); return n.length !== a.length ? !1 : n.every(o => e[o] === t[o]) } return e === t } toRgba() { const [e, t, r, i] = this._components; return { r: e, g: t, b: r, a: i } } toRgb() { const [e, t, r] = this._components; return { r: e, g: t, b: r } } toRgbaString() { const [e, t, r] = this.toUint8RgbArray(); return `rgba(${e},${t},${r},${this.alpha})` } toUint8RgbArray(e) { const [t, r, i] = this._components; return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(t * 255), e[1] = Math.round(r * 255), e[2] = Math.round(i * 255), e } toArray(e) { this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba); const [t, r, i, n] = this._components; return e[0] = t, e[1] = r, e[2] = i, e[3] = n, e } toRgbArray(e) { this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb); const [t, r, i] = this._components; return e[0] = t, e[1] = r, e[2] = i, e } toNumber() { return this._int } toBgrNumber() { const [e, t, r] = this.toUint8RgbArray(); return (r << 16) + (t << 8) + e } toLittleEndianNumber() { const e = this._int; return (e >> 16) + (e & 65280) + ((e & 255) << 16) } multiply(e) { const [t, r, i, n] = zt._temp.setValue(e)._components; return this._components[0] *= t, this._components[1] *= r, this._components[2] *= i, this._components[3] *= n, this._refreshInt(), this._value = null, this } premultiply(e, t = !0) { return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this } toPremultiplied(e, t = !0) { if (e === 1) return (255 << 24) + this._int; if (e === 0) return t ? 0 : this._int; let r = this._int >> 16 & 255, i = this._int >> 8 & 255, n = this._int & 255; return t && (r = r * e + .5 | 0, i = i * e + .5 | 0, n = n * e + .5 | 0), (e * 255 << 24) + (r << 16) + (i << 8) + n } toHex() { const e = this._int.toString(16); return `#${"000000".substring(0, 6 - e.length) + e}` } toHexa() { const t = Math.round(this._components[3] * 255).toString(16); return this.toHex() + "00".substring(0, 2 - t.length) + t } setAlpha(e) { return this._components[3] = this._clamp(e), this } _normalize(e) { let t, r, i, n; if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) { const a = e; t = (a >> 16 & 255) / 255, r = (a >> 8 & 255) / 255, i = (a & 255) / 255, n = 1 } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [t, r, i, n = 1] = e; else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [t, r, i, n = 255] = e, t /= 255, r /= 255, i /= 255, n /= 255; else if (typeof e == "string" || typeof e == "object") { if (typeof e == "string") { const o = zt.HEX_PATTERN.exec(e); o && (e = `#${o[2]}`) } const a = ze(e); a.isValid() && ({ r: t, g: r, b: i, a: n } = a.rgba, t /= 255, r /= 255, i /= 255) } if (t !== void 0) this._components[0] = t, this._components[1] = r, this._components[2] = i, this._components[3] = n, this._refreshInt(); else throw new Error(`Unable to convert color ${e}`) } _refreshInt() { this._clamp(this._components); const [e, t, r] = this._components; this._int = (e * 255 << 16) + (t * 255 << 8) + (r * 255 | 0) } _clamp(e, t = 0, r = 1) { return typeof e == "number" ? Math.min(Math.max(e, t), r) : (e.forEach((i, n) => { e[n] = Math.min(Math.max(i, t), r) }), e) } static isColorLike(e) { return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof zt || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0 } }; Ct.shared = new Ct; Ct._temp = new Ct; Ct.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i; let ie = Ct; const zc = { cullArea: null, cullable: !1, cullableChildren: !0 }; class gi { constructor(e, t) { this._pool = [], this._count = 0, this._index = 0, this._classType = e, t && this.prepopulate(t) } prepopulate(e) { for (let t = 0; t < e; t++)this._pool[this._index++] = new this._classType; this._count += e } get(e) { var r; let t; return this._index > 0 ? t = this._pool[--this._index] : t = new this._classType, (r = t.init) == null || r.call(t, e), t } return(e) { var t; (t = e.reset) == null || t.call(e), this._pool[this._index++] = e } get totalSize() { return this._count } get totalFree() { return this._index } get totalUsed() { return this._count - this._index } clear() { this._pool.length = 0, this._index = 0 } } class Wc { constructor() { this._poolsByClass = new Map } prepopulate(e, t) { this.getPool(e).prepopulate(t) } get(e, t) { return this.getPool(e).get(t) } return(e) { this.getPool(e.constructor).return(e) } getPool(e) { return this._poolsByClass.has(e) || this._poolsByClass.set(e, new gi(e)), this._poolsByClass.get(e) } stats() { const e = {}; return this._poolsByClass.forEach(t => { const r = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name; e[r] = { free: t.totalFree, used: t.totalUsed, size: t.totalSize } }), e } } const j = new Wc, Vc = { get isCachedAsTexture() { var s; return !!((s = this.renderGroup) != null && s.isCachedAsTexture) }, cacheAsTexture(s) { typeof s == "boolean" && s === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(s === !0 ? {} : s)) }, updateCacheTexture() { var s; (s = this.renderGroup) == null || s.updateCacheTexture() }, get cacheAsBitmap() { return this.isCachedAsTexture }, set cacheAsBitmap(s) { X("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(s) } }; function uo(s, e, t) { const r = s.length; let i; if (e >= r || t === 0) return; t = e + t > r ? r - e : t; const n = r - t; for (i = e; i < n; ++i)s[i] = s[i + t]; s.length = n } const $c = { allowChildren: !0, removeChildren(s = 0, e) { const t = e ?? this.children.length, r = t - s, i = []; if (r > 0 && r <= t) { for (let a = t - 1; a >= s; a--) { const o = this.children[a]; o && (i.push(o), o.parent = null) } uo(this.children, s, t); const n = this.renderGroup || this.parentRenderGroup; n && n.removeChildren(i); for (let a = 0; a < i.length; ++a)this.emit("childRemoved", i[a], this, a), i[a].emit("removed", this); return i.length > 0 && this._didViewChangeTick++, i } else if (r === 0 && this.children.length === 0) return i; throw new RangeError("removeChildren: numeric values are outside the acceptable range.") }, removeChildAt(s) { const e = this.getChildAt(s); return this.removeChild(e) }, getChildAt(s) { if (s < 0 || s >= this.children.length) throw new Error(`getChildAt: Index (${s}) does not exist.`); return this.children[s] }, setChildIndex(s, e) { if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`); this.getChildIndex(s), this.addChildAt(s, e) }, getChildIndex(s) { const e = this.children.indexOf(s); if (e === -1) throw new Error("The supplied Container must be a child of the caller"); return e }, addChildAt(s, e) { this.allowChildren || X(ee, "addChildAt: Only Containers will be allowed to add children in v8.0.0"); const { children: t } = this; if (e < 0 || e > t.length) throw new Error(`${s}addChildAt: The index ${e} supplied is out of bounds ${t.length}`); if (s.parent) { const i = s.parent.children.indexOf(s); if (s.parent === this && i === e) return s; i !== -1 && s.parent.children.splice(i, 1) } e === t.length ? t.push(s) : t.splice(e, 0, s), s.parent = this, s.didChange = !0, s._updateFlags = 15; const r = this.renderGroup || this.parentRenderGroup; return r && r.addChild(s), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", s, this, e), s.emit("added", this), s }, swapChildren(s, e) { if (s === e) return; const t = this.getChildIndex(s), r = this.getChildIndex(e); this.children[t] = e, this.children[r] = s; const i = this.renderGroup || this.parentRenderGroup; i && (i.structureDidChange = !0), this._didContainerChangeTick++ }, removeFromParent() { var s; (s = this.parent) == null || s.removeChild(this) }, reparentChild(...s) { return s.length === 1 ? this.reparentChildAt(s[0], this.children.length) : (s.forEach(e => this.reparentChildAt(e, this.children.length)), s[0]) }, reparentChildAt(s, e) { if (s.parent === this) return this.setChildIndex(s, e), s; const t = s.worldTransform.clone(); s.removeFromParent(), this.addChildAt(s, e); const r = this.worldTransform.clone(); return r.invert(), t.prepend(r), s.setFromMatrix(t), s } }, Xc = { collectRenderables(s, e, t) { this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(s, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, s) : this.collectRenderablesWithEffects(s, e, t)) }, collectRenderablesSimple(s, e, t) { const r = this.children, i = r.length; for (let n = 0; n < i; n++)r[n].collectRenderables(s, e, t) }, collectRenderablesWithEffects(s, e, t) { const { renderPipes: r } = e; for (let i = 0; i < this.effects.length; i++) { const n = this.effects[i]; r[n.pipe].push(n, this, s) } this.collectRenderablesSimple(s, e, t); for (let i = this.effects.length - 1; i >= 0; i--) { const n = this.effects[i]; r[n.pipe].pop(n, this, s) } } }; class Ur { constructor() { this.pipe = "filter", this.priority = 1 } destroy() { for (let e = 0; e < this.filters.length; e++)this.filters[e].destroy(); this.filters = null, this.filterArea = null } } class jc { constructor() { this._effectClasses = [], this._tests = [], this._initialized = !1 } init() { this._initialized || (this._initialized = !0, this._effectClasses.forEach(e => { this.add({ test: e.test, maskClass: e }) })) } add(e) { this._tests.push(e) } getMaskEffect(e) { this._initialized || this.init(); for (let t = 0; t < this._tests.length; t++) { const r = this._tests[t]; if (r.test(e)) return j.get(r.maskClass, e) } return e } returnMaskEffect(e) { j.return(e) } } const Vs = new jc; z.handleByList(b.MaskEffect, Vs._effectClasses); const Yc = { _maskEffect: null, _maskOptions: { inverse: !1 }, _filterEffect: null, effects: [], _markStructureAsChanged() { const s = this.renderGroup || this.parentRenderGroup; s && (s.structureDidChange = !0) }, addEffect(s) { this.effects.indexOf(s) === -1 && (this.effects.push(s), this.effects.sort((t, r) => t.priority - r.priority), this._markStructureAsChanged(), this._updateIsSimple()) }, removeEffect(s) { const e = this.effects.indexOf(s); e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple()) }, set mask(s) { const e = this._maskEffect; (e == null ? void 0 : e.mask) !== s && (e && (this.removeEffect(e), Vs.returnMaskEffect(e), this._maskEffect = null), s != null && (this._maskEffect = Vs.getMaskEffect(s), this.addEffect(this._maskEffect))) }, setMask(s) { this._maskOptions = { ...this._maskOptions, ...s }, s.mask && (this.mask = s.mask), this._markStructureAsChanged() }, get mask() { var s; return (s = this._maskEffect) == null ? void 0 : s.mask }, set filters(s) { var n; !Array.isArray(s) && s && (s = [s]); const e = this._filterEffect || (this._filterEffect = new Ur); s = s; const t = (s == null ? void 0 : s.length) > 0, r = ((n = e.filters) == null ? void 0 : n.length) > 0, i = t !== r; s = Array.isArray(s) ? s.slice(0) : s, e.filters = Object.freeze(s), i && (t ? this.addEffect(e) : (this.removeEffect(e), e.filters = s ?? null)) }, get filters() { var s; return (s = this._filterEffect) == null ? void 0 : s.filters }, set filterArea(s) { this._filterEffect || (this._filterEffect = new Ur), this._filterEffect.filterArea = s }, get filterArea() { var s; return (s = this._filterEffect) == null ? void 0 : s.filterArea } }, Kc = { label: null, get name() { return X(ee, "Container.name property has been removed, use Container.label instead"), this.label }, set name(s) { X(ee, "Container.name property has been removed, use Container.label instead"), this.label = s }, getChildByName(s, e = !1) { return this.getChildByLabel(s, e) }, getChildByLabel(s, e = !1) { const t = this.children; for (let r = 0; r < t.length; r++) { const i = t[r]; if (i.label === s || s instanceof RegExp && s.test(i.label)) return i } if (e) for (let r = 0; r < t.length; r++) { const n = t[r].getChildByLabel(s, !0); if (n) return n } return null }, getChildrenByLabel(s, e = !1, t = []) { const r = this.children; for (let i = 0; i < r.length; i++) { const n = r[i]; (n.label === s || s instanceof RegExp && s.test(n.label)) && t.push(n) } if (e) for (let i = 0; i < r.length; i++)r[i].getChildrenByLabel(s, !0, t); return t } }, ye = new gi(D), Ye = new gi(xe), qc = new D, Zc = { getFastGlobalBounds(s, e) { e || (e = new xe), e.clear(), this._getGlobalBoundsRecursive(!!s, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0); const t = this.renderGroup || this.parentRenderGroup; return e.applyMatrix(t.worldTransform), e }, _getGlobalBoundsRecursive(s, e, t) { let r = e; if (s && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable) return; const i = !!this.effects.length; if ((this.renderGroup || i) && (r = Ye.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform); else { if (this.renderPipeId) { const a = this.bounds; r.addFrame(a.minX, a.minY, a.maxX, a.maxY, this.groupTransform) } const n = this.children; for (let a = 0; a < n.length; a++)n[a]._getGlobalBoundsRecursive(s, r, t) } if (i) { let n = !1; const a = this.renderGroup || this.parentRenderGroup; for (let o = 0; o < this.effects.length; o++)this.effects[o].addBounds && (n || (n = !0, r.applyMatrix(a.worldTransform)), this.effects[o].addBounds(r, !0)); n && (r.applyMatrix(a.worldTransform.copyTo(qc).invert()), e.addBounds(r, this.relativeGroupTransform)), e.addBounds(r), Ye.return(r) } else this.renderGroup && (e.addBounds(r, this.relativeGroupTransform), Ye.return(r)) } }; function _i(s, e, t) { t.clear(); let r, i; return s.parent ? e ? r = s.parent.worldTransform : (i = ye.get().identity(), r = xi(s, i)) : r = D.IDENTITY, fo(s, t, r, e), i && ye.return(i), t.isValid || t.set(0, 0, 0, 0), t } function fo(s, e, t, r) { var o, h; if (!s.visible || !s.measurable) return; let i; r ? i = s.worldTransform : (s.updateLocalTransform(), i = ye.get(), i.appendFrom(s.localTransform, t)); const n = e, a = !!s.effects.length; if (a && (e = Ye.get().clear()), s.boundsArea) e.addRect(s.boundsArea, i); else { s.bounds && (e.matrix = i, e.addBounds(s.bounds)); for (let l = 0; l < s.children.length; l++)fo(s.children[l], e, i, r) } if (a) { for (let l = 0; l < s.effects.length; l++)(h = (o = s.effects[l]).addBounds) == null || h.call(o, e); n.addBounds(e, D.IDENTITY), Ye.return(e) } r || ye.return(i) } function xi(s, e) { const t = s.parent; return t && (xi(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e } function po(s, e) { if (s === 16777215 || !e) return e; if (e === 16777215 || !s) return s; const t = s >> 16 & 255, r = s >> 8 & 255, i = s & 255, n = e >> 16 & 255, a = e >> 8 & 255, o = e & 255, h = t * n / 255 | 0, l = r * a / 255 | 0, c = i * o / 255 | 0; return (h << 16) + (l << 8) + c } const wn = 16777215; function Dr(s, e) { return s === wn ? e : e === wn ? s : po(s, e) } function Mr(s) { return ((s & 255) << 16) + (s & 65280) + (s >> 16 & 255) } const Qc = { getGlobalAlpha(s) { if (s) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha; let e = this.alpha, t = this.parent; for (; t;)e *= t.alpha, t = t.parent; return e }, getGlobalTransform(s, e) { if (e) return s.copyFrom(this.worldTransform); this.updateLocalTransform(); const t = xi(this, ye.get().identity()); return s.appendFrom(this.localTransform, t), ye.return(t), s }, getGlobalTint(s) { if (s) return this.renderGroup ? Mr(this.renderGroup.worldColor) : this.parentRenderGroup ? Mr(Dr(this.localColor, this.parentRenderGroup.worldColor)) : this.tint; let e = this.localColor, t = this.parent; for (; t;)e = Dr(e, t.localColor), t = t.parent; return Mr(e) } }; let is = 0; const An = 500; function H(...s) { is !== An && (is++, is === An ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...s)) } function yi(s, e, t) { return e.clear(), t || (t = D.IDENTITY), mo(s, e, t, s, !0), e.isValid || e.set(0, 0, 0, 0), e } function mo(s, e, t, r, i) { var h, l; let n; if (i) n = ye.get(), n = t.copyTo(n); else { if (!s.visible || !s.measurable) return; s.updateLocalTransform(); const c = s.localTransform; n = ye.get(), n.appendFrom(c, t) } const a = e, o = !!s.effects.length; if (o && (e = Ye.get().clear()), s.boundsArea) e.addRect(s.boundsArea, n); else { s.renderPipeId && (e.matrix = n, e.addBounds(s.bounds)); const c = s.children; for (let u = 0; u < c.length; u++)mo(c[u], e, n, r, !1) } if (o) { for (let c = 0; c < s.effects.length; c++)(l = (h = s.effects[c]).addLocalBounds) == null || l.call(h, e, r); a.addBounds(e, D.IDENTITY), Ye.return(e) } ye.return(n) } function go(s, e) { const t = s.children; for (let r = 0; r < t.length; r++) { const i = t[r], n = i.uid, a = (i._didViewChangeTick & 65535) << 16 | i._didContainerChangeTick & 65535, o = e.index; (e.data[o] !== n || e.data[o + 1] !== a) && (e.data[e.index] = n, e.data[e.index + 1] = a, e.didChange = !0), e.index = o + 2, i.children.length && go(i, e) } return e.didChange } const Jc = new D, eu = { _localBoundsCacheId: -1, _localBoundsCacheData: null, _setWidth(s, e) { const t = Math.sign(this.scale.x) || 1; e !== 0 ? this.scale.x = s / e * t : this.scale.x = t }, _setHeight(s, e) { const t = Math.sign(this.scale.y) || 1; e !== 0 ? this.scale.y = s / e * t : this.scale.y = t }, getLocalBounds() { this._localBoundsCacheData || (this._localBoundsCacheData = { data: [], index: 1, didChange: !1, localBounds: new xe }); const s = this._localBoundsCacheData; return s.index = 1, s.didChange = !1, s.data[0] !== this._didViewChangeTick && (s.didChange = !0, s.data[0] = this._didViewChangeTick), go(this, s), s.didChange && yi(this, s.localBounds, Jc), s.localBounds }, getBounds(s, e) { return _i(this, s, e || new xe) } }, tu = { _onRender: null, set onRender(s) { const e = this.renderGroup || this.parentRenderGroup; if (!s) { this._onRender && (e == null || e.removeOnRender(this)), this._onRender = null; return } this._onRender || e == null || e.addOnRender(this), this._onRender = s }, get onRender() { return this._onRender } }, ru = { _zIndex: 0, sortDirty: !1, sortableChildren: !1, get zIndex() { return this._zIndex }, set zIndex(s) { this._zIndex !== s && (this._zIndex = s, this.depthOfChildModified()) }, depthOfChildModified() { this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0) }, sortChildren() { this.sortDirty && (this.sortDirty = !1, this.children.sort(su)) } }; function su(s, e) { return s._zIndex - e._zIndex } const iu = { getGlobalPosition(s = new oe, e = !1) { return this.parent ? this.parent.toGlobal(this._position, s, e) : (s.x = this._position.x, s.y = this._position.y), s }, toGlobal(s, e, t = !1) { const r = this.getGlobalTransform(ye.get(), t); return e = r.apply(s, e), ye.return(r), e }, toLocal(s, e, t, r) { e && (s = e.toGlobal(s, t, r)); const i = this.getGlobalTransform(ye.get(), r); return t = i.applyInverse(s, t), ye.return(i), t } }; class _o { constructor() { this.uid = he("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0 } reset() { this.instructionSize = 0 } add(e) { this.instructions[this.instructionSize++] = e } log() { this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]) } } let nu = 0; class au { constructor(e) { this._poolKeyHash = Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1 } createTexture(e, t, r) { const i = new ge({ ...this.textureOptions, width: e, height: t, resolution: 1, antialias: r, autoGarbageCollect: !1 }); return new F({ source: i, label: `texturePool_${nu++}` }) } getOptimalTexture(e, t, r = 1, i) { let n = Math.ceil(e * r - 1e-6), a = Math.ceil(t * r - 1e-6); n = Et(n), a = Et(a); const o = (n << 17) + (a << 1) + (i ? 1 : 0); this._texturePool[o] || (this._texturePool[o] = []); let h = this._texturePool[o].pop(); return h || (h = this.createTexture(n, a, i)), h.source._resolution = r, h.source.width = n / r, h.source.height = a / r, h.source.pixelWidth = n, h.source.pixelHeight = a, h.frame.x = 0, h.frame.y = 0, h.frame.width = e, h.frame.height = t, h.updateUvs(), this._poolKeyHash[h.uid] = o, h } getSameSizeTexture(e, t = !1) { const r = e.source; return this.getOptimalTexture(e.width, e.height, r._resolution, t) } returnTexture(e) { const t = this._poolKeyHash[e.uid]; this._texturePool[t].push(e) } clear(e) { if (e = e !== !1, e) for (const t in this._texturePool) { const r = this._texturePool[t]; if (r) for (let i = 0; i < r.length; i++)r[i].destroy(!0) } this._texturePool = {} } } const _e = new au; class ou { constructor() { this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new D, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new _o, this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7 } init(e) { this.root = e, e._onRender && this.addOnRender(e), e.didChange = !0; const t = e.children; for (let r = 0; r < t.length; r++) { const i = t[r]; i._updateFlags = 15, this.addChild(i) } } enableCacheAsTexture(e = {}) { this.textureOptions = e, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0 } disableCacheAsTexture() { this.isCachedAsTexture = !1, this.texture && (_e.returnTexture(this.texture), this.texture = null) } updateCacheTexture() { this.textureNeedsUpdate = !0 } reset() { this.renderGroupChildren.length = 0; for (const e in this.childrenToUpdate) { const t = this.childrenToUpdate[e]; t.list.fill(null), t.index = 0 } this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture() } get localTransform() { return this.root.localTransform } addRenderGroupChild(e) { e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e) } _removeRenderGroupChild(e) { const t = this.renderGroupChildren.indexOf(e); t > -1 && this.renderGroupChildren.splice(t, 1), e.renderGroupParent = null } addChild(e) { if (this.structureDidChange = !0, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = !0, this.onChildUpdate(e), e.renderGroup) { this.addRenderGroupChild(e.renderGroup); return } e._onRender && this.addOnRender(e); const t = e.children; for (let r = 0; r < t.length; r++)this.addChild(t[r]) } removeChild(e) { if (this.structureDidChange = !0, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) { this._removeRenderGroupChild(e.renderGroup); return } const t = e.children; for (let r = 0; r < t.length; r++)this.removeChild(t[r]) } removeChildren(e) { for (let t = 0; t < e.length; t++)this.removeChild(e[t]) } onChildUpdate(e) { let t = this.childrenToUpdate[e.relativeRenderGroupDepth]; t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = { index: 0, list: [] }), t.list[t.index++] = e } updateRenderable(e) { e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = !1) } onChildViewUpdate(e) { this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e } get isRenderable() { return this.root.localDisplayStatus === 7 && this.worldAlpha > 0 } addOnRender(e) { this._onRenderContainers.push(e) } removeOnRender(e) { this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1) } runOnRender(e) { for (let t = 0; t < this._onRenderContainers.length; t++)this._onRenderContainers[t]._onRender(e) } destroy() { this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null } getChildren(e = []) { const t = this.root.children; for (let r = 0; r < t.length; r++)this._getChildren(t[r], e); return e } _getChildren(e, t = []) { if (t.push(e), e.renderGroup) return t; const r = e.children; for (let i = 0; i < r.length; i++)this._getChildren(r[i], t); return t } invalidateMatrices() { this._matrixDirty = 7 } get inverseWorldTransform() { return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new D), this._inverseWorldTransform.copyFrom(this.worldTransform).invert()) } get textureOffsetInverseTransform() { return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new D), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y)) } get inverseParentTextureTransform() { if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform; this._matrixDirty &= -5; const e = this._parentCacheAsTextureRenderGroup; return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new D), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform } get cacheToLocalTransform() { return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null } } function hu(s, e, t = {}) { for (const r in e) !t[r] && e[r] !== void 0 && (s[r] = e[r]) } const ns = new me(null), as = new me(null), os = new me(null, 1, 1), Or = 1, bi = 2, jt = 4; class ve extends Ce { constructor(e = {}) { var t, r; super(), this.uid = he("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new D, this.relativeGroupTransform = new D, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new me(this, 0, 0), this._scale = os, this._pivot = as, this._skew = ns, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], hu(this, e, { children: !0, parent: !0, effects: !0 }), (t = e.children) == null || t.forEach(i => this.addChild(i)), (r = e.parent) == null || r.addChild(this) } static mixin(e) { X("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), z.mixin(ve, e) } set _didChangeId(e) { this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095 } get _didChangeId() { return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12 } addChild(...e) { if (this.allowChildren || X(ee, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) { for (let i = 0; i < e.length; i++)this.addChild(e[i]); return e[0] } const t = e[0], r = this.renderGroup || this.parentRenderGroup; return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1), this.children.push(t), r && (r.structureDidChange = !0), t) : (t.parent && t.parent.removeChild(t), this.children.push(t), this.sortableChildren && (this.sortDirty = !0), t.parent = this, t.didChange = !0, t._updateFlags = 15, r && r.addChild(t), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this), this._didViewChangeTick++, t._zIndex !== 0 && t.depthOfChildModified(), t) } removeChild(...e) { if (e.length > 1) { for (let i = 0; i < e.length; i++)this.removeChild(e[i]); return e[0] } const t = e[0], r = this.children.indexOf(t); return r > -1 && (this._didViewChangeTick++, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t), t.parentRenderLayer && t.parentRenderLayer.detach(t), t.parent = null, this.emit("childRemoved", t, this, r), t.emit("removed", this)), t } _onUpdate(e) { e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this)) } set isRenderGroup(e) { !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup()) } get isRenderGroup() { return !!this.renderGroup } enableRenderGroup() { if (this.renderGroup) return; const e = this.parentRenderGroup; e == null || e.removeChild(this), this.renderGroup = j.get(ou, this), this.groupTransform = D.IDENTITY, e == null || e.addChild(this), this._updateIsSimple() } disableRenderGroup() { if (!this.renderGroup) return; const e = this.parentRenderGroup; e == null || e.removeChild(this), j.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e == null || e.addChild(this), this._updateIsSimple() } _updateIsSimple() { this.isSimple = !this.renderGroup && this.effects.length === 0 } get worldTransform() { return this._worldTransform || (this._worldTransform = new D), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform } get x() { return this._position.x } set x(e) { this._position.x = e } get y() { return this._position.y } set y(e) { this._position.y = e } get position() { return this._position } set position(e) { this._position.copyFrom(e) } get rotation() { return this._rotation } set rotation(e) { this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew)) } get angle() { return this.rotation * Pc } set angle(e) { this.rotation = e * Ec } get pivot() { return this._pivot === as && (this._pivot = new me(this, 0, 0)), this._pivot } set pivot(e) { this._pivot === as && (this._pivot = new me(this, 0, 0)), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e) } get skew() { return this._skew === ns && (this._skew = new me(this, 0, 0)), this._skew } set skew(e) { this._skew === ns && (this._skew = new me(this, 0, 0)), this._skew.copyFrom(e) } get scale() { return this._scale === os && (this._scale = new me(this, 1, 1)), this._scale } set scale(e) { this._scale === os && (this._scale = new me(this, 0, 0)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e) } get width() { return Math.abs(this.scale.x * this.getLocalBounds().width) } set width(e) { const t = this.getLocalBounds().width; this._setWidth(e, t) } get height() { return Math.abs(this.scale.y * this.getLocalBounds().height) } set height(e) { const t = this.getLocalBounds().height; this._setHeight(e, t) } getSize(e) { e || (e = {}); const t = this.getLocalBounds(); return e.width = Math.abs(this.scale.x * t.width), e.height = Math.abs(this.scale.y * t.height), e } setSize(e, t) { const r = this.getLocalBounds(); typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, r.width), t !== void 0 && this._setHeight(t, r.height) } _updateSkew() { const e = this._rotation, t = this._skew; this._cx = Math.cos(e + t._y), this._sx = Math.sin(e + t._y), this._cy = -Math.sin(e - t._x), this._sy = Math.cos(e - t._x) } updateTransform(e) { return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this } setFromMatrix(e) { e.decompose(this) } updateLocalTransform() { const e = this._didContainerChangeTick; if (this._didLocalTransformChangeId === e) return; this._didLocalTransformChangeId = e; const t = this.localTransform, r = this._scale, i = this._pivot, n = this._position, a = r._x, o = r._y, h = i._x, l = i._y; t.a = this._cx * a, t.b = this._sx * a, t.c = this._cy * o, t.d = this._sy * o, t.tx = n._x - (h * t.a + l * t.c), t.ty = n._y - (h * t.b + l * t.d) } set alpha(e) { e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= Or, this._onUpdate()) } get alpha() { return this.localAlpha } set tint(e) { const r = ie.shared.setValue(e ?? 16777215).toBgrNumber(); r !== this.localColor && (this.localColor = r, this._updateFlags |= Or, this._onUpdate()) } get tint() { return Mr(this.localColor) } set blendMode(e) { this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= bi, this.localBlendMode = e, this._onUpdate()) } get blendMode() { return this.localBlendMode } get visible() { return !!(this.localDisplayStatus & 2) } set visible(e) { const t = e ? 2 : 0; (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= jt, this.localDisplayStatus ^= 2, this._onUpdate()) } get culled() { return !(this.localDisplayStatus & 4) } set culled(e) { const t = e ? 0 : 4; (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= jt, this.localDisplayStatus ^= 4, this._onUpdate()) } get renderable() { return !!(this.localDisplayStatus & 1) } set renderable(e) { const t = e ? 1 : 0; (this.localDisplayStatus & 1) !== t && (this._updateFlags |= jt, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate()) } get isRenderable() { return this.localDisplayStatus === 7 && this.groupAlpha > 0 } destroy(e = !1) { var i; if (this.destroyed) return; this.destroyed = !0; let t; if (this.children.length && (t = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e == null ? void 0 : e.children) && t) for (let n = 0; n < t.length; ++n)t[n].destroy(e); (i = this.renderGroup) == null || i.destroy(), this.renderGroup = null } } z.mixin(ve, $c, Zc, iu, tu, eu, Yc, Kc, ru, zc, Vc, Qc, Xc); class vi extends ve { constructor(e) { super(e), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._bounds = new xe(0, 1, 0, 0), this._boundsDirty = !0 } get bounds() { return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds } get roundPixels() { return !!this._roundPixels } set roundPixels(e) { this._roundPixels = e ? 1 : 0 } containsPoint(e) { const t = this.bounds, { x: r, y: i } = e; return r >= t.minX && r <= t.maxX && i >= t.minY && i <= t.maxY } onViewUpdate() { if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate) return; this.didViewUpdate = !0; const e = this.renderGroup || this.parentRenderGroup; e && e.onChildViewUpdate(this) } destroy(e) { super.destroy(e), this._bounds = null } collectRenderablesSimple(e, t, r) { const { renderPipes: i, renderableGC: n } = t; i.blendMode.setBlendMode(this, this.groupBlendMode, e), i[this.renderPipeId].addRenderable(this, e), n.addRenderable(this), this.didViewUpdate = !1; const o = this.children, h = o.length; for (let l = 0; l < h; l++)o[l].collectRenderables(e, t, r) } } class pt extends vi { constructor(e = F.EMPTY) { e instanceof F && (e = { texture: e }); const { texture: t = F.EMPTY, anchor: r, roundPixels: i, width: n, height: a, ...o } = e; super({ label: "Sprite", ...o }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._anchor = new me({ _onUpdate: () => { this.onViewUpdate() } }), r ? this.anchor = r : t.defaultAnchor && (this.anchor = t.defaultAnchor), this.texture = t, this.allowChildren = !1, this.roundPixels = i ?? !1, n !== void 0 && (this.width = n), a !== void 0 && (this.height = a) } static from(e, t = !1) { return e instanceof F ? new pt(e) : new pt(F.from(e, t)) } set texture(e) { e || (e = F.EMPTY); const t = this._texture; t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate()) } get texture() { return this._texture } get visualBounds() { return oo(this._visualBounds, this._anchor, this._texture), this._visualBounds } get sourceBounds() { return X("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds } updateBounds() { const e = this._anchor, t = this._texture, r = this._bounds, { width: i, height: n } = t.orig; r.minX = -e._x * i, r.maxX = r.minX + i, r.minY = -e._y * n, r.maxY = r.minY + n } destroy(e = !1) { if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) { const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource; this._texture.destroy(r) } this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null } get anchor() { return this._anchor } set anchor(e) { typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e) } get width() { return Math.abs(this.scale.x) * this._texture.orig.width } set width(e) { this._setWidth(e, this._texture.orig.width), this._width = e } get height() { return Math.abs(this.scale.y) * this._texture.orig.height } set height(e) { this._setHeight(e, this._texture.orig.height), this._height = e } getSize(e) { return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e } setSize(e, t) { typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), t !== void 0 && this._setHeight(t, this._texture.orig.height) } } const lu = new xe; function xo(s, e, t) { const r = lu; s.measurable = !0, _i(s, t, r), e.addBoundsMask(r), s.measurable = !1 } function yo(s, e, t) { const r = Ye.get(); s.measurable = !0; const i = ye.get().identity(), n = bo(s, t, i); yi(s, r, n), s.measurable = !1, e.addBoundsMask(r), ye.return(i), Ye.return(r) } function bo(s, e, t) { return s ? (s !== e && (bo(s.parent, e, t), s.updateLocalTransform(), t.append(s.localTransform)), t) : (H("Mask bounds, renderable is not inside the root container"), t) } class vo { constructor(e) { this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", e != null && e.mask && this.init(e.mask) } init(e) { this.mask = e, this.renderMaskToTexture = !(e instanceof pt), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1 } reset() { this.mask.measurable = !0, this.mask = null } addBounds(e, t) { this.inverse || xo(this.mask, e, t) } addLocalBounds(e, t) { yo(this.mask, e, t) } containsPoint(e, t) { const r = this.mask; return t(r, e) } destroy() { this.reset() } static test(e) { return e instanceof pt } } vo.extension = b.MaskEffect; class To { constructor(e) { this.priority = 0, this.pipe = "colorMask", e != null && e.mask && this.init(e.mask) } init(e) { this.mask = e } destroy() { } static test(e) { return typeof e == "number" } } To.extension = b.MaskEffect; class So { constructor(e) { this.priority = 0, this.pipe = "stencilMask", e != null && e.mask && this.init(e.mask) } init(e) { this.mask = e, this.mask.includeInBuild = !1, this.mask.measurable = !1 } reset() { this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null } addBounds(e, t) { xo(this.mask, e, t) } addLocalBounds(e, t) { yo(this.mask, e, t) } containsPoint(e, t) { const r = this.mask; return t(r, e) } destroy() { this.reset() } static test(e) { return e instanceof ve } } So.extension = b.MaskEffect; const cu = { createCanvas: (s, e) => { const t = document.createElement("canvas"); return t.width = s, t.height = e, t }, getCanvasRenderingContext2D: () => CanvasRenderingContext2D, getWebGLRenderingContext: () => WebGLRenderingContext, getNavigator: () => navigator, getBaseUrl: () => document.baseURI ?? window.location.href, getFontFaceSet: () => document.fonts, fetch: (s, e) => fetch(s, e), parseXML: s => new DOMParser().parseFromString(s, "text/xml") }; let Pn = cu; const K = { get() { return Pn }, set(s) { Pn = s } }; class Ke extends ge { constructor(e) { e.resource || (e.resource = K.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent } resizeCanvas() { this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight) } resize(e = this.width, t = this.height, r = this._resolution) { const i = super.resize(e, t, r); return i && this.resizeCanvas(), i } static test(e) { return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas } get context2D() { return this._context2D || (this._context2D = this.resource.getContext("2d")) } } Ke.extension = b.TextureSource; class mt extends ge { constructor(e) { if (e.resource && globalThis.HTMLImageElement && e.resource instanceof HTMLImageElement) { const t = K.get().createCanvas(e.resource.width, e.resource.height); t.getContext("2d").drawImage(e.resource, 0, 0, e.resource.width, e.resource.height), e.resource = t, H("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.") } super(e), this.uploadMethodId = "image", this.autoGarbageCollect = !0 } static test(e) { return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame } } mt.extension = b.TextureSource; var Qt = (s => (s[s.INTERACTION = 50] = "INTERACTION", s[s.HIGH = 25] = "HIGH", s[s.NORMAL = 0] = "NORMAL", s[s.LOW = -25] = "LOW", s[s.UTILITY = -50] = "UTILITY", s))(Qt || {}); class hs { constructor(e, t = null, r = 0, i = !1) { this.next = null, this.previous = null, this._destroyed = !1, this._fn = e, this._context = t, this.priority = r, this._once = i } match(e, t = null) { return this._fn === e && this._context === t } emit(e) { this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e)); const t = this.next; return this._once && this.destroy(!0), this._destroyed && (this.next = null), t } connect(e) { this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this } destroy(e = !1) { this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous); const t = this.next; return this.next = e ? null : t, this.previous = null, t } } const wo = class we { constructor() { this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new hs(null, null, 1 / 0), this.deltaMS = 1 / we.targetFPMS, this.elapsedMS = 1 / we.targetFPMS, this._tick = e => { this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick))) } } _requestIfNeeded() { this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick)) } _cancelIfNeeded() { this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null) } _startIfPossible() { this.started ? this._requestIfNeeded() : this.autoStart && this.start() } add(e, t, r = Qt.NORMAL) { return this._addListener(new hs(e, t, r)) } addOnce(e, t, r = Qt.NORMAL) { return this._addListener(new hs(e, t, r, !0)) } _addListener(e) { let t = this._head.next, r = this._head; if (!t) e.connect(r); else { for (; t;) { if (e.priority > t.priority) { e.connect(r); break } r = t, t = t.next } e.previous || e.connect(r) } return this._startIfPossible(), this } remove(e, t) { let r = this._head.next; for (; r;)r.match(e, t) ? r = r.destroy() : r = r.next; return this._head.next || this._cancelIfNeeded(), this } get count() { if (!this._head) return 0; let e = 0, t = this._head; for (; t = t.next;)e++; return e } start() { this.started || (this.started = !0, this._requestIfNeeded()) } stop() { this.started && (this.started = !1, this._cancelIfNeeded()) } destroy() { if (!this._protected) { this.stop(); let e = this._head.next; for (; e;)e = e.destroy(!0); this._head.destroy(), this._head = null } } update(e = performance.now()) { let t; if (e > this.lastTime) { if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) { const n = e - this._lastFrame | 0; if (n < this._minElapsedMS) return; this._lastFrame = e - n % this._minElapsedMS } this.deltaMS = t, this.deltaTime = this.deltaMS * we.targetFPMS; const r = this._head; let i = r.next; for (; i;)i = i.emit(this); r.next || this._cancelIfNeeded() } else this.deltaTime = this.deltaMS = this.elapsedMS = 0; this.lastTime = e } get FPS() { return 1e3 / this.elapsedMS } get minFPS() { return 1e3 / this._maxElapsedMS } set minFPS(e) { const t = Math.min(this.maxFPS, e), r = Math.min(Math.max(0, t) / 1e3, we.targetFPMS); this._maxElapsedMS = 1 / r } get maxFPS() { return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0 } set maxFPS(e) { if (e === 0) this._minElapsedMS = 0; else { const t = Math.max(this.minFPS, e); this._minElapsedMS = 1 / (t / 1e3) } } static get shared() { if (!we._shared) { const e = we._shared = new we; e.autoStart = !0, e._protected = !0 } return we._shared } static get system() { if (!we._system) { const e = we._system = new we; e.autoStart = !0, e._protected = !0 } return we._system } }; wo.targetFPMS = .06; let Ve = wo, ls; async function Ao() { return ls ?? (ls = (async () => { var a; const e = document.createElement("canvas").getContext("webgl"); if (!e) return "premultiply-alpha-on-upload"; const t = await new Promise(o => { const h = document.createElement("video"); h.onloadeddata = () => o(h), h.onerror = () => o(null), h.autoplay = !1, h.crossOrigin = "anonymous", h.preload = "auto", h.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", h.load() }); if (!t) return "premultiply-alpha-on-upload"; const r = e.createTexture(); e.bindTexture(e.TEXTURE_2D, r); const i = e.createFramebuffer(); e.bindFramebuffer(e.FRAMEBUFFER, i), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t); const n = new Uint8Array(4); return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, n), e.deleteFramebuffer(i), e.deleteTexture(r), (a = e.getExtension("WEBGL_lose_context")) == null || a.loseContext(), n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload" })()), ls } const jr = class Po extends ge { constructor(e) { super(e), this.isReady = !1, this.uploadMethodId = "video", e = { ...Po.defaultOptions, ...e }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== !1, this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== !1 && this.load() } updateFrame() { if (!this.destroyed) { if (this._updateFPS) { const e = Ve.shared.elapsedMS * this.resource.playbackRate; this._msToNextUpdate = Math.floor(this._msToNextUpdate - e) } (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update() } } _videoFrameRequestCallback() { this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback) } get isValid() { return !!this.resource.videoWidth && !!this.resource.videoHeight } async load() { if (this._load) return this._load; const e = this.resource, t = this.options; return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, !0)), this.alphaMode = await Ao(), this._load = new Promise((r, i) => { this.isValid ? r(this) : (this._resolve = r, this._reject = i, t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => { this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`)) })), e.load()) }), this._load } _onError(e) { this.resource.removeEventListener("error", this._onError, !0), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null) } _isSourcePlaying() { const e = this.resource; return !e.paused && !e.ended } _isSourceReady() { return this.resource.readyState > 2 } _onPlayStart() { this.isValid || this._mediaReady(), this._configureAutoUpdate() } _onPlayStop() { this._configureAutoUpdate() } _onSeeked() { this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0) } _onCanPlay() { this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady() } _onCanPlayThrough() { this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady() } _mediaReady() { const e = this.resource; this.isValid && (this.isReady = !0, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play() } destroy() { this._configureAutoUpdate(); const e = this.resource; e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.destroy() } get autoUpdate() { return this._autoUpdate } set autoUpdate(e) { e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate()) } get updateFPS() { return this._updateFPS } set updateFPS(e) { e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate()) } _configureAutoUpdate() { this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ve.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ve.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ve.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0)) } static test(e) { return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement } }; jr.extension = b.TextureSource; jr.defaultOptions = { ...ge.defaultOptions, autoLoad: !0, autoPlay: !0, updateFPS: 0, crossorigin: !0, loop: !1, muted: !0, playsinline: !0, preload: !1 }; jr.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }; let Br = jr; const Ue = (s, e, t = !1) => (Array.isArray(s) || (s = [s]), e ? s.map(r => typeof r == "string" || t ? e(r) : r) : s); class uu { constructor() { this._parsers = [], this._cache = new Map, this._cacheMap = new Map } reset() { this._cacheMap.clear(), this._cache.clear() } has(e) { return this._cache.has(e) } get(e) { const t = this._cache.get(e); return t || H(`[Assets] Asset id ${e} was not found in the Cache`), t } set(e, t) { const r = Ue(e); let i; for (let h = 0; h < this.parsers.length; h++) { const l = this.parsers[h]; if (l.test(t)) { i = l.getCacheableAssets(r, t); break } } const n = new Map(Object.entries(i || {})); i || r.forEach(h => { n.set(h, t) }); const a = [...n.keys()], o = { cacheKeys: a, keys: r }; r.forEach(h => { this._cacheMap.set(h, o) }), a.forEach(h => { const l = i ? i[h] : t; this._cache.has(h) && this._cache.get(h) !== l && H("[Cache] already has key:", h), this._cache.set(h, n.get(h)) }) } remove(e) { if (!this._cacheMap.has(e)) { H(`[Assets] Asset id ${e} was not found in the Cache`); return } const t = this._cacheMap.get(e); t.cacheKeys.forEach(i => { this._cache.delete(i) }), t.keys.forEach(i => { this._cacheMap.delete(i) }) } get parsers() { return this._parsers } } const ae = new uu, $s = []; z.handleByList(b.TextureSource, $s); function Eo(s = {}) { const e = s && s.resource, t = e ? s.resource : s, r = e ? s : { resource: s }; for (let i = 0; i < $s.length; i++) { const n = $s[i]; if (n.test(t)) return new n(r) } throw new Error(`Could not find a source type for resource: ${r.resource}`) } function du(s = {}, e = !1) { const t = s && s.resource, r = t ? s.resource : s, i = t ? s : { resource: s }; if (!e && ae.has(r)) return ae.get(r); const n = new F({ source: Eo(i) }); return n.on("destroy", () => { ae.has(r) && ae.remove(r) }), e || ae.set(r, n), n } function fu(s, e = !1) { return typeof s == "string" ? ae.get(s) : s instanceof ge ? new F({ source: s }) : du(s, e) } F.from = fu; ge.from = Eo; z.add(vo, To, So, Br, mt, Ke, mi); var nt = (s => (s[s.Low = 0] = "Low", s[s.Normal = 1] = "Normal", s[s.High = 2] = "High", s))(nt || {}); function Ge(s) { if (typeof s != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(s)}`) } function Ut(s) { return s.split("?")[0].split("#")[0] } function pu(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } function mu(s, e, t) { return s.replace(new RegExp(pu(e), "g"), t) } function gu(s, e) { let t = "", r = 0, i = -1, n = 0, a = -1; for (let o = 0; o <= s.length; ++o) { if (o < s.length) a = s.charCodeAt(o); else { if (a === 47) break; a = 47 } if (a === 47) { if (!(i === o - 1 || n === 1)) if (i !== o - 1 && n === 2) { if (t.length < 2 || r !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) { if (t.length > 2) { const h = t.lastIndexOf("/"); if (h !== t.length - 1) { h === -1 ? (t = "", r = 0) : (t = t.slice(0, h), r = t.length - 1 - t.lastIndexOf("/")), i = o, n = 0; continue } } else if (t.length === 2 || t.length === 1) { t = "", r = 0, i = o, n = 0; continue } } } else t.length > 0 ? t += `/${s.slice(i + 1, o)}` : t = s.slice(i + 1, o), r = o - i - 1; i = o, n = 0 } else a === 46 && n !== -1 ? ++n : n = -1 } return t } const Pe = { toPosix(s) { return mu(s, "\\", "/") }, isUrl(s) { return /^https?:/.test(this.toPosix(s)) }, isDataUrl(s) { return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(s) }, isBlobUrl(s) { return s.startsWith("blob:") }, hasProtocol(s) { return /^[^/:]+:/.test(this.toPosix(s)) }, getProtocol(s) { Ge(s), s = this.toPosix(s); const e = /^file:\/\/\//.exec(s); if (e) return e[0]; const t = /^[^/:]+:\/{0,2}/.exec(s); return t ? t[0] : "" }, toAbsolute(s, e, t) { if (Ge(s), this.isDataUrl(s) || this.isBlobUrl(s)) return s; const r = Ut(this.toPosix(e ?? K.get().getBaseUrl())), i = Ut(this.toPosix(t ?? this.rootname(r))); return s = this.toPosix(s), s.startsWith("/") ? Pe.join(i, s.slice(1)) : this.isAbsolute(s) ? s : this.join(r, s) }, normalize(s) { if (Ge(s), s.length === 0) return "."; if (this.isDataUrl(s) || this.isBlobUrl(s)) return s; s = this.toPosix(s); let e = ""; const t = s.startsWith("/"); this.hasProtocol(s) && (e = this.rootname(s), s = s.slice(e.length)); const r = s.endsWith("/"); return s = gu(s), s.length > 0 && r && (s += "/"), t ? `/${s}` : e + s }, isAbsolute(s) { return Ge(s), s = this.toPosix(s), this.hasProtocol(s) ? !0 : s.startsWith("/") }, join(...s) { if (s.length === 0) return "."; let e; for (let t = 0; t < s.length; ++t) { const r = s[t]; if (Ge(r), r.length > 0) if (e === void 0) e = r; else { const i = s[t - 1] ?? ""; this.joinExtensions.includes(this.extname(i).toLowerCase()) ? e += `/../${r}` : e += `/${r}` } } return e === void 0 ? "." : this.normalize(e) }, dirname(s) { if (Ge(s), s.length === 0) return "."; s = this.toPosix(s); let e = s.charCodeAt(0); const t = e === 47; let r = -1, i = !0; const n = this.getProtocol(s), a = s; s = s.slice(n.length); for (let o = s.length - 1; o >= 1; --o)if (e = s.charCodeAt(o), e === 47) { if (!i) { r = o; break } } else i = !1; return r === -1 ? t ? "/" : this.isUrl(a) ? n + s : n : t && r === 1 ? "//" : n + s.slice(0, r) }, rootname(s) { Ge(s), s = this.toPosix(s); let e = ""; if (s.startsWith("/") ? e = "/" : e = this.getProtocol(s), this.isUrl(s)) { const t = s.indexOf("/", e.length); t !== -1 ? e = s.slice(0, t) : e = s, e.endsWith("/") || (e += "/") } return e }, basename(s, e) { Ge(s), e && Ge(e), s = Ut(this.toPosix(s)); let t = 0, r = -1, i = !0, n; if (e !== void 0 && e.length > 0 && e.length <= s.length) { if (e.length === s.length && e === s) return ""; let a = e.length - 1, o = -1; for (n = s.length - 1; n >= 0; --n) { const h = s.charCodeAt(n); if (h === 47) { if (!i) { t = n + 1; break } } else o === -1 && (i = !1, o = n + 1), a >= 0 && (h === e.charCodeAt(a) ? --a === -1 && (r = n) : (a = -1, r = o)) } return t === r ? r = o : r === -1 && (r = s.length), s.slice(t, r) } for (n = s.length - 1; n >= 0; --n)if (s.charCodeAt(n) === 47) { if (!i) { t = n + 1; break } } else r === -1 && (i = !1, r = n + 1); return r === -1 ? "" : s.slice(t, r) }, extname(s) { Ge(s), s = Ut(this.toPosix(s)); let e = -1, t = 0, r = -1, i = !0, n = 0; for (let a = s.length - 1; a >= 0; --a) { const o = s.charCodeAt(a); if (o === 47) { if (!i) { t = a + 1; break } continue } r === -1 && (i = !1, r = a + 1), o === 46 ? e === -1 ? e = a : n !== 1 && (n = 1) : e !== -1 && (n = -1) } return e === -1 || r === -1 || n === 0 || n === 1 && e === r - 1 && e === t + 1 ? "" : s.slice(e, r) }, parse(s) { Ge(s); const e = { root: "", dir: "", base: "", ext: "", name: "" }; if (s.length === 0) return e; s = Ut(this.toPosix(s)); let t = s.charCodeAt(0); const r = this.isAbsolute(s); let i; e.root = this.rootname(s), r || this.hasProtocol(s) ? i = 1 : i = 0; let n = -1, a = 0, o = -1, h = !0, l = s.length - 1, c = 0; for (; l >= i; --l) { if (t = s.charCodeAt(l), t === 47) { if (!h) { a = l + 1; break } continue } o === -1 && (h = !1, o = l + 1), t === 46 ? n === -1 ? n = l : c !== 1 && (c = 1) : n !== -1 && (c = -1) } return n === -1 || o === -1 || c === 0 || c === 1 && n === o - 1 && n === a + 1 ? o !== -1 && (a === 0 && r ? e.base = e.name = s.slice(1, o) : e.base = e.name = s.slice(a, o)) : (a === 0 && r ? (e.name = s.slice(1, n), e.base = s.slice(1, o)) : (e.name = s.slice(a, n), e.base = s.slice(a, o)), e.ext = s.slice(n, o)), e.dir = this.dirname(s), e }, sep: "/", delimiter: ":", joinExtensions: [".html"] }; function Co(s, e, t, r, i) { const n = e[t]; for (let a = 0; a < n.length; a++) { const o = n[a]; t < e.length - 1 ? Co(s.replace(r[t], o), e, t + 1, r, i) : i.push(s.replace(r[t], o)) } } function _u(s) { const e = /\{(.*?)\}/g, t = s.match(e), r = []; if (t) { const i = []; t.forEach(n => { const a = n.substring(1, n.length - 1).split(","); i.push(a) }), Co(s, i, 0, t, r) } else r.push(s); return r } const Lr = s => !Array.isArray(s); class Rt { constructor() { this._defaultBundleIdentifierOptions = { connector: "-", createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`, extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "") }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {} } setBundleIdentifier(e) { if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly") } prefer(...e) { e.forEach(t => { this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params)) }), this._resolverHash = {} } set basePath(e) { this._basePath = e } get basePath() { return this._basePath } set rootPath(e) { this._rootPath = e } get rootPath() { return this._rootPath } get parsers() { return this._parsers } reset() { this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null } setDefaultSearchParams(e) { if (typeof e == "string") this._defaultSearchParams = e; else { const t = e; this._defaultSearchParams = Object.keys(t).map(r => `${encodeURIComponent(r)}=${encodeURIComponent(t[r])}`).join("&") } } getAlias(e) { const { alias: t, src: r } = e; return Ue(t || r, n => typeof n == "string" ? n : Array.isArray(n) ? n.map(a => (a == null ? void 0 : a.src) ?? a) : n != null && n.src ? n.src : n, !0) } addManifest(e) { this._manifest && H("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach(t => { this.addBundle(t.name, t.assets) }) } addBundle(e, t) { const r = []; let i = t; Array.isArray(t) || (i = Object.entries(t).map(([n, a]) => typeof a == "string" || Array.isArray(a) ? { alias: n, src: a } : { alias: n, ...a })), i.forEach(n => { const a = n.src, o = n.alias; let h; if (typeof o == "string") { const l = this._createBundleAssetId(e, o); r.push(l), h = [o, l] } else { const l = o.map(c => this._createBundleAssetId(e, c)); r.push(...l), h = [...o, ...l] } this.add({ ...n, alias: h, src: a }) }), this._bundles[e] = r } add(e) { const t = []; Array.isArray(e) ? t.push(...e) : t.push(e); let r; r = n => { this.hasKey(n) && H(`[Resolver] already has key: ${n} overwriting`) }, Ue(t).forEach(n => { const { src: a } = n; let { data: o, format: h, loadParser: l } = n; const c = Ue(a).map(f => typeof f == "string" ? _u(f) : Array.isArray(f) ? f : [f]), u = this.getAlias(n); Array.isArray(u) ? u.forEach(r) : r(u); const d = []; c.forEach(f => { f.forEach(p => { let g = {}; if (typeof p != "object") { g.src = p; for (let m = 0; m < this._parsers.length; m++) { const y = this._parsers[m]; if (y.test(p)) { g = y.parse(p); break } } } else o = p.data ?? o, h = p.format ?? h, l = p.loadParser ?? l, g = { ...g, ...p }; if (!u) throw new Error(`[Resolver] alias is undefined for this asset: ${g.src}`); g = this._buildResolvedAsset(g, { aliases: u, data: o, format: h, loadParser: l }), d.push(g) }) }), u.forEach(f => { this._assetMap[f] = d }) }) } resolveBundle(e) { const t = Lr(e); e = Ue(e); const r = {}; return e.forEach(i => { const n = this._bundles[i]; if (n) { const a = this.resolve(n), o = {}; for (const h in a) { const l = a[h]; o[this._extractAssetIdFromBundle(i, h)] = l } r[i] = o } }), t ? r[e[0]] : r } resolveUrl(e) { const t = this.resolve(e); if (typeof e != "string") { const r = {}; for (const i in t) r[i] = t[i].src; return r } return t.src } resolve(e) { const t = Lr(e); e = Ue(e); const r = {}; return e.forEach(i => { if (!this._resolverHash[i]) if (this._assetMap[i]) { let n = this._assetMap[i]; const a = this._getPreferredOrder(n); a == null || a.priority.forEach(o => { a.params[o].forEach(h => { const l = n.filter(c => c[o] ? c[o] === h : !1); l.length && (n = l) }) }), this._resolverHash[i] = n[0] } else this._resolverHash[i] = this._buildResolvedAsset({ alias: [i], src: i }, {}); r[i] = this._resolverHash[i] }), t ? r[e[0]] : r } hasKey(e) { return !!this._assetMap[e] } hasBundle(e) { return !!this._bundles[e] } _getPreferredOrder(e) { for (let t = 0; t < e.length; t++) { const r = e[t], i = this._preferredOrder.find(n => n.params.format.includes(r.format)); if (i) return i } return this._preferredOrder[0] } _appendDefaultSearchParams(e) { if (!this._defaultSearchParams) return e; const t = /\?/.test(e) ? "&" : "?"; return `${e}${t}${this._defaultSearchParams}` } _buildResolvedAsset(e, t) { const { aliases: r, data: i, loadParser: n, format: a } = t; return (this._basePath || this._rootPath) && (e.src = Pe.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = r ?? e.alias ?? [e.src], e.src = this._appendDefaultSearchParams(e.src), e.data = { ...i || {}, ...e.data }, e.loadParser = n ?? e.loadParser, e.format = a ?? e.format ?? xu(e.src), e } } Rt.RETINA_PREFIX = /@([0-9\.]+)x/; function xu(s) { return s.split(".").pop().split("?").shift().split("#").shift() } const Xs = (s, e) => { const t = e.split("?")[1]; return t && (s += `?${t}`), s }, Mo = class Wt { constructor(e, t) { this.linkedSheets = [], this._texture = e instanceof F ? e : null, this.textureSource = e.source, this.textures = {}, this.animations = {}, this.data = t; const r = parseFloat(t.meta.scale); r ? (this.resolution = r, e.source.resolution = this.resolution) : this.resolution = e.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null } parse() { return new Promise(e => { this._callback = e, this._batchIndex = 0, this._frameKeys.length <= Wt.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch() }) } _processFrames(e) { let t = e; const r = Wt.BATCH_SIZE; for (; t - e < r && t < this._frameKeys.length;) { const i = this._frameKeys[t], n = this._frames[i], a = n.frame; if (a) { let o = null, h = null; const l = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame, c = new ne(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution); n.rotated ? o = new ne(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : o = new ne(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), n.trimmed !== !1 && n.spriteSourceSize && (h = new ne(Math.floor(n.spriteSourceSize.x) / this.resolution, Math.floor(n.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[i] = new F({ source: this.textureSource, frame: o, orig: c, trim: h, rotate: n.rotated ? 2 : 0, defaultAnchor: n.anchor, defaultBorders: n.borders, label: i.toString() }) } t++ } } _processAnimations() { const e = this.data.animations || {}; for (const t in e) { this.animations[t] = []; for (let r = 0; r < e[t].length; r++) { const i = e[t][r]; this.animations[t].push(this.textures[i]) } } } _parseComplete() { const e = this._callback; this._callback = null, this._batchIndex = 0, e.call(this, this.textures) } _nextBatch() { this._processFrames(this._batchIndex * Wt.BATCH_SIZE), this._batchIndex++, setTimeout(() => { this._batchIndex * Wt.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete()) }, 0) } destroy(e = !1) { var t; for (const r in this.textures) this.textures[r].destroy(); this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((t = this._texture) == null || t.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [] } }; Mo.BATCH_SIZE = 1e3; let En = Mo; const yu = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"]; function Bo(s, e, t) { const r = {}; if (s.forEach(i => { r[i] = e }), Object.keys(e.textures).forEach(i => { r[i] = e.textures[i] }), !t) { const i = Pe.dirname(s[0]); e.linkedSheets.forEach((n, a) => { const o = Bo([`${i}/${e.data.meta.related_multi_packs[a]}`], n, !0); Object.assign(r, o) }) } return r } const bu = { extension: b.Asset, cache: { test: s => s instanceof En, getCacheableAssets: (s, e) => Bo(s, e, !1) }, resolver: { extension: { type: b.ResolveParser, name: "resolveSpritesheet" }, test: s => { const t = s.split("?")[0].split("."), r = t.pop(), i = t.pop(); return r === "json" && yu.includes(i) }, parse: s => { var t; const e = s.split("."); return { resolution: parseFloat(((t = Rt.RETINA_PREFIX.exec(s)) == null ? void 0 : t[1]) ?? "1"), format: e[e.length - 2], src: s } } }, loader: { name: "spritesheetLoader", extension: { type: b.LoadParser, priority: nt.Normal, name: "spritesheetLoader" }, async testParse(s, e) { return Pe.extname(e.src).toLowerCase() === ".json" && !!s.frames }, async parse(s, e, t) { var c, u; const { texture: r, imageFilename: i, textureOptions: n } = (e == null ? void 0 : e.data) ?? {}; let a = Pe.dirname(e.src); a && a.lastIndexOf("/") !== a.length - 1 && (a += "/"); let o; if (r instanceof F) o = r; else { const d = Xs(a + (i ?? s.meta.image), e.src); o = (await t.load([{ src: d, data: n }]))[d] } const h = new En(o.source, s); await h.parse(); const l = (c = s == null ? void 0 : s.meta) == null ? void 0 : c.related_multi_packs; if (Array.isArray(l)) { const d = []; for (const p of l) { if (typeof p != "string") continue; let g = a + p; (u = e.data) != null && u.ignoreMultiPack || (g = Xs(g, e.src), d.push(t.load({ src: g, data: { textureOptions: n, ignoreMultiPack: !0 } }))) } const f = await Promise.all(d); h.linkedSheets = f, f.forEach(p => { p.linkedSheets = [h].concat(h.linkedSheets.filter(g => g !== p)) }) } return h }, async unload(s, e, t) { await t.unload(s.textureSource._sourceOrigin), s.destroy(!1) } } }; z.add(bu); class sr { constructor(e) { this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = sr.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new oe, this.page = new oe, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = e } get layerX() { return this.layer.x } get layerY() { return this.layer.y } get pageX() { return this.page.x } get pageY() { return this.page.y } get data() { return this } composedPath() { return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path } initEvent(e, t, r) { throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } initUIEvent(e, t, r, i, n) { throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.") } preventDefault() { this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0 } stopImmediatePropagation() { this.propagationImmediatelyStopped = !0 } stopPropagation() { this.propagationStopped = !0 } } var cs = /iPhone/i, Cn = /iPod/i, Mn = /iPad/i, Bn = /\biOS-universal(?:.+)Mac\b/i, us = /\bAndroid(?:.+)Mobile\b/i, Rn = /Android/i, _t = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, pr = /Silk/i, je = /Windows Phone/i, kn = /\bWindows(?:.+)ARM\b/i, In = /BlackBerry/i, Gn = /BB10/i, Fn = /Opera Mini/i, Un = /\b(CriOS|Chrome)(?:.+)Mobile/i, Dn = /Mobile(?:.+)Firefox\b/i, On = function(s) { return typeof s < "u" && s.platform === "MacIntel" && typeof s.maxTouchPoints == "number" && s.maxTouchPoints > 1 && typeof MSStream > "u" }; function vu(s) { return function(e) { return e.test(s) } } function Ln(s) { var e = { userAgent: "", platform: "", maxTouchPoints: 0 }; !s && typeof navigator < "u" ? e = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 } : typeof s == "string" ? e.userAgent = s : s && s.userAgent && (e = { userAgent: s.userAgent, platform: s.platform, maxTouchPoints: s.maxTouchPoints || 0 }); var t = e.userAgent, r = t.split("[FBAN"); typeof r[1] < "u" && (t = r[0]), r = t.split("Twitter"), typeof r[1] < "u" && (t = r[0]); var i = vu(t), n = { apple: { phone: i(cs) && !i(je), ipod: i(Cn), tablet: !i(cs) && (i(Mn) || On(e)) && !i(je), universal: i(Bn), device: (i(cs) || i(Cn) || i(Mn) || i(Bn) || On(e)) && !i(je) }, amazon: { phone: i(_t), tablet: !i(_t) && i(pr), device: i(_t) || i(pr) }, android: { phone: !i(je) && i(_t) || !i(je) && i(us), tablet: !i(je) && !i(_t) && !i(us) && (i(pr) || i(Rn)), device: !i(je) && (i(_t) || i(pr) || i(us) || i(Rn)) || i(/\bokhttp\b/i) }, windows: { phone: i(je), tablet: i(kn), device: i(je) || i(kn) }, other: { blackberry: i(In), blackberry10: i(Gn), opera: i(Fn), firefox: i(Dn), chrome: i(Un), device: i(In) || i(Gn) || i(Fn) || i(Dn) || i(Un) }, any: !1, phone: !1, tablet: !1 }; return n.any = n.apple.device || n.android.device || n.windows.device || n.other.device, n.phone = n.apple.phone || n.android.phone || n.windows.phone, n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet, n } const Tu = Ln.default ?? Ln, Su = Tu(globalThis.navigator), wu = 9, mr = 100, Au = 0, Pu = 0, Nn = 2, Hn = 1, Eu = -1e3, Cu = -1e3, Mu = 2, Ti = class Ro {
  constructor(e, t = Su) { this._mobileInfo = t, this.debug = !1, this._activateOnTab = !0, this._deactivateOnMouseMove = !0, this._isActive = !1, this._isMobileAccessibility = !1, this._div = null, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (t.tablet || t.phone) && this._createTouchHook(), this._renderer = e } get isActive() { return this._isActive } get isMobileAccessibility() { return this._isMobileAccessibility } get hookDiv() { return this._hookDiv } _createTouchHook() { const e = document.createElement("button"); e.style.width = `${Hn}px`, e.style.height = `${Hn}px`, e.style.position = "absolute", e.style.top = `${Eu}px`, e.style.left = `${Cu}px`, e.style.zIndex = Mu.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", () => { this._isMobileAccessibility = !0, this._activate(), this._destroyTouchHook() }), document.body.appendChild(e), this._hookDiv = e } _destroyTouchHook() { this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null) } _activate() { if (this._isActive) return; this._isActive = !0, this._div || (this._div = document.createElement("div"), this._div.style.width = `${mr}px`, this._div.style.height = `${mr}px`, this._div.style.position = "absolute", this._div.style.top = `${Au}px`, this._div.style.left = `${Pu}px`, this._div.style.zIndex = Nn.toString(), this._div.style.pointerEvents = "none"), this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._deactivateOnMouseMove && (this._onMouseMove = this._onMouseMove.bind(this), globalThis.document.addEventListener("mousemove", this._onMouseMove, !0)); const e = this._renderer.view.canvas; if (e.parentNode) e.parentNode.appendChild(this._div), this._initAccessibilitySetup(); else { const t = new MutationObserver(() => { e.parentNode && (e.parentNode.appendChild(this._div), t.disconnect(), this._initAccessibilitySetup()) }); t.observe(document.body, { childList: !0, subtree: !0 }) } } _initAccessibilitySetup() { this._renderer.runners.postrender.add(this), this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered) } _deactivate() { if (!(!this._isActive || this._isMobileAccessibility)) { this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1), this._renderer.runners.postrender.remove(this); for (const e of this._children) e._accessibleDiv && e._accessibleDiv.parentNode && (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv), e._accessibleDiv = null), e._accessibleActive = !1; this._pool.forEach(e => { e.parentNode && e.parentNode.removeChild(e) }), this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div), this._pool = [], this._children = [] } } _updateAccessibleObjects(e) { if (!e.visible || !e.accessibleChildren) return; e.accessible && (e._accessibleActive || this._addChild(e), e._renderId = this._renderId); const t = e.children; if (t) for (let r = 0; r < t.length; r++)this._updateAccessibleObjects(t[r]) } init(e) { const r = { accessibilityOptions: { ...Ro.defaultOptions, ...(e == null ? void 0 : e.accessibilityOptions) || {} } }; this.debug = r.accessibilityOptions.debug, this._activateOnTab = r.accessibilityOptions.activateOnTab, this._deactivateOnMouseMove = r.accessibilityOptions.deactivateOnMouseMove, r.accessibilityOptions.enabledByDefault ? this._activate() : this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._renderer.runners.postrender.remove(this) } postrender() { const e = performance.now(); if (this._mobileInfo.android.device && e < this._androidUpdateCount || (this._androidUpdateCount = e + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas)) return; const t = new Set; if (this._renderer.lastObjectRendered) { this._updateAccessibleObjects(this._renderer.lastObjectRendered); for (const r of this._children) r._renderId === this._renderId && t.add(this._children.indexOf(r)) } for (let r = this._children.length - 1; r >= 0; r--) { const i = this._children[r]; t.has(r) || (i._accessibleDiv && i._accessibleDiv.parentNode && (i._accessibleDiv.parentNode.removeChild(i._accessibleDiv), this._pool.push(i._accessibleDiv), i._accessibleDiv = null), i._accessibleActive = !1, uo(this._children, r, 1)) } if (this._renderer.renderingToScreen) { const { x: r, y: i, width: n, height: a } = this._renderer.screen, o = this._div; o.style.left = `${r}px`, o.style.top = `${i}px`, o.style.width = `${n}px`, o.style.height = `${a}px` } for (let r = 0; r < this._children.length; r++) { const i = this._children[r]; if (!i._accessibleActive || !i._accessibleDiv) continue; const n = i._accessibleDiv, a = i.hitArea || i.getBounds().rectangle; if (i.hitArea) { const o = i.worldTransform, h = this._renderer.resolution, l = this._renderer.resolution; n.style.left = `${(o.tx + a.x * o.a) * h}px`, n.style.top = `${(o.ty + a.y * o.d) * l}px`, n.style.width = `${a.width * o.a * h}px`, n.style.height = `${a.height * o.d * l}px` } else { this._capHitArea(a); const o = this._renderer.resolution, h = this._renderer.resolution; n.style.left = `${a.x * o}px`, n.style.top = `${a.y * h}px`, n.style.width = `${a.width * o}px`, n.style.height = `${a.height * h}px` } } this._renderId++ } _updateDebugHTML(e) { e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}` } _capHitArea(e) { e.x < 0 && (e.width += e.x, e.x = 0), e.y < 0 && (e.height += e.y, e.y = 0); const { width: t, height: r } = this._renderer; e.x + e.width > t && (e.width = t - e.x), e.y + e.height > r && (e.height = r - e.y) } _addChild(e) {
    let t = this._pool.pop(); t || (e.accessibleType === "button" ? t = document.createElement("button") : (t = document.createElement(e.accessibleType), t.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `, e.accessibleText && (t.innerText = e.accessibleText)), t.style.width = `${mr}px`, t.style.height = `${mr}px`, t.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", t.style.position = "absolute", t.style.zIndex = Nn.toString(), t.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? t.setAttribute("aria-live", "off") : t.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? t.setAttribute("aria-relevant", "additions") : t.setAttribute("aria-relevant", "text"), t.addEventListener("click", this._onClick.bind(this)), t.addEventListener("focus", this._onFocus.bind(this)), t.addEventListener("focusout", this._onFocusOut.bind(this))), t.style.pointerEvents = e.accessiblePointerEvents, t.type = e.accessibleType, e.accessibleTitle && e.accessibleTitle !== null ? t.title = e.accessibleTitle : (!e.accessibleHint || e.accessibleHint === null) && (t.title = `container ${e.tabIndex}`), e.accessibleHint && e.accessibleHint !== null && t.setAttribute("aria-label", e.accessibleHint), this.debug && this._updateDebugHTML(t), e._accessibleActive = !0, e._accessibleDiv = t, t.container = e, this._children.push(e), this._div.appendChild(e._accessibleDiv), e.interactive && (e._accessibleDiv.tabIndex = e.tabIndex)
  } _dispatchEvent(e, t) { const { container: r } = e.target, i = this._renderer.events.rootBoundary, n = Object.assign(new sr(i), { target: r }); i.rootTarget = this._renderer.lastObjectRendered, t.forEach(a => i.dispatchEvent(n, a)) } _onClick(e) { this._dispatchEvent(e, ["click", "pointertap", "tap"]) } _onFocus(e) { e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e, ["mouseover"]) } _onFocusOut(e) { e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e, ["mouseout"]) } _onKeyDown(e) { e.keyCode !== wu || !this._activateOnTab || this._activate() } _onMouseMove(e) { e.movementX === 0 && e.movementY === 0 || this._deactivate() } destroy() { this._deactivate(), this._destroyTouchHook(), this._div = null, this._pool = null, this._children = null, this._renderer = null, this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown) } setAccessibilityEnabled(e) { e ? this._activate() : this._deactivate() }
}; Ti.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "accessibility" }; Ti.defaultOptions = { enabledByDefault: !1, debug: !1, activateOnTab: !0, deactivateOnMouseMove: !0 }; let Bu = Ti; const Ru = { accessible: !1, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: !1, _accessibleDiv: null, accessibleType: "button", accessibleText: null, accessiblePointerEvents: "auto", accessibleChildren: !0, _renderId: -1 }, ds = Object.create(null), zn = Object.create(null); function Jt(s, e) { let t = zn[s]; return t === void 0 && (ds[e] === void 0 && (ds[e] = 1), zn[s] = t = ds[e]++), t } let xt; function ko() { return (!xt || xt != null && xt.isContextLost()) && (xt = K.get().createCanvas().getContext("webgl", {})), xt } let gr; function ku() { if (!gr) { gr = "mediump"; const s = ko(); s && s.getShaderPrecisionFormat && (gr = s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision ? "highp" : "mediump") } return gr } function Iu(s, e, t) {
  return e ? s : t ? (s = s.replace("out vec4 finalColor;", ""), `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${s}
        `) : `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${s}
        `} function Gu(s, e, t) {
  const r = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision; if (s.substring(0, 9) !== "precision") {
    let i = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision; return i === "highp" && r !== "highp" && (i = "mediump"), `precision ${i} float;
${s}`
  } else if (r !== "highp" && s.substring(0, 15) === "precision highp") return s.replace("precision highp", "precision mediump"); return s
} function Fu(s, e) {
  return e ? `#version 300 es
${s}` : s
} const Uu = {}, Du = {}; function Ou(s, { name: e = "pixi-program" }, t = !0) {
  e = e.replace(/\s+/g, "-"), e += t ? "-fragment" : "-vertex"; const r = t ? Uu : Du; return r[e] ? (r[e]++, e += `-${r[e]}`) : r[e] = 1, s.indexOf("#define SHADER_NAME") !== -1 ? s : `${`#define SHADER_NAME ${e}`}
${s}`
} function Lu(s, e) { return e ? s.replace("#version 300 es", "") : s } const fs = { stripVersion: Lu, ensurePrecision: Gu, addProgramDefines: Iu, setProgramName: Ou, insertVersion: Fu }, ps = Object.create(null), Io = class js { constructor(e) { e = { ...js.defaultOptions, ...e }; const t = e.fragment.indexOf("#version 300 es") !== -1, r = { stripVersion: t, ensurePrecision: { requestedFragmentPrecision: e.preferredFragmentPrecision, requestedVertexPrecision: e.preferredVertexPrecision, maxSupportedVertexPrecision: "highp", maxSupportedFragmentPrecision: ku() }, setProgramName: { name: e.name }, addProgramDefines: t, insertVersion: t }; let i = e.fragment, n = e.vertex; Object.keys(fs).forEach(a => { const o = r[a]; i = fs[a](i, o, !0), n = fs[a](n, o, !1) }), this.fragment = i, this.vertex = n, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = Jt(`${this.vertex}:${this.fragment}`, "gl-program") } destroy() { this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null } static from(e) { const t = `${e.vertex}:${e.fragment}`; return ps[t] || (ps[t] = new js(e)), ps[t] } }; Io.defaultOptions = { preferredVertexPrecision: "highp", preferredFragmentPrecision: "mediump" }; let kt = Io; const Wn = { uint8x2: { size: 2, stride: 2, normalised: !1 }, uint8x4: { size: 4, stride: 4, normalised: !1 }, sint8x2: { size: 2, stride: 2, normalised: !1 }, sint8x4: { size: 4, stride: 4, normalised: !1 }, unorm8x2: { size: 2, stride: 2, normalised: !0 }, unorm8x4: { size: 4, stride: 4, normalised: !0 }, snorm8x2: { size: 2, stride: 2, normalised: !0 }, snorm8x4: { size: 4, stride: 4, normalised: !0 }, uint16x2: { size: 2, stride: 4, normalised: !1 }, uint16x4: { size: 4, stride: 8, normalised: !1 }, sint16x2: { size: 2, stride: 4, normalised: !1 }, sint16x4: { size: 4, stride: 8, normalised: !1 }, unorm16x2: { size: 2, stride: 4, normalised: !0 }, unorm16x4: { size: 4, stride: 8, normalised: !0 }, snorm16x2: { size: 2, stride: 4, normalised: !0 }, snorm16x4: { size: 4, stride: 8, normalised: !0 }, float16x2: { size: 2, stride: 4, normalised: !1 }, float16x4: { size: 4, stride: 8, normalised: !1 }, float32: { size: 1, stride: 4, normalised: !1 }, float32x2: { size: 2, stride: 8, normalised: !1 }, float32x3: { size: 3, stride: 12, normalised: !1 }, float32x4: { size: 4, stride: 16, normalised: !1 }, uint32: { size: 1, stride: 4, normalised: !1 }, uint32x2: { size: 2, stride: 8, normalised: !1 }, uint32x3: { size: 3, stride: 12, normalised: !1 }, uint32x4: { size: 4, stride: 16, normalised: !1 }, sint32: { size: 1, stride: 4, normalised: !1 }, sint32x2: { size: 2, stride: 8, normalised: !1 }, sint32x3: { size: 3, stride: 12, normalised: !1 }, sint32x4: { size: 4, stride: 16, normalised: !1 } }; function rt(s) { return Wn[s] ?? Wn.float32 } const Nu = { f32: "float32", "vec2<f32>": "float32x2", "vec3<f32>": "float32x3", "vec4<f32>": "float32x4", vec2f: "float32x2", vec3f: "float32x3", vec4f: "float32x4", i32: "sint32", "vec2<i32>": "sint32x2", "vec3<i32>": "sint32x3", "vec4<i32>": "sint32x4", u32: "uint32", "vec2<u32>": "uint32x2", "vec3<u32>": "uint32x3", "vec4<u32>": "uint32x4", bool: "uint32", "vec2<bool>": "uint32x2", "vec3<bool>": "uint32x3", "vec4<bool>": "uint32x4" }; function Hu({ source: s, entryPoint: e }) { const t = {}, r = s.indexOf(`fn ${e}`); if (r !== -1) { const i = s.indexOf("->", r); if (i !== -1) { const n = s.substring(r, i), a = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g; let o; for (; (o = a.exec(n)) !== null;) { const h = Nu[o[3]] ?? "float32"; t[o[2]] = { location: parseInt(o[1], 10), format: h, stride: rt(h).stride, offset: 0, instance: !1, start: 0 } } } } return t } function ms(s) { var u, d; const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, t = /@group\((\d+)\)/, r = /@binding\((\d+)\)/, i = /var(<[^>]+>)? (\w+)/, n = /:\s*(\w+)/, a = /struct\s+(\w+)\s*{([^}]+)}/g, o = /(\w+)\s*:\s*([\w\<\>]+)/g, h = /struct\s+(\w+)/, l = (u = s.match(e)) == null ? void 0 : u.map(f => ({ group: parseInt(f.match(t)[1], 10), binding: parseInt(f.match(r)[1], 10), name: f.match(i)[2], isUniform: f.match(i)[1] === "<uniform>", type: f.match(n)[1] })); if (!l) return { groups: [], structs: [] }; const c = ((d = s.match(a)) == null ? void 0 : d.map(f => { const p = f.match(h)[1], g = f.match(o).reduce((m, y) => { const [T, S] = y.split(":"); return m[T.trim()] = S.trim(), m }, {}); return g ? { name: p, members: g } : null }).filter(({ name: f }) => l.some(p => p.type === f))) ?? []; return { groups: l, structs: c } } var Vt = (s => (s[s.VERTEX = 1] = "VERTEX", s[s.FRAGMENT = 2] = "FRAGMENT", s[s.COMPUTE = 4] = "COMPUTE", s))(Vt || {}); function zu({ groups: s }) { const e = []; for (let t = 0; t < s.length; t++) { const r = s[t]; e[r.group] || (e[r.group] = []), r.isUniform ? e[r.group].push({ binding: r.binding, visibility: Vt.VERTEX | Vt.FRAGMENT, buffer: { type: "uniform" } }) : r.type === "sampler" ? e[r.group].push({ binding: r.binding, visibility: Vt.FRAGMENT, sampler: { type: "filtering" } }) : r.type === "texture_2d" && e[r.group].push({ binding: r.binding, visibility: Vt.FRAGMENT, texture: { sampleType: "float", viewDimension: "2d", multisampled: !1 } }) } return e } function Wu({ groups: s }) { const e = []; for (let t = 0; t < s.length; t++) { const r = s[t]; e[r.group] || (e[r.group] = {}), e[r.group][r.name] = r.binding } return e } function Vu(s, e) { const t = new Set, r = new Set, i = [...s.structs, ...e.structs].filter(a => t.has(a.name) ? !1 : (t.add(a.name), !0)), n = [...s.groups, ...e.groups].filter(a => { const o = `${a.name}-${a.binding}`; return r.has(o) ? !1 : (r.add(o), !0) }); return { structs: i, groups: n } } const gs = Object.create(null); class gt { constructor(e) { var o, h; this._layoutKey = 0, this._attributeLocationsKey = 0; const { fragment: t, vertex: r, layout: i, gpuLayout: n, name: a } = e; if (this.name = a, this.fragment = t, this.vertex = r, t.source === r.source) { const l = ms(t.source); this.structsAndGroups = l } else { const l = ms(r.source), c = ms(t.source); this.structsAndGroups = Vu(l, c) } this.layout = i ?? Wu(this.structsAndGroups), this.gpuLayout = n ?? zu(this.structsAndGroups), this.autoAssignGlobalUniforms = ((o = this.layout[0]) == null ? void 0 : o.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((h = this.layout[1]) == null ? void 0 : h.localUniforms) !== void 0, this._generateProgramKey() } _generateProgramKey() { const { vertex: e, fragment: t } = this, r = e.source + t.source + e.entryPoint + t.entryPoint; this._layoutKey = Jt(r, "program") } get attributeData() { return this._attributeData ?? (this._attributeData = Hu(this.vertex)), this._attributeData } destroy() { this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null } static from(e) { const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`; return gs[t] || (gs[t] = new gt(e)), gs[t] } } const Go = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"], $u = Go.reduce((s, e) => (s[e] = !0, s), {}); function Xu(s, e) { switch (s) { case "f32": return 0; case "vec2<f32>": return new Float32Array(2 * e); case "vec3<f32>": return new Float32Array(3 * e); case "vec4<f32>": return new Float32Array(4 * e); case "mat2x2<f32>": return new Float32Array([1, 0, 0, 1]); case "mat3x3<f32>": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4x4<f32>": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } const Fo = class Uo { constructor(e, t) { this._touched = 0, this.uid = he("uniform"), this._resourceType = "uniformGroup", this._resourceId = he("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, t = { ...Uo.defaultOptions, ...t }, this.uniformStructures = e; const r = {}; for (const i in e) { const n = e[i]; if (n.name = i, n.size = n.size ?? 1, !$u[n.type]) throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${Go.join(", ")}`); n.value ?? (n.value = Xu(n.type, n.size)), r[i] = n.value } this.uniforms = r, this._dirtyId = 1, this.ubo = t.ubo, this.isStatic = t.isStatic, this._signature = Jt(Object.keys(r).map(i => `${i}-${e[i].type}`).join("-"), "uniform-group") } update() { this._dirtyId++ } }; Fo.defaultOptions = { ubo: !1, isStatic: !1 }; let be = Fo; class qe { constructor(e) { this.resources = Object.create(null), this._dirty = !0; let t = 0; for (const r in e) { const i = e[r]; this.setResource(i, t++) } this._updateKey() } _updateKey() { if (!this._dirty) return; this._dirty = !1; const e = []; let t = 0; for (const r in this.resources) e[t++] = this.resources[r]._resourceId; this._key = e.join("|") } setResource(e, t) { var i, n; const r = this.resources[t]; e !== r && (r && ((i = e.off) == null || i.call(e, "change", this.onResourceChange, this)), (n = e.on) == null || n.call(e, "change", this.onResourceChange, this), this.resources[t] = e, this._dirty = !0) } getResource(e) { return this.resources[e] } _touch(e) { const t = this.resources; for (const r in t) t[r]._touched = e } destroy() { var t; const e = this.resources; for (const r in e) { const i = e[r]; (t = i.off) == null || t.call(i, "change", this.onResourceChange, this) } this.resources = null } onResourceChange(e) { if (this._dirty = !0, e.destroyed) { const t = this.resources; for (const r in t) t[r] === e && (t[r] = null) } else this._updateKey() } } var De = (s => (s[s.WEBGL = 1] = "WEBGL", s[s.WEBGPU = 2] = "WEBGPU", s[s.BOTH = 3] = "BOTH", s))(De || {}); class ke extends Ce { constructor(e) { super(), this.uid = he("shader"), this._uniformBindMap = Object.create(null), this._ownedBindGroups = []; let { gpuProgram: t, glProgram: r, groups: i, resources: n, compatibleRenderers: a, groupMap: o } = e; this.gpuProgram = t, this.glProgram = r, a === void 0 && (a = 0, t && (a |= De.WEBGPU), r && (a |= De.WEBGL)), this.compatibleRenderers = a; const h = {}; if (!n && !i && (n = {}), n && i) throw new Error("[Shader] Cannot have both resources and groups"); if (!t && i && !o) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead."); if (!t && i && o) for (const l in o) for (const c in o[l]) { const u = o[l][c]; h[u] = { group: l, binding: c, name: u } } else if (t && i && !o) { const l = t.structsAndGroups.groups; o = {}, l.forEach(c => { o[c.group] = o[c.group] || {}, o[c.group][c.binding] = c.name, h[c.name] = c }) } else if (n) { i = {}, o = {}, t && t.structsAndGroups.groups.forEach(u => { o[u.group] = o[u.group] || {}, o[u.group][u.binding] = u.name, h[u.name] = u }); let l = 0; for (const c in n) h[c] || (i[99] || (i[99] = new qe, this._ownedBindGroups.push(i[99])), h[c] = { group: 99, binding: l, name: c }, o[99] = o[99] || {}, o[99][l] = c, l++); for (const c in n) { const u = c; let d = n[c]; !d.source && !d._resourceType && (d = new be(d)); const f = h[u]; f && (i[f.group] || (i[f.group] = new qe, this._ownedBindGroups.push(i[f.group])), i[f.group].setResource(d, f.binding)) } } this.groups = i, this._uniformBindMap = o, this.resources = this._buildResourceAccessor(i, h) } addResource(e, t, r) { var i, n; (i = this._uniformBindMap)[t] || (i[t] = {}), (n = this._uniformBindMap[t])[r] || (n[r] = e), this.groups[t] || (this.groups[t] = new qe, this._ownedBindGroups.push(this.groups[t])) } _buildResourceAccessor(e, t) { const r = {}; for (const i in t) { const n = t[i]; Object.defineProperty(r, n.name, { get() { return e[n.group].getResource(n.binding) }, set(a) { e[n.group].setResource(a, n.binding) } }) } return r } destroy(e = !1) { var t, r; this.emit("destroy", this), e && ((t = this.gpuProgram) == null || t.destroy(), (r = this.glProgram) == null || r.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach(i => { i.destroy() }), this._ownedBindGroups = null, this.resources = null, this.groups = null } static from(e) { const { gpu: t, gl: r, ...i } = e; let n, a; return t && (n = gt.from(t)), r && (a = kt.from(r)), new ke({ gpuProgram: n, glProgram: a, ...i }) } } const ju = { normal: 0, add: 1, multiply: 2, screen: 3, overlay: 4, erase: 5, "normal-npm": 6, "add-npm": 7, "screen-npm": 8, min: 9, max: 10 }, _s = 0, xs = 1, ys = 2, bs = 3, vs = 4, Ts = 5, Ys = class Do { constructor() { this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0 } get blend() { return !!(this.data & 1 << _s) } set blend(e) { !!(this.data & 1 << _s) !== e && (this.data ^= 1 << _s) } get offsets() { return !!(this.data & 1 << xs) } set offsets(e) { !!(this.data & 1 << xs) !== e && (this.data ^= 1 << xs) } set cullMode(e) { if (e === "none") { this.culling = !1; return } this.culling = !0, this.clockwiseFrontFace = e === "front" } get cullMode() { return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none" } get culling() { return !!(this.data & 1 << ys) } set culling(e) { !!(this.data & 1 << ys) !== e && (this.data ^= 1 << ys) } get depthTest() { return !!(this.data & 1 << bs) } set depthTest(e) { !!(this.data & 1 << bs) !== e && (this.data ^= 1 << bs) } get depthMask() { return !!(this.data & 1 << Ts) } set depthMask(e) { !!(this.data & 1 << Ts) !== e && (this.data ^= 1 << Ts) } get clockwiseFrontFace() { return !!(this.data & 1 << vs) } set clockwiseFrontFace(e) { !!(this.data & 1 << vs) !== e && (this.data ^= 1 << vs) } get blendMode() { return this._blendMode } set blendMode(e) { this.blend = e !== "none", this._blendMode = e, this._blendModeId = ju[e] || 0 } get polygonOffset() { return this._polygonOffset } set polygonOffset(e) { this.offsets = !!e, this._polygonOffset = e } toString() { return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]` } static for2d() { const e = new Do; return e.depthTest = !1, e.blend = !0, e } }; Ys.default2d = Ys.for2d(); let Oe = Ys; const Oo = class Ks extends ke { constructor(e) { e = { ...Ks.defaultOptions, ...e }, super(e), this.enabled = !0, this._state = Oe.for2d(), this.blendMode = e.blendMode, this.padding = e.padding, typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias, this.resolution = e.resolution, this.blendRequired = e.blendRequired, this.clipToViewport = e.clipToViewport, this.addResource("uTexture", 0, 1) } apply(e, t, r, i) { e.applyFilter(this, t, r, i) } get blendMode() { return this._state.blendMode } set blendMode(e) { this._state.blendMode = e } static from(e) { const { gpu: t, gl: r, ...i } = e; let n, a; return t && (n = gt.from(t)), r && (a = kt.from(r)), new Ks({ gpuProgram: n, glProgram: a, ...i }) } }; Oo.defaultOptions = { blendMode: "normal", resolution: 1, padding: 0, antialias: "off", blendRequired: !1, clipToViewport: !0 }; let Yu = Oo; const qs = []; z.handleByNamedList(b.Environment, qs); async function Ku(s) { if (!s) for (let e = 0; e < qs.length; e++) { const t = qs[e]; if (t.value.test()) { await t.value.load(); return } } } let Dt; function Lo() { if (typeof Dt == "boolean") return Dt; try { Dt = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0 } catch { Dt = !1 } return Dt } var _r = { exports: {} }, Vn; function qu() { if (Vn) return _r.exports; Vn = 1, _r.exports = s, _r.exports.default = s; function s(_, x, v) { v = v || 2; var w = x && x.length, P = w ? x[0] * v : _.length, M = e(_, 0, P, v, !0), B = []; if (!M || M.next === M.prev) return B; var k, W, O, re, se, q, ue; if (w && (M = h(_, x, M, v)), _.length > 80 * v) { k = O = _[0], W = re = _[1]; for (var te = v; te < P; te += v)se = _[te], q = _[te + 1], se < k && (k = se), q < W && (W = q), se > O && (O = se), q > re && (re = q); ue = Math.max(O - k, re - W), ue = ue !== 0 ? 32767 / ue : 0 } return r(M, B, v, k, W, ue, 0), B } function e(_, x, v, w, P) { var M, B; if (P === Ie(_, x, v, w) > 0) for (M = x; M < v; M += w)B = V(M, _[M], _[M + 1], B); else for (M = v - w; M >= x; M -= w)B = V(M, _[M], _[M + 1], B); return B && A(B, B.next) && (Z(B), B = B.next), B } function t(_, x) { if (!_) return _; x || (x = _); var v = _, w; do if (w = !1, !v.steiner && (A(v, v.next) || S(v.prev, v, v.next) === 0)) { if (Z(v), v = x = v.prev, v === v.next) break; w = !0 } else v = v.next; while (w || v !== x); return x } function r(_, x, v, w, P, M, B) { if (_) { !B && M && f(_, w, P, M); for (var k = _, W, O; _.prev !== _.next;) { if (W = _.prev, O = _.next, M ? n(_, w, P, M) : i(_)) { x.push(W.i / v | 0), x.push(_.i / v | 0), x.push(O.i / v | 0), Z(_), _ = O.next, k = O.next; continue } if (_ = O, _ === k) { B ? B === 1 ? (_ = a(t(_), x, v), r(_, x, v, w, P, M, 2)) : B === 2 && o(_, x, v, w, P, M) : r(t(_), x, v, w, P, M, 1); break } } } } function i(_) { var x = _.prev, v = _, w = _.next; if (S(x, v, w) >= 0) return !1; for (var P = x.x, M = v.x, B = w.x, k = x.y, W = v.y, O = w.y, re = P < M ? P < B ? P : B : M < B ? M : B, se = k < W ? k < O ? k : O : W < O ? W : O, q = P > M ? P > B ? P : B : M > B ? M : B, ue = k > W ? k > O ? k : O : W > O ? W : O, te = w.next; te !== x;) { if (te.x >= re && te.x <= q && te.y >= se && te.y <= ue && y(P, k, M, W, B, O, te.x, te.y) && S(te.prev, te, te.next) >= 0) return !1; te = te.next } return !0 } function n(_, x, v, w) { var P = _.prev, M = _, B = _.next; if (S(P, M, B) >= 0) return !1; for (var k = P.x, W = M.x, O = B.x, re = P.y, se = M.y, q = B.y, ue = k < W ? k < O ? k : O : W < O ? W : O, te = re < se ? re < q ? re : q : se < q ? se : q, $e = k > W ? k > O ? k : O : W > O ? W : O, Se = re > se ? re > q ? re : q : se > q ? se : q, Ne = g(ue, te, x, v, w), He = g($e, Se, x, v, w), $ = _.prevZ, Q = _.nextZ; $ && $.z >= Ne && Q && Q.z <= He;) { if ($.x >= ue && $.x <= $e && $.y >= te && $.y <= Se && $ !== P && $ !== B && y(k, re, W, se, O, q, $.x, $.y) && S($.prev, $, $.next) >= 0 || ($ = $.prevZ, Q.x >= ue && Q.x <= $e && Q.y >= te && Q.y <= Se && Q !== P && Q !== B && y(k, re, W, se, O, q, Q.x, Q.y) && S(Q.prev, Q, Q.next) >= 0)) return !1; Q = Q.nextZ } for (; $ && $.z >= Ne;) { if ($.x >= ue && $.x <= $e && $.y >= te && $.y <= Se && $ !== P && $ !== B && y(k, re, W, se, O, q, $.x, $.y) && S($.prev, $, $.next) >= 0) return !1; $ = $.prevZ } for (; Q && Q.z <= He;) { if (Q.x >= ue && Q.x <= $e && Q.y >= te && Q.y <= Se && Q !== P && Q !== B && y(k, re, W, se, O, q, Q.x, Q.y) && S(Q.prev, Q, Q.next) >= 0) return !1; Q = Q.nextZ } return !0 } function a(_, x, v) { var w = _; do { var P = w.prev, M = w.next.next; !A(P, M) && R(P, w, w.next, M) && N(P, M) && N(M, P) && (x.push(P.i / v | 0), x.push(w.i / v | 0), x.push(M.i / v | 0), Z(w), Z(w.next), w = _ = M), w = w.next } while (w !== _); return t(w) } function o(_, x, v, w, P, M) { var B = _; do { for (var k = B.next.next; k !== B.prev;) { if (B.i !== k.i && T(B, k)) { var W = I(B, k); B = t(B, B.next), W = t(W, W.next), r(B, x, v, w, P, M, 0), r(W, x, v, w, P, M, 0); return } k = k.next } B = B.next } while (B !== _) } function h(_, x, v, w) { var P = [], M, B, k, W, O; for (M = 0, B = x.length; M < B; M++)k = x[M] * w, W = M < B - 1 ? x[M + 1] * w : _.length, O = e(_, k, W, w, !1), O === O.next && (O.steiner = !0), P.push(m(O)); for (P.sort(l), M = 0; M < P.length; M++)v = c(P[M], v); return v } function l(_, x) { return _.x - x.x } function c(_, x) { var v = u(_, x); if (!v) return x; var w = I(v, _); return t(w, w.next), t(v, v.next) } function u(_, x) { var v = x, w = _.x, P = _.y, M = -1 / 0, B; do { if (P <= v.y && P >= v.next.y && v.next.y !== v.y) { var k = v.x + (P - v.y) * (v.next.x - v.x) / (v.next.y - v.y); if (k <= w && k > M && (M = k, B = v.x < v.next.x ? v : v.next, k === w)) return B } v = v.next } while (v !== x); if (!B) return null; var W = B, O = B.x, re = B.y, se = 1 / 0, q; v = B; do w >= v.x && v.x >= O && w !== v.x && y(P < re ? w : M, P, O, re, P < re ? M : w, P, v.x, v.y) && (q = Math.abs(P - v.y) / (w - v.x), N(v, _) && (q < se || q === se && (v.x > B.x || v.x === B.x && d(B, v))) && (B = v, se = q)), v = v.next; while (v !== W); return B } function d(_, x) { return S(_.prev, _, x.prev) < 0 && S(x.next, _, _.next) < 0 } function f(_, x, v, w) { var P = _; do P.z === 0 && (P.z = g(P.x, P.y, x, v, w)), P.prevZ = P.prev, P.nextZ = P.next, P = P.next; while (P !== _); P.prevZ.nextZ = null, P.prevZ = null, p(P) } function p(_) { var x, v, w, P, M, B, k, W, O = 1; do { for (v = _, _ = null, M = null, B = 0; v;) { for (B++, w = v, k = 0, x = 0; x < O && (k++, w = w.nextZ, !!w); x++); for (W = O; k > 0 || W > 0 && w;)k !== 0 && (W === 0 || !w || v.z <= w.z) ? (P = v, v = v.nextZ, k--) : (P = w, w = w.nextZ, W--), M ? M.nextZ = P : _ = P, P.prevZ = M, M = P; v = w } M.nextZ = null, O *= 2 } while (B > 1); return _ } function g(_, x, v, w, P) { return _ = (_ - v) * P | 0, x = (x - w) * P | 0, _ = (_ | _ << 8) & 16711935, _ = (_ | _ << 4) & 252645135, _ = (_ | _ << 2) & 858993459, _ = (_ | _ << 1) & 1431655765, x = (x | x << 8) & 16711935, x = (x | x << 4) & 252645135, x = (x | x << 2) & 858993459, x = (x | x << 1) & 1431655765, _ | x << 1 } function m(_) { var x = _, v = _; do (x.x < v.x || x.x === v.x && x.y < v.y) && (v = x), x = x.next; while (x !== _); return v } function y(_, x, v, w, P, M, B, k) { return (P - B) * (x - k) >= (_ - B) * (M - k) && (_ - B) * (w - k) >= (v - B) * (x - k) && (v - B) * (M - k) >= (P - B) * (w - k) } function T(_, x) { return _.next.i !== x.i && _.prev.i !== x.i && !L(_, x) && (N(_, x) && N(x, _) && G(_, x) && (S(_.prev, _, x.prev) || S(_, x.prev, x)) || A(_, x) && S(_.prev, _, _.next) > 0 && S(x.prev, x, x.next) > 0) } function S(_, x, v) { return (x.y - _.y) * (v.x - x.x) - (x.x - _.x) * (v.y - x.y) } function A(_, x) { return _.x === x.x && _.y === x.y } function R(_, x, v, w) { var P = C(S(_, x, v)), M = C(S(_, x, w)), B = C(S(v, w, _)), k = C(S(v, w, x)); return !!(P !== M && B !== k || P === 0 && E(_, v, x) || M === 0 && E(_, w, x) || B === 0 && E(v, _, w) || k === 0 && E(v, x, w)) } function E(_, x, v) { return x.x <= Math.max(_.x, v.x) && x.x >= Math.min(_.x, v.x) && x.y <= Math.max(_.y, v.y) && x.y >= Math.min(_.y, v.y) } function C(_) { return _ > 0 ? 1 : _ < 0 ? -1 : 0 } function L(_, x) { var v = _; do { if (v.i !== _.i && v.next.i !== _.i && v.i !== x.i && v.next.i !== x.i && R(v, v.next, _, x)) return !0; v = v.next } while (v !== _); return !1 } function N(_, x) { return S(_.prev, _, _.next) < 0 ? S(_, x, _.next) >= 0 && S(_, _.prev, x) >= 0 : S(_, x, _.prev) < 0 || S(_, _.next, x) < 0 } function G(_, x) { var v = _, w = !1, P = (_.x + x.x) / 2, M = (_.y + x.y) / 2; do v.y > M != v.next.y > M && v.next.y !== v.y && P < (v.next.x - v.x) * (M - v.y) / (v.next.y - v.y) + v.x && (w = !w), v = v.next; while (v !== _); return w } function I(_, x) { var v = new fe(_.i, _.x, _.y), w = new fe(x.i, x.x, x.y), P = _.next, M = x.prev; return _.next = x, x.prev = _, v.next = P, P.prev = v, w.next = v, v.prev = w, M.next = w, w.prev = M, w } function V(_, x, v, w) { var P = new fe(_, x, v); return w ? (P.next = w.next, P.prev = w, w.next.prev = P, w.next = P) : (P.prev = P, P.next = P), P } function Z(_) { _.next.prev = _.prev, _.prev.next = _.next, _.prevZ && (_.prevZ.nextZ = _.nextZ), _.nextZ && (_.nextZ.prevZ = _.prevZ) } function fe(_, x, v) { this.i = _, this.x = x, this.y = v, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } s.deviation = function(_, x, v, w) { var P = x && x.length, M = P ? x[0] * v : _.length, B = Math.abs(Ie(_, 0, M, v)); if (P) for (var k = 0, W = x.length; k < W; k++) { var O = x[k] * v, re = k < W - 1 ? x[k + 1] * v : _.length; B -= Math.abs(Ie(_, O, re, v)) } var se = 0; for (k = 0; k < w.length; k += 3) { var q = w[k] * v, ue = w[k + 1] * v, te = w[k + 2] * v; se += Math.abs((_[q] - _[te]) * (_[ue + 1] - _[q + 1]) - (_[q] - _[ue]) * (_[te + 1] - _[q + 1])) } return B === 0 && se === 0 ? 0 : Math.abs((se - B) / B) }; function Ie(_, x, v, w) { for (var P = 0, M = x, B = v - w; M < v; M += w)P += (_[B] - _[M]) * (_[M + 1] + _[B + 1]), B = M; return P } return s.flatten = function(_) { for (var x = _[0][0].length, v = { vertices: [], holes: [], dimensions: x }, w = 0, P = 0; P < _.length; P++) { for (var M = 0; M < _[P].length; M++)for (var B = 0; B < x; B++)v.vertices.push(_[P][M][B]); P > 0 && (w += _[P - 1].length, v.holes.push(w)) } return v }, _r.exports } var Zu = qu(); const Qu = pi(Zu); var Ae = (s => (s[s.NONE = 0] = "NONE", s[s.COLOR = 16384] = "COLOR", s[s.STENCIL = 1024] = "STENCIL", s[s.DEPTH = 256] = "DEPTH", s[s.COLOR_DEPTH = 16640] = "COLOR_DEPTH", s[s.COLOR_STENCIL = 17408] = "COLOR_STENCIL", s[s.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", s[s.ALL = 17664] = "ALL", s))(Ae || {}); class No { constructor(e) { this.items = [], this._name = e } emit(e, t, r, i, n, a, o, h) { const { name: l, items: c } = this; for (let u = 0, d = c.length; u < d; u++)c[u][l](e, t, r, i, n, a, o, h); return this } add(e) { return e[this._name] && (this.remove(e), this.items.push(e)), this } remove(e) { const t = this.items.indexOf(e); return t !== -1 && this.items.splice(t, 1), this } contains(e) { return this.items.indexOf(e) !== -1 } removeAll() { return this.items.length = 0, this } destroy() { this.removeAll(), this.items = null, this._name = null } get empty() { return this.items.length === 0 } get name() { return this._name } } const Ju = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"], Ho = class zo extends Ce { constructor(e) { super(), this.runners = Object.create(null), this.renderPipes = Object.create(null), this._initOptions = {}, this._systemsHash = Object.create(null), this.type = e.type, this.name = e.name, this.config = e; const t = [...Ju, ...this.config.runners ?? []]; this._addRunners(...t), this._unsafeEvalCheck() } async init(e = {}) { const t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1; await Ku(t), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors); for (const r in this._systemsHash) e = { ...this._systemsHash[r].constructor.defaultOptions, ...e }; e = { ...zo.defaultOptions, ...e }, this._roundPixels = e.roundPixels ? 1 : 0; for (let r = 0; r < this.runners.init.items.length; r++)await this.runners.init.items[r].init(e); this._initOptions = e } render(e, t) { let r = e; if (r instanceof ve && (r = { container: r }, t && (X(ee, "passing a second argument is deprecated, please use render options instead"), r.target = t.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor ?? (r.clearColor = this.background.colorRgba), r.clear ?? (r.clear = this.background.clearBeforeRender)), r.clearColor) { const i = Array.isArray(r.clearColor) && r.clearColor.length === 4; r.clearColor = i ? r.clearColor : ie.shared.setValue(r.clearColor).toArray() } r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), r.container.enableRenderGroup(), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r) } resize(e, t, r) { const i = this.view.resolution; this.view.resize(e, t, r), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), r !== void 0 && r !== i && this.runners.resolutionChange.emit(r) } clear(e = {}) { const t = this; e.target || (e.target = t.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = Ae.ALL); const { clear: r, clearColor: i, target: n } = e; ie.shared.setValue(i ?? this.background.colorRgba), t.renderTarget.clear(n, r, ie.shared.toArray()) } get resolution() { return this.view.resolution } set resolution(e) { this.view.resolution = e, this.runners.resolutionChange.emit(e) } get width() { return this.view.texture.frame.width } get height() { return this.view.texture.frame.height } get canvas() { return this.view.canvas } get lastObjectRendered() { return this._lastObjectRendered } get renderingToScreen() { return this.renderTarget.renderingToScreen } get screen() { return this.view.screen } _addRunners(...e) { e.forEach(t => { this.runners[t] = new No(t) }) } _addSystems(e) { let t; for (t in e) { const r = e[t]; this._addSystem(r.value, r.name) } } _addSystem(e, t) { const r = new e(this); if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`); this[t] = r, this._systemsHash[t] = r; for (const i in this.runners) this.runners[i].add(r); return this } _addPipes(e, t) { const r = t.reduce((i, n) => (i[n.name] = n.value, i), {}); e.forEach(i => { const n = i.value, a = i.name, o = r[a]; this.renderPipes[a] = new n(this, o ? new o : null) }) } destroy(e = !1) { this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach(t => { t.destroy() }), this._systemsHash = null, this.renderPipes = null } generateTexture(e) { return this.textureGenerator.generateTexture(e) } get roundPixels() { return !!this._roundPixels } _unsafeEvalCheck() { if (!Lo()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } resetState() { this.runners.resetState.emit() } }; Ho.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: !1, roundPixels: !1 }; let Yr = Ho, xr; function ed(s) { return xr !== void 0 || (xr = (() => { var t; const e = { stencil: !0, failIfMajorPerformanceCaveat: s ?? Yr.defaultOptions.failIfMajorPerformanceCaveat }; try { if (!K.get().getWebGLRenderingContext()) return !1; let i = K.get().createCanvas().getContext("webgl", e); const n = !!((t = i == null ? void 0 : i.getContextAttributes()) != null && t.stencil); if (i) { const a = i.getExtension("WEBGL_lose_context"); a && a.loseContext() } return i = null, n } catch { return !1 } })()), xr } let yr; async function td(s = {}) { return yr !== void 0 || (yr = await (async () => { const e = K.get().getNavigator().gpu; if (!e) return !1; try { return await (await e.requestAdapter(s)).requestDevice(), !0 } catch { return !1 } })()), yr } const $n = ["webgl", "webgpu", "canvas"]; async function rd(s) { let e = []; s.preference ? (e.push(s.preference), $n.forEach(n => { n !== s.preference && e.push(n) })) : e = $n.slice(); let t, r = {}; for (let n = 0; n < e.length; n++) { const a = e[n]; if (a === "webgpu" && await td()) { const { WebGPURenderer: o } = await Fr(async () => { const { WebGPURenderer: h } = await Promise.resolve().then(() => Og); return { WebGPURenderer: h } }, void 0); t = o, r = { ...s, ...s.webgpu }; break } else if (a === "webgl" && ed(s.failIfMajorPerformanceCaveat ?? Yr.defaultOptions.failIfMajorPerformanceCaveat)) { const { WebGLRenderer: o } = await Fr(async () => { const { WebGLRenderer: h } = await Promise.resolve().then(() => yg); return { WebGLRenderer: h } }, void 0); t = o, r = { ...s, ...s.webgl }; break } else if (a === "canvas") throw r = { ...s }, new Error("CanvasRenderer is not yet implemented") } if (delete r.webgpu, delete r.webgl, !t) throw new Error("No available renderer for the current environment"); const i = new t; return await i.init(r), i } const Nr = "8.9.1"; class Wo { static init() { var e; (e = globalThis.__PIXI_APP_INIT__) == null || e.call(globalThis, this, Nr) } static destroy() { } } Wo.extension = b.Application; class Vo { constructor(e) { this._renderer = e } init() { var e; (e = globalThis.__PIXI_RENDERER_INIT__) == null || e.call(globalThis, this._renderer, Nr) } destroy() { this._renderer = null } } Vo.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "initHook", priority: -10 }; const $o = class Zs { constructor(...e) { this.stage = new ve, e[0] !== void 0 && X(ee, "Application constructor options are deprecated, please use Application.init() instead.") } async init(e) { e = { ...e }, this.renderer = await rd(e), Zs._plugins.forEach(t => { t.init.call(this, e) }) } render() { this.renderer.render({ container: this.stage }) } get canvas() { return this.renderer.canvas } get view() { return X(ee, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas } get screen() { return this.renderer.screen } destroy(e = !1, t = !1) { const r = Zs._plugins.slice(0); r.reverse(), r.forEach(i => { i.destroy.call(this) }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null } }; $o._plugins = []; let Xo = $o; z.handleByList(b.Application, Xo._plugins); z.add(Wo); class jo { static init(e) { Object.defineProperty(this, "resizeTo", { set(t) { globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = t, t && (globalThis.addEventListener("resize", this.queueResize), this.resize()) }, get() { return this._resizeTo } }), this.queueResize = () => { this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize())) }, this._cancelResize = () => { this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null) }, this.resize = () => { if (!this._resizeTo) return; this._cancelResize(); let t, r; if (this._resizeTo === globalThis.window) t = globalThis.innerWidth, r = globalThis.innerHeight; else { const { clientWidth: i, clientHeight: n } = this._resizeTo; t = i, r = n } this.renderer.resize(t, r), this.render() }, this._resizeId = null, this._resizeTo = null, this.resizeTo = e.resizeTo || null } static destroy() { globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null } } jo.extension = b.Application; class Yo { static init(e) { e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e), Object.defineProperty(this, "ticker", { set(t) { this._ticker && this._ticker.remove(this.render, this), this._ticker = t, t && t.add(this.render, this, Qt.LOW) }, get() { return this._ticker } }), this.stop = () => { this._ticker.stop() }, this.start = () => { this._ticker.start() }, this._ticker = null, this.ticker = e.sharedTicker ? Ve.shared : new Ve, e.autoStart && this.start() } static destroy() { if (this._ticker) { const e = this._ticker; this.ticker = null, e.destroy() } } } Yo.extension = b.Application; class Ko extends Ce { constructor() { super(...arguments), this.chars = Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100 } get font() { return X(ee, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily } get pageTextures() { return X(ee, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } get size() { return X(ee, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize } get distanceFieldRange() { return X(ee, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range } get distanceFieldType() { return X(ee, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type } destroy(e = !1) { var t; this.emit("destroy", this), this.removeAllListeners(); for (const r in this.chars) (t = this.chars[r].texture) == null || t.destroy(); this.chars = null, e && (this.pages.forEach(r => r.texture.destroy(!0)), this.pages = null) } } const Xn = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }], Si = class Qs { constructor(...e) { this.uid = he("fillGradient"), this.type = "linear", this.colorStops = []; let t = sd(e); t = { ...t.type === "radial" ? Qs.defaultRadialOptions : Qs.defaultLinearOptions, ...eo(t) }, this._textureSize = t.textureSize, t.type === "radial" ? (this.center = t.center, this.outerCenter = t.outerCenter ?? this.center, this.innerRadius = t.innerRadius, this.outerRadius = t.outerRadius, this.scale = t.scale, this.rotation = t.rotation) : (this.start = t.start, this.end = t.end), this.textureSpace = t.textureSpace, this.type = t.type, t.colorStops.forEach(i => { this.addColorStop(i.offset, i.color) }) } addColorStop(e, t) { return this.colorStops.push({ offset: e, color: ie.shared.setValue(t).toHexa() }), this } buildLinearGradient() { if (this.texture) return; const e = this.colorStops.length ? this.colorStops : Xn, t = this._textureSize, { canvas: r, context: i } = Yn(t, 1), n = i.createLinearGradient(0, 0, this._textureSize, 0); jn(n, e), i.fillStyle = n, i.fillRect(0, 0, t, 1), this.texture = new F({ source: new mt({ resource: r }) }); const { x: a, y: o } = this.start, { x: h, y: l } = this.end, c = new D, u = h - a, d = l - o, f = Math.sqrt(u * u + d * d), p = Math.atan2(d, u); c.scale(f / t, 1), c.rotate(p), c.translate(a, o), this.textureSpace === "local" && c.scale(t, t), this.transform = c } buildGradient() { this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient() } buildRadialGradient() { if (this.texture) return; const e = this.colorStops.length ? this.colorStops : Xn, t = this._textureSize, { canvas: r, context: i } = Yn(t, t), { x: n, y: a } = this.center, { x: o, y: h } = this.outerCenter, l = this.innerRadius, c = this.outerRadius, u = o - c, d = h - c, f = t / (c * 2), p = (n - u) * f, g = (a - d) * f, m = i.createRadialGradient(p, g, l * f, (o - u) * f, (h - d) * f, c * f); jn(m, e), i.fillStyle = e[e.length - 1].color, i.fillRect(0, 0, t, t), i.fillStyle = m, i.translate(p, g), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-p, -g), i.fillRect(0, 0, t, t), this.texture = new F({ source: new mt({ resource: r, addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" }) }); const y = new D; y.scale(1 / f, 1 / f), y.translate(u, d), this.textureSpace === "local" && y.scale(t, t), this.transform = y } get styleKey() { return this.uid } destroy() { var e; (e = this.texture) == null || e.destroy(!0), this.texture = null } }; Si.defaultLinearOptions = { start: { x: 0, y: 0 }, end: { x: 0, y: 1 }, colorStops: [], textureSpace: "local", type: "linear", textureSize: 256 }; Si.defaultRadialOptions = { center: { x: .5, y: .5 }, innerRadius: 0, outerRadius: .5, colorStops: [], scale: 1, textureSpace: "local", type: "radial", textureSize: 256 }; let st = Si; function jn(s, e) { for (let t = 0; t < e.length; t++) { const r = e[t]; s.addColorStop(r.offset, r.color) } } function Yn(s, e) { const t = K.get().createCanvas(s, e), r = t.getContext("2d"); return { canvas: t, context: r } } function sd(s) { let e = s[0] ?? {}; return (typeof e == "number" || s[1]) && (X("8.5.2", "use options object instead"), e = { type: "linear", start: { x: s[0], y: s[1] }, end: { x: s[2], y: s[3] }, textureSpace: s[4], textureSize: s[5] ?? st.defaultLinearOptions.textureSize }), e } const Kn = { repeat: { addressModeU: "repeat", addressModeV: "repeat" }, "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" }, "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" }, "no-repeat": { addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" } }; class Kr { constructor(e, t) { this.uid = he("fillPattern"), this.transform = new D, this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), t && (e.source.style.addressModeU = Kn[t].addressModeU, e.source.style.addressModeV = Kn[t].addressModeV) } setTransform(e) { const t = this.texture; this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / t.frame.width, 1 / t.frame.height), this._styleKey = null } get styleKey() { return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey) } } var Ss, qn; function id() { if (qn) return Ss; qn = 1, Ss = t; var s = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, e = /([astvzqmhlc])([^astvzqmhlc]*)/ig; function t(n) { var a = []; return n.replace(e, function(o, h, l) { var c = h.toLowerCase(); for (l = i(l), c == "m" && l.length > 2 && (a.push([h].concat(l.splice(0, 2))), c = "l", h = h == "m" ? "l" : "L"); ;) { if (l.length == s[c]) return l.unshift(h), a.push(l); if (l.length < s[c]) throw new Error("malformed path data"); a.push([h].concat(l.splice(0, s[c]))) } }), a } var r = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig; function i(n) { var a = n.match(r); return a ? a.map(Number) : [] } return Ss } var nd = id(); const ad = pi(nd); function od(s, e) { const t = ad(s), r = []; let i = null, n = 0, a = 0; for (let o = 0; o < t.length; o++) { const h = t[o], l = h[0], c = h; switch (l) { case "M": n = c[1], a = c[2], e.moveTo(n, a); break; case "m": n += c[1], a += c[2], e.moveTo(n, a); break; case "H": n = c[1], e.lineTo(n, a); break; case "h": n += c[1], e.lineTo(n, a); break; case "V": a = c[1], e.lineTo(n, a); break; case "v": a += c[1], e.lineTo(n, a); break; case "L": n = c[1], a = c[2], e.lineTo(n, a); break; case "l": n += c[1], a += c[2], e.lineTo(n, a); break; case "C": n = c[5], a = c[6], e.bezierCurveTo(c[1], c[2], c[3], c[4], n, a); break; case "c": e.bezierCurveTo(n + c[1], a + c[2], n + c[3], a + c[4], n + c[5], a + c[6]), n += c[5], a += c[6]; break; case "S": n = c[3], a = c[4], e.bezierCurveToShort(c[1], c[2], n, a); break; case "s": e.bezierCurveToShort(n + c[1], a + c[2], n + c[3], a + c[4]), n += c[3], a += c[4]; break; case "Q": n = c[3], a = c[4], e.quadraticCurveTo(c[1], c[2], n, a); break; case "q": e.quadraticCurveTo(n + c[1], a + c[2], n + c[3], a + c[4]), n += c[3], a += c[4]; break; case "T": n = c[1], a = c[2], e.quadraticCurveToShort(n, a); break; case "t": n += c[1], a += c[2], e.quadraticCurveToShort(n, a); break; case "A": n = c[6], a = c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], n, a); break; case "a": n += c[6], a += c[7], e.arcToSvg(c[1], c[2], c[3], c[4], c[5], n, a); break; case "Z": case "z": e.closePath(), r.length > 0 && (i = r.pop(), i ? (n = i.startX, a = i.startY) : (n = 0, a = 0)), i = null; break; default: H(`Unknown SVG path command: ${l}`) }l !== "Z" && l !== "z" && i === null && (i = { startX: n, startY: a }, r.push(i)) } return e } class wi { constructor(e = 0, t = 0, r = 0) { this.type = "circle", this.x = e, this.y = t, this.radius = r } clone() { return new wi(this.x, this.y, this.radius) } contains(e, t) { if (this.radius <= 0) return !1; const r = this.radius * this.radius; let i = this.x - e, n = this.y - t; return i *= i, n *= n, i + n <= r } strokeContains(e, t, r, i = .5) { if (this.radius === 0) return !1; const n = this.x - e, a = this.y - t, o = this.radius, h = (1 - i) * r, l = Math.sqrt(n * n + a * a); return l <= o + h && l > o - (r - h) } getBounds(e) { return e || (e = new ne), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e } copyFrom(e) { return this.x = e.x, this.y = e.y, this.radius = e.radius, this } copyTo(e) { return e.copyFrom(this), e } toString() { return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]` } } class Ai { constructor(e = 0, t = 0, r = 0, i = 0) { this.type = "ellipse", this.x = e, this.y = t, this.halfWidth = r, this.halfHeight = i } clone() { return new Ai(this.x, this.y, this.halfWidth, this.halfHeight) } contains(e, t) { if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1; let r = (e - this.x) / this.halfWidth, i = (t - this.y) / this.halfHeight; return r *= r, i *= i, r + i <= 1 } strokeContains(e, t, r, i = .5) { const { halfWidth: n, halfHeight: a } = this; if (n <= 0 || a <= 0) return !1; const o = r * (1 - i), h = r - o, l = n - h, c = a - h, u = n + o, d = a + o, f = e - this.x, p = t - this.y, g = f * f / (l * l) + p * p / (c * c), m = f * f / (u * u) + p * p / (d * d); return g > 1 && m <= 1 } getBounds(e) { return e || (e = new ne), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e } copyFrom(e) { return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this } copyTo(e) { return e.copyFrom(this), e } toString() { return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]` } } function hd(s, e, t, r, i, n) { const a = s - t, o = e - r, h = i - t, l = n - r, c = a * h + o * l, u = h * h + l * l; let d = -1; u !== 0 && (d = c / u); let f, p; d < 0 ? (f = t, p = r) : d > 1 ? (f = i, p = n) : (f = t + d * h, p = r + d * l); const g = s - f, m = e - p; return g * g + m * m } let ld, cd; class Yt { constructor(...e) { this.type = "polygon"; let t = Array.isArray(e[0]) ? e[0] : e; if (typeof t[0] != "number") { const r = []; for (let i = 0, n = t.length; i < n; i++)r.push(t[i].x, t[i].y); t = r } this.points = t, this.closePath = !0 } isClockwise() { let e = 0; const t = this.points, r = t.length; for (let i = 0; i < r; i += 2) { const n = t[i], a = t[i + 1], o = t[(i + 2) % r], h = t[(i + 3) % r]; e += (o - n) * (h + a) } return e < 0 } containsPolygon(e) { const t = this.getBounds(ld), r = e.getBounds(cd); if (!t.containsRect(r)) return !1; const i = e.points; for (let n = 0; n < i.length; n += 2) { const a = i[n], o = i[n + 1]; if (!this.contains(a, o)) return !1 } return !0 } clone() { const e = this.points.slice(), t = new Yt(e); return t.closePath = this.closePath, t } contains(e, t) { let r = !1; const i = this.points.length / 2; for (let n = 0, a = i - 1; n < i; a = n++) { const o = this.points[n * 2], h = this.points[n * 2 + 1], l = this.points[a * 2], c = this.points[a * 2 + 1]; h > t != c > t && e < (l - o) * ((t - h) / (c - h)) + o && (r = !r) } return r } strokeContains(e, t, r, i = .5) { const n = r * r, a = n * (1 - i), o = n - a, { points: h } = this, l = h.length - (this.closePath ? 0 : 2); for (let c = 0; c < l; c += 2) { const u = h[c], d = h[c + 1], f = h[(c + 2) % h.length], p = h[(c + 3) % h.length], g = hd(e, t, u, d, f, p), m = Math.sign((f - u) * (t - d) - (p - d) * (e - u)); if (g <= (m < 0 ? o : a)) return !0 } return !1 } getBounds(e) { e || (e = new ne); const t = this.points; let r = 1 / 0, i = -1 / 0, n = 1 / 0, a = -1 / 0; for (let o = 0, h = t.length; o < h; o += 2) { const l = t[o], c = t[o + 1]; r = l < r ? l : r, i = l > i ? l : i, n = c < n ? c : n, a = c > a ? c : a } return e.x = r, e.width = i - r, e.y = n, e.height = a - n, e } copyFrom(e) { return this.points = e.points.slice(), this.closePath = e.closePath, this } copyTo(e) { return e.copyFrom(this), e } toString() { return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]` } get lastX() { return this.points[this.points.length - 2] } get lastY() { return this.points[this.points.length - 1] } get x() { return this.points[this.points.length - 2] } get y() { return this.points[this.points.length - 1] } } const br = (s, e, t, r, i, n, a) => { const o = s - t, h = e - r, l = Math.sqrt(o * o + h * h); return l >= i - n && l <= i + a }; class Pi { constructor(e = 0, t = 0, r = 0, i = 0, n = 20) { this.type = "roundedRectangle", this.x = e, this.y = t, this.width = r, this.height = i, this.radius = n } getBounds(e) { return e || (e = new ne), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e } clone() { return new Pi(this.x, this.y, this.width, this.height, this.radius) } copyFrom(e) { return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this } copyTo(e) { return e.copyFrom(this), e } contains(e, t) { if (this.width <= 0 || this.height <= 0) return !1; if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) { const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2)); if (t >= this.y + r && t <= this.y + this.height - r || e >= this.x + r && e <= this.x + this.width - r) return !0; let i = e - (this.x + r), n = t - (this.y + r); const a = r * r; if (i * i + n * n <= a || (i = e - (this.x + this.width - r), i * i + n * n <= a) || (n = t - (this.y + this.height - r), i * i + n * n <= a) || (i = e - (this.x + r), i * i + n * n <= a)) return !0 } return !1 } strokeContains(e, t, r, i = .5) { const { x: n, y: a, width: o, height: h, radius: l } = this, c = r * (1 - i), u = r - c, d = n + l, f = a + l, p = o - l * 2, g = h - l * 2, m = n + o, y = a + h; return (e >= n - c && e <= n + u || e >= m - u && e <= m + c) && t >= f && t <= f + g || (t >= a - c && t <= a + u || t >= y - u && t <= y + c) && e >= d && e <= d + p ? !0 : e < d && t < f && br(e, t, d, f, l, u, c) || e > m - l && t < f && br(e, t, m - l, f, l, u, c) || e > m - l && t > y - l && br(e, t, m - l, y - l, l, u, c) || e < d && t > y - l && br(e, t, d, y - l, l, u, c) } toString() { return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]` } } const ud = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`); function dd(s) {
  let e = ""; for (let t = 0; t < s; ++t)t > 0 && (e += `
else `), t < s - 1 && (e += `if(test == ${t}.0){}`); return e
} function fd(s, e) { if (s === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`"); const t = e.createShader(e.FRAGMENT_SHADER); try { for (; ;) { const r = ud.replace(/%forloop%/gi, dd(s)); if (e.shaderSource(t, r), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS)) s = s / 2 | 0; else break } } finally { e.deleteShader(t) } return s } let yt = null; function It() { var e; if (yt) return yt; const s = ko(); return yt = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), yt = fd(yt, s), (e = s.getExtension("WEBGL_lose_context")) == null || e.loseContext(), yt } const qo = {}; function Ei(s, e) { let t = 2166136261; for (let r = 0; r < e; r++)t ^= s[r].uid, t = Math.imul(t, 16777619), t >>>= 0; return qo[t] || pd(s, e, t) } let ws = 0; function pd(s, e, t) { const r = {}; let i = 0; ws || (ws = It()); for (let a = 0; a < ws; a++) { const o = a < e ? s[a] : F.EMPTY.source; r[i++] = o.source, r[i++] = o.style } const n = new qe(r); return qo[t] = n, n } class Tt { constructor(e) { typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength } get int8View() { return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View } get uint8View() { return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View } get int16View() { return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View } get int32View() { return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View } get float64View() { return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array } get bigUint64View() { return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array } view(e) { return this[`${e}View`] } destroy() { this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null } static sizeOf(e) { switch (e) { case "int8": case "uint8": return 1; case "int16": case "uint16": return 2; case "int32": case "uint32": case "float32": return 4; default: throw new Error(`${e} isn't a valid view type`) } } } function Js(s, e) { const t = s.byteLength / 8 | 0, r = new Float64Array(s, 0, t); new Float64Array(e, 0, t).set(r); const n = s.byteLength - t * 8; if (n > 0) { const a = new Uint8Array(s, t * 8, n); new Uint8Array(e, t * 8, n).set(a) } } const md = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" }; var de = (s => (s[s.DISABLED = 0] = "DISABLED", s[s.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", s[s.MASK_ACTIVE = 2] = "MASK_ACTIVE", s[s.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", s[s.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", s[s.NONE = 5] = "NONE", s))(de || {}); function er(s, e) { return e.alphaMode === "no-premultiply-alpha" && md[s] || s } class gd { constructor() { this.ids = Object.create(null), this.textures = [], this.count = 0 } clear() { for (let e = 0; e < this.count; e++) { const t = this.textures[e]; this.textures[e] = null, this.ids[t.uid] = null } this.count = 0 } } class _d { constructor() { this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new gd, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0 } destroy() { this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null } } const Zo = []; let ei = 0; function Zn() { return ei > 0 ? Zo[--ei] : new _d } function Qn(s) { Zo[ei++] = s } let Ot = 0; const Qo = class Rr { constructor(e = {}) { this.uid = he("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], Rr.defaultOptions.maxTextures = Rr.defaultOptions.maxTextures ?? It(), e = { ...Rr.defaultOptions, ...e }; const { maxTextures: t, attributesInitialSize: r, indicesInitialSize: i } = e; this.attributeBuffer = new Tt(r * 4), this.indexBuffer = new Uint16Array(i), this.maxTextures = t } begin() { this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0; for (let e = 0; e < this.batchIndex; e++)Qn(this.batches[e]); this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0 } add(e) { this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize } checkAndUpdateTexture(e, t) { const r = e._batch.textures.ids[t._source.uid]; return !r && r !== 0 ? !1 : (e._textureId = r, e.texture = t, !0) } updateElement(e) { this.dirty = !0; const t = this.attributeBuffer; e.packAsQuad ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId) } break(e) { const t = this._elements; if (!t[this.elementStart]) return; let r = Zn(), i = r.textures; i.clear(); const n = t[this.elementStart]; let a = er(n.blendMode, n.texture._source), o = n.topology; this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize); const h = this.attributeBuffer.float32View, l = this.attributeBuffer.uint32View, c = this.indexBuffer; let u = this._batchIndexSize, d = this._batchIndexStart, f = "startBatch"; const p = this.maxTextures; for (let g = this.elementStart; g < this.elementSize; ++g) { const m = t[g]; t[g] = null; const T = m.texture._source, S = er(m.blendMode, T), A = a !== S || o !== m.topology; if (T._batchTick === Ot && !A) { m._textureId = T._textureBindLocation, u += m.indexSize, m.packAsQuad ? (this.packQuadAttributes(m, h, l, m._attributeStart, m._textureId), this.packQuadIndex(c, m._indexStart, m._attributeStart / this.vertexSize)) : (this.packAttributes(m, h, l, m._attributeStart, m._textureId), this.packIndex(m, c, m._indexStart, m._attributeStart / this.vertexSize)), m._batch = r; continue } T._batchTick = Ot, (i.count >= p || A) && (this._finishBatch(r, d, u - d, i, a, o, e, f), f = "renderBatch", d = u, a = S, o = m.topology, r = Zn(), i = r.textures, i.clear(), ++Ot), m._textureId = T._textureBindLocation = i.count, i.ids[T.uid] = i.count, i.textures[i.count++] = T, m._batch = r, u += m.indexSize, m.packAsQuad ? (this.packQuadAttributes(m, h, l, m._attributeStart, m._textureId), this.packQuadIndex(c, m._indexStart, m._attributeStart / this.vertexSize)) : (this.packAttributes(m, h, l, m._attributeStart, m._textureId), this.packIndex(m, c, m._indexStart, m._attributeStart / this.vertexSize)) } i.count > 0 && (this._finishBatch(r, d, u - d, i, a, o, e, f), d = u, ++Ot), this.elementStart = this.elementSize, this._batchIndexStart = d, this._batchIndexSize = u } _finishBatch(e, t, r, i, n, a, o, h) { e.gpuBindGroup = null, e.bindGroup = null, e.action = h, e.batcher = this, e.textures = i, e.blendMode = n, e.topology = a, e.start = t, e.size = r, ++Ot, this.batches[this.batchIndex++] = e, o.add(e) } finish(e) { this.break(e) } ensureAttributeBuffer(e) { e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4) } ensureIndexBuffer(e) { e <= this.indexBuffer.length || this._resizeIndexBuffer(e) } _resizeAttributeBuffer(e) { const t = Math.max(e, this.attributeBuffer.size * 2), r = new Tt(t); Js(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r } _resizeIndexBuffer(e) { const t = this.indexBuffer; let r = Math.max(e, t.length * 1.5); r += r % 2; const i = r > 65535 ? new Uint32Array(r) : new Uint16Array(r); if (i.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT) for (let n = 0; n < t.length; n++)i[n] = t[n]; else Js(t.buffer, i.buffer); this.indexBuffer = i } packQuadIndex(e, t, r) { e[t] = r + 0, e[t + 1] = r + 1, e[t + 2] = r + 2, e[t + 3] = r + 0, e[t + 4] = r + 2, e[t + 5] = r + 3 } packIndex(e, t, r, i) { const n = e.indices, a = e.indexSize, o = e.indexOffset, h = e.attributeOffset; for (let l = 0; l < a; l++)t[r++] = i + n[l + o] - h } destroy() { for (let e = 0; e < this.batches.length; e++)Qn(this.batches[e]); this.batches = null; for (let e = 0; e < this._elements.length; e++)this._elements[e]._batch = null; this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null } }; Qo.defaultOptions = { maxTextures: null, attributesInitialSize: 4, indicesInitialSize: 6 }; let xd = Qo; var Y = (s => (s[s.MAP_READ = 1] = "MAP_READ", s[s.MAP_WRITE = 2] = "MAP_WRITE", s[s.COPY_SRC = 4] = "COPY_SRC", s[s.COPY_DST = 8] = "COPY_DST", s[s.INDEX = 16] = "INDEX", s[s.VERTEX = 32] = "VERTEX", s[s.UNIFORM = 64] = "UNIFORM", s[s.STORAGE = 128] = "STORAGE", s[s.INDIRECT = 256] = "INDIRECT", s[s.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", s[s.STATIC = 1024] = "STATIC", s))(Y || {}); class Ee extends Ce { constructor(e) { let { data: t, size: r } = e; const { usage: i, label: n, shrinkToFit: a } = e; super(), this.uid = he("buffer"), this._resourceType = "buffer", this._resourceId = he("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, t instanceof Array && (t = new Float32Array(t)), this._data = t, r ?? (r = t == null ? void 0 : t.byteLength); const o = !!t; this.descriptor = { size: r, usage: i, mappedAtCreation: o, label: n }, this.shrinkToFit = a ?? !0 } get data() { return this._data } set data(e) { this.setDataWithSize(e, e.length, !0) } get dataInt32() { return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32 } get static() { return !!(this.descriptor.usage & Y.STATIC) } set static(e) { e ? this.descriptor.usage |= Y.STATIC : this.descriptor.usage &= ~Y.STATIC } setDataWithSize(e, t, r) { if (this._updateID++, this._updateSize = t * e.BYTES_PER_ELEMENT, this._data === e) { r && this.emit("update", this); return } const i = this._data; if (this._data = e, this._dataInt32 = null, !i || i.length !== e.length) { !this.shrinkToFit && i && e.byteLength < i.byteLength ? r && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = he("resource"), this.emit("change", this)); return } r && this.emit("update", this) } update(e) { this._updateSize = e ?? this._updateSize, this._updateID++, this.emit("update", this) } destroy() { this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners() } } function Jo(s, e) { if (!(s instanceof Ee)) { let t = e ? Y.INDEX : Y.VERTEX; s instanceof Array && (e ? (s = new Uint32Array(s), t = Y.INDEX | Y.COPY_DST) : (s = new Float32Array(s), t = Y.VERTEX | Y.COPY_DST)), s = new Ee({ data: s, label: e ? "index-mesh-buffer" : "vertex-mesh-buffer", usage: t }) } return s } function yd(s, e, t) { const r = s.getAttribute(e); if (!r) return t.minX = 0, t.minY = 0, t.maxX = 0, t.maxY = 0, t; const i = r.buffer.data; let n = 1 / 0, a = 1 / 0, o = -1 / 0, h = -1 / 0; const l = i.BYTES_PER_ELEMENT, c = (r.offset || 0) / l, u = (r.stride || 2 * 4) / l; for (let d = c; d < i.length; d += u) { const f = i[d], p = i[d + 1]; f > o && (o = f), p > h && (h = p), f < n && (n = f), p < a && (a = p) } return t.minX = n, t.minY = a, t.maxX = o, t.maxY = h, t } function bd(s) { return (s instanceof Ee || Array.isArray(s) || s.BYTES_PER_ELEMENT) && (s = { buffer: s }), s.buffer = Jo(s.buffer, !1), s } class ir extends Ce { constructor(e = {}) { super(), this.uid = he("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new xe, this._boundsDirty = !0; const { attributes: t, indexBuffer: r, topology: i } = e; if (this.buffers = [], this.attributes = {}, t) for (const n in t) this.addAttribute(n, t[n]); this.instanceCount = e.instanceCount ?? 1, r && this.addIndex(r), this.topology = i || "triangle-list" } onBufferUpdate() { this._boundsDirty = !0, this.emit("update", this) } getAttribute(e) { return this.attributes[e] } getIndex() { return this.indexBuffer } getBuffer(e) { return this.getAttribute(e).buffer } getSize() { for (const e in this.attributes) { const t = this.attributes[e]; return t.buffer.data.length / (t.stride / 4 || t.size) } return 0 } addAttribute(e, t) { const r = bd(t); this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer), r.buffer.on("update", this.onBufferUpdate, this), r.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = r } addIndex(e) { this.indexBuffer = Jo(e, !0), this.buffers.push(this.indexBuffer) } get bounds() { return this._boundsDirty ? (this._boundsDirty = !1, yd(this, "aPosition", this._bounds)) : this._bounds } destroy(e = !1) { this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach(t => t.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null } } const vd = new Float32Array(1), Td = new Uint32Array(1); class Sd extends ir { constructor() { const t = new Ee({ data: vd, label: "attribute-batch-buffer", usage: Y.VERTEX | Y.COPY_DST, shrinkToFit: !1 }), r = new Ee({ data: Td, label: "index-batch-buffer", usage: Y.INDEX | Y.COPY_DST, shrinkToFit: !1 }), i = 6 * 4; super({ attributes: { aPosition: { buffer: t, format: "float32x2", stride: i, offset: 0 }, aUV: { buffer: t, format: "float32x2", stride: i, offset: 2 * 4 }, aColor: { buffer: t, format: "unorm8x4", stride: i, offset: 4 * 4 }, aTextureIdAndRound: { buffer: t, format: "uint16x2", stride: i, offset: 5 * 4 } }, indexBuffer: r }) } } function Jn(s, e, t) { if (s) for (const r in s) { const i = r.toLocaleLowerCase(), n = e[i]; if (n) { let a = s[r]; r === "header" && (a = a.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), t && n.push(`//----${t}----//`), n.push(a) } else H(`${r} placement hook does not exist in shader`) } } const wd = /\{\{(.*?)\}\}/g; function ea(s) { var r; const e = {}; return (((r = s.match(wd)) == null ? void 0 : r.map(i => i.replace(/[{()}]/g, ""))) ?? []).forEach(i => { e[i] = [] }), e } function ta(s, e) { let t; const r = /@in\s+([^;]+);/g; for (; (t = r.exec(s)) !== null;)e.push(t[1]) } function ra(s, e, t = !1) {
  const r = []; ta(e, r), s.forEach(o => { o.header && ta(o.header, r) }); const i = r; t && i.sort(); const n = i.map((o, h) => `       @location(${h}) ${o},`).join(`
`); let a = e.replace(/@in\s+[^;]+;\s*/g, ""); return a = a.replace("{{in}}", `
${n}
`), a
} function sa(s, e) { let t; const r = /@out\s+([^;]+);/g; for (; (t = r.exec(s)) !== null;)e.push(t[1]) } function Ad(s) { const t = /\b(\w+)\s*:/g.exec(s); return t ? t[1] : "" } function Pd(s) { const e = /@.*?\s+/g; return s.replace(e, "") } function Ed(s, e) {
  const t = []; sa(e, t), s.forEach(h => { h.header && sa(h.header, t) }); let r = 0; const i = t.sort().map(h => h.indexOf("builtin") > -1 ? h : `@location(${r++}) ${h}`).join(`,
`), n = t.sort().map(h => `       var ${Pd(h)};`).join(`
`), a = `return VSOutput(
            ${t.sort().map(h => ` ${Ad(h)}`).join(`,
`)});`; let o = e.replace(/@out\s+[^;]+;\s*/g, ""); return o = o.replace("{{struct}}", `
${i}
`), o = o.replace("{{start}}", `
${n}
`), o = o.replace("{{return}}", `
${a}
`), o
} function ia(s, e) {
  let t = s; for (const r in e) {
    const i = e[r]; i.join(`
`).length ? t = t.replace(`{{${r}}}`, `//-----${r} START-----//
${i.join(`
`)}
//----${r} FINISH----//`) : t = t.replace(`{{${r}}}`, "")
  } return t
} const tt = Object.create(null), As = new Map; let Cd = 0; function Md({ template: s, bits: e }) { const t = eh(s, e); if (tt[t]) return tt[t]; const { vertex: r, fragment: i } = Rd(s, e); return tt[t] = th(r, i, e), tt[t] } function Bd({ template: s, bits: e }) { const t = eh(s, e); return tt[t] || (tt[t] = th(s.vertex, s.fragment, e)), tt[t] } function Rd(s, e) { const t = e.map(a => a.vertex).filter(a => !!a), r = e.map(a => a.fragment).filter(a => !!a); let i = ra(t, s.vertex, !0); i = Ed(t, i); const n = ra(r, s.fragment, !0); return { vertex: i, fragment: n } } function eh(s, e) { return e.map(t => (As.has(t) || As.set(t, Cd++), As.get(t))).sort((t, r) => t - r).join("-") + s.vertex + s.fragment } function th(s, e, t) { const r = ea(s), i = ea(e); return t.forEach(n => { Jn(n.vertex, r, n.name), Jn(n.fragment, i, n.name) }), { vertex: ia(s, r), fragment: ia(e, i) } } const kd = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`, Id = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`, Gd = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`, Fd = `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`, Ud = {
    name: "global-uniforms-bit", vertex: {
      header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}
  }, Dd = {
    name: "global-uniforms-bit", vertex: {
      header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}
  }; function nr({ bits: s, name: e }) { const t = Md({ template: { fragment: Id, vertex: kd }, bits: [Ud, ...s] }); return gt.from({ name: e, vertex: { source: t.vertex, entryPoint: "main" }, fragment: { source: t.fragment, entryPoint: "main" } }) } function ar({ bits: s, name: e }) { return new kt({ name: e, ...Bd({ template: { vertex: Gd, fragment: Fd }, bits: [Dd, ...s] }) }) } const Ci = {
    name: "color-bit", vertex: {
      header: `
            @in aColor: vec4<f32>;
        `, main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}
  }, Mi = {
    name: "color-bit", vertex: {
      header: `
            in vec4 aColor;
        `, main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}
  }, Ps = {}; function Od(s) {
    const e = []; if (s === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;"); else { let t = 0; for (let r = 0; r < s; r++)e.push(`@group(1) @binding(${t++}) var textureSource${r + 1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${t++}) var textureSampler${r + 1}: sampler;`) } return e.join(`
`)
  } function Ld(s) {
    const e = []; if (s === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);"); else { e.push("switch vTextureId {"); for (let t = 0; t < s; t++)t === s - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`), e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`), e.push("      break;}"); e.push("}") } return e.join(`
`)
  } function Bi(s) {
    return Ps[s] || (Ps[s] = {
      name: "texture-batch-bit", vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `, main: `
                vTextureId = aTextureIdAndRound.y;
            `, end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `}, fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${Od(s)}
            `, main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Ld(s)}
            `}
    }), Ps[s]
  } const Es = {}; function Nd(s) {
    const e = []; for (let t = 0; t < s; t++)t > 0 && e.push("else"), t < s - 1 && e.push(`if(vTextureId < ${t}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${t}], vUV);`), e.push("}"); return e.join(`
`)
  } function Ri(s) {
    return Es[s] || (Es[s] = {
      name: "texture-batch-bit", vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `, main: `
                vTextureId = aTextureIdAndRound.y;
            `, end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `}, fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${s}];

            `, main: `

                ${Nd(s)}
            `}
    }), Es[s]
  } const or = {
    name: "round-pixels-bit", vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}
  }, hr = {
    name: "round-pixels-bit", vertex: {
      header: `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}
  }, na = {}; function ki(s) { let e = na[s]; if (e) return e; const t = new Int32Array(s); for (let r = 0; r < s; r++)t[r] = r; return e = na[s] = new be({ uTextures: { value: t, type: "i32", size: s } }, { isStatic: !0 }), e } class Hd extends ke { constructor(e) { const t = ar({ name: "batch", bits: [Mi, Ri(e), hr] }), r = nr({ name: "batch", bits: [Ci, Bi(e), or] }); super({ glProgram: t, gpuProgram: r, resources: { batchSamplers: ki(e) } }) } } let aa = null; const rh = class sh extends xd { constructor() { super(...arguments), this.geometry = new Sd, this.shader = aa || (aa = new Hd(this.maxTextures)), this.name = sh.extension.name, this.vertexSize = 6 } packAttributes(e, t, r, i, n) { const a = n << 16 | e.roundPixels & 65535, o = e.transform, h = o.a, l = o.b, c = o.c, u = o.d, d = o.tx, f = o.ty, { positions: p, uvs: g } = e, m = e.color, y = e.attributeOffset, T = y + e.attributeSize; for (let S = y; S < T; S++) { const A = S * 2, R = p[A], E = p[A + 1]; t[i++] = h * R + c * E + d, t[i++] = u * E + l * R + f, t[i++] = g[A], t[i++] = g[A + 1], r[i++] = m, r[i++] = a } } packQuadAttributes(e, t, r, i, n) { const a = e.texture, o = e.transform, h = o.a, l = o.b, c = o.c, u = o.d, d = o.tx, f = o.ty, p = e.bounds, g = p.maxX, m = p.minX, y = p.maxY, T = p.minY, S = a.uvs, A = e.color, R = n << 16 | e.roundPixels & 65535; t[i + 0] = h * m + c * T + d, t[i + 1] = u * T + l * m + f, t[i + 2] = S.x0, t[i + 3] = S.y0, r[i + 4] = A, r[i + 5] = R, t[i + 6] = h * g + c * T + d, t[i + 7] = u * T + l * g + f, t[i + 8] = S.x1, t[i + 9] = S.y1, r[i + 10] = A, r[i + 11] = R, t[i + 12] = h * g + c * y + d, t[i + 13] = u * y + l * g + f, t[i + 14] = S.x2, t[i + 15] = S.y2, r[i + 16] = A, r[i + 17] = R, t[i + 18] = h * m + c * y + d, t[i + 19] = u * y + l * m + f, t[i + 20] = S.x3, t[i + 21] = S.y3, r[i + 22] = A, r[i + 23] = R } }; rh.extension = { type: [b.Batcher], name: "default" }; let Ii = rh; function zd(s, e, t, r, i, n, a, o = null) { let h = 0; t *= e, i *= n; const l = o.a, c = o.b, u = o.c, d = o.d, f = o.tx, p = o.ty; for (; h < a;) { const g = s[t], m = s[t + 1]; r[i] = l * g + u * m + f, r[i + 1] = c * g + d * m + p, i += n, t += e, h++ } } function Wd(s, e, t, r) { let i = 0; for (e *= t; i < r;)s[e] = 0, s[e + 1] = 0, e += t, i++ } function ih(s, e, t, r, i) { const n = e.a, a = e.b, o = e.c, h = e.d, l = e.tx, c = e.ty; t || (t = 0), r || (r = 2), i || (i = s.length / r - t); let u = t * r; for (let d = 0; d < i; d++) { const f = s[u], p = s[u + 1]; s[u] = n * f + o * p + l, s[u + 1] = a * f + h * p + c, u += r } } const Vd = new D; class Gi { constructor() { this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null } get uvs() { return this.geometryData.uvs } get positions() { return this.geometryData.vertices } get indices() { return this.geometryData.indices } get blendMode() { return this.applyTransform ? this.renderable.groupBlendMode : "normal" } get color() { const e = this.baseColor, t = e >> 16 | e & 65280 | (e & 255) << 16, r = this.renderable; return r ? po(t, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24) } get transform() { var e; return ((e = this.renderable) == null ? void 0 : e.groupTransform) || Vd } copyTo(e) { e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology } reset() { this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list" } } const tr = { extension: { type: b.ShapeBuilder, name: "circle" }, build(s, e) { let t, r, i, n, a, o; if (s.type === "circle") { const A = s; t = A.x, r = A.y, a = o = A.radius, i = n = 0 } else if (s.type === "ellipse") { const A = s; t = A.x, r = A.y, a = A.halfWidth, o = A.halfHeight, i = n = 0 } else { const A = s, R = A.width / 2, E = A.height / 2; t = A.x + R, r = A.y + E, a = o = Math.max(0, Math.min(A.radius, Math.min(R, E))), i = R - a, n = E - o } if (!(a >= 0 && o >= 0 && i >= 0 && n >= 0)) return e; const h = Math.ceil(2.3 * Math.sqrt(a + o)), l = h * 8 + (i ? 4 : 0) + (n ? 4 : 0); if (l === 0) return e; if (h === 0) return e[0] = e[6] = t + i, e[1] = e[3] = r + n, e[2] = e[4] = t - i, e[5] = e[7] = r - n, e; let c = 0, u = h * 4 + (i ? 2 : 0) + 2, d = u, f = l, p = i + a, g = n, m = t + p, y = t - p, T = r + g; if (e[c++] = m, e[c++] = T, e[--u] = T, e[--u] = y, n) { const A = r - g; e[d++] = y, e[d++] = A, e[--f] = A, e[--f] = m } for (let A = 1; A < h; A++) { const R = Math.PI / 2 * (A / h), E = i + Math.cos(R) * a, C = n + Math.sin(R) * o, L = t + E, N = t - E, G = r + C, I = r - C; e[c++] = L, e[c++] = G, e[--u] = G, e[--u] = N, e[d++] = N, e[d++] = I, e[--f] = I, e[--f] = L } p = i, g = n + o, m = t + p, y = t - p, T = r + g; const S = r - g; return e[c++] = m, e[c++] = T, e[--f] = S, e[--f] = m, i && (e[c++] = y, e[c++] = T, e[--f] = S, e[--f] = y), e }, triangulate(s, e, t, r, i, n) { if (s.length === 0) return; let a = 0, o = 0; for (let c = 0; c < s.length; c += 2)a += s[c], o += s[c + 1]; a /= s.length / 2, o /= s.length / 2; let h = r; e[h * t] = a, e[h * t + 1] = o; const l = h++; for (let c = 0; c < s.length; c += 2)e[h * t] = s[c], e[h * t + 1] = s[c + 1], c > 0 && (i[n++] = h, i[n++] = l, i[n++] = h - 1), h++; i[n++] = l + 1, i[n++] = l, i[n++] = h - 1 } }, $d = { ...tr, extension: { ...tr.extension, name: "ellipse" } }, Xd = { ...tr, extension: { ...tr.extension, name: "roundedRectangle" } }, nh = 1e-4, oa = 1e-4; function jd(s) { const e = s.length; if (e < 6) return 1; let t = 0; for (let r = 0, i = s[e - 2], n = s[e - 1]; r < e; r += 2) { const a = s[r], o = s[r + 1]; t += (a - i) * (o + n), i = a, n = o } return t < 0 ? -1 : 1 } function ha(s, e, t, r, i, n, a, o) { const h = s - t * i, l = e - r * i, c = s + t * n, u = e + r * n; let d, f; a ? (d = r, f = -t) : (d = -r, f = t); const p = h + d, g = l + f, m = c + d, y = u + f; return o.push(p, g), o.push(m, y), 2 } function ot(s, e, t, r, i, n, a, o) { const h = t - s, l = r - e; let c = Math.atan2(h, l), u = Math.atan2(i - s, n - e); o && c < u ? c += Math.PI * 2 : !o && c > u && (u += Math.PI * 2); let d = c; const f = u - c, p = Math.abs(f), g = Math.sqrt(h * h + l * l), m = (15 * p * Math.sqrt(g) / Math.PI >> 0) + 1, y = f / m; if (d += y, o) { a.push(s, e), a.push(t, r); for (let T = 1, S = d; T < m; T++, S += y)a.push(s, e), a.push(s + Math.sin(S) * g, e + Math.cos(S) * g); a.push(s, e), a.push(i, n) } else { a.push(t, r), a.push(s, e); for (let T = 1, S = d; T < m; T++, S += y)a.push(s + Math.sin(S) * g, e + Math.cos(S) * g), a.push(s, e); a.push(i, n), a.push(s, e) } return m * 2 } function Yd(s, e, t, r, i, n) { const a = nh; if (s.length === 0) return; const o = e; let h = o.alignment; if (e.alignment !== .5) { let w = jd(s); h = (h - .5) * w + .5 } const l = new oe(s[0], s[1]), c = new oe(s[s.length - 2], s[s.length - 1]), u = r, d = Math.abs(l.x - c.x) < a && Math.abs(l.y - c.y) < a; if (u) { s = s.slice(), d && (s.pop(), s.pop(), c.set(s[s.length - 2], s[s.length - 1])); const w = (l.x + c.x) * .5, P = (c.y + l.y) * .5; s.unshift(w, P), s.push(w, P) } const f = i, p = s.length / 2; let g = s.length; const m = f.length / 2, y = o.width / 2, T = y * y, S = o.miterLimit * o.miterLimit; let A = s[0], R = s[1], E = s[2], C = s[3], L = 0, N = 0, G = -(R - C), I = A - E, V = 0, Z = 0, fe = Math.sqrt(G * G + I * I); G /= fe, I /= fe, G *= y, I *= y; const Ie = h, _ = (1 - Ie) * 2, x = Ie * 2; u || (o.cap === "round" ? g += ot(A - G * (_ - x) * .5, R - I * (_ - x) * .5, A - G * _, R - I * _, A + G * x, R + I * x, f, !0) + 2 : o.cap === "square" && (g += ha(A, R, G, I, _, x, !0, f))), f.push(A - G * _, R - I * _), f.push(A + G * x, R + I * x); for (let w = 1; w < p - 1; ++w) { A = s[(w - 1) * 2], R = s[(w - 1) * 2 + 1], E = s[w * 2], C = s[w * 2 + 1], L = s[(w + 1) * 2], N = s[(w + 1) * 2 + 1], G = -(R - C), I = A - E, fe = Math.sqrt(G * G + I * I), G /= fe, I /= fe, G *= y, I *= y, V = -(C - N), Z = E - L, fe = Math.sqrt(V * V + Z * Z), V /= fe, Z /= fe, V *= y, Z *= y; const P = E - A, M = R - C, B = E - L, k = N - C, W = P * B + M * k, O = M * B - k * P, re = O < 0; if (Math.abs(O) < .001 * Math.abs(W)) { f.push(E - G * _, C - I * _), f.push(E + G * x, C + I * x), W >= 0 && (o.join === "round" ? g += ot(E, C, E - G * _, C - I * _, E - V * _, C - Z * _, f, !1) + 4 : g += 2, f.push(E - V * x, C - Z * x), f.push(E + V * _, C + Z * _)); continue } const se = (-G + A) * (-I + C) - (-G + E) * (-I + R), q = (-V + L) * (-Z + C) - (-V + E) * (-Z + N), ue = (P * q - B * se) / O, te = (k * se - M * q) / O, $e = (ue - E) * (ue - E) + (te - C) * (te - C), Se = E + (ue - E) * _, Ne = C + (te - C) * _, He = E - (ue - E) * x, $ = C - (te - C) * x, Q = Math.min(P * P + M * M, B * B + k * k), ln = re ? _ : x, gc = Q + ln * ln * T; $e <= gc ? o.join === "bevel" || $e / T > S ? (re ? (f.push(Se, Ne), f.push(E + G * x, C + I * x), f.push(Se, Ne), f.push(E + V * x, C + Z * x)) : (f.push(E - G * _, C - I * _), f.push(He, $), f.push(E - V * _, C - Z * _), f.push(He, $)), g += 2) : o.join === "round" ? re ? (f.push(Se, Ne), f.push(E + G * x, C + I * x), g += ot(E, C, E + G * x, C + I * x, E + V * x, C + Z * x, f, !0) + 4, f.push(Se, Ne), f.push(E + V * x, C + Z * x)) : (f.push(E - G * _, C - I * _), f.push(He, $), g += ot(E, C, E - G * _, C - I * _, E - V * _, C - Z * _, f, !1) + 4, f.push(E - V * _, C - Z * _), f.push(He, $)) : (f.push(Se, Ne), f.push(He, $)) : (f.push(E - G * _, C - I * _), f.push(E + G * x, C + I * x), o.join === "round" ? re ? g += ot(E, C, E + G * x, C + I * x, E + V * x, C + Z * x, f, !0) + 2 : g += ot(E, C, E - G * _, C - I * _, E - V * _, C - Z * _, f, !1) + 2 : o.join === "miter" && $e / T <= S && (re ? (f.push(He, $), f.push(He, $)) : (f.push(Se, Ne), f.push(Se, Ne)), g += 2), f.push(E - V * _, C - Z * _), f.push(E + V * x, C + Z * x), g += 2) } A = s[(p - 2) * 2], R = s[(p - 2) * 2 + 1], E = s[(p - 1) * 2], C = s[(p - 1) * 2 + 1], G = -(R - C), I = A - E, fe = Math.sqrt(G * G + I * I), G /= fe, I /= fe, G *= y, I *= y, f.push(E - G * _, C - I * _), f.push(E + G * x, C + I * x), u || (o.cap === "round" ? g += ot(E - G * (_ - x) * .5, C - I * (_ - x) * .5, E - G * _, C - I * _, E + G * x, C + I * x, f, !1) + 2 : o.cap === "square" && (g += ha(E, C, G, I, _, x, !1, f))); const v = oa * oa; for (let w = m; w < g + m - 2; ++w)A = f[w * 2], R = f[w * 2 + 1], E = f[(w + 1) * 2], C = f[(w + 1) * 2 + 1], L = f[(w + 2) * 2], N = f[(w + 2) * 2 + 1], !(Math.abs(A * (C - N) + E * (N - R) + L * (R - C)) < v) && n.push(w, w + 1, w + 2) } function Kd(s, e, t, r) { const i = nh; if (s.length === 0) return; const n = s[0], a = s[1], o = s[s.length - 2], h = s[s.length - 1], l = e || Math.abs(n - o) < i && Math.abs(a - h) < i, c = t, u = s.length / 2, d = c.length / 2; for (let f = 0; f < u; f++)c.push(s[f * 2]), c.push(s[f * 2 + 1]); for (let f = 0; f < u - 1; f++)r.push(d + f, d + f + 1); l && r.push(d + u - 1, d) } function ah(s, e, t, r, i, n, a) { const o = Qu(s, e, 2); if (!o) return; for (let l = 0; l < o.length; l += 3)n[a++] = o[l] + i, n[a++] = o[l + 1] + i, n[a++] = o[l + 2] + i; let h = i * r; for (let l = 0; l < s.length; l += 2)t[h] = s[l], t[h + 1] = s[l + 1], h += r } const qd = [], Zd = { extension: { type: b.ShapeBuilder, name: "polygon" }, build(s, e) { for (let t = 0; t < s.points.length; t++)e[t] = s.points[t]; return e }, triangulate(s, e, t, r, i, n) { ah(s, qd, e, t, r, i, n) } }, Qd = { extension: { type: b.ShapeBuilder, name: "rectangle" }, build(s, e) { const t = s, r = t.x, i = t.y, n = t.width, a = t.height; return n >= 0 && a >= 0 && (e[0] = r, e[1] = i, e[2] = r + n, e[3] = i, e[4] = r + n, e[5] = i + a, e[6] = r, e[7] = i + a), e }, triangulate(s, e, t, r, i, n) { let a = 0; r *= t, e[r + a] = s[0], e[r + a + 1] = s[1], a += t, e[r + a] = s[2], e[r + a + 1] = s[3], a += t, e[r + a] = s[6], e[r + a + 1] = s[7], a += t, e[r + a] = s[4], e[r + a + 1] = s[5], a += t; const o = r / t; i[n++] = o, i[n++] = o + 1, i[n++] = o + 2, i[n++] = o + 1, i[n++] = o + 3, i[n++] = o + 2 } }, Jd = { extension: { type: b.ShapeBuilder, name: "triangle" }, build(s, e) { return e[0] = s.x, e[1] = s.y, e[2] = s.x2, e[3] = s.y2, e[4] = s.x3, e[5] = s.y3, e }, triangulate(s, e, t, r, i, n) { let a = 0; r *= t, e[r + a] = s[0], e[r + a + 1] = s[1], a += t, e[r + a] = s[2], e[r + a + 1] = s[3], a += t, e[r + a] = s[4], e[r + a + 1] = s[5]; const o = r / t; i[n++] = o, i[n++] = o + 1, i[n++] = o + 2 } }, ef = new D, tf = new ne; function rf(s, e, t, r) { const i = e.matrix ? s.copyFrom(e.matrix).invert() : s.identity(); if (e.textureSpace === "local") { const n = t.getBounds(tf); i.translate(-n.x, -n.y), i.scale(1 / n.width, 1 / n.height) } else { i.translate(e.texture.frame.x, e.texture.frame.y), i.scale(1 / e.texture.source.width, 1 / e.texture.source.height); const n = e.texture.source.style; n.addressMode === "clamp-to-edge" && (n.addressMode = "repeat", n.update()) } return r && i.append(ef.copyFrom(r).invert()), i } const qr = {}; z.handleByMap(b.ShapeBuilder, qr); z.add(Qd, Zd, Jd, tr, $d, Xd); const sf = new ne, nf = new D; function af(s, e) { const { geometryData: t, batches: r } = e; r.length = 0, t.indices.length = 0, t.vertices.length = 0, t.uvs.length = 0; for (let i = 0; i < s.instructions.length; i++) { const n = s.instructions[i]; if (n.action === "texture") of(n.data, r, t); else if (n.action === "fill" || n.action === "stroke") { const a = n.action === "stroke", o = n.data.path.shapePath, h = n.data.style, l = n.data.hole; a && l && la(l.shapePath, h, !0, r, t), l && (o.shapePrimitives[o.shapePrimitives.length - 1].holes = l.shapePath.shapePrimitives), la(o, h, a, r, t) } } } function of(s, e, t) { const { vertices: r, uvs: i, indices: n } = t, a = n.length, o = r.length / 2, h = [], l = qr.rectangle, c = sf, u = s.image; c.x = s.dx, c.y = s.dy, c.width = s.dw, c.height = s.dh; const d = s.transform; l.build(c, h), d && ih(h, d), l.triangulate(h, r, 2, o, n, a); const f = u.uvs; i.push(f.x0, f.y0, f.x1, f.y1, f.x3, f.y3, f.x2, f.y2); const p = j.get(Gi); p.indexOffset = a, p.indexSize = n.length - a, p.attributeOffset = o, p.attributeSize = r.length / 2 - o, p.baseColor = s.style, p.alpha = s.alpha, p.texture = u, p.geometryData = t, e.push(p) } function la(s, e, t, r, i) { const { vertices: n, uvs: a, indices: o } = i; s.shapePrimitives.forEach(({ shape: h, transform: l, holes: c }) => { const u = o.length, d = n.length / 2, f = [], p = qr[h.type]; let g = "triangle-list"; if (p.build(h, f), l && ih(f, l), t) { const S = h.closePath ?? !0, A = e; A.pixelLine ? (Kd(f, S, n, o), g = "line-list") : Yd(f, A, !1, S, n, o) } else if (c) { const S = [], A = f.slice(); hf(c).forEach(E => { S.push(A.length / 2), A.push(...E) }), ah(A, S, n, 2, d, o, u) } else p.triangulate(f, n, 2, d, o, u); const m = a.length / 2, y = e.texture; if (y !== F.WHITE) { const S = rf(nf, e, h, l); zd(n, 2, d, a, m, 2, n.length / 2 - d, S) } else Wd(a, m, 2, n.length / 2 - d); const T = j.get(Gi); T.indexOffset = u, T.indexSize = o.length - u, T.attributeOffset = d, T.attributeSize = n.length / 2 - d, T.baseColor = e.color, T.alpha = e.alpha, T.texture = y, T.geometryData = i, T.topology = g, r.push(T) }) } function hf(s) { const e = []; for (let t = 0; t < s.length; t++) { const r = s[t].shape, i = []; qr[r.type].build(r, i), e.push(i) } return e } class lf { constructor() { this.batches = [], this.geometryData = { vertices: [], uvs: [], indices: [] } } } class cf { constructor() { this.batcher = new Ii, this.instructions = new _o } init() { this.instructions.reset() } get geometry() { return X(Rc, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry } } const Fi = class ti { constructor(e) { this._gpuContextHash = {}, this._graphicsDataContextHash = Object.create(null), e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash") } init(e) { ti.defaultOptions.bezierSmoothness = (e == null ? void 0 : e.bezierSmoothness) ?? ti.defaultOptions.bezierSmoothness } getContextRenderData(e) { return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e) } updateGpuContext(e) { let t = this._gpuContextHash[e.uid] || this._initContext(e); if (e.dirty) { t ? this._cleanGraphicsContextData(e) : t = this._initContext(e), af(e, t); const r = e.batchMode; e.customShader || r === "no-batch" ? t.isBatchable = !1 : r === "auto" && (t.isBatchable = t.geometryData.vertices.length < 400), e.dirty = !1 } return t } getGpuContext(e) { return this._gpuContextHash[e.uid] || this._initContext(e) } _initContextRenderData(e) { const t = j.get(cf), { batches: r, geometryData: i } = this._gpuContextHash[e.uid], n = i.vertices.length, a = i.indices.length; for (let c = 0; c < r.length; c++)r[c].applyTransform = !1; const o = t.batcher; o.ensureAttributeBuffer(n), o.ensureIndexBuffer(a), o.begin(); for (let c = 0; c < r.length; c++) { const u = r[c]; o.add(u) } o.finish(t.instructions); const h = o.geometry; h.indexBuffer.setDataWithSize(o.indexBuffer, o.indexSize, !0), h.buffers[0].setDataWithSize(o.attributeBuffer.float32View, o.attributeSize, !0); const l = o.batches; for (let c = 0; c < l.length; c++) { const u = l[c]; u.bindGroup = Ei(u.textures.textures, u.textures.count) } return this._graphicsDataContextHash[e.uid] = t, t } _initContext(e) { const t = new lf; return t.context = e, this._gpuContextHash[e.uid] = t, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] } onGraphicsContextDestroy(e) { this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null } _cleanGraphicsContextData(e) { const t = this._gpuContextHash[e.uid]; t.isBatchable || this._graphicsDataContextHash[e.uid] && (j.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), t.batches && t.batches.forEach(r => { j.return(r) }) } destroy() { for (const e in this._gpuContextHash) this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context) } }; Fi.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "graphicsContext" }; Fi.defaultOptions = { bezierSmoothness: .5 }; let Ui = Fi; const uf = 8, vr = 11920929e-14, df = 1; function oh(s, e, t, r, i, n, a, o, h, l) { const u = Math.min(.99, Math.max(0, l ?? Ui.defaultOptions.bezierSmoothness)); let d = (df - u) / 1; return d *= d, ff(e, t, r, i, n, a, o, h, s, d), s } function ff(s, e, t, r, i, n, a, o, h, l) { ri(s, e, t, r, i, n, a, o, h, l, 0), h.push(a, o) } function ri(s, e, t, r, i, n, a, o, h, l, c) { if (c > uf) return; const u = (s + t) / 2, d = (e + r) / 2, f = (t + i) / 2, p = (r + n) / 2, g = (i + a) / 2, m = (n + o) / 2, y = (u + f) / 2, T = (d + p) / 2, S = (f + g) / 2, A = (p + m) / 2, R = (y + S) / 2, E = (T + A) / 2; if (c > 0) { let C = a - s, L = o - e; const N = Math.abs((t - a) * L - (r - o) * C), G = Math.abs((i - a) * L - (n - o) * C); if (N > vr && G > vr) { if ((N + G) * (N + G) <= l * (C * C + L * L)) { h.push(R, E); return } } else if (N > vr) { if (N * N <= l * (C * C + L * L)) { h.push(R, E); return } } else if (G > vr) { if (G * G <= l * (C * C + L * L)) { h.push(R, E); return } } else if (C = R - (s + a) / 2, L = E - (e + o) / 2, C * C + L * L <= l) { h.push(R, E); return } } ri(s, e, u, d, y, T, R, E, h, l, c + 1), ri(R, E, S, A, g, m, a, o, h, l, c + 1) } const pf = 8, mf = 11920929e-14, gf = 1; function _f(s, e, t, r, i, n, a, o) { const l = Math.min(.99, Math.max(0, o ?? Ui.defaultOptions.bezierSmoothness)); let c = (gf - l) / 1; return c *= c, xf(e, t, r, i, n, a, s, c), s } function xf(s, e, t, r, i, n, a, o) { si(a, s, e, t, r, i, n, o, 0), a.push(i, n) } function si(s, e, t, r, i, n, a, o, h) { if (h > pf) return; const l = (e + r) / 2, c = (t + i) / 2, u = (r + n) / 2, d = (i + a) / 2, f = (l + u) / 2, p = (c + d) / 2; let g = n - e, m = a - t; const y = Math.abs((r - n) * m - (i - a) * g); if (y > mf) { if (y * y <= o * (g * g + m * m)) { s.push(f, p); return } } else if (g = f - (e + n) / 2, m = p - (t + a) / 2, g * g + m * m <= o) { s.push(f, p); return } si(s, e, t, l, c, f, p, o, h + 1), si(s, f, p, u, d, n, a, o, h + 1) } function hh(s, e, t, r, i, n, a, o) { let h = Math.abs(i - n); (!a && i > n || a && n > i) && (h = 2 * Math.PI - h), o || (o = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (h / Math.PI)))), o = Math.max(o, 3); let l = h / o, c = i; l *= a ? -1 : 1; for (let u = 0; u < o + 1; u++) { const d = Math.cos(c), f = Math.sin(c), p = e + d * r, g = t + f * r; s.push(p, g), c += l } } function yf(s, e, t, r, i, n) { const a = s[s.length - 2], h = s[s.length - 1] - t, l = a - e, c = i - t, u = r - e, d = Math.abs(h * u - l * c); if (d < 1e-8 || n === 0) { (s[s.length - 2] !== e || s[s.length - 1] !== t) && s.push(e, t); return } const f = h * h + l * l, p = c * c + u * u, g = h * c + l * u, m = n * Math.sqrt(f) / d, y = n * Math.sqrt(p) / d, T = m * g / f, S = y * g / p, A = m * u + y * l, R = m * c + y * h, E = l * (y + T), C = h * (y + T), L = u * (m + S), N = c * (m + S), G = Math.atan2(C - R, E - A), I = Math.atan2(N - R, L - A); hh(s, A + e, R + t, n, G, I, l * c > u * h) } const Kt = Math.PI * 2, Cs = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 }, Ms = ({ x: s, y: e }, t, r, i, n, a, o, h) => { s *= t, e *= r; const l = i * s - n * e, c = n * s + i * e; return h.x = l + a, h.y = c + o, h }; function bf(s, e) { const t = e === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(e / 4), r = e === 1.5707963267948966 ? .551915024494 : t, i = Math.cos(s), n = Math.sin(s), a = Math.cos(s + e), o = Math.sin(s + e); return [{ x: i - n * r, y: n + i * r }, { x: a + o * r, y: o - a * r }, { x: a, y: o }] } const ca = (s, e, t, r) => { const i = s * r - e * t < 0 ? -1 : 1; let n = s * t + e * r; return n > 1 && (n = 1), n < -1 && (n = -1), i * Math.acos(n) }, vf = (s, e, t, r, i, n, a, o, h, l, c, u, d) => { const f = Math.pow(i, 2), p = Math.pow(n, 2), g = Math.pow(c, 2), m = Math.pow(u, 2); let y = f * p - f * m - p * g; y < 0 && (y = 0), y /= f * m + p * g, y = Math.sqrt(y) * (a === o ? -1 : 1); const T = y * i / n * u, S = y * -n / i * c, A = l * T - h * S + (s + t) / 2, R = h * T + l * S + (e + r) / 2, E = (c - T) / i, C = (u - S) / n, L = (-c - T) / i, N = (-u - S) / n, G = ca(1, 0, E, C); let I = ca(E, C, L, N); o === 0 && I > 0 && (I -= Kt), o === 1 && I < 0 && (I += Kt), d.centerX = A, d.centerY = R, d.ang1 = G, d.ang2 = I }; function Tf(s, e, t, r, i, n, a, o = 0, h = 0, l = 0) { if (n === 0 || a === 0) return; const c = Math.sin(o * Kt / 360), u = Math.cos(o * Kt / 360), d = u * (e - r) / 2 + c * (t - i) / 2, f = -c * (e - r) / 2 + u * (t - i) / 2; if (d === 0 && f === 0) return; n = Math.abs(n), a = Math.abs(a); const p = Math.pow(d, 2) / Math.pow(n, 2) + Math.pow(f, 2) / Math.pow(a, 2); p > 1 && (n *= Math.sqrt(p), a *= Math.sqrt(p)), vf(e, t, r, i, n, a, h, l, c, u, d, f, Cs); let { ang1: g, ang2: m } = Cs; const { centerX: y, centerY: T } = Cs; let S = Math.abs(m) / (Kt / 4); Math.abs(1 - S) < 1e-7 && (S = 1); const A = Math.max(Math.ceil(S), 1); m /= A; let R = s[s.length - 2], E = s[s.length - 1]; const C = { x: 0, y: 0 }; for (let L = 0; L < A; L++) { const N = bf(g, m), { x: G, y: I } = Ms(N[0], n, a, u, c, y, T, C), { x: V, y: Z } = Ms(N[1], n, a, u, c, y, T, C), { x: fe, y: Ie } = Ms(N[2], n, a, u, c, y, T, C); oh(s, R, E, G, I, V, Z, fe, Ie), R = fe, E = Ie, g += m } } function Sf(s, e, t) { const r = (a, o) => { const h = o.x - a.x, l = o.y - a.y, c = Math.sqrt(h * h + l * l), u = h / c, d = l / c; return { len: c, nx: u, ny: d } }, i = (a, o) => { a === 0 ? s.moveTo(o.x, o.y) : s.lineTo(o.x, o.y) }; let n = e[e.length - 1]; for (let a = 0; a < e.length; a++) { const o = e[a % e.length], h = o.radius ?? t; if (h <= 0) { i(a, o), n = o; continue } const l = e[(a + 1) % e.length], c = r(o, n), u = r(o, l); if (c.len < 1e-4 || u.len < 1e-4) { i(a, o), n = o; continue } let d = Math.asin(c.nx * u.ny - c.ny * u.nx), f = 1, p = !1; c.nx * u.nx - c.ny * -u.ny < 0 ? d < 0 ? d = Math.PI + d : (d = Math.PI - d, f = -1, p = !0) : d > 0 && (f = -1, p = !0); const g = d / 2; let m, y = Math.abs(Math.cos(g) * h / Math.sin(g)); y > Math.min(c.len / 2, u.len / 2) ? (y = Math.min(c.len / 2, u.len / 2), m = Math.abs(y * Math.sin(g) / Math.cos(g))) : m = h; const T = o.x + u.nx * y + -u.ny * m * f, S = o.y + u.ny * y + u.nx * m * f, A = Math.atan2(c.ny, c.nx) + Math.PI / 2 * f, R = Math.atan2(u.ny, u.nx) - Math.PI / 2 * f; a === 0 && s.moveTo(T + Math.cos(A) * m, S + Math.sin(A) * m), s.arc(T, S, m, A, R, p), n = o } } function wf(s, e, t, r) { const i = (o, h) => Math.sqrt((o.x - h.x) ** 2 + (o.y - h.y) ** 2), n = (o, h, l) => ({ x: o.x + (h.x - o.x) * l, y: o.y + (h.y - o.y) * l }), a = e.length; for (let o = 0; o < a; o++) { const h = e[(o + 1) % a], l = h.radius ?? t; if (l <= 0) { o === 0 ? s.moveTo(h.x, h.y) : s.lineTo(h.x, h.y); continue } const c = e[o], u = e[(o + 2) % a], d = i(c, h); let f; if (d < 1e-4) f = h; else { const m = Math.min(d / 2, l); f = n(h, c, m / d) } const p = i(u, h); let g; if (p < 1e-4) g = h; else { const m = Math.min(p / 2, l); g = n(h, u, m / p) } o === 0 ? s.moveTo(f.x, f.y) : s.lineTo(f.x, f.y), s.quadraticCurveTo(h.x, h.y, g.x, g.y, r) } } const Af = new ne; class Pf { constructor(e) { this.shapePrimitives = [], this._currentPoly = null, this._bounds = new xe, this._graphicsPath2D = e, this.signed = e.checkForHoles } moveTo(e, t) { return this.startPoly(e, t), this } lineTo(e, t) { this._ensurePoly(); const r = this._currentPoly.points, i = r[r.length - 2], n = r[r.length - 1]; return (i !== e || n !== t) && r.push(e, t), this } arc(e, t, r, i, n, a) { this._ensurePoly(!1); const o = this._currentPoly.points; return hh(o, e, t, r, i, n, a), this } arcTo(e, t, r, i, n) { this._ensurePoly(); const a = this._currentPoly.points; return yf(a, e, t, r, i, n), this } arcToSvg(e, t, r, i, n, a, o) { const h = this._currentPoly.points; return Tf(h, this._currentPoly.lastX, this._currentPoly.lastY, a, o, e, t, r, i, n), this } bezierCurveTo(e, t, r, i, n, a, o) { this._ensurePoly(); const h = this._currentPoly; return oh(this._currentPoly.points, h.lastX, h.lastY, e, t, r, i, n, a, o), this } quadraticCurveTo(e, t, r, i, n) { this._ensurePoly(); const a = this._currentPoly; return _f(this._currentPoly.points, a.lastX, a.lastY, e, t, r, i, n), this } closePath() { return this.endPoly(!0), this } addPath(e, t) { this.endPoly(), t && !t.isIdentity() && (e = e.clone(!0), e.transform(t)); const r = this.shapePrimitives, i = r.length; for (let n = 0; n < e.instructions.length; n++) { const a = e.instructions[n]; this[a.action](...a.data) } if (e.checkForHoles && r.length - i > 1) { let n = null; for (let a = i; a < r.length; a++) { const o = r[a]; if (o.shape.type === "polygon") { const h = o.shape, l = n == null ? void 0 : n.shape; l && l.containsPolygon(h) ? (n.holes || (n.holes = []), n.holes.push(o), r.copyWithin(a, a + 1), r.length--, a--) : n = o } } } return this } finish(e = !1) { this.endPoly(e) } rect(e, t, r, i, n) { return this.drawShape(new ne(e, t, r, i), n), this } circle(e, t, r, i) { return this.drawShape(new wi(e, t, r), i), this } poly(e, t, r) { const i = new Yt(e); return i.closePath = t, this.drawShape(i, r), this } regularPoly(e, t, r, i, n = 0, a) { i = Math.max(i | 0, 3); const o = -1 * Math.PI / 2 + n, h = Math.PI * 2 / i, l = []; for (let c = 0; c < i; c++) { const u = o - c * h; l.push(e + r * Math.cos(u), t + r * Math.sin(u)) } return this.poly(l, !0, a), this } roundPoly(e, t, r, i, n, a = 0, o) { if (i = Math.max(i | 0, 3), n <= 0) return this.regularPoly(e, t, r, i, a); const h = r * Math.sin(Math.PI / i) - .001; n = Math.min(n, h); const l = -1 * Math.PI / 2 + a, c = Math.PI * 2 / i, u = (i - 2) * Math.PI / i / 2; for (let d = 0; d < i; d++) { const f = d * c + l, p = e + r * Math.cos(f), g = t + r * Math.sin(f), m = f + Math.PI + u, y = f - Math.PI - u, T = p + n * Math.cos(m), S = g + n * Math.sin(m), A = p + n * Math.cos(y), R = g + n * Math.sin(y); d === 0 ? this.moveTo(T, S) : this.lineTo(T, S), this.quadraticCurveTo(p, g, A, R, o) } return this.closePath() } roundShape(e, t, r = !1, i) { return e.length < 3 ? this : (r ? wf(this, e, t, i) : Sf(this, e, t), this.closePath()) } filletRect(e, t, r, i, n) { if (n === 0) return this.rect(e, t, r, i); const a = Math.min(r, i) / 2, o = Math.min(a, Math.max(-a, n)), h = e + r, l = t + i, c = o < 0 ? -o : 0, u = Math.abs(o); return this.moveTo(e, t + u).arcTo(e + c, t + c, e + u, t, u).lineTo(h - u, t).arcTo(h - c, t + c, h, t + u, u).lineTo(h, l - u).arcTo(h - c, l - c, e + r - u, l, u).lineTo(e + u, l).arcTo(e + c, l - c, e, l - u, u).closePath() } chamferRect(e, t, r, i, n, a) { if (n <= 0) return this.rect(e, t, r, i); const o = Math.min(n, Math.min(r, i) / 2), h = e + r, l = t + i, c = [e + o, t, h - o, t, h, t + o, h, l - o, h - o, l, e + o, l, e, l - o, e, t + o]; for (let u = c.length - 1; u >= 2; u -= 2)c[u] === c[u - 2] && c[u - 1] === c[u - 3] && c.splice(u - 1, 2); return this.poly(c, !0, a) } ellipse(e, t, r, i, n) { return this.drawShape(new Ai(e, t, r, i), n), this } roundRect(e, t, r, i, n, a) { return this.drawShape(new Pi(e, t, r, i, n), a), this } drawShape(e, t) { return this.endPoly(), this.shapePrimitives.push({ shape: e, transform: t }), this } startPoly(e, t) { let r = this._currentPoly; return r && this.endPoly(), r = new Yt, r.points.push(e, t), this._currentPoly = r, this } endPoly(e = !1) { const t = this._currentPoly; return t && t.points.length > 2 && (t.closePath = e, this.shapePrimitives.push({ shape: t })), this._currentPoly = null, this } _ensurePoly(e = !0) { if (!this._currentPoly && (this._currentPoly = new Yt, e)) { const t = this.shapePrimitives[this.shapePrimitives.length - 1]; if (t) { let r = t.shape.x, i = t.shape.y; if (t.transform && !t.transform.isIdentity()) { const n = t.transform, a = r; r = n.a * r + n.c * i + n.tx, i = n.b * a + n.d * i + n.ty } this._currentPoly.points.push(r, i) } else this._currentPoly.points.push(0, 0) } } buildPath() { const e = this._graphicsPath2D; this.shapePrimitives.length = 0, this._currentPoly = null; for (let t = 0; t < e.instructions.length; t++) { const r = e.instructions[t]; this[r.action](...r.data) } this.finish() } get bounds() { const e = this._bounds; e.clear(); const t = this.shapePrimitives; for (let r = 0; r < t.length; r++) { const i = t[r], n = i.shape.getBounds(Af); i.transform ? e.addRect(n, i.transform) : e.addRect(n) } return e } } class Mt { constructor(e, t = !1) { this.instructions = [], this.uid = he("graphicsPath"), this._dirty = !0, this.checkForHoles = t, typeof e == "string" ? od(e, this) : this.instructions = (e == null ? void 0 : e.slice()) ?? [] } get shapePath() { return this._shapePath || (this._shapePath = new Pf(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath } addPath(e, t) { return e = e.clone(), this.instructions.push({ action: "addPath", data: [e, t] }), this._dirty = !0, this } arc(...e) { return this.instructions.push({ action: "arc", data: e }), this._dirty = !0, this } arcTo(...e) { return this.instructions.push({ action: "arcTo", data: e }), this._dirty = !0, this } arcToSvg(...e) { return this.instructions.push({ action: "arcToSvg", data: e }), this._dirty = !0, this } bezierCurveTo(...e) { return this.instructions.push({ action: "bezierCurveTo", data: e }), this._dirty = !0, this } bezierCurveToShort(e, t, r, i, n) { const a = this.instructions[this.instructions.length - 1], o = this.getLastPoint(oe.shared); let h = 0, l = 0; if (!a || a.action !== "bezierCurveTo") h = o.x, l = o.y; else { h = a.data[2], l = a.data[3]; const c = o.x, u = o.y; h = c + (c - h), l = u + (u - l) } return this.instructions.push({ action: "bezierCurveTo", data: [h, l, e, t, r, i, n] }), this._dirty = !0, this } closePath() { return this.instructions.push({ action: "closePath", data: [] }), this._dirty = !0, this } ellipse(...e) { return this.instructions.push({ action: "ellipse", data: e }), this._dirty = !0, this } lineTo(...e) { return this.instructions.push({ action: "lineTo", data: e }), this._dirty = !0, this } moveTo(...e) { return this.instructions.push({ action: "moveTo", data: e }), this } quadraticCurveTo(...e) { return this.instructions.push({ action: "quadraticCurveTo", data: e }), this._dirty = !0, this } quadraticCurveToShort(e, t, r) { const i = this.instructions[this.instructions.length - 1], n = this.getLastPoint(oe.shared); let a = 0, o = 0; if (!i || i.action !== "quadraticCurveTo") a = n.x, o = n.y; else { a = i.data[0], o = i.data[1]; const h = n.x, l = n.y; a = h + (h - a), o = l + (l - o) } return this.instructions.push({ action: "quadraticCurveTo", data: [a, o, e, t, r] }), this._dirty = !0, this } rect(e, t, r, i, n) { return this.instructions.push({ action: "rect", data: [e, t, r, i, n] }), this._dirty = !0, this } circle(e, t, r, i) { return this.instructions.push({ action: "circle", data: [e, t, r, i] }), this._dirty = !0, this } roundRect(...e) { return this.instructions.push({ action: "roundRect", data: e }), this._dirty = !0, this } poly(...e) { return this.instructions.push({ action: "poly", data: e }), this._dirty = !0, this } regularPoly(...e) { return this.instructions.push({ action: "regularPoly", data: e }), this._dirty = !0, this } roundPoly(...e) { return this.instructions.push({ action: "roundPoly", data: e }), this._dirty = !0, this } roundShape(...e) { return this.instructions.push({ action: "roundShape", data: e }), this._dirty = !0, this } filletRect(...e) { return this.instructions.push({ action: "filletRect", data: e }), this._dirty = !0, this } chamferRect(...e) { return this.instructions.push({ action: "chamferRect", data: e }), this._dirty = !0, this } star(e, t, r, i, n, a, o) { n || (n = i / 2); const h = -1 * Math.PI / 2 + a, l = r * 2, c = Math.PI * 2 / l, u = []; for (let d = 0; d < l; d++) { const f = d % 2 ? n : i, p = d * c + h; u.push(e + f * Math.cos(p), t + f * Math.sin(p)) } return this.poly(u, !0, o), this } clone(e = !1) { const t = new Mt; if (t.checkForHoles = this.checkForHoles, !e) t.instructions = this.instructions.slice(); else for (let r = 0; r < this.instructions.length; r++) { const i = this.instructions[r]; t.instructions.push({ action: i.action, data: i.data.slice() }) } return t } clear() { return this.instructions.length = 0, this._dirty = !0, this } transform(e) { if (e.isIdentity()) return this; const t = e.a, r = e.b, i = e.c, n = e.d, a = e.tx, o = e.ty; let h = 0, l = 0, c = 0, u = 0, d = 0, f = 0, p = 0, g = 0; for (let m = 0; m < this.instructions.length; m++) { const y = this.instructions[m], T = y.data; switch (y.action) { case "moveTo": case "lineTo": h = T[0], l = T[1], T[0] = t * h + i * l + a, T[1] = r * h + n * l + o; break; case "bezierCurveTo": c = T[0], u = T[1], d = T[2], f = T[3], h = T[4], l = T[5], T[0] = t * c + i * u + a, T[1] = r * c + n * u + o, T[2] = t * d + i * f + a, T[3] = r * d + n * f + o, T[4] = t * h + i * l + a, T[5] = r * h + n * l + o; break; case "quadraticCurveTo": c = T[0], u = T[1], h = T[2], l = T[3], T[0] = t * c + i * u + a, T[1] = r * c + n * u + o, T[2] = t * h + i * l + a, T[3] = r * h + n * l + o; break; case "arcToSvg": h = T[5], l = T[6], p = T[0], g = T[1], T[0] = t * p + i * g, T[1] = r * p + n * g, T[5] = t * h + i * l + a, T[6] = r * h + n * l + o; break; case "circle": T[4] = Lt(T[3], e); break; case "rect": T[4] = Lt(T[4], e); break; case "ellipse": T[8] = Lt(T[8], e); break; case "roundRect": T[5] = Lt(T[5], e); break; case "addPath": T[0].transform(e); break; case "poly": T[2] = Lt(T[2], e); break; default: H("unknown transform action", y.action); break } } return this._dirty = !0, this } get bounds() { return this.shapePath.bounds } getLastPoint(e) { let t = this.instructions.length - 1, r = this.instructions[t]; if (!r) return e.x = 0, e.y = 0, e; for (; r.action === "closePath";) { if (t--, t < 0) return e.x = 0, e.y = 0, e; r = this.instructions[t] } switch (r.action) { case "moveTo": case "lineTo": e.x = r.data[0], e.y = r.data[1]; break; case "quadraticCurveTo": e.x = r.data[2], e.y = r.data[3]; break; case "bezierCurveTo": e.x = r.data[4], e.y = r.data[5]; break; case "arc": case "arcToSvg": e.x = r.data[5], e.y = r.data[6]; break; case "addPath": r.data[0].getLastPoint(e); break }return e } } function Lt(s, e) { return s ? s.prepend(e) : e.clone() } function ce(s, e, t) { const r = s.getAttribute(e); return r ? Number(r) : t } function Ef(s, e) { const t = s.querySelectorAll("defs"); for (let r = 0; r < t.length; r++) { const i = t[r]; for (let n = 0; n < i.children.length; n++) { const a = i.children[n]; switch (a.nodeName.toLowerCase()) { case "lineargradient": e.defs[a.id] = Cf(a); break; case "radialgradient": e.defs[a.id] = Mf(); break } } } } function Cf(s) { const e = ce(s, "x1", 0), t = ce(s, "y1", 0), r = ce(s, "x2", 1), i = ce(s, "y2", 0), n = s.getAttribute("gradientUnits") || "objectBoundingBox", a = new st(e, t, r, i, n === "objectBoundingBox" ? "local" : "global"); for (let o = 0; o < s.children.length; o++) { const h = s.children[o], l = ce(h, "offset", 0), c = ie.shared.setValue(h.getAttribute("stop-color")).toNumber(); a.addColorStop(l, c) } return a } function Mf(s) { return H("[SVG Parser] Radial gradients are not yet supported"), new st(0, 0, 1, 0) } function ua(s) { const e = s.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i); return e ? e[1] : "" } const da = { fill: { type: "paint", default: 0 }, "fill-opacity": { type: "number", default: 1 }, stroke: { type: "paint", default: 0 }, "stroke-width": { type: "number", default: 1 }, "stroke-opacity": { type: "number", default: 1 }, "stroke-linecap": { type: "string", default: "butt" }, "stroke-linejoin": { type: "string", default: "miter" }, "stroke-miterlimit": { type: "number", default: 10 }, "stroke-dasharray": { type: "string", default: "none" }, "stroke-dashoffset": { type: "number", default: 0 }, opacity: { type: "number", default: 1 } }; function lh(s, e) { const t = s.getAttribute("style"), r = {}, i = {}, n = { strokeStyle: r, fillStyle: i, useFill: !1, useStroke: !1 }; for (const a in da) { const o = s.getAttribute(a); o && fa(e, n, a, o.trim()) } if (t) { const a = t.split(";"); for (let o = 0; o < a.length; o++) { const h = a[o].trim(), [l, c] = h.split(":"); da[l] && fa(e, n, l, c.trim()) } } return { strokeStyle: n.useStroke ? r : null, fillStyle: n.useFill ? i : null, useFill: n.useFill, useStroke: n.useStroke } } function fa(s, e, t, r) { switch (t) { case "stroke": if (r !== "none") { if (r.startsWith("url(")) { const i = ua(r); e.strokeStyle.fill = s.defs[i] } else e.strokeStyle.color = ie.shared.setValue(r).toNumber(); e.useStroke = !0 } break; case "stroke-width": e.strokeStyle.width = Number(r); break; case "fill": if (r !== "none") { if (r.startsWith("url(")) { const i = ua(r); e.fillStyle.fill = s.defs[i] } else e.fillStyle.color = ie.shared.setValue(r).toNumber(); e.useFill = !0 } break; case "fill-opacity": e.fillStyle.alpha = Number(r); break; case "stroke-opacity": e.strokeStyle.alpha = Number(r); break; case "opacity": e.fillStyle.alpha = Number(r), e.strokeStyle.alpha = Number(r); break } } function Bf(s, e) { if (typeof s == "string") { const a = document.createElement("div"); a.innerHTML = s.trim(), s = a.querySelector("svg") } const t = { context: e, defs: {}, path: new Mt }; Ef(s, t); const r = s.children, { fillStyle: i, strokeStyle: n } = lh(s, t); for (let a = 0; a < r.length; a++) { const o = r[a]; o.nodeName.toLowerCase() !== "defs" && ch(o, t, i, n) } return e } function ch(s, e, t, r) { const i = s.children, { fillStyle: n, strokeStyle: a } = lh(s, e); n && t ? t = { ...t, ...n } : n && (t = n), a && r ? r = { ...r, ...a } : a && (r = a); const o = !t && !r; o && (t = { color: 0 }); let h, l, c, u, d, f, p, g, m, y, T, S, A, R, E, C, L; switch (s.nodeName.toLowerCase()) { case "path": R = s.getAttribute("d"), s.getAttribute("fill-rule") === "evenodd" && H("SVG Evenodd fill rule not supported, your svg may render incorrectly"), E = new Mt(R, !0), e.context.path(E), t && e.context.fill(t), r && e.context.stroke(r); break; case "circle": p = ce(s, "cx", 0), g = ce(s, "cy", 0), m = ce(s, "r", 0), e.context.ellipse(p, g, m, m), t && e.context.fill(t), r && e.context.stroke(r); break; case "rect": h = ce(s, "x", 0), l = ce(s, "y", 0), C = ce(s, "width", 0), L = ce(s, "height", 0), y = ce(s, "rx", 0), T = ce(s, "ry", 0), y || T ? e.context.roundRect(h, l, C, L, y || T) : e.context.rect(h, l, C, L), t && e.context.fill(t), r && e.context.stroke(r); break; case "ellipse": p = ce(s, "cx", 0), g = ce(s, "cy", 0), y = ce(s, "rx", 0), T = ce(s, "ry", 0), e.context.beginPath(), e.context.ellipse(p, g, y, T), t && e.context.fill(t), r && e.context.stroke(r); break; case "line": c = ce(s, "x1", 0), u = ce(s, "y1", 0), d = ce(s, "x2", 0), f = ce(s, "y2", 0), e.context.beginPath(), e.context.moveTo(c, u), e.context.lineTo(d, f), r && e.context.stroke(r); break; case "polygon": A = s.getAttribute("points"), S = A.match(/\d+/g).map(N => parseInt(N, 10)), e.context.poly(S, !0), t && e.context.fill(t), r && e.context.stroke(r); break; case "polyline": A = s.getAttribute("points"), S = A.match(/\d+/g).map(N => parseInt(N, 10)), e.context.poly(S, !1), r && e.context.stroke(r); break; case "g": case "svg": break; default: { H(`[SVG parser] <${s.nodeName}> elements unsupported`); break } }o && (t = null); for (let N = 0; N < i.length; N++)ch(i[N], e, t, r) } function Rf(s) { return ie.isColorLike(s) } function pa(s) { return s instanceof Kr } function ma(s) { return s instanceof st } function kf(s) { return s instanceof F } function If(s, e, t) { const r = ie.shared.setValue(e ?? 0); return s.color = r.toNumber(), s.alpha = r.alpha === 1 ? t.alpha : r.alpha, s.texture = F.WHITE, { ...t, ...s } } function Gf(s, e, t) { return s.texture = e, { ...t, ...s } } function ga(s, e, t) { return s.fill = e, s.color = 16777215, s.texture = e.texture, s.matrix = e.transform, { ...t, ...s } } function _a(s, e, t) { return e.buildGradient(), s.fill = e, s.color = 16777215, s.texture = e.texture, s.matrix = e.transform, s.textureSpace = e.textureSpace, { ...t, ...s } } function Ff(s, e) { const t = { ...e, ...s }, r = ie.shared.setValue(t.color); return t.alpha *= r.alpha, t.color = r.toNumber(), t } function dt(s, e) { if (s == null) return null; const t = {}, r = s; return Rf(s) ? If(t, s, e) : kf(s) ? Gf(t, s, e) : pa(s) ? ga(t, s, e) : ma(s) ? _a(t, s, e) : r.fill && pa(r.fill) ? ga(r, r.fill, e) : r.fill && ma(r.fill) ? _a(r, r.fill, e) : Ff(r, e) } function Hr(s, e) { const { width: t, alignment: r, miterLimit: i, cap: n, join: a, pixelLine: o, ...h } = e, l = dt(s, h); return l ? { width: t, alignment: r, miterLimit: i, cap: n, join: a, pixelLine: o, ...l } : null } const Uf = new oe, xa = new D, Di = class We extends Ce { constructor() { super(...arguments), this.uid = he("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new Mt, this._transform = new D, this._fillStyle = { ...We.defaultFillStyle }, this._strokeStyle = { ...We.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new xe, this._boundsDirty = !0 } clone() { const e = new We; return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = { ...this._fillStyle }, e._strokeStyle = { ...this._strokeStyle }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = !0, e } get fillStyle() { return this._fillStyle } set fillStyle(e) { this._fillStyle = dt(e, We.defaultFillStyle) } get strokeStyle() { return this._strokeStyle } set strokeStyle(e) { this._strokeStyle = Hr(e, We.defaultStrokeStyle) } setFillStyle(e) { return this._fillStyle = dt(e, We.defaultFillStyle), this } setStrokeStyle(e) { return this._strokeStyle = dt(e, We.defaultStrokeStyle), this } texture(e, t, r, i, n, a) { return this.instructions.push({ action: "texture", data: { image: e, dx: r || 0, dy: i || 0, dw: n || e.frame.width, dh: a || e.frame.height, transform: this._transform.clone(), alpha: this._fillStyle.alpha, style: t ? ie.shared.setValue(t).toNumber() : 16777215 } }), this.onUpdate(), this } beginPath() { return this._activePath = new Mt, this } fill(e, t) { let r; const i = this.instructions[this.instructions.length - 1]; return this._tick === 0 && i && i.action === "stroke" ? r = i.data.path : r = this._activePath.clone(), r ? (e != null && (t !== void 0 && typeof e == "number" && (X(ee, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = { color: e, alpha: t }), this._fillStyle = dt(e, We.defaultFillStyle)), this.instructions.push({ action: "fill", data: { style: this.fillStyle, path: r } }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this } _initNextPathLocation() { const { x: e, y: t } = this._activePath.getLastPoint(oe.shared); this._activePath.clear(), this._activePath.moveTo(e, t) } stroke(e) { let t; const r = this.instructions[this.instructions.length - 1]; return this._tick === 0 && r && r.action === "fill" ? t = r.data.path : t = this._activePath.clone(), t ? (e != null && (this._strokeStyle = Hr(e, We.defaultStrokeStyle)), this.instructions.push({ action: "stroke", data: { style: this.strokeStyle, path: t } }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this } cut() { for (let e = 0; e < 2; e++) { const t = this.instructions[this.instructions.length - 1 - e], r = this._activePath.clone(); if (t && (t.action === "stroke" || t.action === "fill")) if (t.data.hole) t.data.hole.addPath(r); else { t.data.hole = r; break } } return this._initNextPathLocation(), this } arc(e, t, r, i, n, a) { this._tick++; const o = this._transform; return this._activePath.arc(o.a * e + o.c * t + o.tx, o.b * e + o.d * t + o.ty, r, i, n, a), this } arcTo(e, t, r, i, n) { this._tick++; const a = this._transform; return this._activePath.arcTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * r + a.c * i + a.tx, a.b * r + a.d * i + a.ty, n), this } arcToSvg(e, t, r, i, n, a, o) { this._tick++; const h = this._transform; return this._activePath.arcToSvg(e, t, r, i, n, h.a * a + h.c * o + h.tx, h.b * a + h.d * o + h.ty), this } bezierCurveTo(e, t, r, i, n, a, o) { this._tick++; const h = this._transform; return this._activePath.bezierCurveTo(h.a * e + h.c * t + h.tx, h.b * e + h.d * t + h.ty, h.a * r + h.c * i + h.tx, h.b * r + h.d * i + h.ty, h.a * n + h.c * a + h.tx, h.b * n + h.d * a + h.ty, o), this } closePath() { var e; return this._tick++, (e = this._activePath) == null || e.closePath(), this } ellipse(e, t, r, i) { return this._tick++, this._activePath.ellipse(e, t, r, i, this._transform.clone()), this } circle(e, t, r) { return this._tick++, this._activePath.circle(e, t, r, this._transform.clone()), this } path(e) { return this._tick++, this._activePath.addPath(e, this._transform.clone()), this } lineTo(e, t) { this._tick++; const r = this._transform; return this._activePath.lineTo(r.a * e + r.c * t + r.tx, r.b * e + r.d * t + r.ty), this } moveTo(e, t) { this._tick++; const r = this._transform, i = this._activePath.instructions, n = r.a * e + r.c * t + r.tx, a = r.b * e + r.d * t + r.ty; return i.length === 1 && i[0].action === "moveTo" ? (i[0].data[0] = n, i[0].data[1] = a, this) : (this._activePath.moveTo(n, a), this) } quadraticCurveTo(e, t, r, i, n) { this._tick++; const a = this._transform; return this._activePath.quadraticCurveTo(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, a.a * r + a.c * i + a.tx, a.b * r + a.d * i + a.ty, n), this } rect(e, t, r, i) { return this._tick++, this._activePath.rect(e, t, r, i, this._transform.clone()), this } roundRect(e, t, r, i, n) { return this._tick++, this._activePath.roundRect(e, t, r, i, n, this._transform.clone()), this } poly(e, t) { return this._tick++, this._activePath.poly(e, t, this._transform.clone()), this } regularPoly(e, t, r, i, n = 0, a) { return this._tick++, this._activePath.regularPoly(e, t, r, i, n, a), this } roundPoly(e, t, r, i, n, a) { return this._tick++, this._activePath.roundPoly(e, t, r, i, n, a), this } roundShape(e, t, r, i) { return this._tick++, this._activePath.roundShape(e, t, r, i), this } filletRect(e, t, r, i, n) { return this._tick++, this._activePath.filletRect(e, t, r, i, n), this } chamferRect(e, t, r, i, n, a) { return this._tick++, this._activePath.chamferRect(e, t, r, i, n, a), this } star(e, t, r, i, n = 0, a = 0) { return this._tick++, this._activePath.star(e, t, r, i, n, a, this._transform.clone()), this } svg(e) { return this._tick++, Bf(e, this), this } restore() { const e = this._stateStack.pop(); return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this } save() { return this._stateStack.push({ transform: this._transform.clone(), fillStyle: { ...this._fillStyle }, strokeStyle: { ...this._strokeStyle } }), this } getTransform() { return this._transform } resetTransform() { return this._transform.identity(), this } rotate(e) { return this._transform.rotate(e), this } scale(e, t = e) { return this._transform.scale(e, t), this } setTransform(e, t, r, i, n, a) { return e instanceof D ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, t, r, i, n, a), this) } transform(e, t, r, i, n, a) { return e instanceof D ? (this._transform.append(e), this) : (xa.set(e, t, r, i, n, a), this._transform.append(xa), this) } translate(e, t = e) { return this._transform.translate(e, t), this } clear() { return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this } onUpdate() { this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0) } get bounds() { if (!this._boundsDirty) return this._bounds; const e = this._bounds; e.clear(); for (let t = 0; t < this.instructions.length; t++) { const r = this.instructions[t], i = r.action; if (i === "fill") { const n = r.data; e.addBounds(n.path.bounds) } else if (i === "texture") { const n = r.data; e.addFrame(n.dx, n.dy, n.dx + n.dw, n.dy + n.dh, n.transform) } if (i === "stroke") { const n = r.data, a = n.style.alignment, o = n.style.width * (1 - a), h = n.path.bounds; e.addFrame(h.minX - o, h.minY - o, h.maxX + o, h.maxY + o) } } return e } containsPoint(e) { var i; if (!this.bounds.containsPoint(e.x, e.y)) return !1; const t = this.instructions; let r = !1; for (let n = 0; n < t.length; n++) { const a = t[n], o = a.data, h = o.path; if (!a.action || !h) continue; const l = o.style, c = h.shapePath.shapePrimitives; for (let u = 0; u < c.length; u++) { const d = c[u].shape; if (!l || !d) continue; const f = c[u].transform, p = f ? f.applyInverse(e, Uf) : e; if (a.action === "fill") r = d.contains(p.x, p.y); else { const m = l; r = d.strokeContains(p.x, p.y, m.width, m.alignment) } const g = o.hole; if (g) { const m = (i = g.shapePath) == null ? void 0 : i.shapePrimitives; if (m) for (let y = 0; y < m.length; y++)m[y].shape.contains(p.x, p.y) && (r = !1) } if (r) return !0 } } return r } destroy(e = !1) { if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) { const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource; this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r) } this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null } }; Di.defaultFillStyle = { color: 16777215, alpha: 1, texture: F.WHITE, matrix: null, fill: null, textureSpace: "local" }; Di.defaultStrokeStyle = { width: 1, color: 16777215, alpha: 1, alignment: .5, miterLimit: 10, cap: "butt", join: "miter", texture: F.WHITE, matrix: null, fill: null, textureSpace: "local", pixelLine: !1 }; let Be = Di; const ya = ["align", "breakWords", "cssOverrides", "fontVariant", "fontWeight", "leading", "letterSpacing", "lineHeight", "padding", "textBaseline", "trim", "whiteSpace", "wordWrap", "wordWrapWidth", "fontFamily", "fontStyle", "fontSize"]; function uh(s) { const e = []; let t = 0; for (let r = 0; r < ya.length; r++) { const i = `_${ya[r]}`; e[t++] = s[i] } return t = dh(s._fill, e, t), t = Df(s._stroke, e, t), t = Of(s.dropShadow, e, t), e.join("-") } function dh(s, e, t) { var r; return s && (e[t++] = s.color, e[t++] = s.alpha, e[t++] = (r = s.fill) == null ? void 0 : r.styleKey), t } function Df(s, e, t) { return s && (t = dh(s, e, t), e[t++] = s.width, e[t++] = s.alignment, e[t++] = s.cap, e[t++] = s.join, e[t++] = s.miterLimit), t } function Of(s, e, t) { return s && (e[t++] = s.alpha, e[t++] = s.angle, e[t++] = s.blur, e[t++] = s.distance, e[t++] = ie.shared.setValue(s.color).toNumber()), t } const Oi = class vt extends Ce { constructor(e = {}) { super(), Lf(e); const t = { ...vt.defaultTextStyle, ...e }; for (const r in t) { const i = r; this[i] = t[r] } this.update() } get align() { return this._align } set align(e) { this._align = e, this.update() } get breakWords() { return this._breakWords } set breakWords(e) { this._breakWords = e, this.update() } get dropShadow() { return this._dropShadow } set dropShadow(e) { e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({ ...vt.defaultDropShadow, ...e }) : this._dropShadow = e ? this._createProxy({ ...vt.defaultDropShadow }) : null, this.update() } get fontFamily() { return this._fontFamily } set fontFamily(e) { this._fontFamily = e, this.update() } get fontSize() { return this._fontSize } set fontSize(e) { typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update() } get fontStyle() { return this._fontStyle } set fontStyle(e) { this._fontStyle = e.toLowerCase(), this.update() } get fontVariant() { return this._fontVariant } set fontVariant(e) { this._fontVariant = e, this.update() } get fontWeight() { return this._fontWeight } set fontWeight(e) { this._fontWeight = e, this.update() } get leading() { return this._leading } set leading(e) { this._leading = e, this.update() } get letterSpacing() { return this._letterSpacing } set letterSpacing(e) { this._letterSpacing = e, this.update() } get lineHeight() { return this._lineHeight } set lineHeight(e) { this._lineHeight = e, this.update() } get padding() { return this._padding } set padding(e) { this._padding = e, this.update() } get trim() { return this._trim } set trim(e) { this._trim = e, this.update() } get textBaseline() { return this._textBaseline } set textBaseline(e) { this._textBaseline = e, this.update() } get whiteSpace() { return this._whiteSpace } set whiteSpace(e) { this._whiteSpace = e, this.update() } get wordWrap() { return this._wordWrap } set wordWrap(e) { this._wordWrap = e, this.update() } get wordWrapWidth() { return this._wordWrapWidth } set wordWrapWidth(e) { this._wordWrapWidth = e, this.update() } get fill() { return this._originalFill } set fill(e) { e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({ ...Be.defaultFillStyle, ...e }, () => { this._fill = dt({ ...this._originalFill }, Be.defaultFillStyle) })), this._fill = dt(e === 0 ? "black" : e, Be.defaultFillStyle), this.update()) } get stroke() { return this._originalStroke } set stroke(e) { e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({ ...Be.defaultStrokeStyle, ...e }, () => { this._stroke = Hr({ ...this._originalStroke }, Be.defaultStrokeStyle) })), this._stroke = Hr(e, Be.defaultStrokeStyle), this.update()) } _generateKey() { return this._styleKey = uh(this), this._styleKey } update() { this._styleKey = null, this.emit("update", this) } reset() { const e = vt.defaultTextStyle; for (const t in e) this[t] = e[t] } get styleKey() { return this._styleKey || this._generateKey() } clone() { return new vt({ align: this.align, breakWords: this.breakWords, dropShadow: this._dropShadow ? { ...this._dropShadow } : null, fill: this._fill, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, leading: this.leading, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this._stroke, textBaseline: this.textBaseline, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth }) } destroy(e = !1) { var r, i, n, a; if (this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) { const o = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource; (r = this._fill) != null && r.texture && this._fill.texture.destroy(o), (i = this._originalFill) != null && i.texture && this._originalFill.texture.destroy(o), (n = this._stroke) != null && n.texture && this._stroke.texture.destroy(o), (a = this._originalStroke) != null && a.texture && this._originalStroke.texture.destroy(o) } this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null } _createProxy(e, t) { return new Proxy(e, { set: (r, i, n) => (r[i] = n, t == null || t(i, n), this.update(), !0) }) } _isFillStyle(e) { return (e ?? null) !== null && !(ie.isColorLike(e) || e instanceof st || e instanceof Kr) } }; Oi.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: "black", distance: 5 }; Oi.defaultTextStyle = { align: "left", breakWords: !1, dropShadow: null, fill: "black", fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", leading: 0, letterSpacing: 0, lineHeight: 0, padding: 0, stroke: null, textBaseline: "alphabetic", trim: !1, whiteSpace: "pre", wordWrap: !1, wordWrapWidth: 100 }; let it = Oi; function Lf(s) { const e = s; if (typeof e.dropShadow == "boolean" && e.dropShadow) { const t = it.defaultDropShadow; s.dropShadow = { alpha: e.dropShadowAlpha ?? t.alpha, angle: e.dropShadowAngle ?? t.angle, blur: e.dropShadowBlur ?? t.blur, color: e.dropShadowColor ?? t.color, distance: e.dropShadowDistance ?? t.distance } } if (e.strokeThickness !== void 0) { X(ee, "strokeThickness is now a part of stroke"); const t = e.stroke; let r = {}; if (ie.isColorLike(t)) r.color = t; else if (t instanceof st || t instanceof Kr) r.fill = t; else if (Object.hasOwnProperty.call(t, "color") || Object.hasOwnProperty.call(t, "fill")) r = t; else throw new Error("Invalid stroke value."); s.stroke = { ...r, width: e.strokeThickness } } if (Array.isArray(e.fillGradientStops)) { X(ee, "gradient fill is now a fill pattern: `new FillGradient(...)`"); let t; s.fontSize == null ? s.fontSize = it.defaultTextStyle.fontSize : typeof s.fontSize == "string" ? t = parseInt(s.fontSize, 10) : t = s.fontSize; const r = new st({ start: { x: 0, y: 0 }, end: { x: 0, y: (t || 0) * 1.7 } }), i = e.fillGradientStops.map(n => ie.shared.setValue(n).toNumber()); i.forEach((n, a) => { const o = a / (i.length - 1); r.addColorStop(o, n) }), s.fill = { fill: r } } } class Nf { constructor(e) { this._canvasPool = Object.create(null), this.canvasOptions = e || {}, this.enableFullScreen = !1 } _createCanvasAndContext(e, t) { const r = K.get().createCanvas(); r.width = e, r.height = t; const i = r.getContext("2d"); return { canvas: r, context: i } } getOptimalCanvasAndContext(e, t, r = 1) { e = Math.ceil(e * r - 1e-6), t = Math.ceil(t * r - 1e-6), e = Et(e), t = Et(t); const i = (e << 17) + (t << 1); this._canvasPool[i] || (this._canvasPool[i] = []); let n = this._canvasPool[i].pop(); return n || (n = this._createCanvasAndContext(e, t)), n } returnCanvasAndContext(e) { const t = e.canvas, { width: r, height: i } = t, n = (r << 17) + (i << 1); e.context.clearRect(0, 0, r, i), this._canvasPool[n].push(e) } clear() { this._canvasPool = {} } } const Ze = new Nf, Hf = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]; function zr(s) { const e = typeof s.fontSize == "number" ? `${s.fontSize}px` : s.fontSize; let t = s.fontFamily; Array.isArray(s.fontFamily) || (t = s.fontFamily.split(",")); for (let r = t.length - 1; r >= 0; r--) { let i = t[r].trim(); !/([\"\'])[^\'\"]+\1/.test(i) && !Hf.includes(i) && (i = `"${i}"`), t[r] = i } return `${s.fontStyle} ${s.fontVariant} ${s.fontWeight} ${e} ${t.join(",")}` } const Bs = { willReadFrequently: !0 }, Le = class U {
    static get experimentalLetterSpacingSupported() { let e = U._experimentalLetterSpacingSupported; if (e !== void 0) { const t = K.get().getCanvasRenderingContext2D().prototype; e = U._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t } return e } constructor(e, t, r, i, n, a, o, h, l) { this.text = e, this.style = t, this.width = r, this.height = i, this.lines = n, this.lineWidths = a, this.lineHeight = o, this.maxLineWidth = h, this.fontProperties = l } static measureText(e = " ", t, r = U._canvas, i = t.wordWrap) { var T; const n = `${e}:${t.styleKey}`; if (U._measurementCache[n]) return U._measurementCache[n]; const a = zr(t), o = U.measureFont(a); o.fontSize === 0 && (o.fontSize = t.fontSize, o.ascent = t.fontSize); const h = U.__context; h.font = a; const c = (i ? U._wordWrap(e, t, r) : e).split(/(?:\r\n|\r|\n)/), u = new Array(c.length); let d = 0; for (let S = 0; S < c.length; S++) { const A = U._measureText(c[S], t.letterSpacing, h); u[S] = A, d = Math.max(d, A) } const f = ((T = t._stroke) == null ? void 0 : T.width) || 0; let p = d + f; t.dropShadow && (p += t.dropShadow.distance); const g = t.lineHeight || o.fontSize; let m = Math.max(g, o.fontSize + f) + (c.length - 1) * (g + t.leading); return t.dropShadow && (m += t.dropShadow.distance), new U(e, t, p, m, c, u, g + t.leading, d, o) } static _measureText(e, t, r) { let i = !1; U.experimentalLetterSpacingSupported && (U.experimentalLetterSpacing ? (r.letterSpacing = `${t}px`, r.textLetterSpacing = `${t}px`, i = !0) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px")); const n = r.measureText(e); let a = n.width; const o = -n.actualBoundingBoxLeft; let l = n.actualBoundingBoxRight - o; if (a > 0) if (i) a -= t, l -= t; else { const c = (U.graphemeSegmenter(e).length - 1) * t; a += c, l += c } return Math.max(a, l) } static _wordWrap(e, t, r = U._canvas) { const i = r.getContext("2d", Bs); let n = 0, a = "", o = ""; const h = Object.create(null), { letterSpacing: l, whiteSpace: c } = t, u = U._collapseSpaces(c), d = U._collapseNewlines(c); let f = !u; const p = t.wordWrapWidth + l, g = U._tokenize(e); for (let m = 0; m < g.length; m++) { let y = g[m]; if (U._isNewline(y)) { if (!d) { o += U._addLine(a), f = !u, a = "", n = 0; continue } y = " " } if (u) { const S = U.isBreakingSpace(y), A = U.isBreakingSpace(a[a.length - 1]); if (S && A) continue } const T = U._getFromCache(y, l, h, i); if (T > p) if (a !== "" && (o += U._addLine(a), a = "", n = 0), U.canBreakWords(y, t.breakWords)) { const S = U.wordWrapSplit(y); for (let A = 0; A < S.length; A++) { let R = S[A], E = R, C = 1; for (; S[A + C];) { const N = S[A + C]; if (!U.canBreakChars(E, N, y, A, t.breakWords)) R += N; else break; E = N, C++ } A += C - 1; const L = U._getFromCache(R, l, h, i); L + n > p && (o += U._addLine(a), f = !1, a = "", n = 0), a += R, n += L } } else { a.length > 0 && (o += U._addLine(a), a = "", n = 0); const S = m === g.length - 1; o += U._addLine(y, !S), f = !1, a = "", n = 0 } else T + n > p && (f = !1, o += U._addLine(a), a = "", n = 0), (a.length > 0 || !U.isBreakingSpace(y) || f) && (a += y, n += T) } return o += U._addLine(a, !1), o } static _addLine(e, t = !0) {
      return e = U._trimRight(e), e = t ? `${e}
`: e, e
    } static _getFromCache(e, t, r, i) { let n = r[e]; return typeof n != "number" && (n = U._measureText(e, t, i) + t, r[e] = n), n } static _collapseSpaces(e) { return e === "normal" || e === "pre-line" } static _collapseNewlines(e) { return e === "normal" } static _trimRight(e) { if (typeof e != "string") return ""; for (let t = e.length - 1; t >= 0; t--) { const r = e[t]; if (!U.isBreakingSpace(r)) break; e = e.slice(0, -1) } return e } static _isNewline(e) { return typeof e != "string" ? !1 : U._newlines.includes(e.charCodeAt(0)) } static isBreakingSpace(e, t) { return typeof e != "string" ? !1 : U._breakingSpaces.includes(e.charCodeAt(0)) } static _tokenize(e) { const t = []; let r = ""; if (typeof e != "string") return t; for (let i = 0; i < e.length; i++) { const n = e[i], a = e[i + 1]; if (U.isBreakingSpace(n, a) || U._isNewline(n)) { r !== "" && (t.push(r), r = ""), t.push(n); continue } r += n } return r !== "" && t.push(r), t } static canBreakWords(e, t) { return t } static canBreakChars(e, t, r, i, n) { return !0 } static wordWrapSplit(e) { return U.graphemeSegmenter(e) } static measureFont(e) { if (U._fonts[e]) return U._fonts[e]; const t = U._context; t.font = e; const r = t.measureText(U.METRICS_STRING + U.BASELINE_SYMBOL), i = { ascent: r.actualBoundingBoxAscent, descent: r.actualBoundingBoxDescent, fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent }; return U._fonts[e] = i, i } static clearMetrics(e = "") { e ? delete U._fonts[e] : U._fonts = {} } static get _canvas() { if (!U.__canvas) { let e; try { const t = new OffscreenCanvas(0, 0), r = t.getContext("2d", Bs); if (r != null && r.measureText) return U.__canvas = t, t; e = K.get().createCanvas() } catch { e = K.get().createCanvas() } e.width = e.height = 10, U.__canvas = e } return U.__canvas } static get _context() { return U.__context || (U.__context = U._canvas.getContext("2d", Bs)), U.__context }
  }; Le.METRICS_STRING = "|ÉqÅ"; Le.BASELINE_SYMBOL = "M"; Le.BASELINE_MULTIPLIER = 1.4; Le.HEIGHT_MULTIPLIER = 2; Le.graphemeSegmenter = (() => { if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") { const s = new Intl.Segmenter; return e => [...s.segment(e)].map(t => t.segment) } return s => [...s] })(); Le.experimentalLetterSpacing = !1; Le._fonts = {}; Le._newlines = [10, 13]; Le._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288]; Le._measurementCache = {}; let Je = Le; const ba = 1e5; function Wr(s, e, t, r = 0) { if (s.texture === F.WHITE && !s.fill) return ie.shared.setValue(s.color).setAlpha(s.alpha ?? 1).toHexa(); if (s.fill) { if (s.fill instanceof Kr) { const i = s.fill, n = e.createPattern(i.texture.source.resource, "repeat"), a = i.transform.copyTo(D.shared); return a.scale(i.texture.frame.width, i.texture.frame.height), n.setTransform(a), n } else if (s.fill instanceof st) { const i = s.fill, n = i.type === "linear", a = i.textureSpace === "local"; let o = 1, h = 1; a && t && (o = t.width + r, h = t.height + r); let l, c = !1; if (n) { const { start: u, end: d } = i; l = e.createLinearGradient(u.x * o, u.y * h, d.x * o, d.y * h), c = Math.abs(d.x - u.x) < Math.abs((d.y - u.y) * .1) } else { const { center: u, innerRadius: d, outerCenter: f, outerRadius: p } = i; l = e.createRadialGradient(u.x * o, u.y * h, d * o, f.x * o, f.y * h, p * o) } if (c && a && t) { const u = t.lineHeight / h; for (let d = 0; d < t.lines.length; d++) { const f = (d * t.lineHeight + r / 2) / h; i.colorStops.forEach(p => { const g = f + p.offset * u; l.addColorStop(Math.floor(g * ba) / ba, ie.shared.setValue(p.color).toHex()) }) } } else i.colorStops.forEach(u => { l.addColorStop(u.offset, ie.shared.setValue(u.color).toHex()) }); return l } } else { const i = e.createPattern(s.texture.source.resource, "repeat"), n = s.matrix.copyTo(D.shared); return n.scale(s.texture.frame.width, s.texture.frame.height), i.setTransform(n), i } return H("FillStyle not recognised", s), "red" } function fh(s) { if (s === "") return []; typeof s == "string" && (s = [s]); const e = []; for (let t = 0, r = s.length; t < r; t++) { const i = s[t]; if (Array.isArray(i)) { if (i.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`); if (i[0].length === 0 || i[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter."); const n = i[0].charCodeAt(0), a = i[1].charCodeAt(0); if (a < n) throw new Error("[BitmapFont]: Invalid character range."); for (let o = n, h = a; o <= h; o++)e.push(String.fromCharCode(o)) } else e.push(...Array.from(i)) } if (e.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters."); return e } const ph = class mh extends Ko {
    constructor(e) { super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentPageIndex = -1, this._skipKerning = !1; const t = { ...mh.defaultOptions, ...e }; this._textureSize = t.textureSize, this._mipmap = t.mipmap; const r = t.style.clone(); t.overrideFill && (r._fill.color = 16777215, r._fill.alpha = 1, r._fill.texture = F.WHITE, r._fill.fill = null), this.applyFillAsTint = t.overrideFill; const i = r.fontSize; r.fontSize = this.baseMeasurementFontSize; const n = zr(r); t.overrideSize ? r._stroke && (r._stroke.width *= this.baseRenderedFontSize / i) : r.fontSize = this.baseRenderedFontSize = i, this._style = r, this._skipKerning = t.skipKerning ?? !1, this.resolution = t.resolution ?? 1, this._padding = t.padding ?? 4, this.fontMetrics = Je.measureFont(n), this.lineHeight = r.lineHeight || this.fontMetrics.fontSize || r.fontSize } ensureCharacters(e) {
      var m, y; const t = fh(e).filter(T => !this._currentChars.includes(T)).filter((T, S, A) => A.indexOf(T) === S); if (!t.length) return; this._currentChars = [...this._currentChars, ...t]; let r; this._currentPageIndex === -1 ? r = this._nextPage() : r = this.pages[this._currentPageIndex]; let { canvas: i, context: n } = r.canvasAndContext, a = r.texture.source; const o = this._style; let h = this._currentX, l = this._currentY; const c = this.baseRenderedFontSize / this.baseMeasurementFontSize, u = this._padding * c; let d = 0, f = !1; const p = i.width / this.resolution, g = i.height / this.resolution; for (let T = 0; T < t.length; T++) {
        const S = t[T], A = Je.measureText(S, o, i, !1); A.lineHeight = A.height; const R = A.width * c, E = Math.ceil((o.fontStyle === "italic" ? 2 : 1) * R), C = A.height * c, L = E + u * 2, N = C + u * 2; if (f = !1, S !== `
`&& S !== "\r" && S !== "	" && S !== " " && (f = !0, d = Math.ceil(Math.max(N, d))), h + L > p && (l += d, d = N, h = 0, l + d > g)) { a.update(); const I = this._nextPage(); i = I.canvasAndContext.canvas, n = I.canvasAndContext.context, a = I.texture.source, l = 0 } const G = R / c - (((m = o.dropShadow) == null ? void 0 : m.distance) ?? 0) - (((y = o._stroke) == null ? void 0 : y.width) ?? 0); if (this.chars[S] = { id: S.codePointAt(0), xOffset: -this._padding, yOffset: -this._padding, xAdvance: G, kerning: {} }, f) { this._drawGlyph(n, A, h + u, l + u, c, o); const I = a.width * c, V = a.height * c, Z = new ne(h / I * a.width, l / V * a.height, L / I * a.width, N / V * a.height); this.chars[S].texture = new F({ source: a, frame: Z }), h += Math.ceil(L) }
      } a.update(), this._currentX = h, this._currentY = l, this._skipKerning && this._applyKerning(t, n)
    } get pageTextures() { return X(ee, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages } _applyKerning(e, t) { const r = this._measureCache; for (let i = 0; i < e.length; i++) { const n = e[i]; for (let a = 0; a < this._currentChars.length; a++) { const o = this._currentChars[a]; let h = r[n]; h || (h = r[n] = t.measureText(n).width); let l = r[o]; l || (l = r[o] = t.measureText(o).width); let c = t.measureText(n + o).width, u = c - (h + l); u && (this.chars[n].kerning[o] = u), c = t.measureText(n + o).width, u = c - (h + l), u && (this.chars[o].kerning[n] = u) } } } _nextPage() { this._currentPageIndex++; const e = this.resolution, t = Ze.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e); this._setupContext(t.context, this._style, e); const r = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize), i = new F({ source: new mt({ resource: t.canvas, resolution: r, alphaMode: "premultiply-alpha-on-upload", autoGenerateMipmaps: this._mipmap }) }), n = { canvasAndContext: t, texture: i }; return this.pages[this._currentPageIndex] = n, n } _setupContext(e, t, r) { t.fontSize = this.baseRenderedFontSize, e.scale(r, r), e.font = zr(t), t.fontSize = this.baseMeasurementFontSize, e.textBaseline = t.textBaseline; const i = t._stroke, n = (i == null ? void 0 : i.width) ?? 0; if (i && (e.lineWidth = n, e.lineJoin = i.join, e.miterLimit = i.miterLimit, e.strokeStyle = Wr(i, e)), t._fill && (e.fillStyle = Wr(t._fill, e)), t.dropShadow) { const a = t.dropShadow, o = ie.shared.setValue(a.color).toArray(), h = a.blur * r, l = a.distance * r; e.shadowColor = `rgba(${o[0] * 255},${o[1] * 255},${o[2] * 255},${a.alpha})`, e.shadowBlur = h, e.shadowOffsetX = Math.cos(a.angle) * l, e.shadowOffsetY = Math.sin(a.angle) * l } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0 } _drawGlyph(e, t, r, i, n, a) { const o = t.text, h = t.fontProperties, l = a._stroke, c = ((l == null ? void 0 : l.width) ?? 0) * n, u = r + c / 2, d = i - c / 2, f = h.descent * n, p = t.lineHeight * n; a.stroke && c && e.strokeText(o, u, d + p - f), a._fill && e.fillText(o, u, d + p - f) } destroy() { super.destroy(); for (let e = 0; e < this.pages.length; e++) { const { canvasAndContext: t, texture: r } = this.pages[e]; Ze.returnCanvasAndContext(t), r.destroy(!0) } this.pages = null }
  }; ph.defaultOptions = { textureSize: 512, style: new it, mipmap: !0 }; let va = ph; function gh(s, e, t, r) {
    const i = { width: 0, height: 0, offsetY: 0, scale: e.fontSize / t.baseMeasurementFontSize, lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }] }; i.offsetY = t.baseLineOffset; let n = i.lines[0], a = null, o = !0; const h = { width: 0, start: 0, index: 0, positions: [], chars: [] }, l = p => { const g = n.width; for (let m = 0; m < h.index; m++) { const y = p.positions[m]; n.chars.push(p.chars[m]), n.charPositions.push(y + g) } n.width += p.width, o = !1, h.width = 0, h.index = 0, h.chars.length = 0 }, c = () => { let p = n.chars.length - 1; if (r) { let g = n.chars[p]; for (; g === " ";)n.width -= t.chars[g].xAdvance, g = n.chars[--p] } i.width = Math.max(i.width, n.width), n = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }, o = !0, i.lines.push(n), i.height += t.lineHeight }, u = t.baseMeasurementFontSize / e.fontSize, d = e.letterSpacing * u, f = e.wordWrapWidth * u; for (let p = 0; p < s.length + 1; p++) {
      let g; const m = p === s.length; m || (g = s[p]); const y = t.chars[g] || t.chars[" "]; if (/(?:\s)/.test(g) || g === "\r" || g === `
`|| m) {
        if (!o && e.wordWrap && n.width + h.width - d > f ? (c(), l(h), m || n.charPositions.push(0)) : (h.start = n.width, l(h), m || n.charPositions.push(0)), g === "\r" || g === `
`) n.width !== 0 && c(); else if (!m) { const R = y.xAdvance + (y.kerning[a] || 0) + d; n.width += R, n.spaceWidth = R, n.spacesIndex.push(n.charPositions.length), n.chars.push(g) }
      } else { const A = y.kerning[a] || 0, R = y.xAdvance + A + d; h.positions[h.index++] = h.width + A, h.chars.push(g), h.width += R } a = g
    } return c(), e.align === "center" ? zf(i) : e.align === "right" ? Wf(i) : e.align === "justify" && Vf(i), i
  } function zf(s) { for (let e = 0; e < s.lines.length; e++) { const t = s.lines[e], r = s.width / 2 - t.width / 2; for (let i = 0; i < t.charPositions.length; i++)t.charPositions[i] += r } } function Wf(s) { for (let e = 0; e < s.lines.length; e++) { const t = s.lines[e], r = s.width - t.width; for (let i = 0; i < t.charPositions.length; i++)t.charPositions[i] += r } } function Vf(s) { const e = s.width; for (let t = 0; t < s.lines.length; t++) { const r = s.lines[t]; let i = 0, n = r.spacesIndex[i++], a = 0; const o = r.spacesIndex.length, l = (e - r.width) / o; for (let c = 0; c < r.charPositions.length; c++)c === n && (n = r.spacesIndex[i++], a += l), r.charPositions[c] += a } } let Tr = 0; class $f { constructor() { this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = { chars: this.ALPHANUMERIC, resolution: 1, padding: 4, skipKerning: !1 } } getFont(e, t) { var a; let r = `${t.fontFamily}-bitmap`, i = !0; if (t._fill.fill && !t._stroke) r += t._fill.fill.styleKey, i = !1; else if (t._stroke || t.dropShadow) { let o = t.styleKey; o = o.substring(0, o.lastIndexOf("-")), r = `${o}-bitmap`, i = !1 } if (!ae.has(r)) { const o = new va({ style: t, overrideFill: i, overrideSize: !0, ...this.defaultOptions }); Tr++, Tr > 50 && H("BitmapText", `You have dynamically created ${Tr} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), o.once("destroy", () => { Tr--, ae.remove(r) }), ae.set(r, o) } const n = ae.get(r); return (a = n.ensureCharacters) == null || a.call(n, e), n } getLayout(e, t, r = !0) { const i = this.getFont(e, t); return gh([...e], t, i, r) } measureText(e, t, r = !0) { return this.getLayout(e, t, r) } install(...e) { var l, c, u, d; let t = e[0]; typeof t == "string" && (t = { name: t, style: e[1], chars: (l = e[2]) == null ? void 0 : l.chars, resolution: (c = e[2]) == null ? void 0 : c.resolution, padding: (u = e[2]) == null ? void 0 : u.padding, skipKerning: (d = e[2]) == null ? void 0 : d.skipKerning }, X(ee, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})")); const r = t == null ? void 0 : t.name; if (!r) throw new Error("[BitmapFontManager] Property `name` is required."); t = { ...this.defaultOptions, ...t }; const i = t.style, n = i instanceof it ? i : new it(i), a = n._fill.fill !== null && n._fill.fill !== void 0, o = new va({ style: n, overrideFill: a, skipKerning: t.skipKerning, padding: t.padding, resolution: t.resolution, overrideSize: !1 }), h = fh(t.chars); return o.ensureCharacters(h.join("")), ae.set(`${r}-bitmap`, o), o.once("destroy", () => ae.remove(`${r}-bitmap`)), o } uninstall(e) { const t = `${e}-bitmap`, r = ae.get(t); r && r.destroy() } } const ii = new $f; class _h extends Ko { constructor(e, t) { super(); const { textures: r, data: i } = e; Object.keys(i.pages).forEach(n => { const a = i.pages[parseInt(n, 10)], o = r[a.id]; this.pages.push({ texture: o }) }), Object.keys(i.chars).forEach(n => { const a = i.chars[n], { frame: o, source: h } = r[a.page], l = new ne(a.x + o.x, a.y + o.y, a.width, a.height), c = new F({ source: h, frame: l }); this.chars[n] = { id: n.codePointAt(0), xOffset: a.xOffset, yOffset: a.yOffset, xAdvance: a.xAdvance, kerning: a.kerning ?? {}, texture: c } }), this.baseRenderedFontSize = i.fontSize, this.baseMeasurementFontSize = i.fontSize, this.fontMetrics = { ascent: 0, descent: 0, fontSize: i.fontSize }, this.baseLineOffset = i.baseLineOffset, this.lineHeight = i.lineHeight, this.fontFamily = i.fontFamily, this.distanceField = i.distanceField ?? { type: "none", range: 0 }, this.url = t } destroy() { super.destroy(); for (let e = 0; e < this.pages.length; e++) { const { texture: t } = this.pages[e]; t.destroy(!0) } this.pages = null } static install(e) { ii.install(e) } static uninstall(e) { ii.uninstall(e) } } const Rs = { test(s) { return typeof s == "string" && s.startsWith("info face=") }, parse(s) { const e = s.match(/^[a-z]+\s+.+$/gm), t = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] }; for (const u in e) { const d = e[u].match(/^[a-z]+/gm)[0], f = e[u].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), p = {}; for (const g in f) { const m = f[g].split("="), y = m[0], T = m[1].replace(/"/gm, ""), S = parseFloat(T), A = isNaN(S) ? T : S; p[y] = A } t[d].push(p) } const r = { chars: {}, pages: [], lineHeight: 0, fontSize: 0, fontFamily: "", distanceField: null, baseLineOffset: 0 }, [i] = t.info, [n] = t.common, [a] = t.distanceField ?? []; a && (r.distanceField = { range: parseInt(a.distanceRange, 10), type: a.fieldType }), r.fontSize = parseInt(i.size, 10), r.fontFamily = i.face, r.lineHeight = parseInt(n.lineHeight, 10); const o = t.page; for (let u = 0; u < o.length; u++)r.pages.push({ id: parseInt(o[u].id, 10) || 0, file: o[u].file }); const h = {}; r.baseLineOffset = r.lineHeight - parseInt(n.base, 10); const l = t.char; for (let u = 0; u < l.length; u++) { const d = l[u], f = parseInt(d.id, 10); let p = d.letter ?? d.char ?? String.fromCharCode(f); p === "space" && (p = " "), h[f] = p, r.chars[p] = { id: f, page: parseInt(d.page, 10) || 0, x: parseInt(d.x, 10), y: parseInt(d.y, 10), width: parseInt(d.width, 10), height: parseInt(d.height, 10), xOffset: parseInt(d.xoffset, 10), yOffset: parseInt(d.yoffset, 10), xAdvance: parseInt(d.xadvance, 10), kerning: {} } } const c = t.kerning || []; for (let u = 0; u < c.length; u++) { const d = parseInt(c[u].first, 10), f = parseInt(c[u].second, 10), p = parseInt(c[u].amount, 10); r.chars[h[f]].kerning[h[d]] = p } return r } }, Ta = { test(s) { const e = s; return typeof e != "string" && "getElementsByTagName" in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null }, parse(s) { const e = { chars: {}, pages: [], lineHeight: 0, fontSize: 0, fontFamily: "", distanceField: null, baseLineOffset: 0 }, t = s.getElementsByTagName("info")[0], r = s.getElementsByTagName("common")[0], i = s.getElementsByTagName("distanceField")[0]; i && (e.distanceField = { type: i.getAttribute("fieldType"), range: parseInt(i.getAttribute("distanceRange"), 10) }); const n = s.getElementsByTagName("page"), a = s.getElementsByTagName("char"), o = s.getElementsByTagName("kerning"); e.fontSize = parseInt(t.getAttribute("size"), 10), e.fontFamily = t.getAttribute("face"), e.lineHeight = parseInt(r.getAttribute("lineHeight"), 10); for (let l = 0; l < n.length; l++)e.pages.push({ id: parseInt(n[l].getAttribute("id"), 10) || 0, file: n[l].getAttribute("file") }); const h = {}; e.baseLineOffset = e.lineHeight - parseInt(r.getAttribute("base"), 10); for (let l = 0; l < a.length; l++) { const c = a[l], u = parseInt(c.getAttribute("id"), 10); let d = c.getAttribute("letter") ?? c.getAttribute("char") ?? String.fromCharCode(u); d === "space" && (d = " "), h[u] = d, e.chars[d] = { id: u, page: parseInt(c.getAttribute("page"), 10) || 0, x: parseInt(c.getAttribute("x"), 10), y: parseInt(c.getAttribute("y"), 10), width: parseInt(c.getAttribute("width"), 10), height: parseInt(c.getAttribute("height"), 10), xOffset: parseInt(c.getAttribute("xoffset"), 10), yOffset: parseInt(c.getAttribute("yoffset"), 10), xAdvance: parseInt(c.getAttribute("xadvance"), 10), kerning: {} } } for (let l = 0; l < o.length; l++) { const c = parseInt(o[l].getAttribute("first"), 10), u = parseInt(o[l].getAttribute("second"), 10), d = parseInt(o[l].getAttribute("amount"), 10); e.chars[h[u]].kerning[h[c]] = d } return e } }, Sa = { test(s) { return typeof s == "string" && s.includes("<font>") ? Ta.test(K.get().parseXML(s)) : !1 }, parse(s) { return Ta.parse(K.get().parseXML(s)) } }, Xf = [".xml", ".fnt"], jf = { extension: { type: b.CacheParser, name: "cacheBitmapFont" }, test: s => s instanceof _h, getCacheableAssets(s, e) { const t = {}; return s.forEach(r => { t[r] = e, t[`${r}-bitmap`] = e }), t[`${e.fontFamily}-bitmap`] = e, t } }, Yf = { extension: { type: b.LoadParser, priority: nt.Normal }, name: "loadBitmapFont", test(s) { return Xf.includes(Pe.extname(s).toLowerCase()) }, async testParse(s) { return Rs.test(s) || Sa.test(s) }, async parse(s, e, t) { const r = Rs.test(s) ? Rs.parse(s) : Sa.parse(s), { src: i } = e, { pages: n } = r, a = [], o = r.distanceField ? { scaleMode: "linear", alphaMode: "premultiply-alpha-on-upload", autoGenerateMipmaps: !1, resolution: 1 } : {}; for (let u = 0; u < n.length; ++u) { const d = n[u].file; let f = Pe.join(Pe.dirname(i), d); f = Xs(f, i), a.push({ src: f, data: o }) } const h = await t.load(a), l = a.map(u => h[u.src]); return new _h({ data: r, textures: l }, i) }, async load(s, e) { return await (await K.get().fetch(s)).text() }, async unload(s, e, t) { await Promise.all(s.pages.map(r => t.unload(r.texture.source._sourceOrigin))), s.destroy() } }; class Kf { constructor(e, t = !1) { this._loader = e, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = t } add(e) { e.forEach(t => { this._assetList.push(t) }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next() } async _next() { if (this._assetList.length && this._isActive) { this._isLoading = !0; const e = [], t = Math.min(this._assetList.length, this._maxConcurrent); for (let r = 0; r < t; r++)e.push(this._assetList.pop()); await this._loader.load(e), this._isLoading = !1, this._next() } } get active() { return this._isActive } set active(e) { this._isActive !== e && (this._isActive = e, e && !this._isLoading && this._next()) } } const qf = { extension: { type: b.CacheParser, name: "cacheTextureArray" }, test: s => Array.isArray(s) && s.every(e => e instanceof F), getCacheableAssets: (s, e) => { const t = {}; return s.forEach(r => { e.forEach((i, n) => { t[r + (n === 0 ? "" : n + 1)] = i }) }), t } }; async function xh(s) { if ("Image" in globalThis) return new Promise(e => { const t = new Image; t.onload = () => { e(!0) }, t.onerror = () => { e(!1) }, t.src = s }); if ("createImageBitmap" in globalThis && "fetch" in globalThis) { try { const e = await (await fetch(s)).blob(); await createImageBitmap(e) } catch { return !1 } return !0 } return !1 } const Zf = { extension: { type: b.DetectionParser, priority: 1 }, test: async () => xh("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="), add: async s => [...s, "avif"], remove: async s => s.filter(e => e !== "avif") }, wa = ["png", "jpg", "jpeg"], Qf = { extension: { type: b.DetectionParser, priority: -1 }, test: () => Promise.resolve(!0), add: async s => [...s, ...wa], remove: async s => s.filter(e => !wa.includes(e)) }, Jf = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope; function Li(s) { return Jf ? !1 : document.createElement("video").canPlayType(s) !== "" } const ep = { extension: { type: b.DetectionParser, priority: 0 }, test: async () => Li("video/mp4"), add: async s => [...s, "mp4", "m4v"], remove: async s => s.filter(e => e !== "mp4" && e !== "m4v") }, tp = { extension: { type: b.DetectionParser, priority: 0 }, test: async () => Li("video/ogg"), add: async s => [...s, "ogv"], remove: async s => s.filter(e => e !== "ogv") }, rp = { extension: { type: b.DetectionParser, priority: 0 }, test: async () => Li("video/webm"), add: async s => [...s, "webm"], remove: async s => s.filter(e => e !== "webm") }, sp = { extension: { type: b.DetectionParser, priority: 0 }, test: async () => xh("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="), add: async s => [...s, "webp"], remove: async s => s.filter(e => e !== "webp") }; class ip {
    constructor() { this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, { set: (e, t, r) => (this._parsersValidated = !1, e[t] = r, !0) }), this.promiseCache = {} } reset() { this._parsersValidated = !1, this.promiseCache = {} } _getLoadPromiseAndParser(e, t) { const r = { promise: null, parser: null }; return r.promise = (async () => { var a, o; let i = null, n = null; if (t.loadParser && (n = this._parserHash[t.loadParser], n || H(`[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`)), !n) { for (let h = 0; h < this.parsers.length; h++) { const l = this.parsers[h]; if (l.load && ((a = l.test) != null && a.call(l, e, t, this))) { n = l; break } } if (!n) return H(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null } i = await n.load(e, t, this), r.parser = n; for (let h = 0; h < this.parsers.length; h++) { const l = this.parsers[h]; l.parse && l.parse && await ((o = l.testParse) == null ? void 0 : o.call(l, i, t, this)) && (i = await l.parse(i, t, this) || i, r.parser = l) } return i })(), r } async load(e, t) {
      this._parsersValidated || this._validateParsers(); let r = 0; const i = {}, n = Lr(e), a = Ue(e, l => ({ alias: [l], src: l, data: {} })), o = a.length, h = a.map(async l => {
        const c = Pe.toAbsolute(l.src); if (!i[l.src]) try { this.promiseCache[c] || (this.promiseCache[c] = this._getLoadPromiseAndParser(c, l)), i[l.src] = await this.promiseCache[c].promise, t && t(++r / o) } catch (u) {
          throw delete this.promiseCache[c], delete i[l.src], new Error(`[Loader.load] Failed to load ${c}.
${u}`)
        }
      }); return await Promise.all(h), n ? i[a[0].src] : i
    } async unload(e) { const r = Ue(e, i => ({ alias: [i], src: i })).map(async i => { var o, h; const n = Pe.toAbsolute(i.src), a = this.promiseCache[n]; if (a) { const l = await a.promise; delete this.promiseCache[n], await ((h = (o = a.parser) == null ? void 0 : o.unload) == null ? void 0 : h.call(o, l, i, this)) } }); await Promise.all(r) } _validateParsers() { this._parsersValidated = !0, this._parserHash = this._parsers.filter(e => e.name).reduce((e, t) => (t.name ? e[t.name] && H(`[Assets] loadParser name conflict "${t.name}"`) : H("[Assets] loadParser should have a name"), { ...e, [t.name]: t }), {}) }
} function Gt(s, e) { if (Array.isArray(e)) { for (const t of e) if (s.startsWith(`data:${t}`)) return !0; return !1 } return s.startsWith(`data:${e}`) } function Ft(s, e) { const t = s.split("?")[0], r = Pe.extname(t).toLowerCase(); return Array.isArray(e) ? e.includes(r) : r === e } const np = ".json", ap = "application/json", op = { extension: { type: b.LoadParser, priority: nt.Low }, name: "loadJson", test(s) { return Gt(s, ap) || Ft(s, np) }, async load(s) { return await (await K.get().fetch(s)).json() } }, hp = ".txt", lp = "text/plain", cp = { name: "loadTxt", extension: { type: b.LoadParser, priority: nt.Low, name: "loadTxt" }, test(s) { return Gt(s, lp) || Ft(s, hp) }, async load(s) { return await (await K.get().fetch(s)).text() } }, up = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"], dp = [".ttf", ".otf", ".woff", ".woff2"], fp = ["font/ttf", "font/otf", "font/woff", "font/woff2"], pp = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i; function mp(s) { const e = Pe.extname(s), i = Pe.basename(s, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(o => o.charAt(0).toUpperCase() + o.slice(1)); let n = i.length > 0; for (const o of i) if (!o.match(pp)) { n = !1; break } let a = i.join(" "); return n || (a = `"${a.replace(/[\\"]/g, "\\$&")}"`), a } const gp = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/; function _p(s) { return gp.test(s) ? s : encodeURI(s) } const xp = { extension: { type: b.LoadParser, priority: nt.Low }, name: "loadWebFont", test(s) { return Gt(s, fp) || Ft(s, dp) }, async load(s, e) { var r, i, n; const t = K.get().getFontFaceSet(); if (t) { const a = [], o = ((r = e.data) == null ? void 0 : r.family) ?? mp(s), h = ((n = (i = e.data) == null ? void 0 : i.weights) == null ? void 0 : n.filter(c => up.includes(c))) ?? ["normal"], l = e.data ?? {}; for (let c = 0; c < h.length; c++) { const u = h[c], d = new FontFace(o, `url(${_p(s)})`, { ...l, weight: u }); await d.load(), t.add(d), a.push(d) } return ae.set(`${o}-and-url`, { url: s, fontFaces: a }), a.length === 1 ? a[0] : a } return H("[loadWebFont] FontFace API is not supported. Skipping loading font"), null }, unload(s) { (Array.isArray(s) ? s : [s]).forEach(e => { ae.remove(`${e.family}-and-url`), K.get().getFontFaceSet().delete(e) }) } }; function Ni(s, e = 1) { var r; const t = (r = Rt.RETINA_PREFIX) == null ? void 0 : r.exec(s); return t ? parseFloat(t[1]) : e } function Hi(s, e, t) { s.label = t, s._sourceOrigin = t; const r = new F({ source: s, label: t }), i = () => { delete e.promiseCache[t], ae.has(t) && ae.remove(t) }; return r.source.once("destroy", () => { e.promiseCache[t] && (H("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), i()) }), r.once("destroy", () => { s.destroyed || (H("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), i()) }), r } const yp = ".svg", bp = "image/svg+xml", vp = { extension: { type: b.LoadParser, priority: nt.Low, name: "loadSVG" }, name: "loadSVG", config: { crossOrigin: "anonymous", parseAsGraphicsContext: !1 }, test(s) { return Gt(s, bp) || Ft(s, yp) }, async load(s, e, t) { var r; return ((r = e.data) == null ? void 0 : r.parseAsGraphicsContext) ?? this.config.parseAsGraphicsContext ? Sp(s) : Tp(s, e, t, this.config.crossOrigin) }, unload(s) { s.destroy(!0) } }; async function Tp(s, e, t, r) { var m, y, T; const n = await (await K.get().fetch(s)).blob(), a = URL.createObjectURL(n), o = new Image; o.src = a, o.crossOrigin = r, await o.decode(), URL.revokeObjectURL(a); const h = document.createElement("canvas"), l = h.getContext("2d"), c = ((m = e.data) == null ? void 0 : m.resolution) || Ni(s), u = ((y = e.data) == null ? void 0 : y.width) ?? o.width, d = ((T = e.data) == null ? void 0 : T.height) ?? o.height; h.width = u * c, h.height = d * c, l.drawImage(o, 0, 0, u * c, d * c); const { parseAsGraphicsContext: f, ...p } = e.data ?? {}, g = new mt({ resource: h, alphaMode: "premultiply-alpha-on-upload", resolution: c, ...p }); return Hi(g, t, s) } async function Sp(s) { const t = await (await K.get().fetch(s)).text(), r = new Be; return r.svg(t), r } const wp = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`; let At = null, ni = class { constructor() { At || (At = URL.createObjectURL(new Blob([wp], { type: "application/javascript" }))), this.worker = new Worker(At) } }; ni.revokeObjectURL = function() { At && (URL.revokeObjectURL(At), At = null) }; const Ap = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`; let Pt = null; class yh { constructor() { Pt || (Pt = URL.createObjectURL(new Blob([Ap], { type: "application/javascript" }))), this.worker = new Worker(Pt) } } yh.revokeObjectURL = function() { Pt && (URL.revokeObjectURL(Pt), Pt = null) }; let Aa = 0, ks; class Pp { constructor() { this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {} } isImageBitmapSupported() { return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(e => { const { worker: t } = new ni; t.addEventListener("message", r => { t.terminate(), ni.revokeObjectURL(), e(r.data) }) }), this._isImageBitmapSupported) } loadImageBitmap(e, t) { var r; return this._run("loadImageBitmap", [e, (r = t == null ? void 0 : t.data) == null ? void 0 : r.alphaMode]) } async _initWorkers() { this._initialized || (this._initialized = !0) } _getWorker() { ks === void 0 && (ks = navigator.hardwareConcurrency || 4); let e = this._workerPool.pop(); return !e && this._createdWorkers < ks && (this._createdWorkers++, e = new yh().worker, e.addEventListener("message", t => { this._complete(t.data), this._returnWorker(t.target), this._next() })), e } _returnWorker(e) { this._workerPool.push(e) } _complete(e) { e.error !== void 0 ? this._resolveHash[e.uuid].reject(e.error) : this._resolveHash[e.uuid].resolve(e.data), this._resolveHash[e.uuid] = null } async _run(e, t) { await this._initWorkers(); const r = new Promise((i, n) => { this._queue.push({ id: e, arguments: t, resolve: i, reject: n }) }); return this._next(), r } _next() { if (!this._queue.length) return; const e = this._getWorker(); if (!e) return; const t = this._queue.pop(), r = t.id; this._resolveHash[Aa] = { resolve: t.resolve, reject: t.reject }, e.postMessage({ data: t.arguments, uuid: Aa++, id: r }) } } const Pa = new Pp, Ep = [".jpeg", ".jpg", ".png", ".webp", ".avif"], Cp = ["image/jpeg", "image/png", "image/webp", "image/avif"]; async function Mp(s, e) { var i; const t = await K.get().fetch(s); if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${s}: ${t.status} ${t.statusText}`); const r = await t.blob(); return ((i = e == null ? void 0 : e.data) == null ? void 0 : i.alphaMode) === "premultiplied-alpha" ? createImageBitmap(r, { premultiplyAlpha: "none" }) : createImageBitmap(r) } const bh = { name: "loadTextures", extension: { type: b.LoadParser, priority: nt.High, name: "loadTextures" }, config: { preferWorkers: !0, preferCreateImageBitmap: !0, crossOrigin: "anonymous" }, test(s) { return Gt(s, Cp) || Ft(s, Ep) }, async load(s, e, t) { var n; let r = null; globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await Pa.isImageBitmapSupported() ? r = await Pa.loadImageBitmap(s, e) : r = await Mp(s, e) : r = await new Promise((a, o) => { r = new Image, r.crossOrigin = this.config.crossOrigin, r.src = s, r.complete ? a(r) : (r.onload = () => { a(r) }, r.onerror = o) }); const i = new mt({ resource: r, alphaMode: "premultiply-alpha-on-upload", resolution: ((n = e.data) == null ? void 0 : n.resolution) || Ni(s), ...e.data }); return Hi(i, t, s) }, unload(s) { s.destroy(!0) } }, vh = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"], Bp = vh.map(s => `video/${s.substring(1)}`); function Rp(s, e, t) { t === void 0 && !e.startsWith("data:") ? s.crossOrigin = Ip(e) : t !== !1 && (s.crossOrigin = typeof t == "string" ? t : "anonymous") } function kp(s) { return new Promise((e, t) => { s.addEventListener("canplaythrough", r), s.addEventListener("error", i), s.load(); function r() { n(), e() } function i(a) { n(), t(a) } function n() { s.removeEventListener("canplaythrough", r), s.removeEventListener("error", i) } }) } function Ip(s, e = globalThis.location) { if (s.startsWith("data:")) return ""; e || (e = globalThis.location); const t = new URL(s, document.baseURI); return t.hostname !== e.hostname || t.port !== e.port || t.protocol !== e.protocol ? "anonymous" : "" } const Gp = { name: "loadVideo", extension: { type: b.LoadParser, name: "loadVideo" }, test(s) { const e = Gt(s, Bp), t = Ft(s, vh); return e || t }, async load(s, e, t) { var h, l; const r = { ...Br.defaultOptions, resolution: ((h = e.data) == null ? void 0 : h.resolution) || Ni(s), alphaMode: ((l = e.data) == null ? void 0 : l.alphaMode) || await Ao(), ...e.data }, i = document.createElement("video"), n = { preload: r.autoLoad !== !1 ? "auto" : void 0, "webkit-playsinline": r.playsinline !== !1 ? "" : void 0, playsinline: r.playsinline !== !1 ? "" : void 0, muted: r.muted === !0 ? "" : void 0, loop: r.loop === !0 ? "" : void 0, autoplay: r.autoPlay !== !1 ? "" : void 0 }; Object.keys(n).forEach(c => { const u = n[c]; u !== void 0 && i.setAttribute(c, u) }), r.muted === !0 && (i.muted = !0), Rp(i, s, r.crossorigin); const a = document.createElement("source"); let o; if (s.startsWith("data:")) o = s.slice(5, s.indexOf(";")); else if (!s.startsWith("blob:")) { const c = s.split("?")[0].slice(s.lastIndexOf(".") + 1).toLowerCase(); o = Br.MIME_TYPES[c] || `video/${c}` } return a.src = s, o && (a.type = o), new Promise(c => { const u = async () => { const d = new Br({ ...r, resource: i }); i.removeEventListener("canplay", u), e.data.preload && await kp(i), c(Hi(d, t, s)) }; i.addEventListener("canplay", u), i.appendChild(a) }) }, unload(s) { s.destroy(!0) } }, Th = { extension: { type: b.ResolveParser, name: "resolveTexture" }, test: bh.test, parse: s => { var e; return { resolution: parseFloat(((e = Rt.RETINA_PREFIX.exec(s)) == null ? void 0 : e[1]) ?? "1"), format: s.split(".").pop(), src: s } } }, Fp = { extension: { type: b.ResolveParser, priority: -2, name: "resolveJson" }, test: s => Rt.RETINA_PREFIX.test(s) && s.endsWith(".json"), parse: Th.parse }; class Up { constructor() { this._detections = [], this._initialized = !1, this.resolver = new Rt, this.loader = new ip, this.cache = ae, this._backgroundLoader = new Kf(this.loader), this._backgroundLoader.active = !0, this.reset() } async init(e = {}) { var n, a; if (this._initialized) { H("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?"); return } if (this._initialized = !0, e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams), e.basePath && (this.resolver.basePath = e.basePath), e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier), e.manifest) { let o = e.manifest; typeof o == "string" && (o = await this.load(o)), this.resolver.addManifest(o) } const t = ((n = e.texturePreference) == null ? void 0 : n.resolution) ?? 1, r = typeof t == "number" ? [t] : t, i = await this._detectFormats({ preferredFormats: (a = e.texturePreference) == null ? void 0 : a.format, skipDetections: e.skipDetections, detections: this._detections }); this.resolver.prefer({ params: { format: i, resolution: r } }), e.preferences && this.setPreferences(e.preferences) } add(e) { this.resolver.add(e) } async load(e, t) { this._initialized || await this.init(); const r = Lr(e), i = Ue(e).map(o => { if (typeof o != "string") { const h = this.resolver.getAlias(o); return h.some(l => !this.resolver.hasKey(l)) && this.add(o), Array.isArray(h) ? h[0] : h } return this.resolver.hasKey(o) || this.add({ alias: o, src: o }), o }), n = this.resolver.resolve(i), a = await this._mapLoadToResolve(n, t); return r ? a[i[0]] : a } addBundle(e, t) { this.resolver.addBundle(e, t) } async loadBundle(e, t) { this._initialized || await this.init(); let r = !1; typeof e == "string" && (r = !0, e = [e]); const i = this.resolver.resolveBundle(e), n = {}, a = Object.keys(i); let o = 0, h = 0; const l = () => { t == null || t(++o / h) }, c = a.map(u => { const d = i[u]; return h += Object.keys(d).length, this._mapLoadToResolve(d, l).then(f => { n[u] = f }) }); return await Promise.all(c), r ? n[e[0]] : n } async backgroundLoad(e) { this._initialized || await this.init(), typeof e == "string" && (e = [e]); const t = this.resolver.resolve(e); this._backgroundLoader.add(Object.values(t)) } async backgroundLoadBundle(e) { this._initialized || await this.init(), typeof e == "string" && (e = [e]); const t = this.resolver.resolveBundle(e); Object.values(t).forEach(r => { this._backgroundLoader.add(Object.values(r)) }) } reset() { this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1 } get(e) { if (typeof e == "string") return ae.get(e); const t = {}; for (let r = 0; r < e.length; r++)t[r] = ae.get(e[r]); return t } async _mapLoadToResolve(e, t) { const r = [...new Set(Object.values(e))]; this._backgroundLoader.active = !1; const i = await this.loader.load(r, t); this._backgroundLoader.active = !0; const n = {}; return r.forEach(a => { const o = i[a.src], h = [a.src]; a.alias && h.push(...a.alias), h.forEach(l => { n[l] = o }), ae.set(h, o) }), n } async unload(e) { this._initialized || await this.init(); const t = Ue(e).map(i => typeof i != "string" ? i.src : i), r = this.resolver.resolve(t); await this._unloadFromResolved(r) } async unloadBundle(e) { this._initialized || await this.init(), e = Ue(e); const t = this.resolver.resolveBundle(e), r = Object.keys(t).map(i => this._unloadFromResolved(t[i])); await Promise.all(r) } async _unloadFromResolved(e) { const t = Object.values(e); t.forEach(r => { ae.remove(r.src) }), await this.loader.unload(t) } async _detectFormats(e) { let t = []; e.preferredFormats && (t = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]); for (const r of e.detections) e.skipDetections || await r.test() ? t = await r.add(t) : e.skipDetections || (t = await r.remove(t)); return t = t.filter((r, i) => t.indexOf(r) === i), t } get detections() { return this._detections } setPreferences(e) { this.loader.parsers.forEach(t => { t.config && Object.keys(t.config).filter(r => r in e).forEach(r => { t.config[r] = e[r] }) }) } } const St = new Up; z.handleByList(b.LoadParser, St.loader.parsers).handleByList(b.ResolveParser, St.resolver.parsers).handleByList(b.CacheParser, St.cache.parsers).handleByList(b.DetectionParser, St.detections); z.add(qf, Qf, Zf, sp, ep, tp, rp, op, cp, xp, vp, bh, Gp, Yf, jf, Th, Fp); const Ea = { loader: b.LoadParser, resolver: b.ResolveParser, cache: b.CacheParser, detection: b.DetectionParser }; z.handle(b.Asset, s => { const e = s.ref; Object.entries(Ea).filter(([t]) => !!e[t]).forEach(([t, r]) => z.add(Object.assign(e[t], { extension: e[t].extension ?? r }))) }, s => { const e = s.ref; Object.keys(Ea).filter(t => !!e[t]).forEach(t => z.remove(e[t])) }); class Sh { constructor(e) { this._destroyRenderableBound = this.destroyRenderable.bind(this), this._attachedDomElements = [], this._renderer = e, this._renderer.runners.postrender.add(this), this._domElement = document.createElement("div"), this._domElement.style.position = "absolute", this._domElement.style.top = "0", this._domElement.style.left = "0", this._domElement.style.pointerEvents = "none", this._domElement.style.zIndex = "1000" } addRenderable(e, t) { this._attachedDomElements.includes(e) || (this._attachedDomElements.push(e), e.on("destroyed", this._destroyRenderableBound)) } updateRenderable(e) { } validateRenderable(e) { return !0 } destroyRenderable(e) { const t = this._attachedDomElements.indexOf(e); t !== -1 && this._attachedDomElements.splice(t, 1), e.off("destroyed", this._destroyRenderableBound) } postrender() { var r; const e = this._attachedDomElements; if (e.length === 0) { this._domElement.remove(); return } const t = this._renderer.view.canvas; this._domElement.parentNode !== t.parentNode && ((r = t.parentNode) == null || r.appendChild(this._domElement)), this._domElement.style.transform = `translate(${t.offsetLeft}px, ${t.offsetTop}px)`; for (let i = 0; i < e.length; i++) { const n = e[i], a = n.element; if (!n.parent || n.globalDisplayStatus < 7) a.remove(), e.splice(i, 1), i--; else { this._domElement.contains(a) || (a.style.position = "absolute", a.style.pointerEvents = "auto", this._domElement.appendChild(a)); const o = n.worldTransform, h = n._anchor, l = n.width * h.x, c = n.height * h.y; a.style.transformOrigin = `${l}px ${c}px`, a.style.transform = `matrix(${o.a}, ${o.b}, ${o.c}, ${o.d}, ${o.tx - l}, ${o.ty - c})`, a.style.opacity = n.groupAlpha.toString() } } } destroy() { this._renderer.runners.postrender.remove(this); for (let e = 0; e < this._attachedDomElements.length; e++) { const t = this._attachedDomElements[e]; t.off("destroyed", this._destroyRenderableBound), t.element.remove() } this._attachedDomElements.length = 0, this._domElement.remove(), this._renderer = null } } Sh.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "dom" }; class Dp { constructor() { this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0 } init(e) { this.removeTickerListener(), this.events = e, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0 } get pauseUpdate() { return this._pauseUpdate } set pauseUpdate(e) { this._pauseUpdate = e } addTickerListener() { this._tickerAdded || !this.domElement || (Ve.system.add(this._tickerUpdate, this, Qt.INTERACTION), this._tickerAdded = !0) } removeTickerListener() { this._tickerAdded && (Ve.system.remove(this._tickerUpdate, this), this._tickerAdded = !1) } pointerMoved() { this._didMove = !0 } _update() { if (!this.domElement || this._pauseUpdate) return; if (this._didMove) { this._didMove = !1; return } const e = this.events._rootPointerEvent; this.events.supportsTouchEvents && e.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", { clientX: e.clientX, clientY: e.clientY, pointerType: e.pointerType, pointerId: e.pointerId })) } _tickerUpdate(e) { this._deltaTime += e.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update()) } } const et = new Dp; class Vr extends sr { constructor() { super(...arguments), this.client = new oe, this.movement = new oe, this.offset = new oe, this.global = new oe, this.screen = new oe } get clientX() { return this.client.x } get clientY() { return this.client.y } get x() { return this.clientX } get y() { return this.clientY } get movementX() { return this.movement.x } get movementY() { return this.movement.y } get offsetX() { return this.offset.x } get offsetY() { return this.offset.y } get globalX() { return this.global.x } get globalY() { return this.global.y } get screenX() { return this.screen.x } get screenY() { return this.screen.y } getLocalPosition(e, t, r) { return e.worldTransform.applyInverse(r || this.global, t) } getModifierState(e) { return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(e) } initMouseEvent(e, t, r, i, n, a, o, h, l, c, u, d, f, p, g) { throw new Error("Method not implemented.") } } class Fe extends Vr { constructor() { super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1 } getCoalescedEvents() { return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : [] } getPredictedEvents() { throw new Error("getPredictedEvents is not supported!") } } class Bt extends Vr { constructor() { super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2 } } Bt.DOM_DELTA_PIXEL = 0; Bt.DOM_DELTA_LINE = 1; Bt.DOM_DELTA_PAGE = 2; const Op = 2048, Lp = new oe, Nt = new oe; class Np { constructor(e) { this.dispatch = new Ce, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = { trackingData: {} }, this.eventPool = new Map, this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = e, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel) } addEventMapping(e, t) { this.mappingTable[e] || (this.mappingTable[e] = []), this.mappingTable[e].push({ fn: t, priority: 0 }), this.mappingTable[e].sort((r, i) => r.priority - i.priority) } dispatchEvent(e, t) { e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, t), this.dispatch.emit(t || e.type, e) } mapEvent(e) { if (!this.rootTarget) return; const t = this.mappingTable[e.type]; if (t) for (let r = 0, i = t.length; r < i; r++)t[r].fn(e); else H(`[EventBoundary]: Event mapping not defined for ${e.type}`) } hitTest(e, t) { et.pauseUpdate = !0; const i = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive", n = this[i](this.rootTarget, this.rootTarget.eventMode, Lp.set(e, t), this.hitTestFn, this.hitPruneFn); return n && n[0] } propagate(e, t) { if (!e.target) return; const r = e.composedPath(); e.eventPhase = e.CAPTURING_PHASE; for (let i = 0, n = r.length - 1; i < n; i++)if (e.currentTarget = r[i], this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped) return; if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, t), !(e.propagationStopped || e.propagationImmediatelyStopped)) { e.eventPhase = e.BUBBLING_PHASE; for (let i = r.length - 2; i >= 0; i--)if (e.currentTarget = r[i], this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped) return } } all(e, t, r = this._allInteractiveElements) { if (r.length === 0) return; e.eventPhase = e.BUBBLING_PHASE; const i = Array.isArray(t) ? t : [t]; for (let n = r.length - 1; n >= 0; n--)i.forEach(a => { e.currentTarget = r[n], this.notifyTarget(e, a) }) } propagationPath(e) { const t = [e]; for (let r = 0; r < Op && e !== this.rootTarget && e.parent; r++) { if (!e.parent) throw new Error("Cannot find propagation path to disconnected target"); t.push(e.parent), e = e.parent } return t.reverse(), t } hitTestMoveRecursive(e, t, r, i, n, a = !1) { let o = !1; if (this._interactivePrune(e)) return null; if ((e.eventMode === "dynamic" || t === "dynamic") && (et.pauseUpdate = !1), e.interactiveChildren && e.children) { const c = e.children; for (let u = c.length - 1; u >= 0; u--) { const d = c[u], f = this.hitTestMoveRecursive(d, this._isInteractive(t) ? t : d.eventMode, r, i, n, a || n(e, r)); if (f) { if (f.length > 0 && !f[f.length - 1].parent) continue; const p = e.isInteractive(); (f.length > 0 || p) && (p && this._allInteractiveElements.push(e), f.push(e)), this._hitElements.length === 0 && (this._hitElements = f), o = !0 } } } const h = this._isInteractive(t), l = e.isInteractive(); return l && l && this._allInteractiveElements.push(e), a || this._hitElements.length > 0 ? null : o ? this._hitElements : h && !n(e, r) && i(e, r) ? l ? [e] : [] : null } hitTestRecursive(e, t, r, i, n) { if (this._interactivePrune(e) || n(e, r)) return null; if ((e.eventMode === "dynamic" || t === "dynamic") && (et.pauseUpdate = !1), e.interactiveChildren && e.children) { const h = e.children, l = r; for (let c = h.length - 1; c >= 0; c--) { const u = h[c], d = this.hitTestRecursive(u, this._isInteractive(t) ? t : u.eventMode, l, i, n); if (d) { if (d.length > 0 && !d[d.length - 1].parent) continue; const f = e.isInteractive(); return (d.length > 0 || f) && d.push(e), d } } } const a = this._isInteractive(t), o = e.isInteractive(); return a && i(e, r) ? o ? [e] : [] : null } _isInteractive(e) { return e === "static" || e === "dynamic" } _interactivePrune(e) { return !e || !e.visible || !e.renderable || !e.measurable || e.eventMode === "none" || e.eventMode === "passive" && !e.interactiveChildren } hitPruneFn(e, t) { if (e.hitArea && (e.worldTransform.applyInverse(t, Nt), !e.hitArea.contains(Nt.x, Nt.y))) return !0; if (e.effects && e.effects.length) for (let r = 0; r < e.effects.length; r++) { const i = e.effects[r]; if (i.containsPoint && !i.containsPoint(t, this.hitTestFn)) return !0 } return !1 } hitTestFn(e, t) { return e.hitArea ? !0 : e != null && e.containsPoint ? (e.worldTransform.applyInverse(t, Nt), e.containsPoint(Nt)) : !1 } notifyTarget(e, t) { var n, a; if (!e.currentTarget.isInteractive()) return; t ?? (t = e.type); const r = `on${t}`; (a = (n = e.currentTarget)[r]) == null || a.call(n, e); const i = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${t}capture` : t; this._notifyListeners(e, i), e.eventPhase === e.AT_TARGET && this._notifyListeners(e, t) } mapPointerDown(e) { if (!(e instanceof Fe)) { H("EventBoundary cannot map a non-pointer event as a pointer event"); return } const t = this.createPointerEvent(e); if (this.dispatchEvent(t, "pointerdown"), t.pointerType === "touch") this.dispatchEvent(t, "touchstart"); else if (t.pointerType === "mouse" || t.pointerType === "pen") { const i = t.button === 2; this.dispatchEvent(t, i ? "rightdown" : "mousedown") } const r = this.trackingData(e.pointerId); r.pressTargetsByButton[e.button] = t.composedPath(), this.freeEvent(t) } mapPointerMove(e) { var h, l; if (!(e instanceof Fe)) { H("EventBoundary cannot map a non-pointer event as a pointer event"); return } this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0; const t = this.createPointerEvent(e); this._isPointerMoveEvent = !1; const r = t.pointerType === "mouse" || t.pointerType === "pen", i = this.trackingData(e.pointerId), n = this.findMountedTarget(i.overTargets); if (((h = i.overTargets) == null ? void 0 : h.length) > 0 && n !== t.target) { const c = e.type === "mousemove" ? "mouseout" : "pointerout", u = this.createPointerEvent(e, c, n); if (this.dispatchEvent(u, "pointerout"), r && this.dispatchEvent(u, "mouseout"), !t.composedPath().includes(n)) { const d = this.createPointerEvent(e, "pointerleave", n); for (d.eventPhase = d.AT_TARGET; d.target && !t.composedPath().includes(d.target);)d.currentTarget = d.target, this.notifyTarget(d), r && this.notifyTarget(d, "mouseleave"), d.target = d.target.parent; this.freeEvent(d) } this.freeEvent(u) } if (n !== t.target) { const c = e.type === "mousemove" ? "mouseover" : "pointerover", u = this.clonePointerEvent(t, c); this.dispatchEvent(u, "pointerover"), r && this.dispatchEvent(u, "mouseover"); let d = n == null ? void 0 : n.parent; for (; d && d !== this.rootTarget.parent && d !== t.target;)d = d.parent; if (!d || d === this.rootTarget.parent) { const p = this.clonePointerEvent(t, "pointerenter"); for (p.eventPhase = p.AT_TARGET; p.target && p.target !== n && p.target !== this.rootTarget.parent;)p.currentTarget = p.target, this.notifyTarget(p), r && this.notifyTarget(p, "mouseenter"), p.target = p.target.parent; this.freeEvent(p) } this.freeEvent(u) } const a = [], o = this.enableGlobalMoveEvents ?? !0; this.moveOnAll ? a.push("pointermove") : this.dispatchEvent(t, "pointermove"), o && a.push("globalpointermove"), t.pointerType === "touch" && (this.moveOnAll ? a.splice(1, 0, "touchmove") : this.dispatchEvent(t, "touchmove"), o && a.push("globaltouchmove")), r && (this.moveOnAll ? a.splice(1, 0, "mousemove") : this.dispatchEvent(t, "mousemove"), o && a.push("globalmousemove"), this.cursor = (l = t.target) == null ? void 0 : l.cursor), a.length > 0 && this.all(t, a), this._allInteractiveElements.length = 0, this._hitElements.length = 0, i.overTargets = t.composedPath(), this.freeEvent(t) } mapPointerOver(e) { var a; if (!(e instanceof Fe)) { H("EventBoundary cannot map a non-pointer event as a pointer event"); return } const t = this.trackingData(e.pointerId), r = this.createPointerEvent(e), i = r.pointerType === "mouse" || r.pointerType === "pen"; this.dispatchEvent(r, "pointerover"), i && this.dispatchEvent(r, "mouseover"), r.pointerType === "mouse" && (this.cursor = (a = r.target) == null ? void 0 : a.cursor); const n = this.clonePointerEvent(r, "pointerenter"); for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent;)n.currentTarget = n.target, this.notifyTarget(n), i && this.notifyTarget(n, "mouseenter"), n.target = n.target.parent; t.overTargets = r.composedPath(), this.freeEvent(r), this.freeEvent(n) } mapPointerOut(e) { if (!(e instanceof Fe)) { H("EventBoundary cannot map a non-pointer event as a pointer event"); return } const t = this.trackingData(e.pointerId); if (t.overTargets) { const r = e.pointerType === "mouse" || e.pointerType === "pen", i = this.findMountedTarget(t.overTargets), n = this.createPointerEvent(e, "pointerout", i); this.dispatchEvent(n), r && this.dispatchEvent(n, "mouseout"); const a = this.createPointerEvent(e, "pointerleave", i); for (a.eventPhase = a.AT_TARGET; a.target && a.target !== this.rootTarget.parent;)a.currentTarget = a.target, this.notifyTarget(a), r && this.notifyTarget(a, "mouseleave"), a.target = a.target.parent; t.overTargets = null, this.freeEvent(n), this.freeEvent(a) } this.cursor = null } mapPointerUp(e) { if (!(e instanceof Fe)) { H("EventBoundary cannot map a non-pointer event as a pointer event"); return } const t = performance.now(), r = this.createPointerEvent(e); if (this.dispatchEvent(r, "pointerup"), r.pointerType === "touch") this.dispatchEvent(r, "touchend"); else if (r.pointerType === "mouse" || r.pointerType === "pen") { const o = r.button === 2; this.dispatchEvent(r, o ? "rightup" : "mouseup") } const i = this.trackingData(e.pointerId), n = this.findMountedTarget(i.pressTargetsByButton[e.button]); let a = n; if (n && !r.composedPath().includes(n)) { let o = n; for (; o && !r.composedPath().includes(o);) { if (r.currentTarget = o, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch") this.notifyTarget(r, "touchendoutside"); else if (r.pointerType === "mouse" || r.pointerType === "pen") { const h = r.button === 2; this.notifyTarget(r, h ? "rightupoutside" : "mouseupoutside") } o = o.parent } delete i.pressTargetsByButton[e.button], a = o } if (a) { const o = this.clonePointerEvent(r, "click"); o.target = a, o.path = null, i.clicksByButton[e.button] || (i.clicksByButton[e.button] = { clickCount: 0, target: o.target, timeStamp: t }); const h = i.clicksByButton[e.button]; if (h.target === o.target && t - h.timeStamp < 200 ? ++h.clickCount : h.clickCount = 1, h.target = o.target, h.timeStamp = t, o.detail = h.clickCount, o.pointerType === "mouse") { const l = o.button === 2; this.dispatchEvent(o, l ? "rightclick" : "click") } else o.pointerType === "touch" && this.dispatchEvent(o, "tap"); this.dispatchEvent(o, "pointertap"), this.freeEvent(o) } this.freeEvent(r) } mapPointerUpOutside(e) { if (!(e instanceof Fe)) { H("EventBoundary cannot map a non-pointer event as a pointer event"); return } const t = this.trackingData(e.pointerId), r = this.findMountedTarget(t.pressTargetsByButton[e.button]), i = this.createPointerEvent(e); if (r) { let n = r; for (; n;)i.currentTarget = n, this.notifyTarget(i, "pointerupoutside"), i.pointerType === "touch" ? this.notifyTarget(i, "touchendoutside") : (i.pointerType === "mouse" || i.pointerType === "pen") && this.notifyTarget(i, i.button === 2 ? "rightupoutside" : "mouseupoutside"), n = n.parent; delete t.pressTargetsByButton[e.button] } this.freeEvent(i) } mapWheel(e) { if (!(e instanceof Bt)) { H("EventBoundary cannot map a non-wheel event as a wheel event"); return } const t = this.createWheelEvent(e); this.dispatchEvent(t), this.freeEvent(t) } findMountedTarget(e) { if (!e) return null; let t = e[0]; for (let r = 1; r < e.length && e[r].parent === t; r++)t = e[r]; return t } createPointerEvent(e, t, r) { const i = this.allocateEvent(Fe); return this.copyPointerData(e, i), this.copyMouseData(e, i), this.copyData(e, i), i.nativeEvent = e.nativeEvent, i.originalEvent = e, i.target = r ?? this.hitTest(i.global.x, i.global.y) ?? this._hitElements[0], typeof t == "string" && (i.type = t), i } createWheelEvent(e) { const t = this.allocateEvent(Bt); return this.copyWheelData(e, t), this.copyMouseData(e, t), this.copyData(e, t), t.nativeEvent = e.nativeEvent, t.originalEvent = e, t.target = this.hitTest(t.global.x, t.global.y), t } clonePointerEvent(e, t) { const r = this.allocateEvent(Fe); return r.nativeEvent = e.nativeEvent, r.originalEvent = e.originalEvent, this.copyPointerData(e, r), this.copyMouseData(e, r), this.copyData(e, r), r.target = e.target, r.path = e.composedPath().slice(), r.type = t ?? r.type, r } copyWheelData(e, t) { t.deltaMode = e.deltaMode, t.deltaX = e.deltaX, t.deltaY = e.deltaY, t.deltaZ = e.deltaZ } copyPointerData(e, t) { e instanceof Fe && t instanceof Fe && (t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist) } copyMouseData(e, t) { e instanceof Vr && t instanceof Vr && (t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.copyFrom(e.client), t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.copyFrom(e.movement), t.screen.copyFrom(e.screen), t.shiftKey = e.shiftKey, t.global.copyFrom(e.global)) } copyData(e, t) { t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.detail = e.detail, t.view = e.view, t.which = e.which, t.layer.copyFrom(e.layer), t.page.copyFrom(e.page) } trackingData(e) { return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }), this.mappingState.trackingData[e] } allocateEvent(e) { this.eventPool.has(e) || this.eventPool.set(e, []); const t = this.eventPool.get(e).pop() || new e(this); return t.eventPhase = t.NONE, t.currentTarget = null, t.defaultPrevented = !1, t.path = null, t.target = null, t } freeEvent(e) { if (e.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!"); const t = e.constructor; this.eventPool.has(t) || this.eventPool.set(t, []), this.eventPool.get(t).push(e) } _notifyListeners(e, t) { const r = e.currentTarget._events[t]; if (r) if ("fn" in r) r.once && e.currentTarget.removeListener(t, r.fn, void 0, !0), r.fn.call(r.context, e); else for (let i = 0, n = r.length; i < n && !e.propagationImmediatelyStopped; i++)r[i].once && e.currentTarget.removeListener(t, r[i].fn, void 0, !0), r[i].fn.call(r[i].context, e) } } const Hp = 1, zp = { touchstart: "pointerdown", touchend: "pointerup", touchendoutside: "pointerupoutside", touchmove: "pointermove", touchcancel: "pointercancel" }, zi = class ai { constructor(e) { this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = e, this.rootBoundary = new Np(null), et.init(this), this.autoPreventDefault = !0, this._eventsAdded = !1, this._rootPointerEvent = new Fe(null), this._rootWheelEvent = new Bt(null), this.cursorStyles = { default: "inherit", pointer: "pointer" }, this.features = new Proxy({ ...ai.defaultEventFeatures }, { set: (t, r, i) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = i), t[r] = i, !0) }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this) } static get defaultEventMode() { return this._defaultEventMode } init(e) { const { canvas: t, resolution: r } = this.renderer; this.setTargetElement(t), this.resolution = r, ai._defaultEventMode = e.eventMode ?? "passive", Object.assign(this.features, e.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove } resolutionChange(e) { this.resolution = e } destroy() { this.setTargetElement(null), this.renderer = null, this._currentCursor = null } setCursor(e) { e || (e = "default"); let t = !0; if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1), this._currentCursor === e) return; this._currentCursor = e; const r = this.cursorStyles[e]; if (r) switch (typeof r) { case "string": t && (this.domElement.style.cursor = r); break; case "function": r(e); break; case "object": t && Object.assign(this.domElement.style, r); break } else t && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e) } get pointer() { return this._rootPointerEvent } _onPointerDown(e) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; const t = this._normalizeToPointerData(e); this.autoPreventDefault && t[0].isNormalized && (e.cancelable || !("cancelable" in e)) && e.preventDefault(); for (let r = 0, i = t.length; r < i; r++) { const n = t[r], a = this._bootstrapEvent(this._rootPointerEvent, n); this.rootBoundary.mapEvent(a) } this.setCursor(this.rootBoundary.cursor) } _onPointerMove(e) { if (!this.features.move) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, et.pointerMoved(); const t = this._normalizeToPointerData(e); for (let r = 0, i = t.length; r < i; r++) { const n = this._bootstrapEvent(this._rootPointerEvent, t[r]); this.rootBoundary.mapEvent(n) } this.setCursor(this.rootBoundary.cursor) } _onPointerUp(e) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; let t = e.target; e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0]); const r = t !== this.domElement ? "outside" : "", i = this._normalizeToPointerData(e); for (let n = 0, a = i.length; n < a; n++) { const o = this._bootstrapEvent(this._rootPointerEvent, i[n]); o.type += r, this.rootBoundary.mapEvent(o) } this.setCursor(this.rootBoundary.cursor) } _onPointerOverOut(e) { if (!this.features.click) return; this.rootBoundary.rootTarget = this.renderer.lastObjectRendered; const t = this._normalizeToPointerData(e); for (let r = 0, i = t.length; r < i; r++) { const n = this._bootstrapEvent(this._rootPointerEvent, t[r]); this.rootBoundary.mapEvent(n) } this.setCursor(this.rootBoundary.cursor) } onWheel(e) { if (!this.features.wheel) return; const t = this.normalizeWheelEvent(e); this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(t) } setTargetElement(e) { this._removeEvents(), this.domElement = e, et.domElement = e, this._addEvents() } _addEvents() { if (this._eventsAdded || !this.domElement) return; et.addTickerListener(); const e = this.domElement.style; e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0), this.domElement.addEventListener("pointerdown", this._onPointerDown, !0), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0), globalThis.addEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0), this.domElement.addEventListener("mousedown", this._onPointerDown, !0), this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0), globalThis.addEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, !0), this.domElement.addEventListener("touchend", this._onPointerUp, !0), this.domElement.addEventListener("touchmove", this._onPointerMove, !0))), this.domElement.addEventListener("wheel", this.onWheel, { passive: !0, capture: !0 }), this._eventsAdded = !0 } _removeEvents() { if (!this._eventsAdded || !this.domElement) return; et.removeTickerListener(); const e = this.domElement.style; e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0), this.domElement.removeEventListener("mousedown", this._onPointerDown, !0), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0), this.domElement.removeEventListener("touchend", this._onPointerUp, !0), this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this._eventsAdded = !1 } mapPositionToPoint(e, t, r) { const i = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : { width: this.domElement.width, height: this.domElement.height, left: 0, top: 0 }, n = 1 / this.resolution; e.x = (t - i.left) * (this.domElement.width / i.width) * n, e.y = (r - i.top) * (this.domElement.height / i.height) * n } _normalizeToPointerData(e) { const t = []; if (this.supportsTouchEvents && e instanceof TouchEvent) for (let r = 0, i = e.changedTouches.length; r < i; r++) { const n = e.changedTouches[r]; typeof n.button > "u" && (n.button = 0), typeof n.buttons > "u" && (n.buttons = 1), typeof n.isPrimary > "u" && (n.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof n.width > "u" && (n.width = n.radiusX || 1), typeof n.height > "u" && (n.height = n.radiusY || 1), typeof n.tiltX > "u" && (n.tiltX = 0), typeof n.tiltY > "u" && (n.tiltY = 0), typeof n.pointerType > "u" && (n.pointerType = "touch"), typeof n.pointerId > "u" && (n.pointerId = n.identifier || 0), typeof n.pressure > "u" && (n.pressure = n.force || .5), typeof n.twist > "u" && (n.twist = 0), typeof n.tangentialPressure > "u" && (n.tangentialPressure = 0), typeof n.layerX > "u" && (n.layerX = n.offsetX = n.clientX), typeof n.layerY > "u" && (n.layerY = n.offsetY = n.clientY), n.isNormalized = !0, n.type = e.type, t.push(n) } else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) { const r = e; typeof r.isPrimary > "u" && (r.isPrimary = !0), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = Hp), typeof r.pressure > "u" && (r.pressure = .5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = !0, t.push(r) } else t.push(e); return t } normalizeWheelEvent(e) { const t = this._rootWheelEvent; return this._transferMouseData(t, e), t.deltaX = e.deltaX, t.deltaY = e.deltaY, t.deltaZ = e.deltaZ, t.deltaMode = e.deltaMode, this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.nativeEvent = e, t.type = e.type, t } _bootstrapEvent(e, t) { return e.originalEvent = null, e.nativeEvent = t, e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist, this._transferMouseData(e, t), this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.isTrusted = t.isTrusted, e.type === "pointerleave" && (e.type = "pointerout"), e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")), e.type.startsWith("touch") && (e.type = zp[e.type] || e.type), e } _transferMouseData(e, t) { e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.x = t.clientX, e.client.y = t.clientY, e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.x = t.movementX, e.movement.y = t.movementY, e.page.x = t.pageX, e.page.y = t.pageY, e.relatedTarget = null, e.shiftKey = t.shiftKey } }; zi.extension = { name: "events", type: [b.WebGLSystem, b.CanvasSystem, b.WebGPUSystem], priority: -1 }; zi.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 }; let wh = zi; const Wp = { onclick: null, onmousedown: null, onmouseenter: null, onmouseleave: null, onmousemove: null, onglobalmousemove: null, onmouseout: null, onmouseover: null, onmouseup: null, onmouseupoutside: null, onpointercancel: null, onpointerdown: null, onpointerenter: null, onpointerleave: null, onpointermove: null, onglobalpointermove: null, onpointerout: null, onpointerover: null, onpointertap: null, onpointerup: null, onpointerupoutside: null, onrightclick: null, onrightdown: null, onrightup: null, onrightupoutside: null, ontap: null, ontouchcancel: null, ontouchend: null, ontouchendoutside: null, ontouchmove: null, onglobaltouchmove: null, ontouchstart: null, onwheel: null, get interactive() { return this.eventMode === "dynamic" || this.eventMode === "static" }, set interactive(s) { this.eventMode = s ? "static" : "passive" }, _internalEventMode: void 0, get eventMode() { return this._internalEventMode ?? wh.defaultEventMode }, set eventMode(s) { this._internalEventMode = s }, isInteractive() { return this.eventMode === "static" || this.eventMode === "dynamic" }, interactiveChildren: !0, hitArea: null, addEventListener(s, e, t) { const r = typeof t == "boolean" && t || typeof t == "object" && t.capture, i = typeof t == "object" ? t.signal : void 0, n = typeof t == "object" ? t.once === !0 : !1, a = typeof e == "function" ? void 0 : e; s = r ? `${s}capture` : s; const o = typeof e == "function" ? e : e.handleEvent, h = this; i && i.addEventListener("abort", () => { h.off(s, o, a) }), n ? h.once(s, o, a) : h.on(s, o, a) }, removeEventListener(s, e, t) { const r = typeof t == "boolean" && t || typeof t == "object" && t.capture, i = typeof e == "function" ? void 0 : e; s = r ? `${s}capture` : s, e = typeof e == "function" ? e : e.handleEvent, this.off(s, e, i) }, dispatchEvent(s) { if (!(s instanceof sr)) throw new Error("Container cannot propagate events outside of the Federated Events API"); return s.defaultPrevented = !1, s.path = null, s.target = this, s.manager.dispatchEvent(s), !s.defaultPrevented } }; class Ah { constructor(e) { this._renderer = e } push(e, t, r) { this._renderer.renderPipes.batch.break(r), r.add({ renderPipeId: "filter", canBundle: !1, action: "pushFilter", container: t, filterEffect: e }) } pop(e, t, r) { this._renderer.renderPipes.batch.break(r), r.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } execute(e) { e.action === "pushFilter" ? this._renderer.filter.push(e) : e.action === "popFilter" && this._renderer.filter.pop() } destroy() { this._renderer = null } } Ah.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "filter" }; function Vp(s, e) { e.clear(); const t = e.matrix; for (let r = 0; r < s.length; r++) { const i = s[r]; i.globalDisplayStatus < 7 || (e.matrix = i.worldTransform, e.addBounds(i.bounds)) } return e.matrix = t, e } const $p = new ir({ attributes: { aPosition: { buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), format: "float32x2", stride: 2 * 4, offset: 0 } }, indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]) }); class Ph { constructor(e) { this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new be({ uInputSize: { value: new Float32Array(4), type: "vec4<f32>" }, uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" }, uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" }, uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" } }), this._globalFilterBindGroup = new qe({}), this.renderer = e } get activeBackTexture() { var e; return (e = this._activeFilterData) == null ? void 0 : e.backTexture } push(e) { var f; const t = this.renderer, r = e.filterEffect.filters; this._filterStack[this._filterStackIndex] || (this._filterStack[this._filterStackIndex] = this._getFilterData()); const i = this._filterStack[this._filterStackIndex]; if (this._filterStackIndex++, r.length === 0) { i.skip = !0; return } const n = i.bounds; if (e.renderables ? Vp(e.renderables, n) : e.filterEffect.filterArea ? (n.clear(), n.addRect(e.filterEffect.filterArea), n.applyMatrix(e.container.worldTransform)) : e.container.getFastGlobalBounds(!0, n), e.container) { const g = (e.container.renderGroup || e.container.parentRenderGroup).cacheToLocalTransform; g && n.applyMatrix(g) } const a = t.renderTarget.renderTarget.colorTexture.source; let o = 1 / 0, h = 0, l = !0, c = !1, u = !1, d = !0; for (let p = 0; p < r.length; p++) { const g = r[p]; if (o = Math.min(o, g.resolution === "inherit" ? a._resolution : g.resolution), h += g.padding, g.antialias === "off" ? l = !1 : g.antialias === "inherit" && l && (l = a.antialias), g.clipToViewport || (d = !1), !!!(g.compatibleRenderers & t.type)) { u = !1; break } if (g.blendRequired && !(((f = t.backBuffer) == null ? void 0 : f.useBackBuffer) ?? !0)) { H("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), u = !1; break } u = g.enabled || u, c || (c = g.blendRequired) } if (!u) { i.skip = !0; return } if (d) { const p = t.renderTarget.rootViewPort, g = t.renderTarget.renderTarget.resolution; n.fitBounds(0, p.width / g, 0, p.height / g) } if (n.scale(o).ceil().scale(1 / o).pad(h | 0), !n.isPositive) { i.skip = !0; return } i.skip = !1, i.bounds = n, i.blendRequired = c, i.container = e.container, i.filterEffect = e.filterEffect, i.previousRenderSurface = t.renderTarget.renderSurface, i.inputTexture = _e.getOptimalTexture(n.width, n.height, o, l), t.renderTarget.bind(i.inputTexture, !0), t.globalUniforms.push({ offset: n }) } pop() { const e = this.renderer; this._filterStackIndex--; const t = this._filterStack[this._filterStackIndex]; if (t.skip) return; this._activeFilterData = t; const r = t.inputTexture, i = t.bounds; let n = F.EMPTY; if (e.renderTarget.finishRenderPass(), t.blendRequired) { const o = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null, h = e.renderTarget.getRenderTarget(t.previousRenderSurface); n = this.getBackTexture(h, i, o) } t.backTexture = n; const a = t.filterEffect.filters; if (this._globalFilterBindGroup.setResource(r.source.style, 2), this._globalFilterBindGroup.setResource(n.source, 3), e.globalUniforms.pop(), a.length === 1) a[0].apply(this, r, t.previousRenderSurface, !1), _e.returnTexture(r); else { let o = t.inputTexture, h = _e.getOptimalTexture(i.width, i.height, o.source._resolution, !1), l = 0; for (l = 0; l < a.length - 1; ++l) { a[l].apply(this, o, h, !0); const u = o; o = h, h = u } a[l].apply(this, o, t.previousRenderSurface, !1), _e.returnTexture(o), _e.returnTexture(h) } t.blendRequired && _e.returnTexture(n) } getBackTexture(e, t, r) { const i = e.colorTexture.source._resolution, n = _e.getOptimalTexture(t.width, t.height, i, !1); let a = t.minX, o = t.minY; r && (a -= r.minX, o -= r.minY), a = Math.floor(a * i), o = Math.floor(o * i); const h = Math.ceil(t.width * i), l = Math.ceil(t.height * i); return this.renderer.renderTarget.copyToTexture(e, n, { x: a, y: o }, { width: h, height: l }, { x: 0, y: 0 }), n } applyFilter(e, t, r, i) { const n = this.renderer, a = this._filterStack[this._filterStackIndex], o = a.bounds, h = oe.shared, c = a.previousRenderSurface === r; let u = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution, d = this._filterStackIndex - 1; for (; d > 0 && this._filterStack[d].skip;)--d; d > 0 && (u = this._filterStack[d].inputTexture.source._resolution); const f = this._filterGlobalUniforms, p = f.uniforms, g = p.uOutputFrame, m = p.uInputSize, y = p.uInputPixel, T = p.uInputClamp, S = p.uGlobalFrame, A = p.uOutputTexture; if (c) { let C = this._filterStackIndex; for (; C > 0;) { C--; const L = this._filterStack[this._filterStackIndex - 1]; if (!L.skip) { h.x = L.bounds.minX, h.y = L.bounds.minY; break } } g[0] = o.minX - h.x, g[1] = o.minY - h.y } else g[0] = 0, g[1] = 0; g[2] = t.frame.width, g[3] = t.frame.height, m[0] = t.source.width, m[1] = t.source.height, m[2] = 1 / m[0], m[3] = 1 / m[1], y[0] = t.source.pixelWidth, y[1] = t.source.pixelHeight, y[2] = 1 / y[0], y[3] = 1 / y[1], T[0] = .5 * y[2], T[1] = .5 * y[3], T[2] = t.frame.width * m[2] - .5 * y[2], T[3] = t.frame.height * m[3] - .5 * y[3]; const R = this.renderer.renderTarget.rootRenderTarget.colorTexture; S[0] = h.x * u, S[1] = h.y * u, S[2] = R.source.width * u, S[3] = R.source.height * u; const E = this.renderer.renderTarget.getRenderTarget(r); if (n.renderTarget.bind(r, !!i), r instanceof F ? (A[0] = r.frame.width, A[1] = r.frame.height) : (A[0] = E.width, A[1] = E.height), A[2] = E.isRoot ? -1 : 1, f.update(), n.renderPipes.uniformBatch) { const C = n.renderPipes.uniformBatch.getUboResource(f); this._globalFilterBindGroup.setResource(C, 0) } else this._globalFilterBindGroup.setResource(f, 0); this._globalFilterBindGroup.setResource(t.source, 1), this._globalFilterBindGroup.setResource(t.source.style, 2), e.groups[0] = this._globalFilterBindGroup, n.encoder.draw({ geometry: $p, shader: e, state: e._state, topology: "triangle-list" }), n.type === De.WEBGL && n.renderTarget.finishRenderPass() } _getFilterData() { return { skip: !1, inputTexture: null, bounds: new xe, container: null, filterEffect: null, blendRequired: !1, previousRenderSurface: null } } calculateSpriteMatrix(e, t) { const r = this._activeFilterData, i = e.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY), n = t.worldTransform.copyTo(D.shared), a = t.renderGroup || t.parentRenderGroup; return a && a.cacheToLocalTransform && n.prepend(a.cacheToLocalTransform), n.invert(), i.prepend(n), i.scale(1 / t.texture.frame.width, 1 / t.texture.frame.height), i.translate(t.anchor.x, t.anchor.y), i } } Ph.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "filter" }; var Xp = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`, jp = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`, Ca = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`; class Yp extends Yu { constructor(e) { const { sprite: t, ...r } = e, i = new ao(t.texture), n = new be({ uFilterMatrix: { value: new D, type: "mat3x3<f32>" }, uMaskClamp: { value: i.uClampFrame, type: "vec4<f32>" }, uAlpha: { value: 1, type: "f32" }, uInverse: { value: e.inverse ? 1 : 0, type: "f32" } }), a = gt.from({ vertex: { source: Ca, entryPoint: "mainVertex" }, fragment: { source: Ca, entryPoint: "mainFragment" } }), o = kt.from({ vertex: jp, fragment: Xp, name: "mask-filter" }); super({ ...r, gpuProgram: a, glProgram: o, resources: { filterUniforms: n, uMaskTexture: t.texture.source } }), this.sprite = t, this._textureMatrix = i } set inverse(e) { this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0 } get inverse() { return this.resources.filterUniforms.uniforms.uInverse === 1 } apply(e, t, r, i) { this._textureMatrix.texture = this.sprite.texture, e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, e.applyFilter(this, t, r, i) } } class rr extends vi { constructor(e) { e instanceof Be && (e = { context: e }); const { context: t, roundPixels: r, ...i } = e || {}; super({ label: "Graphics", ...i }), this.renderPipeId = "graphics", t ? this._context = t : this._context = this._ownedContext = new Be, this._context.on("update", this.onViewUpdate, this), this.allowChildren = !1, this.roundPixels = r ?? !1 } set context(e) { e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate()) } get context() { return this._context } get bounds() { return this._context.bounds } updateBounds() { } containsPoint(e) { return this._context.containsPoint(e) } destroy(e) { this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || (e == null ? void 0 : e.context) === !0) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e) } _callContextMethod(e, t) { return this.context[e](...t), this } setFillStyle(...e) { return this._callContextMethod("setFillStyle", e) } setStrokeStyle(...e) { return this._callContextMethod("setStrokeStyle", e) } fill(...e) { return this._callContextMethod("fill", e) } stroke(...e) { return this._callContextMethod("stroke", e) } texture(...e) { return this._callContextMethod("texture", e) } beginPath() { return this._callContextMethod("beginPath", []) } cut() { return this._callContextMethod("cut", []) } arc(...e) { return this._callContextMethod("arc", e) } arcTo(...e) { return this._callContextMethod("arcTo", e) } arcToSvg(...e) { return this._callContextMethod("arcToSvg", e) } bezierCurveTo(...e) { return this._callContextMethod("bezierCurveTo", e) } closePath() { return this._callContextMethod("closePath", []) } ellipse(...e) { return this._callContextMethod("ellipse", e) } circle(...e) { return this._callContextMethod("circle", e) } path(...e) { return this._callContextMethod("path", e) } lineTo(...e) { return this._callContextMethod("lineTo", e) } moveTo(...e) { return this._callContextMethod("moveTo", e) } quadraticCurveTo(...e) { return this._callContextMethod("quadraticCurveTo", e) } rect(...e) { return this._callContextMethod("rect", e) } roundRect(...e) { return this._callContextMethod("roundRect", e) } poly(...e) { return this._callContextMethod("poly", e) } regularPoly(...e) { return this._callContextMethod("regularPoly", e) } roundPoly(...e) { return this._callContextMethod("roundPoly", e) } roundShape(...e) { return this._callContextMethod("roundShape", e) } filletRect(...e) { return this._callContextMethod("filletRect", e) } chamferRect(...e) { return this._callContextMethod("chamferRect", e) } star(...e) { return this._callContextMethod("star", e) } svg(...e) { return this._callContextMethod("svg", e) } restore(...e) { return this._callContextMethod("restore", e) } save() { return this._callContextMethod("save", []) } getTransform() { return this.context.getTransform() } resetTransform() { return this._callContextMethod("resetTransform", []) } rotateTransform(...e) { return this._callContextMethod("rotate", e) } scaleTransform(...e) { return this._callContextMethod("scale", e) } setTransform(...e) { return this._callContextMethod("setTransform", e) } transform(...e) { return this._callContextMethod("transform", e) } translateTransform(...e) { return this._callContextMethod("translate", e) } clear() { return this._callContextMethod("clear", []) } get fillStyle() { return this._context.fillStyle } set fillStyle(e) { this._context.fillStyle = e } get strokeStyle() { return this._context.strokeStyle } set strokeStyle(e) { this._context.strokeStyle = e } clone(e = !1) { return e ? new rr(this._context.clone()) : (this._ownedContext = null, new rr(this._context)) } lineStyle(e, t, r) { X(ee, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style."); const i = {}; return e && (i.width = e), t && (i.color = t), r && (i.alpha = r), this.context.strokeStyle = i, this } beginFill(e, t) { X(ee, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."); const r = {}; return e !== void 0 && (r.color = e), t !== void 0 && (r.alpha = t), this.context.fillStyle = r, this } endFill() { X(ee, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill(); const e = this.context.strokeStyle; return (e.width !== Be.defaultStrokeStyle.width || e.color !== Be.defaultStrokeStyle.color || e.alpha !== Be.defaultStrokeStyle.alpha) && this.context.stroke(), this } drawCircle(...e) { return X(ee, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e) } drawEllipse(...e) { return X(ee, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e) } drawPolygon(...e) { return X(ee, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e) } drawRect(...e) { return X(ee, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e) } drawRoundedRect(...e) { return X(ee, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e) } drawStar(...e) { return X(ee, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e) } } const Eh = class Ch extends ir { constructor(...e) { let t = e[0] ?? {}; t instanceof Float32Array && (X(ee, "use new MeshGeometry({ positions, uvs, indices }) instead"), t = { positions: t, uvs: e[1], indices: e[2] }), t = { ...Ch.defaultOptions, ...t }; const r = t.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]); let i = t.uvs; i || (t.positions ? i = new Float32Array(r.length) : i = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])); const n = t.indices || new Uint32Array([0, 1, 2, 0, 2, 3]), a = t.shrinkBuffersToFit, o = new Ee({ data: r, label: "attribute-mesh-positions", shrinkToFit: a, usage: Y.VERTEX | Y.COPY_DST }), h = new Ee({ data: i, label: "attribute-mesh-uvs", shrinkToFit: a, usage: Y.VERTEX | Y.COPY_DST }), l = new Ee({ data: n, label: "index-mesh-buffer", shrinkToFit: a, usage: Y.INDEX | Y.COPY_DST }); super({ attributes: { aPosition: { buffer: o, format: "float32x2", stride: 2 * 4, offset: 0 }, aUV: { buffer: h, format: "float32x2", stride: 2 * 4, offset: 0 } }, indexBuffer: l, topology: t.topology }), this.batchMode = "auto" } get positions() { return this.attributes.aPosition.buffer.data } set positions(e) { this.attributes.aPosition.buffer.data = e } get uvs() { return this.attributes.aUV.buffer.data } set uvs(e) { this.attributes.aUV.buffer.data = e } get indices() { return this.indexBuffer.data } set indices(e) { this.indexBuffer.data = e } }; Eh.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: !1 }; let Wi = Eh; class Kp { constructor({ matrix: e, observer: t } = {}) { this.dirty = !0, this._matrix = e ?? new D, this.observer = t, this.position = new me(this, 0, 0), this.scale = new me(this, 1, 1), this.pivot = new me(this, 0, 0), this.skew = new me(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1 } get matrix() { const e = this._matrix; return this.dirty && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this.dirty = !1), e } _onUpdate(e) { var t; this.dirty = !0, e === this.skew && this.updateSkew(), (t = this.observer) == null || t._onUpdate(this) } updateSkew() { this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = !0 } toString() { return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]` } setFromMatrix(e) { e.decompose(this), this.dirty = !0 } get rotation() { return this._rotation } set rotation(e) { this._rotation !== e && (this._rotation = e, this._onUpdate(this.skew)) } } const Mh = class kr extends vi { constructor(...e) { let t = e[0] || {}; t instanceof F && (t = { texture: t }), e.length > 1 && (X(ee, "use new TilingSprite({ texture, width:100, height:100 }) instead"), t.width = e[1], t.height = e[2]), t = { ...kr.defaultOptions, ...t }; const { texture: r, anchor: i, tilePosition: n, tileScale: a, tileRotation: o, width: h, height: l, applyAnchorToTexture: c, roundPixels: u, ...d } = t ?? {}; super({ label: "TilingSprite", ...d }), this.renderPipeId = "tilingSprite", this.batched = !0, this.allowChildren = !1, this._anchor = new me({ _onUpdate: () => { this.onViewUpdate() } }), this.applyAnchorToTexture = c, this.texture = r, this._width = h ?? r.width, this._height = l ?? r.height, this._tileTransform = new Kp({ observer: { _onUpdate: () => this.onViewUpdate() } }), i && (this.anchor = i), this.tilePosition = n, this.tileScale = a, this.tileRotation = o, this.roundPixels = u ?? !1 } static from(e, t = {}) { return typeof e == "string" ? new kr({ texture: ae.get(e), ...t }) : new kr({ texture: e, ...t }) } get uvRespectAnchor() { return H("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"), this.applyAnchorToTexture } set uvRespectAnchor(e) { H("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"), this.applyAnchorToTexture = e } get clampMargin() { return this._texture.textureMatrix.clampMargin } set clampMargin(e) { this._texture.textureMatrix.clampMargin = e } get anchor() { return this._anchor } set anchor(e) { typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e) } get tilePosition() { return this._tileTransform.position } set tilePosition(e) { this._tileTransform.position.copyFrom(e) } get tileScale() { return this._tileTransform.scale } set tileScale(e) { typeof e == "number" ? this._tileTransform.scale.set(e) : this._tileTransform.scale.copyFrom(e) } set tileRotation(e) { this._tileTransform.rotation = e } get tileRotation() { return this._tileTransform.rotation } get tileTransform() { return this._tileTransform } set texture(e) { e || (e = F.EMPTY); const t = this._texture; t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this.onViewUpdate()) } get texture() { return this._texture } set width(e) { this._width = e, this.onViewUpdate() } get width() { return this._width } set height(e) { this._height = e, this.onViewUpdate() } get height() { return this._height } setSize(e, t) { typeof e == "object" && (t = e.height ?? e.width, e = e.width), this._width = e, this._height = t ?? e, this.onViewUpdate() } getSize(e) { return e || (e = {}), e.width = this._width, e.height = this._height, e } updateBounds() { const e = this._bounds, t = this._anchor, r = this._width, i = this._height; e.minX = -t._x * r, e.maxX = e.minX + r, e.minY = -t._y * i, e.maxY = e.minY + i } containsPoint(e) { const t = this._width, r = this._height, i = -t * this._anchor._x; let n = 0; return e.x >= i && e.x <= i + t && (n = -r * this._anchor._y, e.y >= n && e.y <= n + r) } destroy(e = !1) { if (super.destroy(e), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof e == "boolean" ? e : e == null ? void 0 : e.texture) { const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource; this._texture.destroy(r) } this._texture = null } }; Mh.defaultOptions = { texture: F.EMPTY, anchor: { x: 0, y: 0 }, tilePosition: { x: 0, y: 0 }, tileScale: { x: 1, y: 1 }, tileRotation: 0, applyAnchorToTexture: !1 }; let qp = Mh; function Zp(s) { const e = s._stroke, t = s._fill, i = [`div { ${[`color: ${ie.shared.setValue(t.color).toHex()}`, `font-size: ${s.fontSize}px`, `font-family: ${s.fontFamily}`, `font-weight: ${s.fontWeight}`, `font-style: ${s.fontStyle}`, `font-variant: ${s.fontVariant}`, `letter-spacing: ${s.letterSpacing}px`, `text-align: ${s.align}`, `padding: ${s.padding}px`, `white-space: ${s.whiteSpace === "pre" && s.wordWrap ? "pre-wrap" : s.whiteSpace}`, ...s.lineHeight ? [`line-height: ${s.lineHeight}px`] : [], ...s.wordWrap ? [`word-wrap: ${s.breakWords ? "break-all" : "break-word"}`, `max-width: ${s.wordWrapWidth}px`] : [], ...e ? [Rh(e)] : [], ...s.dropShadow ? [Bh(s.dropShadow)] : [], ...s.cssOverrides].join(";")} }`]; return Qp(s.tagStyles, i), i.join(" ") } function Bh(s) { const e = ie.shared.setValue(s.color).setAlpha(s.alpha).toHexa(), t = Math.round(Math.cos(s.angle) * s.distance), r = Math.round(Math.sin(s.angle) * s.distance), i = `${t}px ${r}px`; return s.blur > 0 ? `text-shadow: ${i} ${s.blur}px ${e}` : `text-shadow: ${i} ${e}` } function Rh(s) { return [`-webkit-text-stroke-width: ${s.width}px`, `-webkit-text-stroke-color: ${ie.shared.setValue(s.color).toHex()}`, `text-stroke-width: ${s.width}px`, `text-stroke-color: ${ie.shared.setValue(s.color).toHex()}`, "paint-order: stroke"].join(";") } const Ma = { fontSize: "font-size: {{VALUE}}px", fontFamily: "font-family: {{VALUE}}", fontWeight: "font-weight: {{VALUE}}", fontStyle: "font-style: {{VALUE}}", fontVariant: "font-variant: {{VALUE}}", letterSpacing: "letter-spacing: {{VALUE}}px", align: "text-align: {{VALUE}}", padding: "padding: {{VALUE}}px", whiteSpace: "white-space: {{VALUE}}", lineHeight: "line-height: {{VALUE}}px", wordWrapWidth: "max-width: {{VALUE}}px" }, Ba = { fill: s => `color: ${ie.shared.setValue(s).toHex()}`, breakWords: s => `word-wrap: ${s ? "break-all" : "break-word"}`, stroke: Rh, dropShadow: Bh }; function Qp(s, e) { for (const t in s) { const r = s[t], i = []; for (const n in r) Ba[n] ? i.push(Ba[n](r[n])) : Ma[n] && i.push(Ma[n].replace("{{VALUE}}", r[n])); e.push(`${t} { ${i.join(";")} }`) } } class Vi extends it { constructor(e = {}) { super(e), this._cssOverrides = [], this.cssOverrides ?? (this.cssOverrides = e.cssOverrides), this.tagStyles = e.tagStyles ?? {} } set cssOverrides(e) { this._cssOverrides = e instanceof Array ? e : [e], this.update() } get cssOverrides() { return this._cssOverrides } _generateKey() { return this._styleKey = uh(this) + this._cssOverrides.join("-"), this._styleKey } update() { this._cssStyle = null, super.update() } clone() { return new Vi({ align: this.align, breakWords: this.breakWords, dropShadow: this.dropShadow ? { ...this.dropShadow } : null, fill: this._fill, fontFamily: this.fontFamily, fontSize: this.fontSize, fontStyle: this.fontStyle, fontVariant: this.fontVariant, fontWeight: this.fontWeight, letterSpacing: this.letterSpacing, lineHeight: this.lineHeight, padding: this.padding, stroke: this._stroke, whiteSpace: this.whiteSpace, wordWrap: this.wordWrap, wordWrapWidth: this.wordWrapWidth, cssOverrides: this.cssOverrides }) } get cssStyle() { return this._cssStyle || (this._cssStyle = Zp(this)), this._cssStyle } addOverride(...e) { const t = e.filter(r => !this.cssOverrides.includes(r)); t.length > 0 && (this.cssOverrides.push(...t), this.update()) } removeOverride(...e) { const t = e.filter(r => this.cssOverrides.includes(r)); t.length > 0 && (this.cssOverrides = this.cssOverrides.filter(r => !t.includes(r)), this.update()) } set fill(e) { typeof e != "string" && typeof e != "number" && H("[HTMLTextStyle] only color fill is not supported by HTMLText"), super.fill = e } set stroke(e) { e && typeof e != "string" && typeof e != "number" && H("[HTMLTextStyle] only color stroke is not supported by HTMLText"), super.stroke = e } } const Ra = "http://www.w3.org/2000/svg", ka = "http://www.w3.org/1999/xhtml"; class kh { constructor() { this.svgRoot = document.createElementNS(Ra, "svg"), this.foreignObject = document.createElementNS(Ra, "foreignObject"), this.domElement = document.createElementNS(ka, "div"), this.styleElement = document.createElementNS(ka, "style"), this.image = new Image; const { foreignObject: e, svgRoot: t, styleElement: r, domElement: i } = this; e.setAttribute("width", "10000"), e.setAttribute("height", "10000"), e.style.overflow = "hidden", t.appendChild(e), e.appendChild(r), e.appendChild(i) } } let Ia; function Jp(s, e, t, r) { r || (r = Ia || (Ia = new kh)); const { domElement: i, styleElement: n, svgRoot: a } = r; i.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${s}</div>`, i.setAttribute("style", "transform-origin: top left; display: inline-block"), t && (n.textContent = t), document.body.appendChild(a); const o = i.getBoundingClientRect(); a.remove(); const h = e.padding * 2; return { width: o.width - h, height: o.height - h } } class Ih { constructor() { this._tempState = Oe.for2d(), this._didUploadHash = {} } init(e) { e.renderer.runners.contextChange.add(this) } contextChange() { this._didUploadHash = {} } start(e, t, r) { const i = e.renderer, n = this._didUploadHash[r.uid]; i.shader.bind(r, n), n || (this._didUploadHash[r.uid] = !0), i.shader.updateUniformGroup(i.globalUniforms.uniformGroup), i.geometry.bind(t, r.glProgram) } execute(e, t) { const r = e.renderer; this._tempState.blendMode = t.blendMode, r.state.set(this._tempState); const i = t.textures.textures; for (let n = 0; n < t.textures.count; n++)r.texture.bind(i[n], n); r.geometry.draw(t.topology, t.size, t.start) } } Ih.extension = { type: [b.WebGLPipesAdaptor], name: "batch" }; const Sr = Oe.for2d(); class Gh { start(e, t, r) { const i = e.renderer, n = i.encoder, a = r.gpuProgram; this._shader = r, this._geometry = t, n.setGeometry(t, a), Sr.blendMode = "normal", i.pipeline.getPipeline(t, a, Sr); const o = i.globalUniforms.bindGroup; n.resetBindGroup(1), n.setBindGroup(0, o, a) } execute(e, t) { const r = this._shader.gpuProgram, i = e.renderer, n = i.encoder; if (!t.bindGroup) { const h = t.textures; t.bindGroup = Ei(h.textures, h.count) } Sr.blendMode = t.blendMode; const a = i.bindGroup.getBindGroup(t.bindGroup, r, 1), o = i.pipeline.getPipeline(this._geometry, r, Sr, t.topology); t.bindGroup._touch(i.textureGC.count), n.setPipeline(o), n.renderPassEncoder.setBindGroup(1, a), n.renderPassEncoder.drawIndexed(t.size, 1, t.start) } } Gh.extension = { type: [b.WebGPUPipesAdaptor], name: "batch" }; const $i = class Fh { constructor(e, t) { var r, i; this.state = Oe.for2d(), this._batchersByInstructionSet = Object.create(null), this._activeBatches = Object.create(null), this.renderer = e, this._adaptor = t, (i = (r = this._adaptor).init) == null || i.call(r, this) } static getBatcher(e) { return new this._availableBatchers[e] } buildStart(e) { let t = this._batchersByInstructionSet[e.uid]; t || (t = this._batchersByInstructionSet[e.uid] = Object.create(null), t.default || (t.default = new Ii)), this._activeBatches = t, this._activeBatch = this._activeBatches.default; for (const r in this._activeBatches) this._activeBatches[r].begin() } addToBatch(e, t) { if (this._activeBatch.name !== e.batcherName) { this._activeBatch.break(t); let r = this._activeBatches[e.batcherName]; r || (r = this._activeBatches[e.batcherName] = Fh.getBatcher(e.batcherName), r.begin()), this._activeBatch = r } this._activeBatch.add(e) } break(e) { this._activeBatch.break(e) } buildEnd(e) { this._activeBatch.break(e); const t = this._activeBatches; for (const r in t) { const i = t[r], n = i.geometry; n.indexBuffer.setDataWithSize(i.indexBuffer, i.indexSize, !0), n.buffers[0].setDataWithSize(i.attributeBuffer.float32View, i.attributeSize, !1) } } upload(e) { const t = this._batchersByInstructionSet[e.uid]; for (const r in t) { const i = t[r], n = i.geometry; i.dirty && (i.dirty = !1, n.buffers[0].update(i.attributeSize * 4)) } } execute(e) { if (e.action === "startBatch") { const t = e.batcher, r = t.geometry, i = t.shader; this._adaptor.start(this, r, i) } this._adaptor.execute(this, e) } destroy() { this.state = null, this.renderer = null, this._adaptor = null; for (const e in this._activeBatches) this._activeBatches[e].destroy(); this._activeBatches = null } }; $i.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "batch" }; $i._availableBatchers = Object.create(null); let Uh = $i; z.handleByMap(b.Batcher, Uh._availableBatchers); z.add(Ii); const qt = {
  name: "local-uniform-bit", vertex: {
    header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `, main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `, end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}
}, em = { ...qt, vertex: { ...qt.vertex, header: qt.vertex.header.replace("group(1)", "group(2)") } }, Xi = {
  name: "local-uniform-bit", vertex: {
    header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `, main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `, end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}
}, tm = {
  name: "texture-bit", vertex: {
    header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `, main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `}, fragment: {
    header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `, main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `}
}, rm = {
  name: "texture-bit", vertex: {
    header: `
            uniform mat3 uTextureMatrix;
        `, main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `}, fragment: {
    header: `
        uniform sampler2D uTexture;

         
        `, main: `
            outColor = texture(uTexture, vUV);
        `}
}, sm = new xe; class im extends Ur { constructor() { super(), this.filters = [new Yp({ sprite: new pt(F.EMPTY), inverse: !1, resolution: "inherit", antialias: "inherit" })] } get sprite() { return this.filters[0].sprite } set sprite(e) { this.filters[0].sprite = e } get inverse() { return this.filters[0].inverse } set inverse(e) { this.filters[0].inverse = e } } class Dh { constructor(e) { this._activeMaskStage = [], this._renderer = e } push(e, t, r) { const i = this._renderer; if (i.renderPipes.batch.break(r), r.add({ renderPipeId: "alphaMask", action: "pushMaskBegin", mask: e, inverse: t._maskOptions.inverse, canBundle: !1, maskedContainer: t }), e.inverse = t._maskOptions.inverse, e.renderMaskToTexture) { const n = e.mask; n.includeInBuild = !0, n.collectRenderables(r, i, null), n.includeInBuild = !1 } i.renderPipes.batch.break(r), r.add({ renderPipeId: "alphaMask", action: "pushMaskEnd", mask: e, maskedContainer: t, inverse: t._maskOptions.inverse, canBundle: !1 }) } pop(e, t, r) { this._renderer.renderPipes.batch.break(r), r.add({ renderPipeId: "alphaMask", action: "popMaskEnd", mask: e, inverse: t._maskOptions.inverse, canBundle: !1 }) } execute(e) { const t = this._renderer, r = e.mask.renderMaskToTexture; if (e.action === "pushMaskBegin") { const i = j.get(im); if (i.inverse = e.inverse, r) { e.mask.mask.measurable = !0; const n = _i(e.mask.mask, !0, sm); e.mask.mask.measurable = !1, n.ceil(); const a = t.renderTarget.renderTarget.colorTexture.source, o = _e.getOptimalTexture(n.width, n.height, a._resolution, a.antialias); t.renderTarget.push(o, !0), t.globalUniforms.push({ offset: n, worldColor: 4294967295 }); const h = i.sprite; h.texture = o, h.worldTransform.tx = n.minX, h.worldTransform.ty = n.minY, this._activeMaskStage.push({ filterEffect: i, maskedContainer: e.maskedContainer, filterTexture: o }) } else i.sprite = e.mask.mask, this._activeMaskStage.push({ filterEffect: i, maskedContainer: e.maskedContainer }) } else if (e.action === "pushMaskEnd") { const i = this._activeMaskStage[this._activeMaskStage.length - 1]; r && (t.type === De.WEBGL && t.renderTarget.finishRenderPass(), t.renderTarget.pop(), t.globalUniforms.pop()), t.filter.push({ renderPipeId: "filter", action: "pushFilter", container: i.maskedContainer, filterEffect: i.filterEffect, canBundle: !1 }) } else if (e.action === "popMaskEnd") { t.filter.pop(); const i = this._activeMaskStage.pop(); r && _e.returnTexture(i.filterTexture), j.return(i.filterEffect) } } destroy() { this._renderer = null, this._activeMaskStage = null } } Dh.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "alphaMask" }; class Oh { constructor(e) { this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = e } buildStart() { this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15 } push(e, t, r) { this._renderer.renderPipes.batch.break(r); const n = this._colorStack; n[this._colorStackIndex] = n[this._colorStackIndex - 1] & e.mask; const a = this._colorStack[this._colorStackIndex]; a !== this._currentColor && (this._currentColor = a, r.add({ renderPipeId: "colorMask", colorMask: a, canBundle: !1 })), this._colorStackIndex++ } pop(e, t, r) { this._renderer.renderPipes.batch.break(r); const n = this._colorStack; this._colorStackIndex--; const a = n[this._colorStackIndex - 1]; a !== this._currentColor && (this._currentColor = a, r.add({ renderPipeId: "colorMask", colorMask: a, canBundle: !1 })) } execute(e) { this._renderer.colorMask.setMask(e.colorMask) } destroy() { this._colorStack = null } } Oh.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "colorMask" }; class Lh { constructor(e) { this._maskStackHash = {}, this._maskHash = new WeakMap, this._renderer = e } push(e, t, r) { var i; const n = e, a = this._renderer; a.renderPipes.batch.break(r), a.renderPipes.blendMode.setBlendMode(n.mask, "none", r), r.add({ renderPipeId: "stencilMask", action: "pushMaskBegin", mask: e, inverse: t._maskOptions.inverse, canBundle: !1 }); const o = n.mask; o.includeInBuild = !0, this._maskHash.has(n) || this._maskHash.set(n, { instructionsStart: 0, instructionsLength: 0 }); const h = this._maskHash.get(n); h.instructionsStart = r.instructionSize, o.collectRenderables(r, a, null), o.includeInBuild = !1, a.renderPipes.batch.break(r), r.add({ renderPipeId: "stencilMask", action: "pushMaskEnd", mask: e, inverse: t._maskOptions.inverse, canBundle: !1 }); const l = r.instructionSize - h.instructionsStart - 1; h.instructionsLength = l; const c = a.renderTarget.renderTarget.uid; (i = this._maskStackHash)[c] ?? (i[c] = 0) } pop(e, t, r) { const i = e, n = this._renderer; n.renderPipes.batch.break(r), n.renderPipes.blendMode.setBlendMode(i.mask, "none", r), r.add({ renderPipeId: "stencilMask", action: "popMaskBegin", inverse: t._maskOptions.inverse, canBundle: !1 }); const a = this._maskHash.get(e); for (let o = 0; o < a.instructionsLength; o++)r.instructions[r.instructionSize++] = r.instructions[a.instructionsStart++]; r.add({ renderPipeId: "stencilMask", action: "popMaskEnd", canBundle: !1 }) } execute(e) { var t; const r = this._renderer, i = r.renderTarget.renderTarget.uid; let n = (t = this._maskStackHash)[i] ?? (t[i] = 0); e.action === "pushMaskBegin" ? (r.renderTarget.ensureDepthStencil(), r.stencil.setStencilMode(de.RENDERING_MASK_ADD, n), n++, r.colorMask.setMask(0)) : e.action === "pushMaskEnd" ? (e.inverse ? r.stencil.setStencilMode(de.INVERSE_MASK_ACTIVE, n) : r.stencil.setStencilMode(de.MASK_ACTIVE, n), r.colorMask.setMask(15)) : e.action === "popMaskBegin" ? (r.colorMask.setMask(0), n !== 0 ? r.stencil.setStencilMode(de.RENDERING_MASK_REMOVE, n) : (r.renderTarget.clear(null, Ae.STENCIL), r.stencil.setStencilMode(de.DISABLED, n)), n--) : e.action === "popMaskEnd" && (e.inverse ? r.stencil.setStencilMode(de.INVERSE_MASK_ACTIVE, n) : r.stencil.setStencilMode(de.MASK_ACTIVE, n), r.colorMask.setMask(15)), this._maskStackHash[i] = n } destroy() { this._renderer = null, this._maskStackHash = null, this._maskHash = null } } Lh.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "stencilMask" }; var Ir = (s => (s[s.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", s[s.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", s[s.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", s))(Ir || {}); class nm { constructor(e, t) { this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.type = t } } class Nh { constructor(e) { this._gpuBuffers = Object.create(null), this._boundBufferBases = Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers") } destroy() { this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null } contextChange() { const e = this._gl = this._renderer.gl; this._gpuBuffers = Object.create(null), this._maxBindings = e.MAX_UNIFORM_BUFFER_BINDINGS ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0 } getGlBuffer(e) { return this._gpuBuffers[e.uid] || this.createGLBuffer(e) } bind(e) { const { _gl: t } = this, r = this.getGlBuffer(e); t.bindBuffer(r.type, r.buffer) } bindBufferBase(e, t) { const { _gl: r } = this; this._boundBufferBases[t] !== e && (this._boundBufferBases[t] = e, e._lastBindBaseLocation = t, r.bindBufferBase(r.UNIFORM_BUFFER, t, e.buffer)) } nextBindBase(e) { this._bindCallId++, this._minBaseLocation = 0, e && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1)) } freeLocationForBufferBase(e) { let t = this.getLastBindBaseLocation(e); if (t >= this._minBaseLocation) return e._lastBindCallId = this._bindCallId, t; let r = 0, i = this._nextBindBaseIndex; for (; r < 2;) { i >= this._maxBindings && (i = this._minBaseLocation, r++); const n = this._boundBufferBases[i]; if (n && n._lastBindCallId === this._bindCallId) { i++; continue } break } return t = i, this._nextBindBaseIndex = i + 1, r >= 2 ? -1 : (e._lastBindCallId = this._bindCallId, this._boundBufferBases[t] = null, t) } getLastBindBaseLocation(e) { const t = e._lastBindBaseLocation; return this._boundBufferBases[t] === e ? t : -1 } bindBufferRange(e, t, r, i) { const { _gl: n } = this; r || (r = 0), t || (t = 0), this._boundBufferBases[t] = null, n.bindBufferRange(n.UNIFORM_BUFFER, t || 0, e.buffer, r * 256, i || 256) } updateBuffer(e) { const { _gl: t } = this, r = this.getGlBuffer(e); if (e._updateID === r.updateID) return r; r.updateID = e._updateID, t.bindBuffer(r.type, r.buffer); const i = e.data, n = e.descriptor.usage & Y.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW; return i ? r.byteLength >= i.byteLength ? t.bufferSubData(r.type, 0, i, 0, e._updateSize / i.BYTES_PER_ELEMENT) : (r.byteLength = i.byteLength, t.bufferData(r.type, i, n)) : (r.byteLength = e.descriptor.size, t.bufferData(r.type, r.byteLength, n)), r } destroyAll() { const e = this._gl; for (const t in this._gpuBuffers) e.deleteBuffer(this._gpuBuffers[t].buffer); this._gpuBuffers = Object.create(null) } onBufferDestroy(e, t) { const r = this._gpuBuffers[e.uid], i = this._gl; t || i.deleteBuffer(r.buffer), this._gpuBuffers[e.uid] = null } createGLBuffer(e) { const { _gl: t } = this; let r = Ir.ARRAY_BUFFER; e.descriptor.usage & Y.INDEX ? r = Ir.ELEMENT_ARRAY_BUFFER : e.descriptor.usage & Y.UNIFORM && (r = Ir.UNIFORM_BUFFER); const i = new nm(t.createBuffer(), r); return this._gpuBuffers[e.uid] = i, e.on("destroy", this.onBufferDestroy, this), i } resetState() { this._boundBufferBases = Object.create(null) } } Nh.extension = { type: [b.WebGLSystem], name: "buffer" }; const ji = class Hh { constructor(e) { this.supports = { uint32Indices: !0, uniformBufferObject: !0, vertexArrayObject: !0, srgbTextures: !0, nonPowOf2wrapping: !0, msaa: !0, nonPowOf2mipmaps: !0 }, this._renderer = e, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this) } get isLost() { return !this.gl || this.gl.isContextLost() } contextChange(e) { this.gl = e, this._renderer.gl = e } init(e) { e = { ...Hh.defaultOptions, ...e }; let t = this.multiView = e.multiView; if (e.context && t && (H("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), t = !1), t ? this.canvas = K.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, e.context) this.initFromContext(e.context); else { const r = this._renderer.background.alpha < 1, i = e.premultipliedAlpha ?? !0, n = e.antialias && !this._renderer.backBuffer.useBackBuffer; this.createContext(e.preferWebGLVersion, { alpha: r, premultipliedAlpha: i, antialias: n, stencil: !0, preserveDrawingBuffer: e.preserveDrawingBuffer, powerPreference: e.powerPreference ?? "default" }) } } ensureCanvasSize(e) { if (!this.multiView) { e !== this.canvas && H("multiView is disabled, but targetCanvas is not the main canvas"); return } const { canvas: t } = this; (t.width < e.width || t.height < e.height) && (t.width = Math.max(e.width, e.width), t.height = Math.max(e.height, e.height)) } initFromContext(e) { this.gl = e, this.webGLVersion = e instanceof K.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(e), this._renderer.runners.contextChange.emit(e); const t = this._renderer.view.canvas; t.addEventListener("webglcontextlost", this.handleContextLost, !1), t.addEventListener("webglcontextrestored", this.handleContextRestored, !1) } createContext(e, t) { let r; const i = this.canvas; if (e === 2 && (r = i.getContext("webgl2", t)), !r && (r = i.getContext("webgl", t), !r)) throw new Error("This browser does not support WebGL. Try using the canvas renderer"); this.gl = r, this.initFromContext(this.gl) } getExtensions() { const { gl: e } = this, t = { anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: e.getExtension("OES_texture_float_linear"), s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: e.getExtension("WEBGL_compressed_texture_etc"), etc1: e.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: e.getExtension("WEBGL_compressed_texture_atc"), astc: e.getExtension("WEBGL_compressed_texture_astc"), bptc: e.getExtension("EXT_texture_compression_bptc"), rgtc: e.getExtension("EXT_texture_compression_rgtc"), loseContext: e.getExtension("WEBGL_lose_context") }; if (this.webGLVersion === 1) this.extensions = { ...t, drawBuffers: e.getExtension("WEBGL_draw_buffers"), depthTexture: e.getExtension("WEBGL_depth_texture"), vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: e.getExtension("OES_element_index_uint"), floatTexture: e.getExtension("OES_texture_float"), floatTextureLinear: e.getExtension("OES_texture_float_linear"), textureHalfFloat: e.getExtension("OES_texture_half_float"), textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"), vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"), srgb: e.getExtension("EXT_sRGB") }; else { this.extensions = { ...t, colorBufferFloat: e.getExtension("EXT_color_buffer_float") }; const r = e.getExtension("WEBGL_provoking_vertex"); r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL) } } handleContextLost(e) { e.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(() => { var t; this.gl.isContextLost() && ((t = this.extensions.loseContext) == null || t.restoreContext()) }, 0)) } handleContextRestored() { this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl) } destroy() { var t; const e = this._renderer.view.canvas; this._renderer = null, e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), (t = this.extensions.loseContext) == null || t.loseContext() } forceContextLoss() { var e; (e = this.extensions.loseContext) == null || e.loseContext(), this._contextLossForced = !0 } validateContext(e) { const t = e.getContextAttributes(); t && !t.stencil && H("Provided WebGL context does not have a stencil buffer, masks may not render correctly"); const r = this.supports, i = this.webGLVersion === 2, n = this.extensions; r.uint32Indices = i || !!n.uint32ElementIndex, r.uniformBufferObject = i, r.vertexArrayObject = i || !!n.vertexArrayObject, r.srgbTextures = i || !!n.srgb, r.nonPowOf2wrapping = i, r.nonPowOf2mipmaps = i, r.msaa = i, r.uint32Indices || H("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly") } }; ji.extension = { type: [b.WebGLSystem], name: "context" }; ji.defaultOptions = { context: null, premultipliedAlpha: !0, preserveDrawingBuffer: !1, powerPreference: void 0, preferWebGLVersion: 2, multiView: !1 }; let am = ji; function zh(s, e) { for (const t in s.attributes) { const r = s.attributes[t], i = e[t]; i ? (r.format ?? (r.format = i.format), r.offset ?? (r.offset = i.offset), r.instance ?? (r.instance = i.instance)) : H(`Attribute ${t} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`) } om(s) } function om(s) { const { buffers: e, attributes: t } = s, r = {}, i = {}; for (const n in e) { const a = e[n]; r[a.uid] = 0, i[a.uid] = 0 } for (const n in t) { const a = t[n]; r[a.buffer.uid] += rt(a.format).stride } for (const n in t) { const a = t[n]; a.stride ?? (a.stride = r[a.buffer.uid]), a.start ?? (a.start = i[a.buffer.uid]), i[a.buffer.uid] += rt(a.format).stride } } var oi = (s => (s[s.RGBA = 6408] = "RGBA", s[s.RGB = 6407] = "RGB", s[s.RG = 33319] = "RG", s[s.RED = 6403] = "RED", s[s.RGBA_INTEGER = 36249] = "RGBA_INTEGER", s[s.RGB_INTEGER = 36248] = "RGB_INTEGER", s[s.RG_INTEGER = 33320] = "RG_INTEGER", s[s.RED_INTEGER = 36244] = "RED_INTEGER", s[s.ALPHA = 6406] = "ALPHA", s[s.LUMINANCE = 6409] = "LUMINANCE", s[s.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", s[s.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", s[s.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", s))(oi || {}), Wh = (s => (s[s.TEXTURE_2D = 3553] = "TEXTURE_2D", s[s.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", s[s.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", s[s.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", s[s.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", s[s.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", s[s.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", s[s.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", s[s.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", s))(Wh || {}), J = (s => (s[s.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", s[s.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", s[s.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", s[s.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", s[s.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", s[s.UNSIGNED_INT = 5125] = "UNSIGNED_INT", s[s.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", s[s.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", s[s.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", s[s.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", s[s.BYTE = 5120] = "BYTE", s[s.SHORT = 5122] = "SHORT", s[s.INT = 5124] = "INT", s[s.FLOAT = 5126] = "FLOAT", s[s.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", s[s.HALF_FLOAT = 36193] = "HALF_FLOAT", s))(J || {}); const Ga = { uint8x2: J.UNSIGNED_BYTE, uint8x4: J.UNSIGNED_BYTE, sint8x2: J.BYTE, sint8x4: J.BYTE, unorm8x2: J.UNSIGNED_BYTE, unorm8x4: J.UNSIGNED_BYTE, snorm8x2: J.BYTE, snorm8x4: J.BYTE, uint16x2: J.UNSIGNED_SHORT, uint16x4: J.UNSIGNED_SHORT, sint16x2: J.SHORT, sint16x4: J.SHORT, unorm16x2: J.UNSIGNED_SHORT, unorm16x4: J.UNSIGNED_SHORT, snorm16x2: J.SHORT, snorm16x4: J.SHORT, float16x2: J.HALF_FLOAT, float16x4: J.HALF_FLOAT, float32: J.FLOAT, float32x2: J.FLOAT, float32x3: J.FLOAT, float32x4: J.FLOAT, uint32: J.UNSIGNED_INT, uint32x2: J.UNSIGNED_INT, uint32x3: J.UNSIGNED_INT, uint32x4: J.UNSIGNED_INT, sint32: J.INT, sint32x2: J.INT, sint32x3: J.INT, sint32x4: J.INT }; function hm(s) { return Ga[s] ?? Ga.float32 } const lm = { "point-list": 0, "line-list": 1, "line-strip": 3, "triangle-list": 4, "triangle-strip": 5 }; class Vh { constructor(e) { this._geometryVaoHash = Object.create(null), this._renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash") } contextChange() { const e = this.gl = this._renderer.gl; if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device"); const t = this._renderer.context.extensions.vertexArrayObject; t && (e.createVertexArray = () => t.createVertexArrayOES(), e.bindVertexArray = i => t.bindVertexArrayOES(i), e.deleteVertexArray = i => t.deleteVertexArrayOES(i)); const r = this._renderer.context.extensions.vertexAttribDivisorANGLE; r && (e.drawArraysInstanced = (i, n, a, o) => { r.drawArraysInstancedANGLE(i, n, a, o) }, e.drawElementsInstanced = (i, n, a, o, h) => { r.drawElementsInstancedANGLE(i, n, a, o, h) }, e.vertexAttribDivisor = (i, n) => r.vertexAttribDivisorANGLE(i, n)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = Object.create(null) } bind(e, t) { const r = this.gl; this._activeGeometry = e; const i = this.getVao(e, t); this._activeVao !== i && (this._activeVao = i, r.bindVertexArray(i)), this.updateBuffers() } resetState() { this.unbind() } updateBuffers() { const e = this._activeGeometry, t = this._renderer.buffer; for (let r = 0; r < e.buffers.length; r++) { const i = e.buffers[r]; t.updateBuffer(i) } } checkCompatibility(e, t) { const r = e.attributes, i = t._attributeData; for (const n in i) if (!r[n]) throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`) } getSignature(e, t) { const r = e.attributes, i = t._attributeData, n = ["g", e.uid]; for (const a in r) i[a] && n.push(a, i[a].location); return n.join("-") } getVao(e, t) { var r; return ((r = this._geometryVaoHash[e.uid]) == null ? void 0 : r[t._key]) || this.initGeometryVao(e, t) } initGeometryVao(e, t, r = !0) { const i = this._renderer.gl, n = this._renderer.buffer; this._renderer.shader._getProgramData(t), this.checkCompatibility(e, t); const a = this.getSignature(e, t); this._geometryVaoHash[e.uid] || (this._geometryVaoHash[e.uid] = Object.create(null), e.on("destroy", this.onGeometryDestroy, this)); const o = this._geometryVaoHash[e.uid]; let h = o[a]; if (h) return o[t._key] = h, h; zh(e, t._attributeData); const l = e.buffers; h = i.createVertexArray(), i.bindVertexArray(h); for (let c = 0; c < l.length; c++) { const u = l[c]; n.bind(u) } return this.activateVao(e, t), o[t._key] = h, o[a] = h, i.bindVertexArray(null), h } onGeometryDestroy(e, t) { const r = this._geometryVaoHash[e.uid], i = this.gl; if (r) { if (t) for (const n in r) this._activeVao !== r[n] && this.unbind(), i.deleteVertexArray(r[n]); this._geometryVaoHash[e.uid] = null } } destroyAll(e = !1) { const t = this.gl; for (const r in this._geometryVaoHash) { if (e) for (const i in this._geometryVaoHash[r]) { const n = this._geometryVaoHash[r]; this._activeVao !== n && this.unbind(), t.deleteVertexArray(n[i]) } this._geometryVaoHash[r] = null } } activateVao(e, t) { var o; const r = this._renderer.gl, i = this._renderer.buffer, n = e.attributes; e.indexBuffer && i.bind(e.indexBuffer); let a = null; for (const h in n) { const l = n[h], c = l.buffer, u = i.getGlBuffer(c), d = t._attributeData[h]; if (d) { a !== u && (i.bind(c), a = u); const f = d.location; r.enableVertexAttribArray(f); const p = rt(l.format), g = hm(l.format); if (((o = d.format) == null ? void 0 : o.substring(1, 4)) === "int" ? r.vertexAttribIPointer(f, p.size, g, l.stride, l.offset) : r.vertexAttribPointer(f, p.size, g, p.normalised, l.stride, l.offset), l.instance) if (this.hasInstance) { const m = l.divisor ?? 1; r.vertexAttribDivisor(f, m) } else throw new Error("geometry error, GPU Instancing is not supported on this device") } } } draw(e, t, r, i) { const { gl: n } = this._renderer, a = this._activeGeometry, o = lm[e || a.topology]; if (i ?? (i = a.instanceCount), a.indexBuffer) { const h = a.indexBuffer.data.BYTES_PER_ELEMENT, l = h === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT; i > 1 ? n.drawElementsInstanced(o, t || a.indexBuffer.data.length, l, (r || 0) * h, i) : n.drawElements(o, t || a.indexBuffer.data.length, l, (r || 0) * h) } else i > 1 ? n.drawArraysInstanced(o, r || 0, t || a.getSize(), i) : n.drawArrays(o, r || 0, t || a.getSize()); return this } unbind() { this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null } destroy() { this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null } } Vh.extension = { type: [b.WebGLSystem], name: "geometry" }; const cm = new ir({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } }), Yi = class $h {
  constructor(e) { this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = e } init(e = {}) {
    const { useBackBuffer: t, antialias: r } = { ...$h.defaultOptions, ...e }; this.useBackBuffer = t, this._antialias = r, this._renderer.context.supports.msaa || (H("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = Oe.for2d(); const i = new kt({
      vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`, fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`, name: "big-triangle"
    }); this._bigTriangleShader = new ke({ glProgram: i, resources: { uTexture: F.WHITE.source } })
  } renderStart(e) { const t = this._renderer.renderTarget.getRenderTarget(e.target); if (this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot, this._useBackBufferThisRender) { const r = this._renderer.renderTarget.getRenderTarget(e.target); this._targetTexture = r.colorTexture, e.target = this._getBackBufferTexture(r.colorTexture) } } renderEnd() { this._presentBackBuffer() } _presentBackBuffer() { const e = this._renderer; e.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (e.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, e.encoder.draw({ geometry: cm, shader: this._bigTriangleShader, state: this._state })) } _getBackBufferTexture(e) { return this._backBufferTexture = this._backBufferTexture || new F({ source: new ge({ width: e.width, height: e.height, resolution: e._resolution, antialias: this._antialias }) }), this._backBufferTexture.source.resize(e.width, e.height, e._resolution), this._backBufferTexture } destroy() { this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null) }
}; Yi.extension = { type: [b.WebGLSystem], name: "backBuffer", priority: 1 }; Yi.defaultOptions = { useBackBuffer: !1 }; let um = Yi; class Xh { constructor(e) { this._colorMaskCache = 15, this._renderer = e } setMask(e) { this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1))) } } Xh.extension = { type: [b.WebGLSystem], name: "colorMask" }; class jh { constructor(e) { this.commandFinished = Promise.resolve(), this._renderer = e } setGeometry(e, t) { this._renderer.geometry.bind(e, t.glProgram) } finishRenderPass() { } draw(e) { const t = this._renderer, { geometry: r, shader: i, state: n, skipSync: a, topology: o, size: h, start: l, instanceCount: c } = e; t.shader.bind(i, a), t.geometry.bind(r, t.shader._activeProgram), n && t.state.set(n), t.geometry.draw(o, h, l, c ?? r.instanceCount) } destroy() { this._renderer = null } } jh.extension = { type: [b.WebGLSystem], name: "encoder" }; class dm { constructor() { this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = [] } } const at = []; at[de.NONE] = void 0; at[de.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }; at[de.RENDERING_MASK_ADD] = { stencilFront: { compare: "equal", passOp: "increment-clamp" }, stencilBack: { compare: "equal", passOp: "increment-clamp" } }; at[de.RENDERING_MASK_REMOVE] = { stencilFront: { compare: "equal", passOp: "decrement-clamp" }, stencilBack: { compare: "equal", passOp: "decrement-clamp" } }; at[de.MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "equal", passOp: "keep" }, stencilBack: { compare: "equal", passOp: "keep" } }; at[de.INVERSE_MASK_ACTIVE] = { stencilWriteMask: 0, stencilFront: { compare: "not-equal", passOp: "replace" }, stencilBack: { compare: "not-equal", passOp: "replace" } }; class Yh { constructor(e) { this._stencilCache = { enabled: !1, stencilReference: 0, stencilMode: de.NONE }, this._renderTargetStencilState = Object.create(null), e.renderTarget.onRenderTargetChange.add(this) } contextChange(e) { this._gl = e, this._comparisonFuncMapping = { always: e.ALWAYS, never: e.NEVER, equal: e.EQUAL, "not-equal": e.NOTEQUAL, less: e.LESS, "less-equal": e.LEQUAL, greater: e.GREATER, "greater-equal": e.GEQUAL }, this._stencilOpsMapping = { keep: e.KEEP, zero: e.ZERO, replace: e.REPLACE, invert: e.INVERT, "increment-clamp": e.INCR, "decrement-clamp": e.DECR, "increment-wrap": e.INCR_WRAP, "decrement-wrap": e.DECR_WRAP }, this.resetState() } onRenderTargetChange(e) { if (this._activeRenderTarget === e) return; this._activeRenderTarget = e; let t = this._renderTargetStencilState[e.uid]; t || (t = this._renderTargetStencilState[e.uid] = { stencilMode: de.DISABLED, stencilReference: 0 }), this.setStencilMode(t.stencilMode, t.stencilReference) } resetState() { this._stencilCache.enabled = !1, this._stencilCache.stencilMode = de.NONE, this._stencilCache.stencilReference = 0 } setStencilMode(e, t) { const r = this._renderTargetStencilState[this._activeRenderTarget.uid], i = this._gl, n = at[e], a = this._stencilCache; if (r.stencilMode = e, r.stencilReference = t, e === de.DISABLED) { this._stencilCache.enabled && (this._stencilCache.enabled = !1, i.disable(i.STENCIL_TEST)); return } this._stencilCache.enabled || (this._stencilCache.enabled = !0, i.enable(i.STENCIL_TEST)), (e !== a.stencilMode || a.stencilReference !== t) && (a.stencilMode = e, a.stencilReference = t, i.stencilFunc(this._comparisonFuncMapping[n.stencilBack.compare], t, 255), i.stencilOp(i.KEEP, i.KEEP, this._stencilOpsMapping[n.stencilBack.passOp])) } } Yh.extension = { type: [b.WebGLSystem], name: "stencil" }; class Kh { constructor(e) { this._syncFunctionHash = Object.create(null), this._adaptor = e, this._systemCheck() } _systemCheck() { if (!Lo()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.") } ensureUniformGroup(e) { const t = this.getUniformGroupData(e); e.buffer || (e.buffer = new Ee({ data: new Float32Array(t.layout.size / 4), usage: Y.UNIFORM | Y.COPY_DST })) } getUniformGroupData(e) { return this._syncFunctionHash[e._signature] || this._initUniformGroup(e) } _initUniformGroup(e) { const t = e._signature; let r = this._syncFunctionHash[t]; if (!r) { const i = Object.keys(e.uniformStructures).map(o => e.uniformStructures[o]), n = this._adaptor.createUboElements(i), a = this._generateUboSync(n.uboElements); r = this._syncFunctionHash[t] = { layout: n, syncFunction: a } } return this._syncFunctionHash[t] } _generateUboSync(e) { return this._adaptor.generateUboSync(e) } syncUniformGroup(e, t, r) { const i = this.getUniformGroupData(e); e.buffer || (e.buffer = new Ee({ data: new Float32Array(i.layout.size / 4), usage: Y.UNIFORM | Y.COPY_DST })); let n = null; return t || (t = e.buffer.data, n = e.buffer.dataInt32), r || (r = 0), i.syncFunction(e.uniforms, t, n, r), !0 } updateUniformGroup(e) { if (e.isStatic && !e._dirtyId) return !1; e._dirtyId = 0; const t = this.syncUniformGroup(e); return e.buffer.update(), t } destroy() { this._syncFunctionHash = null } } const qh = { f32: 4, i32: 4, "vec2<f32>": 8, "vec3<f32>": 12, "vec4<f32>": 16, "vec2<i32>": 8, "vec3<i32>": 12, "vec4<i32>": 16, "mat2x2<f32>": 16 * 2, "mat3x3<f32>": 16 * 3, "mat4x4<f32>": 16 * 4 }; function fm(s) { const e = s.map(n => ({ data: n, offset: 0, size: 0 })), t = 16; let r = 0, i = 0; for (let n = 0; n < e.length; n++) { const a = e[n]; if (r = qh[a.data.type], !r) throw new Error(`Unknown type ${a.data.type}`); a.data.size > 1 && (r = Math.max(r, t) * a.data.size); const o = r === 12 ? 16 : r; a.size = r; const h = i % t; h > 0 && t - h < o ? i += (t - h) % 16 : i += (r - h % r) % r, a.offset = i, i += r } return i = Math.ceil(i / 16) * 16, { uboElements: e, size: i } } const ft = [{
  type: "mat3x3<f32>", test: s => s.value.a !== void 0, ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `, uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `}, {
  type: "vec4<f32>", test: s => s.type === "vec4<f32>" && s.size === 1 && s.value.width !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `}, {
  type: "vec2<f32>", test: s => s.type === "vec2<f32>" && s.size === 1 && s.value.x !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `}, {
  type: "vec4<f32>", test: s => s.type === "vec4<f32>" && s.size === 1 && s.value.red !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `}, {
  type: "vec3<f32>", test: s => s.type === "vec3<f32>" && s.size === 1 && s.value.red !== void 0, ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `, uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `}]; function Zh(s, e, t, r) {
  const i = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `]; let n = 0; for (let o = 0; o < s.length; o++) {
    const h = s[o], l = h.data.name; let c = !1, u = 0; for (let d = 0; d < ft.length; d++)if (ft[d].test(h.data)) { u = h.offset / 4, i.push(`name = "${l}";`, `offset += ${u - n};`, ft[d][e] || ft[d].ubo), c = !0; break } if (!c) if (h.data.size > 1) u = h.offset / 4, i.push(t(h, u - n)); else {
      const d = r[h.data.type]; u = h.offset / 4, i.push(`
                    v = uv.${l};
                    offset += ${u - n};
                    ${d};
                `)
    } n = u
  } const a = i.join(`
`); return new Function("uv", "data", "dataInt32", "offset", a)
} function bt(s, e) {
  return `
        for (let i = 0; i < ${s * e}; i++) {
            data[offset + (((i / ${s})|0) * 4) + (i % ${s})] = v[i];
        }
    `} const Qh = {
  f32: `
        data[offset] = v;`, i32: `
        dataInt32[offset] = v;`, "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`, "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`, "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`, "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`, "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`, "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`, "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`, "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`, "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`, "mat3x2<f32>": bt(3, 2), "mat4x2<f32>": bt(4, 2), "mat2x3<f32>": bt(2, 3), "mat4x3<f32>": bt(4, 3), "mat2x4<f32>": bt(2, 4), "mat3x4<f32>": bt(3, 4)
}, pm = {
  ...Qh, "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `}; function mm(s, e) {
  const t = Math.max(qh[s.data.type] / 16, 1), r = s.data.value.length / s.data.size, i = (4 - r % 4) % 4, n = s.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"; return `
        v = uv.${s.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${s.data.size * t}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                ${n}[arrayOffset++] = v[t++];
            }
            ${i !== 0 ? `arrayOffset += ${i};` : ""}
        }
    `} function gm(s) { return Zh(s, "uboStd40", mm, Qh) } class Jh extends Kh { constructor() { super({ createUboElements: fm, generateUboSync: gm }) } } Jh.extension = { type: [b.WebGLSystem], name: "ubo" }; class _m { constructor() { this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new ne } init(e, t) { this._renderer = e, this._renderTargetSystem = t, e.runners.contextChange.add(this) } contextChange() { this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new ne } copyToTexture(e, t, r, i, n) { const a = this._renderTargetSystem, o = this._renderer, h = a.getGpuRenderTarget(e), l = o.gl; return this.finishRenderPass(e), l.bindFramebuffer(l.FRAMEBUFFER, h.resolveTargetFramebuffer), o.texture.bind(t, 0), l.copyTexSubImage2D(l.TEXTURE_2D, 0, n.x, n.y, r.x, r.y, i.width, i.height), t } startRenderPass(e, t = !0, r, i) { const n = this._renderTargetSystem, a = e.colorTexture, o = n.getGpuRenderTarget(e); let h = i.y; e.isRoot && (h = a.pixelHeight - i.height), e.colorTextures.forEach(u => { this._renderer.texture.unbind(u) }); const l = this._renderer.gl; l.bindFramebuffer(l.FRAMEBUFFER, o.framebuffer); const c = this._viewPortCache; (c.x !== i.x || c.y !== h || c.width !== i.width || c.height !== i.height) && (c.x = i.x, c.y = h, c.width = i.width, c.height = i.height, l.viewport(i.x, h, i.width, i.height)), !o.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(o), this.clear(e, t, r) } finishRenderPass(e) { const r = this._renderTargetSystem.getGpuRenderTarget(e); if (!r.msaa) return; const i = this._renderer.gl; i.bindFramebuffer(i.FRAMEBUFFER, r.resolveTargetFramebuffer), i.bindFramebuffer(i.READ_FRAMEBUFFER, r.framebuffer), i.blitFramebuffer(0, 0, r.width, r.height, 0, 0, r.width, r.height, i.COLOR_BUFFER_BIT, i.NEAREST), i.bindFramebuffer(i.FRAMEBUFFER, r.framebuffer) } initGpuRenderTarget(e) { const r = this._renderer.gl, i = new dm, n = e.colorTexture; return Ke.test(n.resource) ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource), i.framebuffer = null, i) : (this._initColor(e, i), r.bindFramebuffer(r.FRAMEBUFFER, null), i) } destroyGpuRenderTarget(e) { const t = this._renderer.gl; e.framebuffer && (t.deleteFramebuffer(e.framebuffer), e.framebuffer = null), e.resolveTargetFramebuffer && (t.deleteFramebuffer(e.resolveTargetFramebuffer), e.resolveTargetFramebuffer = null), e.depthStencilRenderBuffer && (t.deleteRenderbuffer(e.depthStencilRenderBuffer), e.depthStencilRenderBuffer = null), e.msaaRenderBuffer.forEach(r => { t.deleteRenderbuffer(r) }), e.msaaRenderBuffer = null } clear(e, t, r) { if (!t) return; const i = this._renderTargetSystem; typeof t == "boolean" && (t = t ? Ae.ALL : Ae.NONE); const n = this._renderer.gl; if (t & Ae.COLOR) { r ?? (r = i.defaultClearColor); const a = this._clearColorCache, o = r; (a[0] !== o[0] || a[1] !== o[1] || a[2] !== o[2] || a[3] !== o[3]) && (a[0] = o[0], a[1] = o[1], a[2] = o[2], a[3] = o[3], n.clearColor(o[0], o[1], o[2], o[3])) } n.clear(t) } resizeGpuRenderTarget(e) { if (e.isRoot) return; const r = this._renderTargetSystem.getGpuRenderTarget(e); this._resizeColor(e, r), (e.stencil || e.depth) && this._resizeStencil(r) } _initColor(e, t) { const r = this._renderer, i = r.gl, n = i.createFramebuffer(); if (t.resolveTargetFramebuffer = n, i.bindFramebuffer(i.FRAMEBUFFER, n), t.width = e.colorTexture.source.pixelWidth, t.height = e.colorTexture.source.pixelHeight, e.colorTextures.forEach((a, o) => { const h = a.source; h.antialias && (r.context.supports.msaa ? t.msaa = !0 : H("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), r.texture.bindSource(h, 0); const c = r.texture.getGlSource(h).texture; i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + o, 3553, c, 0) }), t.msaa) { const a = i.createFramebuffer(); t.framebuffer = a, i.bindFramebuffer(i.FRAMEBUFFER, a), e.colorTextures.forEach((o, h) => { const l = i.createRenderbuffer(); t.msaaRenderBuffer[h] = l }) } else t.framebuffer = n; this._resizeColor(e, t) } _resizeColor(e, t) { const r = e.colorTexture.source; if (t.width = r.pixelWidth, t.height = r.pixelHeight, e.colorTextures.forEach((i, n) => { n !== 0 && i.source.resize(r.width, r.height, r._resolution) }), t.msaa) { const i = this._renderer, n = i.gl, a = t.framebuffer; n.bindFramebuffer(n.FRAMEBUFFER, a), e.colorTextures.forEach((o, h) => { const l = o.source; i.texture.bindSource(l, 0); const u = i.texture.getGlSource(l).internalFormat, d = t.msaaRenderBuffer[h]; n.bindRenderbuffer(n.RENDERBUFFER, d), n.renderbufferStorageMultisample(n.RENDERBUFFER, 4, u, l.pixelWidth, l.pixelHeight), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + h, n.RENDERBUFFER, d) }) } } _initStencil(e) { if (e.framebuffer === null) return; const t = this._renderer.gl, r = t.createRenderbuffer(); e.depthStencilRenderBuffer = r, t.bindRenderbuffer(t.RENDERBUFFER, r), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, r), this._resizeStencil(e) } _resizeStencil(e) { const t = this._renderer.gl; t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer), e.msaa ? t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? t.DEPTH24_STENCIL8 : t.DEPTH_STENCIL, e.width, e.height) } prerender(e) { const t = e.colorTexture.resource; this._renderer.context.multiView && Ke.test(t) && this._renderer.context.ensureCanvasSize(t) } postrender(e) { if (this._renderer.context.multiView && Ke.test(e.colorTexture.resource)) { const t = this._renderer.context.canvas, r = e.colorTexture; r.context2D.drawImage(t, 0, r.pixelHeight - t.height) } } } function xm(s, e, t, r, i, n) { const a = n ? 1 : -1; return s.identity(), s.a = 1 / r * 2, s.d = a * (1 / i * 2), s.tx = -1 - e * s.a, s.ty = -a - t * s.d, s } const Ht = new Map; function el(s, e) { if (!Ht.has(s)) { const t = new F({ source: new Ke({ resource: s, ...e }) }), r = () => { Ht.get(s) === t && Ht.delete(s) }; t.once("destroy", r), t.source.once("destroy", r), Ht.set(s, t) } return Ht.get(s) } function ym(s) { const e = s.colorTexture.source.resource; return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e) } const tl = class rl { constructor(e = {}) { if (this.uid = he("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, e = { ...rl.defaultOptions, ...e }, this.stencil = e.stencil, this.depth = e.depth, this.isRoot = e.isRoot, typeof e.colorTextures == "number") { this._managedColorTextures = !0; for (let t = 0; t < e.colorTextures; t++)this.colorTextures.push(new ge({ width: e.width, height: e.height, resolution: e.resolution, antialias: e.antialias })) } else { this.colorTextures = [...e.colorTextures.map(r => r.source)]; const t = this.colorTexture.source; this.resize(t.width, t.height, t._resolution) } this.colorTexture.source.on("resize", this.onSourceResize, this), (e.depthStencilTexture || this.stencil) && (e.depthStencilTexture instanceof F || e.depthStencilTexture instanceof ge ? this.depthStencilTexture = e.depthStencilTexture.source : this.ensureDepthStencilTexture()) } get size() { const e = this._size; return e[0] = this.pixelWidth, e[1] = this.pixelHeight, e } get width() { return this.colorTexture.source.width } get height() { return this.colorTexture.source.height } get pixelWidth() { return this.colorTexture.source.pixelWidth } get pixelHeight() { return this.colorTexture.source.pixelHeight } get resolution() { return this.colorTexture.source._resolution } get colorTexture() { return this.colorTextures[0] } onSourceResize(e) { this.resize(e.width, e.height, e._resolution, !0) } ensureDepthStencilTexture() { this.depthStencilTexture || (this.depthStencilTexture = new ge({ width: this.width, height: this.height, resolution: this.resolution, format: "depth24plus-stencil8", autoGenerateMipmaps: !1, antialias: !1, mipLevelCount: 1 })) } resize(e, t, r = this.resolution, i = !1) { this.dirtyId++, this.colorTextures.forEach((n, a) => { i && a === 0 || n.source.resize(e, t, r) }), this.depthStencilTexture && this.depthStencilTexture.source.resize(e, t, r) } destroy() { this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach(e => { e.destroy() }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture) } }; tl.defaultOptions = { width: 0, height: 0, resolution: 1, colorTextures: 1, stencil: !1, depth: !1, antialias: !1, isRoot: !1 }; let hi = tl; class sl { constructor(e) { this.rootViewPort = new ne, this.viewport = new ne, this.onRenderTargetChange = new No("onRenderTargetChange"), this.projectionMatrix = new D, this.defaultClearColor = [0, 0, 0, 0], this._renderSurfaceToRenderTargetHash = new Map, this._gpuRenderTargetHash = Object.create(null), this._renderTargetStack = [], this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash") } finishRenderPass() { this.adaptor.finishRenderPass(this.renderTarget) } renderStart({ target: e, clear: t, clearColor: r, frame: i }) { var n, a; this._renderTargetStack.length = 0, this.push(e, t, r, i), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = ym(this.rootRenderTarget), (a = (n = this.adaptor).prerender) == null || a.call(n, this.rootRenderTarget) } postrender() { var e, t; (t = (e = this.adaptor).postrender) == null || t.call(e, this.rootRenderTarget) } bind(e, t = !0, r, i) { const n = this.getRenderTarget(e), a = this.renderTarget !== n; this.renderTarget = n, this.renderSurface = e; const o = this.getGpuRenderTarget(n); (n.pixelWidth !== o.width || n.pixelHeight !== o.height) && (this.adaptor.resizeGpuRenderTarget(n), o.width = n.pixelWidth, o.height = n.pixelHeight); const h = n.colorTexture, l = this.viewport, c = h.pixelWidth, u = h.pixelHeight; if (!i && e instanceof F && (i = e.frame), i) { const d = h._resolution; l.x = i.x * d + .5 | 0, l.y = i.y * d + .5 | 0, l.width = i.width * d + .5 | 0, l.height = i.height * d + .5 | 0 } else l.x = 0, l.y = 0, l.width = c, l.height = u; return xm(this.projectionMatrix, 0, 0, l.width / h.resolution, l.height / h.resolution, !n.isRoot), this.adaptor.startRenderPass(n, t, r, l), a && this.onRenderTargetChange.emit(n), n } clear(e, t = Ae.ALL, r) { t && (e && (e = this.getRenderTarget(e)), this.adaptor.clear(e || this.renderTarget, t, r, this.viewport)) } contextChange() { this._gpuRenderTargetHash = Object.create(null) } push(e, t = Ae.ALL, r, i) { const n = this.bind(e, t, r, i); return this._renderTargetStack.push({ renderTarget: n, frame: i }), n } pop() { this._renderTargetStack.pop(); const e = this._renderTargetStack[this._renderTargetStack.length - 1]; this.bind(e.renderTarget, !1, null, e.frame) } getRenderTarget(e) { return e.isTexture && (e = e.source), this._renderSurfaceToRenderTargetHash.get(e) ?? this._initRenderTarget(e) } copyToTexture(e, t, r, i, n) { r.x < 0 && (i.width += r.x, n.x -= r.x, r.x = 0), r.y < 0 && (i.height += r.y, n.y -= r.y, r.y = 0); const { pixelWidth: a, pixelHeight: o } = e; return i.width = Math.min(i.width, a - r.x), i.height = Math.min(i.height, o - r.y), this.adaptor.copyToTexture(e, t, r, i, n) } ensureDepthStencil() { this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport)) } destroy() { this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((e, t) => { e !== t && e.destroy() }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = Object.create(null) } _initRenderTarget(e) { let t = null; return Ke.test(e) && (e = el(e).source), e instanceof hi ? t = e : e instanceof ge && (t = new hi({ colorTextures: [e] }), Ke.test(e.source.resource) && (t.isRoot = !0), e.once("destroy", () => { t.destroy(), this._renderSurfaceToRenderTargetHash.delete(e); const r = this._gpuRenderTargetHash[t.uid]; r && (this._gpuRenderTargetHash[t.uid] = null, this.adaptor.destroyGpuRenderTarget(r)) })), this._renderSurfaceToRenderTargetHash.set(e, t), t } getGpuRenderTarget(e) { return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e)) } resetState() { this.renderTarget = null, this.renderSurface = null } } class il extends sl { constructor(e) { super(e), this.adaptor = new _m, this.adaptor.init(e, this) } } il.extension = { type: [b.WebGLSystem], name: "renderTarget" }; class Ki extends Ce { constructor({ buffer: e, offset: t, size: r }) { super(), this.uid = he("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = he("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = e, this.offset = t | 0, this.size = r, this.buffer.on("change", this.onBufferChange, this) } onBufferChange() { this._resourceId = he("resource"), this.emit("change", this) } destroy(e = !1) { this.destroyed = !0, e && this.buffer.destroy(), this.emit("change", this), this.buffer = null } } function bm(s, e) {
  const t = [], r = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `]; let i = !1, n = 0; const a = e._getProgramData(s.glProgram); for (const h in s.groups) {
    const l = s.groups[h]; t.push(`
            resources = g[${h}].resources;
        `); for (const c in l.resources) {
      const u = l.resources[c]; if (u instanceof be) if (u.ubo) {
        const d = s._uniformBindMap[h][Number(c)]; t.push(`
                        sS.bindUniformBlock(
                            resources[${c}],
                            '${d}',
                            ${s.glProgram._uniformBlockData[d].index}
                        );
                    `)
      } else t.push(`
                        ugS.updateUniformGroup(resources[${c}], p, sD);
                    `); else if (u instanceof Ki) {
        const d = s._uniformBindMap[h][Number(c)]; t.push(`
                    sS.bindUniformBlock(
                        resources[${c}],
                        '${d}',
                        ${s.glProgram._uniformBlockData[d].index}
                    );
                `)
      } else if (u instanceof ge) {
        const d = s._uniformBindMap[h][c], f = a.uniformData[d]; f && (i || (i = !0, r.push(`
                        var tS = r.texture;
                        `)), e._gl.uniform1i(f.location, n), t.push(`
                        tS.bind(resources[${c}], ${n});
                    `), n++)
      }
    }
  } const o = [...r, ...t].join(`
`); return new Function("r", "s", "sD", o)
} class vm { constructor(e, t) { this.program = e, this.uniformData = t, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {} } destroy() { this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null } } function Fa(s, e, t) { const r = s.createShader(e); return s.shaderSource(r, t), s.compileShader(r), r } function Is(s) { const e = new Array(s); for (let t = 0; t < e.length; t++)e[t] = !1; return e } function nl(s, e) { switch (s) { case "float": return 0; case "vec2": return new Float32Array(2 * e); case "vec3": return new Float32Array(3 * e); case "vec4": return new Float32Array(4 * e); case "int": case "uint": case "sampler2D": case "sampler2DArray": return 0; case "ivec2": return new Int32Array(2 * e); case "ivec3": return new Int32Array(3 * e); case "ivec4": return new Int32Array(4 * e); case "uvec2": return new Uint32Array(2 * e); case "uvec3": return new Uint32Array(3 * e); case "uvec4": return new Uint32Array(4 * e); case "bool": return !1; case "bvec2": return Is(2 * e); case "bvec3": return Is(3 * e); case "bvec4": return Is(4 * e); case "mat2": return new Float32Array([1, 0, 0, 1]); case "mat3": return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); case "mat4": return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) }return null } let wr = null; const Ua = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" }, Tm = { float: "float32", vec2: "float32x2", vec3: "float32x3", vec4: "float32x4", int: "sint32", ivec2: "sint32x2", ivec3: "sint32x3", ivec4: "sint32x4", uint: "uint32", uvec2: "uint32x2", uvec3: "uint32x3", uvec4: "uint32x4", bool: "uint32", bvec2: "uint32x2", bvec3: "uint32x3", bvec4: "uint32x4" }; function al(s, e) { if (!wr) { const t = Object.keys(Ua); wr = {}; for (let r = 0; r < t.length; ++r) { const i = t[r]; wr[s[i]] = Ua[i] } } return wr[e] } function Sm(s, e) { const t = al(s, e); return Tm[t] || "float32" } function wm(s, e, t = !1) { const r = {}, i = e.getProgramParameter(s, e.ACTIVE_ATTRIBUTES); for (let a = 0; a < i; a++) { const o = e.getActiveAttrib(s, a); if (o.name.startsWith("gl_")) continue; const h = Sm(e, o.type); r[o.name] = { location: 0, format: h, stride: rt(h).stride, offset: 0, instance: !1, start: 0 } } const n = Object.keys(r); if (t) { n.sort((a, o) => a > o ? 1 : -1); for (let a = 0; a < n.length; a++)r[n[a]].location = a, e.bindAttribLocation(s, a, n[a]); e.linkProgram(s) } else for (let a = 0; a < n.length; a++)r[n[a]].location = e.getAttribLocation(s, n[a]); return r } function Am(s, e) { if (!e.ACTIVE_UNIFORM_BLOCKS) return {}; const t = {}, r = e.getProgramParameter(s, e.ACTIVE_UNIFORM_BLOCKS); for (let i = 0; i < r; i++) { const n = e.getActiveUniformBlockName(s, i), a = e.getUniformBlockIndex(s, n), o = e.getActiveUniformBlockParameter(s, i, e.UNIFORM_BLOCK_DATA_SIZE); t[n] = { name: n, index: a, size: o } } return t } function Pm(s, e) { const t = {}, r = e.getProgramParameter(s, e.ACTIVE_UNIFORMS); for (let i = 0; i < r; i++) { const n = e.getActiveUniform(s, i), a = n.name.replace(/\[.*?\]$/, ""), o = !!n.name.match(/\[.*?\]$/), h = al(e, n.type); t[a] = { name: a, index: i, type: h, size: n.size, isArray: o, value: nl(h, n.size) } } return t } function Da(s, e) {
  const t = s.getShaderSource(e).split(`
`).map((l, c) => `${c}: ${l}`), r = s.getShaderInfoLog(e), i = r.split(`
`), n = {}, a = i.map(l => parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(l => l && !n[l] ? (n[l] = !0, !0) : !1), o = [""]; a.forEach(l => { t[l - 1] = `%c${t[l - 1]}%c`, o.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px") }); const h = t.join(`
`); o[0] = h, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn(...o), console.groupEnd()
} function Em(s, e, t, r) { s.getProgramParameter(e, s.LINK_STATUS) || (s.getShaderParameter(t, s.COMPILE_STATUS) || Da(s, t), s.getShaderParameter(r, s.COMPILE_STATUS) || Da(s, r), console.error("PixiJS Error: Could not initialize shader."), s.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", s.getProgramInfoLog(e))) } function Cm(s, e) { const t = Fa(s, s.VERTEX_SHADER, e.vertex), r = Fa(s, s.FRAGMENT_SHADER, e.fragment), i = s.createProgram(); s.attachShader(i, t), s.attachShader(i, r); const n = e.transformFeedbackVaryings; n && (typeof s.transformFeedbackVaryings != "function" ? H("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : s.transformFeedbackVaryings(i, n.names, n.bufferMode === "separate" ? s.SEPARATE_ATTRIBS : s.INTERLEAVED_ATTRIBS)), s.linkProgram(i), s.getProgramParameter(i, s.LINK_STATUS) || Em(s, i, t, r), e._attributeData = wm(i, s, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)), e._uniformData = Pm(i, s), e._uniformBlockData = Am(i, s), s.deleteShader(t), s.deleteShader(r); const a = {}; for (const h in e._uniformData) { const l = e._uniformData[h]; a[h] = { location: s.getUniformLocation(i, h), value: nl(l.type, l.size) } } return new vm(i, a) } const Ar = { textureCount: 0, blockIndex: 0 }; class ol { constructor(e) { this._activeProgram = null, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_programDataHash") } contextChange(e) { this._gl = e, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._activeProgram = null, this.maxTextures = It() } bind(e, t) { if (this._setProgram(e.glProgram), t) return; Ar.textureCount = 0, Ar.blockIndex = 0; let r = this._shaderSyncFunctions[e.glProgram._key]; r || (r = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)), this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings), r(this._renderer, e, Ar) } updateUniformGroup(e) { this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, Ar) } bindUniformBlock(e, t, r = 0) { const i = this._renderer.buffer, n = this._getProgramData(this._activeProgram), a = e._bufferResource; a || this._renderer.ubo.updateUniformGroup(e); const o = e.buffer, h = i.updateBuffer(o), l = i.freeLocationForBufferBase(h); if (a) { const { offset: u, size: d } = e; u === 0 && d === o.data.byteLength ? i.bindBufferBase(h, l) : i.bindBufferRange(h, l, u) } else i.getLastBindBaseLocation(h) !== l && i.bindBufferBase(h, l); const c = this._activeProgram._uniformBlockData[t].index; n.uniformBlockBindings[r] !== l && (n.uniformBlockBindings[r] = l, this._renderer.gl.uniformBlockBinding(n.program, c, l)) } _setProgram(e) { if (this._activeProgram === e) return; this._activeProgram = e; const t = this._getProgramData(e); this._gl.useProgram(t.program) } _getProgramData(e) { return this._programDataHash[e._key] || this._createProgramData(e) } _createProgramData(e) { const t = e._key; return this._programDataHash[t] = Cm(this._gl, e), this._programDataHash[t] } destroy() { for (const e of Object.keys(this._programDataHash)) this._programDataHash[e].destroy(), this._programDataHash[e] = null; this._programDataHash = null } _generateShaderSync(e, t) { return bm(e, t) } resetState() { this._activeProgram = null } } ol.extension = { type: [b.WebGLSystem], name: "shader" }; const Mm = {
  f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`, "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`, "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`, "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`, i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`, "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`, "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`, "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`, u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`, "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`, "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`, "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`, bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`, "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`, "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`, "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`, "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
}, Bm = { f32: "gl.uniform1fv(location, v);", "vec2<f32>": "gl.uniform2fv(location, v);", "vec3<f32>": "gl.uniform3fv(location, v);", "vec4<f32>": "gl.uniform4fv(location, v);", "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);", "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);", "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);", i32: "gl.uniform1iv(location, v);", "vec2<i32>": "gl.uniform2iv(location, v);", "vec3<i32>": "gl.uniform3iv(location, v);", "vec4<i32>": "gl.uniform4iv(location, v);", u32: "gl.uniform1iv(location, v);", "vec2<u32>": "gl.uniform2iv(location, v);", "vec3<u32>": "gl.uniform3iv(location, v);", "vec4<u32>": "gl.uniform4iv(location, v);", bool: "gl.uniform1iv(location, v);", "vec2<bool>": "gl.uniform2iv(location, v);", "vec3<bool>": "gl.uniform3iv(location, v);", "vec4<bool>": "gl.uniform4iv(location, v);" }; function Rm(s, e) {
  const t = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `]; for (const r in s.uniforms) {
    if (!e[r]) {
      s.uniforms[r] instanceof be ? s.uniforms[r].ubo ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : t.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : s.uniforms[r] instanceof Ki && t.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `); continue
    } const i = s.uniformStructures[r]; let n = !1; for (let a = 0; a < ft.length; a++) { const o = ft[a]; if (i.type === o.type && o.test(i)) { t.push(`name = "${r}";`, ft[a].uniform), n = !0; break } } if (!n) {
      const o = (i.size === 1 ? Mm : Bm)[i.type].replace("location", `ud["${r}"].location`); t.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${o};`)
    }
  } return new Function("ud", "uv", "renderer", "syncData", t.join(`
`))
} class hl { constructor(e) { this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = e, this.gl = null, this._cache = {} } contextChange(e) { this.gl = e } updateUniformGroup(e, t, r) { const i = this._renderer.shader._getProgramData(t); (!e.isStatic || e._dirtyId !== i.uniformDirtyGroups[e.uid]) && (i.uniformDirtyGroups[e.uid] = e._dirtyId, this._getUniformSyncFunction(e, t)(i.uniformData, e.uniforms, this._renderer, r)) } _getUniformSyncFunction(e, t) { var r; return ((r = this._uniformGroupSyncHash[e._signature]) == null ? void 0 : r[t._key]) || this._createUniformSyncFunction(e, t) } _createUniformSyncFunction(e, t) { const r = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {}), i = this._getSignature(e, t._uniformData, "u"); return this._cache[i] || (this._cache[i] = this._generateUniformsSync(e, t._uniformData)), r[t._key] = this._cache[i], r[t._key] } _generateUniformsSync(e, t) { return Rm(e, t) } _getSignature(e, t, r) { const i = e.uniforms, n = [`${r}-`]; for (const a in i) n.push(a), t[a] && n.push(t[a].type); return n.join("-") } destroy() { this._renderer = null, this._cache = null } } hl.extension = { type: [b.WebGLSystem], name: "uniformGroup" }; function km(s) { const e = {}; if (e.normal = [s.ONE, s.ONE_MINUS_SRC_ALPHA], e.add = [s.ONE, s.ONE], e.multiply = [s.DST_COLOR, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA], e.screen = [s.ONE, s.ONE_MINUS_SRC_COLOR, s.ONE, s.ONE_MINUS_SRC_ALPHA], e.none = [0, 0], e["normal-npm"] = [s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA], e["add-npm"] = [s.SRC_ALPHA, s.ONE, s.ONE, s.ONE], e["screen-npm"] = [s.SRC_ALPHA, s.ONE_MINUS_SRC_COLOR, s.ONE, s.ONE_MINUS_SRC_ALPHA], e.erase = [s.ZERO, s.ONE_MINUS_SRC_ALPHA], !(s instanceof K.get().getWebGLRenderingContext())) e.min = [s.ONE, s.ONE, s.ONE, s.ONE, s.MIN, s.MIN], e.max = [s.ONE, s.ONE, s.ONE, s.ONE, s.MAX, s.MAX]; else { const r = s.getExtension("EXT_blend_minmax"); r && (e.min = [s.ONE, s.ONE, s.ONE, s.ONE, r.MIN_EXT, r.MIN_EXT], e.max = [s.ONE, s.ONE, s.ONE, s.ONE, r.MAX_EXT, r.MAX_EXT]) } return e } const Im = 0, Gm = 1, Fm = 2, Um = 3, Dm = 4, Om = 5, ll = class li { constructor(e) { this._invertFrontFace = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[Im] = this.setBlend, this.map[Gm] = this.setOffset, this.map[Fm] = this.setCullFace, this.map[Um] = this.setDepthTest, this.map[Dm] = this.setFrontFace, this.map[Om] = this.setDepthMask, this.checks = [], this.defaultState = Oe.for2d(), e.renderTarget.onRenderTargetChange.add(this) } onRenderTargetChange(e) { this._invertFrontFace = !e.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0 } contextChange(e) { this.gl = e, this.blendModesMap = km(e), this.resetState() } set(e) { if (e || (e = this.defaultState), this.stateId !== e.data) { let t = this.stateId ^ e.data, r = 0; for (; t;)t & 1 && this.map[r].call(this, !!(e.data & 1 << r)), t >>= 1, r++; this.stateId = e.data } for (let t = 0; t < this.checks.length; t++)this.checks[t](this, e) } forceState(e) { e || (e = this.defaultState); for (let t = 0; t < this.map.length; t++)this.map[t].call(this, !!(e.data & 1 << t)); for (let t = 0; t < this.checks.length; t++)this.checks[t](this, e); this.stateId = e.data } setBlend(e) { this._updateCheck(li._checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND) } setOffset(e) { this._updateCheck(li._checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL) } setDepthTest(e) { this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST) } setDepthMask(e) { this.gl.depthMask(e) } setCullFace(e) { this._cullFace = e, this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace) } setFrontFace(e) { this._frontFace = e, this._frontFaceDirty = !1; const t = this._invertFrontFace ? !e : e; this._glFrontFace !== t && (this._glFrontFace = t, this.gl.frontFace(this.gl[t ? "CW" : "CCW"])) } setBlendMode(e) { if (this.blendModesMap[e] || (e = "normal"), e === this.blendMode) return; this.blendMode = e; const t = this.blendModesMap[e], r = this.gl; t.length === 2 ? r.blendFunc(t[0], t[1]) : r.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD)) } setPolygonOffset(e, t) { this.gl.polygonOffset(e, t) } resetState() { this._glFrontFace = !1, this._frontFace = !1, this._cullFace = !1, this._frontFaceDirty = !1, this._invertFrontFace = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal") } _updateCheck(e, t) { const r = this.checks.indexOf(e); t && r === -1 ? this.checks.push(e) : !t && r !== -1 && this.checks.splice(r, 1) } static _checkBlendMode(e, t) { e.setBlendMode(t.blendMode) } static _checkPolygonOffset(e, t) { e.setPolygonOffset(1, t.polygonOffset) } destroy() { this.gl = null, this.checks.length = 0 } }; ll.extension = { type: [b.WebGLSystem], name: "state" }; let Lm = ll; class Nm { constructor(e) { this.target = Wh.TEXTURE_2D, this.texture = e, this.width = -1, this.height = -1, this.type = J.UNSIGNED_BYTE, this.internalFormat = oi.RGBA, this.format = oi.RGBA, this.samplerType = 0 } } const Hm = { id: "buffer", upload(s, e, t) { e.width === s.width || e.height === s.height ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, s.width, s.height, e.format, e.type, s.resource) : t.texImage2D(e.target, 0, e.internalFormat, s.width, s.height, 0, e.format, e.type, s.resource), e.width = s.width, e.height = s.height } }, zm = { "bc1-rgba-unorm": !0, "bc1-rgba-unorm-srgb": !0, "bc2-rgba-unorm": !0, "bc2-rgba-unorm-srgb": !0, "bc3-rgba-unorm": !0, "bc3-rgba-unorm-srgb": !0, "bc4-r-unorm": !0, "bc4-r-snorm": !0, "bc5-rg-unorm": !0, "bc5-rg-snorm": !0, "bc6h-rgb-ufloat": !0, "bc6h-rgb-float": !0, "bc7-rgba-unorm": !0, "bc7-rgba-unorm-srgb": !0, "etc2-rgb8unorm": !0, "etc2-rgb8unorm-srgb": !0, "etc2-rgb8a1unorm": !0, "etc2-rgb8a1unorm-srgb": !0, "etc2-rgba8unorm": !0, "etc2-rgba8unorm-srgb": !0, "eac-r11unorm": !0, "eac-r11snorm": !0, "eac-rg11unorm": !0, "eac-rg11snorm": !0, "astc-4x4-unorm": !0, "astc-4x4-unorm-srgb": !0, "astc-5x4-unorm": !0, "astc-5x4-unorm-srgb": !0, "astc-5x5-unorm": !0, "astc-5x5-unorm-srgb": !0, "astc-6x5-unorm": !0, "astc-6x5-unorm-srgb": !0, "astc-6x6-unorm": !0, "astc-6x6-unorm-srgb": !0, "astc-8x5-unorm": !0, "astc-8x5-unorm-srgb": !0, "astc-8x6-unorm": !0, "astc-8x6-unorm-srgb": !0, "astc-8x8-unorm": !0, "astc-8x8-unorm-srgb": !0, "astc-10x5-unorm": !0, "astc-10x5-unorm-srgb": !0, "astc-10x6-unorm": !0, "astc-10x6-unorm-srgb": !0, "astc-10x8-unorm": !0, "astc-10x8-unorm-srgb": !0, "astc-10x10-unorm": !0, "astc-10x10-unorm-srgb": !0, "astc-12x10-unorm": !0, "astc-12x10-unorm-srgb": !0, "astc-12x12-unorm": !0, "astc-12x12-unorm-srgb": !0 }, Wm = { id: "compressed", upload(s, e, t) { t.pixelStorei(t.UNPACK_ALIGNMENT, 4); let r = s.pixelWidth, i = s.pixelHeight; const n = !!zm[s.format]; for (let a = 0; a < s.resource.length; a++) { const o = s.resource[a]; n ? t.compressedTexImage2D(t.TEXTURE_2D, a, e.internalFormat, r, i, 0, o) : t.texImage2D(t.TEXTURE_2D, a, e.internalFormat, r, i, 0, e.format, e.type, o), r = Math.max(r >> 1, 1), i = Math.max(i >> 1, 1) } } }, cl = { id: "image", upload(s, e, t, r) { const i = e.width, n = e.height, a = s.pixelWidth, o = s.pixelHeight, h = s.resourceWidth, l = s.resourceHeight; h < a || l < o ? ((i !== a || n !== o) && t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, null), r === 2 ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, h, l, e.format, e.type, s.resource) : t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, s.resource)) : i === a && n === o ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, s.resource) : r === 2 ? t.texImage2D(e.target, 0, e.internalFormat, a, o, 0, e.format, e.type, s.resource) : t.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, s.resource), e.width = a, e.height = o } }, Vm = { id: "video", upload(s, e, t, r) { if (!s.isValid) { t.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null); return } cl.upload(s, e, t, r) } }, Oa = { linear: 9729, nearest: 9728 }, $m = { linear: { linear: 9987, nearest: 9985 }, nearest: { linear: 9986, nearest: 9984 } }, Gs = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 }, Xm = { never: 512, less: 513, equal: 514, "less-equal": 515, greater: 516, "not-equal": 517, "greater-equal": 518, always: 519 }; function La(s, e, t, r, i, n, a, o) { const h = n; if (!o || s.addressModeU !== "repeat" || s.addressModeV !== "repeat" || s.addressModeW !== "repeat") { const l = Gs[a ? "clamp-to-edge" : s.addressModeU], c = Gs[a ? "clamp-to-edge" : s.addressModeV], u = Gs[a ? "clamp-to-edge" : s.addressModeW]; e[i](h, e.TEXTURE_WRAP_S, l), e[i](h, e.TEXTURE_WRAP_T, c), e.TEXTURE_WRAP_R && e[i](h, e.TEXTURE_WRAP_R, u) } if ((!o || s.magFilter !== "linear") && e[i](h, e.TEXTURE_MAG_FILTER, Oa[s.magFilter]), t) { if (!o || s.mipmapFilter !== "linear") { const l = $m[s.minFilter][s.mipmapFilter]; e[i](h, e.TEXTURE_MIN_FILTER, l) } } else e[i](h, e.TEXTURE_MIN_FILTER, Oa[s.minFilter]); if (r && s.maxAnisotropy > 1) { const l = Math.min(s.maxAnisotropy, e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT)); e[i](h, r.TEXTURE_MAX_ANISOTROPY_EXT, l) } s.compare && e[i](h, e.TEXTURE_COMPARE_FUNC, Xm[s.compare]) } function jm(s) { return { r8unorm: s.RED, r8snorm: s.RED, r8uint: s.RED, r8sint: s.RED, r16uint: s.RED, r16sint: s.RED, r16float: s.RED, rg8unorm: s.RG, rg8snorm: s.RG, rg8uint: s.RG, rg8sint: s.RG, r32uint: s.RED, r32sint: s.RED, r32float: s.RED, rg16uint: s.RG, rg16sint: s.RG, rg16float: s.RG, rgba8unorm: s.RGBA, "rgba8unorm-srgb": s.RGBA, rgba8snorm: s.RGBA, rgba8uint: s.RGBA, rgba8sint: s.RGBA, bgra8unorm: s.RGBA, "bgra8unorm-srgb": s.RGBA, rgb9e5ufloat: s.RGB, rgb10a2unorm: s.RGBA, rg11b10ufloat: s.RGB, rg32uint: s.RG, rg32sint: s.RG, rg32float: s.RG, rgba16uint: s.RGBA, rgba16sint: s.RGBA, rgba16float: s.RGBA, rgba32uint: s.RGBA, rgba32sint: s.RGBA, rgba32float: s.RGBA, stencil8: s.STENCIL_INDEX8, depth16unorm: s.DEPTH_COMPONENT, depth24plus: s.DEPTH_COMPONENT, "depth24plus-stencil8": s.DEPTH_STENCIL, depth32float: s.DEPTH_COMPONENT, "depth32float-stencil8": s.DEPTH_STENCIL } } function Ym(s, e) { let t = {}, r = s.RGBA; return s instanceof K.get().getWebGLRenderingContext() ? e.srgb && (t = { "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT, "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT }) : (t = { "rgba8unorm-srgb": s.SRGB8_ALPHA8, "bgra8unorm-srgb": s.SRGB8_ALPHA8 }, r = s.RGBA8), { r8unorm: s.R8, r8snorm: s.R8_SNORM, r8uint: s.R8UI, r8sint: s.R8I, r16uint: s.R16UI, r16sint: s.R16I, r16float: s.R16F, rg8unorm: s.RG8, rg8snorm: s.RG8_SNORM, rg8uint: s.RG8UI, rg8sint: s.RG8I, r32uint: s.R32UI, r32sint: s.R32I, r32float: s.R32F, rg16uint: s.RG16UI, rg16sint: s.RG16I, rg16float: s.RG16F, rgba8unorm: s.RGBA, ...t, rgba8snorm: s.RGBA8_SNORM, rgba8uint: s.RGBA8UI, rgba8sint: s.RGBA8I, bgra8unorm: r, rgb9e5ufloat: s.RGB9_E5, rgb10a2unorm: s.RGB10_A2, rg11b10ufloat: s.R11F_G11F_B10F, rg32uint: s.RG32UI, rg32sint: s.RG32I, rg32float: s.RG32F, rgba16uint: s.RGBA16UI, rgba16sint: s.RGBA16I, rgba16float: s.RGBA16F, rgba32uint: s.RGBA32UI, rgba32sint: s.RGBA32I, rgba32float: s.RGBA32F, stencil8: s.STENCIL_INDEX8, depth16unorm: s.DEPTH_COMPONENT16, depth24plus: s.DEPTH_COMPONENT24, "depth24plus-stencil8": s.DEPTH24_STENCIL8, depth32float: s.DEPTH_COMPONENT32F, "depth32float-stencil8": s.DEPTH32F_STENCIL8, ...e.s3tc ? { "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT, "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT, "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT } : {}, ...e.s3tc_sRGB ? { "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } : {}, ...e.rgtc ? { "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT, "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT, "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT, "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } : {}, ...e.bptc ? { "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT, "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT, "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT, "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT } : {}, ...e.etc ? { "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2, "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2, "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC, "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, "eac-r11unorm": e.etc.COMPRESSED_R11_EAC, "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC } : {}, ...e.astc ? { "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR, "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR, "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR, "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR, "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR, "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR, "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR, "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR, "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR, "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR, "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR, "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR, "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR, "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR, "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR, "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR, "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR, "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR, "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR, "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR, "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR, "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR, "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR, "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR, "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR, "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR, "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR, "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR } : {} } } function Km(s) { return { r8unorm: s.UNSIGNED_BYTE, r8snorm: s.BYTE, r8uint: s.UNSIGNED_BYTE, r8sint: s.BYTE, r16uint: s.UNSIGNED_SHORT, r16sint: s.SHORT, r16float: s.HALF_FLOAT, rg8unorm: s.UNSIGNED_BYTE, rg8snorm: s.BYTE, rg8uint: s.UNSIGNED_BYTE, rg8sint: s.BYTE, r32uint: s.UNSIGNED_INT, r32sint: s.INT, r32float: s.FLOAT, rg16uint: s.UNSIGNED_SHORT, rg16sint: s.SHORT, rg16float: s.HALF_FLOAT, rgba8unorm: s.UNSIGNED_BYTE, "rgba8unorm-srgb": s.UNSIGNED_BYTE, rgba8snorm: s.BYTE, rgba8uint: s.UNSIGNED_BYTE, rgba8sint: s.BYTE, bgra8unorm: s.UNSIGNED_BYTE, "bgra8unorm-srgb": s.UNSIGNED_BYTE, rgb9e5ufloat: s.UNSIGNED_INT_5_9_9_9_REV, rgb10a2unorm: s.UNSIGNED_INT_2_10_10_10_REV, rg11b10ufloat: s.UNSIGNED_INT_10F_11F_11F_REV, rg32uint: s.UNSIGNED_INT, rg32sint: s.INT, rg32float: s.FLOAT, rgba16uint: s.UNSIGNED_SHORT, rgba16sint: s.SHORT, rgba16float: s.HALF_FLOAT, rgba32uint: s.UNSIGNED_INT, rgba32sint: s.INT, rgba32float: s.FLOAT, stencil8: s.UNSIGNED_BYTE, depth16unorm: s.UNSIGNED_SHORT, depth24plus: s.UNSIGNED_INT, "depth24plus-stencil8": s.UNSIGNED_INT_24_8, depth32float: s.FLOAT, "depth32float-stencil8": s.FLOAT_32_UNSIGNED_INT_24_8_REV } } const qm = 4; class ul { constructor(e) { this.managedTextures = [], this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = Object.create(null), this._uploads = { image: cl, buffer: Hm, video: Vm, compressed: Wm }, this._premultiplyAlpha = !1, this._useSeparateSamplers = !1, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers") } contextChange(e) { this._gl = e, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = Ym(e, this._renderer.context.extensions), this._mapFormatToType = Km(e), this._mapFormatToFormat = jm(e)), this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundSamplers = Object.create(null), this._premultiplyAlpha = !1; for (let t = 0; t < 16; t++)this.bind(F.EMPTY, t) } initSource(e) { this.bind(e) } bind(e, t = 0) { const r = e.source; e ? (this.bindSource(r, t), this._useSeparateSamplers && this._bindSampler(r.style, t)) : (this.bindSource(null, t), this._useSeparateSamplers && this._bindSampler(null, t)) } bindSource(e, t = 0) { const r = this._gl; if (e._touched = this._renderer.textureGC.count, this._boundTextures[t] !== e) { this._boundTextures[t] = e, this._activateLocation(t), e || (e = F.EMPTY.source); const i = this.getGlSource(e); r.bindTexture(i.target, i.texture) } } _bindSampler(e, t = 0) { const r = this._gl; if (!e) { this._boundSamplers[t] = null, r.bindSampler(t, null); return } const i = this._getGlSampler(e); this._boundSamplers[t] !== i && (this._boundSamplers[t] = i, r.bindSampler(t, i)) } unbind(e) { const t = e.source, r = this._boundTextures, i = this._gl; for (let n = 0; n < r.length; n++)if (r[n] === t) { this._activateLocation(n); const a = this.getGlSource(t); i.bindTexture(a.target, null), r[n] = null } } _activateLocation(e) { this._activeTextureLocation !== e && (this._activeTextureLocation = e, this._gl.activeTexture(this._gl.TEXTURE0 + e)) } _initSource(e) { const t = this._gl, r = new Nm(t.createTexture()); if (r.type = this._mapFormatToType[e.format], r.internalFormat = this._mapFormatToInternalFormat[e.format], r.format = this._mapFormatToFormat[e.format], e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo)) { const i = Math.max(e.width, e.height); e.mipLevelCount = Math.floor(Math.log2(i)) + 1 } return this._glTextures[e.uid] = r, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceUpdate, this), e.on("styleChange", this.onStyleChange, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), this.updateStyle(e, !1), r } onStyleChange(e) { this.updateStyle(e, !1) } updateStyle(e, t) { const r = this._gl, i = this.getGlSource(e); r.bindTexture(r.TEXTURE_2D, i.texture), this._boundTextures[this._activeTextureLocation] = e, La(e.style, r, e.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo, t) } onSourceUnload(e) { const t = this._glTextures[e.uid]; t && (this.unbind(e), this._glTextures[e.uid] = null, this._gl.deleteTexture(t.texture)) } onSourceUpdate(e) { const t = this._gl, r = this.getGlSource(e); t.bindTexture(t.TEXTURE_2D, r.texture), this._boundTextures[this._activeTextureLocation] = e; const i = e.alphaMode === "premultiply-alpha-on-upload"; this._premultiplyAlpha !== i && (this._premultiplyAlpha = i, t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i)), this._uploads[e.uploadMethodId] ? this._uploads[e.uploadMethodId].upload(e, r, t, this._renderer.context.webGLVersion) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.pixelWidth, e.pixelHeight, 0, t.RGBA, t.UNSIGNED_BYTE, null), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1) } onUpdateMipmaps(e, t = !0) { t && this.bindSource(e, 0); const r = this.getGlSource(e); this._gl.generateMipmap(r.target) } onSourceDestroy(e) { e.off("destroy", this.onSourceDestroy, this), e.off("update", this.onSourceUpdate, this), e.off("resize", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("styleChange", this.onStyleChange, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e) } _initSampler(e) { const t = this._gl, r = this._gl.createSampler(); return this._glSamplers[e._resourceId] = r, La(e, t, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, !1, !0), this._glSamplers[e._resourceId] } _getGlSampler(e) { return this._glSamplers[e._resourceId] || this._initSampler(e) } getGlSource(e) { return this._glTextures[e.uid] || this._initSource(e) } generateCanvas(e) { const { pixels: t, width: r, height: i } = this.getPixels(e), n = K.get().createCanvas(); n.width = r, n.height = i; const a = n.getContext("2d"); if (a) { const o = a.createImageData(r, i); o.data.set(t), a.putImageData(o, 0, 0) } return n } getPixels(e) { const t = e.source.resolution, r = e.frame, i = Math.max(Math.round(r.width * t), 1), n = Math.max(Math.round(r.height * t), 1), a = new Uint8Array(qm * i * n), o = this._renderer, h = o.renderTarget.getRenderTarget(e), l = o.renderTarget.getGpuRenderTarget(h), c = o.gl; return c.bindFramebuffer(c.FRAMEBUFFER, l.resolveTargetFramebuffer), c.readPixels(Math.round(r.x * t), Math.round(r.y * t), i, n, c.RGBA, c.UNSIGNED_BYTE, a), { pixels: new Uint8ClampedArray(a.buffer), width: i, height: n } } destroy() { this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)), this.managedTextures = null, this._renderer = null } resetState() { this._activeTextureLocation = -1, this._boundTextures.fill(F.EMPTY.source), this._boundSamplers = Object.create(null); const e = this._gl; this._premultiplyAlpha = !1, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha) } } ul.extension = { type: [b.WebGLSystem], name: "texture" }; class dl { init() { const e = new be({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new D, type: "mat3x3<f32>" }, uRound: { value: 0, type: "f32" } }), t = It(), r = ar({ name: "graphics", bits: [Mi, Ri(t), Xi, hr] }); this.shader = new ke({ glProgram: r, resources: { localUniforms: e, batchSamplers: ki(t) } }) } execute(e, t) { const r = t.context, i = r.customShader || this.shader, n = e.renderer, a = n.graphicsContext, { batcher: o, instructions: h } = a.getContextRenderData(r); i.groups[0] = n.globalUniforms.bindGroup, n.state.set(e.state), n.shader.bind(i), n.geometry.bind(o.geometry, i.glProgram); const l = h.instructions; for (let c = 0; c < h.instructionSize; c++) { const u = l[c]; if (u.size) { for (let d = 0; d < u.textures.count; d++)n.texture.bind(u.textures.textures[d], d); n.geometry.draw(u.topology, u.size, u.start) } } } destroy() { this.shader.destroy(!0), this.shader = null } } dl.extension = { type: [b.WebGLPipesAdaptor], name: "graphics" }; class fl { init() { const e = ar({ name: "mesh", bits: [Xi, rm, hr] }); this._shader = new ke({ glProgram: e, resources: { uTexture: F.EMPTY.source, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new D } } } }) } execute(e, t) { const r = e.renderer; let i = t._shader; if (i) { if (!i.glProgram) { H("Mesh shader has no glProgram", t.shader); return } } else { i = this._shader; const n = t.texture, a = n.source; i.resources.uTexture = a, i.resources.uSampler = a.style, i.resources.textureUniforms.uniforms.uTextureMatrix = n.textureMatrix.mapCoord } i.groups[100] = r.globalUniforms.bindGroup, i.groups[101] = e.localUniformsBindGroup, r.encoder.draw({ geometry: t._geometry, shader: i, state: t.state }) } destroy() { this._shader.destroy(!0), this._shader = null } } fl.extension = { type: [b.WebGLPipesAdaptor], name: "mesh" }; class pl { constructor(e) { this._renderer = e } updateRenderable() { } destroyRenderable() { } validateRenderable() { return !1 } addRenderable(e, t) { this._renderer.renderPipes.batch.break(t), t.add(e) } execute(e) { e.isRenderable && e.render(this._renderer) } destroy() { this._renderer = null } } pl.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "customRender" }; class Zr { constructor() { this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null } get blendMode() { return this.renderable.groupBlendMode } get color() { return this.renderable.groupColorAlpha } reset() { this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null } } function ci(s, e) { const t = s.instructionSet, r = t.instructions; for (let i = 0; i < t.instructionSize; i++) { const n = r[i]; e[n.renderPipeId].execute(n) } } const Zm = new D; class ml { constructor(e) { this._renderer = e } addRenderGroup(e, t) { e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, t) : this._addRenderableDirect(e, t) } execute(e) { e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e)) } destroy() { this._renderer = null } _addRenderableDirect(e, t) { this._renderer.renderPipes.batch.break(t), e._batchableRenderGroup && (j.return(e._batchableRenderGroup), e._batchableRenderGroup = null), t.add(e) } _addRenderableCacheAsTexture(e, t) { const r = e._batchableRenderGroup ?? (e._batchableRenderGroup = j.get(Zr)); r.renderable = e.root, r.transform = e.root.relativeGroupTransform, r.texture = e.texture, r.bounds = e._textureBounds, t.add(e), this._renderer.renderPipes.batch.addToBatch(r, t) } _executeCacheAsTexture(e) { if (e.textureNeedsUpdate) { e.textureNeedsUpdate = !1; const t = Zm.identity().translate(-e._textureBounds.x, -e._textureBounds.y); this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame), this._renderer.globalUniforms.push({ worldTransformMatrix: t, worldColor: 4294967295 }), ci(e, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop() } e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup), e._batchableRenderGroup._batcher.geometry.buffers[0].update() } _executeDirect(e) { this._renderer.globalUniforms.push({ worldTransformMatrix: e.inverseParentTextureTransform, worldColor: e.worldColorAlpha }), ci(e, this._renderer.renderPipes), this._renderer.globalUniforms.pop() } } ml.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "renderGroup" }; function ui(s, e) { e || (e = 0); for (let t = e; t < s.length && s[t]; t++)s[t] = null } const Qm = new ve, Na = jt | Or | bi; function gl(s, e = !1) { Jm(s); const t = s.childrenToUpdate, r = s.updateTick++; for (const i in t) { const n = Number(i), a = t[i], o = a.list, h = a.index; for (let l = 0; l < h; l++) { const c = o[l]; c.parentRenderGroup === s && c.relativeRenderGroupDepth === n && _l(c, r, 0) } ui(o, h), a.index = 0 } if (e) for (let i = 0; i < s.renderGroupChildren.length; i++)gl(s.renderGroupChildren[i], e) } function Jm(s) { const e = s.root; let t; if (s.renderGroupParent) { const r = s.renderGroupParent; s.worldTransform.appendFrom(e.relativeGroupTransform, r.worldTransform), s.worldColor = Dr(e.groupColor, r.worldColor), t = e.groupAlpha * r.worldAlpha } else s.worldTransform.copyFrom(e.localTransform), s.worldColor = e.localColor, t = e.localAlpha; t = t < 0 ? 0 : t > 1 ? 1 : t, s.worldAlpha = t, s.worldColorAlpha = s.worldColor + ((t * 255 | 0) << 24) } function _l(s, e, t) { if (e === s.updateTick) return; s.updateTick = e, s.didChange = !1; const r = s.localTransform; s.updateLocalTransform(); const i = s.parent; if (i && !i.renderGroup ? (t |= s._updateFlags, s.relativeGroupTransform.appendFrom(r, i.relativeGroupTransform), t & Na && Ha(s, i, t)) : (t = s._updateFlags, s.relativeGroupTransform.copyFrom(r), t & Na && Ha(s, Qm, t)), !s.renderGroup) { const n = s.children, a = n.length; for (let l = 0; l < a; l++)_l(n[l], e, t); const o = s.parentRenderGroup, h = s; h.renderPipeId && !o.structureDidChange && o.updateRenderable(h) } } function Ha(s, e, t) { if (t & Or) { s.groupColor = Dr(s.localColor, e.groupColor); let r = s.localAlpha * e.groupAlpha; r = r < 0 ? 0 : r > 1 ? 1 : r, s.groupAlpha = r, s.groupColorAlpha = s.groupColor + ((r * 255 | 0) << 24) } t & bi && (s.groupBlendMode = s.localBlendMode === "inherit" ? e.groupBlendMode : s.localBlendMode), t & jt && (s.globalDisplayStatus = s.localDisplayStatus & e.globalDisplayStatus), s._updateFlags = 0 } function eg(s, e) { const { list: t, index: r } = s.childrenRenderablesToUpdate; let i = !1; for (let n = 0; n < r; n++) { const a = t[n]; if (i = e[a.renderPipeId].validateRenderable(a), i) break } return s.structureDidChange = i, i } const tg = new D; class xl { constructor(e) { this._renderer = e } render({ container: e, transform: t }) { const r = e.parent, i = e.renderGroup.renderGroupParent; e.parent = null, e.renderGroup.renderGroupParent = null; const n = this._renderer; let a = tg; t && (a = a.copyFrom(e.renderGroup.localTransform), e.renderGroup.localTransform.copyFrom(t)); const o = n.renderPipes; this._updateCachedRenderGroups(e.renderGroup, null), this._updateRenderGroups(e.renderGroup), n.globalUniforms.start({ worldTransformMatrix: t ? e.renderGroup.localTransform : e.renderGroup.worldTransform, worldColor: e.renderGroup.worldColorAlpha }), ci(e.renderGroup, o), o.uniformBatch && o.uniformBatch.renderEnd(), t && e.renderGroup.localTransform.copyFrom(a), e.parent = r, e.renderGroup.renderGroupParent = i } destroy() { this._renderer = null } _updateCachedRenderGroups(e, t) { if (e.isCachedAsTexture) { if (!e.updateCacheTexture) return; t = e } e._parentCacheAsTextureRenderGroup = t; for (let r = e.renderGroupChildren.length - 1; r >= 0; r--)this._updateCachedRenderGroups(e.renderGroupChildren[r], t); if (e.invalidateMatrices(), e.isCachedAsTexture) { if (e.textureNeedsUpdate) { const r = e.root.getLocalBounds(); r.ceil(); const i = e.texture; e.texture && _e.returnTexture(e.texture); const n = this._renderer, a = e.textureOptions.resolution || n.view.resolution, o = e.textureOptions.antialias ?? n.view.antialias; e.texture = _e.getOptimalTexture(r.width, r.height, a, o), e._textureBounds || (e._textureBounds = new xe), e._textureBounds.copyFrom(r), i !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0) } } else e.texture && (_e.returnTexture(e.texture), e.texture = null) } _updateRenderGroups(e) { const t = this._renderer, r = t.renderPipes; if (e.runOnRender(t), e.instructionSet.renderPipes = r, e.structureDidChange ? ui(e.childrenRenderablesToUpdate.list, 0) : eg(e, r), gl(e), e.structureDidChange ? (e.structureDidChange = !1, this._buildInstructions(e, t)) : this._updateRenderables(e), e.childrenRenderablesToUpdate.index = 0, t.renderPipes.batch.upload(e.instructionSet), !(e.isCachedAsTexture && !e.textureNeedsUpdate)) for (let i = 0; i < e.renderGroupChildren.length; i++)this._updateRenderGroups(e.renderGroupChildren[i]) } _updateRenderables(e) { const { list: t, index: r } = e.childrenRenderablesToUpdate; for (let i = 0; i < r; i++) { const n = t[i]; n.didViewUpdate && e.updateRenderable(n) } ui(t, r) } _buildInstructions(e, t) { const r = e.root, i = e.instructionSet; i.reset(); const n = t.renderPipes ? t : t.batch.renderer, a = n.renderPipes; a.batch.buildStart(i), a.blendMode.buildStart(), a.colorMask.buildStart(), r.sortableChildren && r.sortChildren(), r.collectRenderablesWithEffects(i, n, null), a.batch.buildEnd(i), a.blendMode.buildEnd(i) } } xl.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "renderGroup" }; class yl { constructor(e) { this._gpuSpriteHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash") } addRenderable(e, t) { const r = this._getGpuSprite(e); e.didViewUpdate && this._updateBatchableSprite(e, r), this._renderer.renderPipes.batch.addToBatch(r, t) } updateRenderable(e) { const t = this._gpuSpriteHash[e.uid]; e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t) } validateRenderable(e) { const t = this._getGpuSprite(e); return !t._batcher.checkAndUpdateTexture(t, e._texture) } destroyRenderable(e) { const t = this._gpuSpriteHash[e.uid]; j.return(t), this._gpuSpriteHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound) } _updateBatchableSprite(e, t) { t.bounds = e.visualBounds, t.texture = e._texture } _getGpuSprite(e) { return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e) } _initGPUSprite(e) { const t = j.get(Zr); return t.renderable = e, t.transform = e.groupTransform, t.texture = e._texture, t.bounds = e.visualBounds, t.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuSpriteHash[e.uid] = t, e.on("destroyed", this._destroyRenderableBound), t } destroy() { for (const e in this._gpuSpriteHash) j.return(this._gpuSpriteHash[e]); this._gpuSpriteHash = null, this._renderer = null } } yl.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "sprite" }; const qi = class bl { constructor() { this.clearBeforeRender = !0, this._backgroundColor = new ie(0), this.color = this._backgroundColor, this.alpha = 1 } init(e) { e = { ...bl.defaultOptions, ...e }, this.clearBeforeRender = e.clearBeforeRender, this.color = e.background || e.backgroundColor || this._backgroundColor, this.alpha = e.backgroundAlpha, this._backgroundColor.setAlpha(e.backgroundAlpha) } get color() { return this._backgroundColor } set color(e) { this._backgroundColor.setValue(e) } get alpha() { return this._backgroundColor.alpha } set alpha(e) { this._backgroundColor.setAlpha(e) } get colorRgba() { return this._backgroundColor.toArray() } destroy() { } }; qi.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "background", priority: 0 }; qi.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 }; let rg = qi; const Zt = {}; z.handle(b.BlendMode, s => { if (!s.name) throw new Error("BlendMode extension must have a name property"); Zt[s.name] = s.ref }, s => { delete Zt[s.name] }); class vl { constructor(e) { this._isAdvanced = !1, this._filterHash = Object.create(null), this._renderer = e, this._renderer.runners.prerender.add(this) } prerender() { this._activeBlendMode = "normal", this._isAdvanced = !1 } setBlendMode(e, t, r) { if (this._activeBlendMode === t) { this._isAdvanced && this._renderableList.push(e); return } this._activeBlendMode = t, this._isAdvanced && this._endAdvancedBlendMode(r), this._isAdvanced = !!Zt[t], this._isAdvanced && (this._beginAdvancedBlendMode(r), this._renderableList.push(e)) } _beginAdvancedBlendMode(e) { this._renderer.renderPipes.batch.break(e); const t = this._activeBlendMode; if (!Zt[t]) { H(`Unable to assign BlendMode: '${t}'. You may want to include: import 'pixi.js/advanced-blend-modes'`); return } let r = this._filterHash[t]; r || (r = this._filterHash[t] = new Ur, r.filters = [new Zt[t]]); const i = { renderPipeId: "filter", action: "pushFilter", renderables: [], filterEffect: r, canBundle: !1 }; this._renderableList = i.renderables, e.add(i) } _endAdvancedBlendMode(e) { this._renderableList = null, this._renderer.renderPipes.batch.break(e), e.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 }) } buildStart() { this._isAdvanced = !1 } buildEnd(e) { this._isAdvanced && this._endAdvancedBlendMode(e) } destroy() { this._renderer = null, this._renderableList = null; for (const e in this._filterHash) this._filterHash[e].destroy(); this._filterHash = null } } vl.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "blendMode" }; const Fs = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" }, Zi = class Tl { constructor(e) { this._renderer = e } _normalizeOptions(e, t = {}) { return e instanceof ve || e instanceof F ? { target: e, ...t } : { ...t, ...e } } async image(e) { const t = new Image; return t.src = await this.base64(e), t } async base64(e) { e = this._normalizeOptions(e, Tl.defaultImageOptions); const { format: t, quality: r } = e, i = this.canvas(e); if (i.toBlob !== void 0) return new Promise((n, a) => { i.toBlob(o => { if (!o) { a(new Error("ICanvas.toBlob failed!")); return } const h = new FileReader; h.onload = () => n(h.result), h.onerror = a, h.readAsDataURL(o) }, Fs[t], r) }); if (i.toDataURL !== void 0) return i.toDataURL(Fs[t], r); if (i.convertToBlob !== void 0) { const n = await i.convertToBlob({ type: Fs[t], quality: r }); return new Promise((a, o) => { const h = new FileReader; h.onload = () => a(h.result), h.onerror = o, h.readAsDataURL(n) }) } throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented") } canvas(e) { e = this._normalizeOptions(e); const t = e.target, r = this._renderer; if (t instanceof F) return r.texture.generateCanvas(t); const i = r.textureGenerator.generateTexture(e), n = r.texture.generateCanvas(i); return i.destroy(!0), n } pixels(e) { e = this._normalizeOptions(e); const t = e.target, r = this._renderer, i = t instanceof F ? t : r.textureGenerator.generateTexture(e), n = r.texture.getPixels(i); return t instanceof ve && i.destroy(!0), n } texture(e) { return e = this._normalizeOptions(e), e.target instanceof F ? e.target : this._renderer.textureGenerator.generateTexture(e) } download(e) { e = this._normalizeOptions(e); const t = this.canvas(e), r = document.createElement("a"); r.download = e.filename ?? "image.png", r.href = t.toDataURL("image/png"), document.body.appendChild(r), r.click(), document.body.removeChild(r) } log(e) { const t = e.width ?? 200; e = this._normalizeOptions(e); const r = this.canvas(e), i = r.toDataURL(); console.log(`[Pixi Texture] ${r.width}px ${r.height}px`); const n = ["font-size: 1px;", `padding: ${t}px 300px;`, `background: url(${i}) no-repeat;`, "background-size: contain;"].join(" "); console.log("%c ", n) } destroy() { this._renderer = null } }; Zi.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "extract" }; Zi.defaultImageOptions = { format: "png", quality: 1 }; let sg = Zi; class Qi extends F { static create(e) { return new Qi({ source: new ge(e) }) } resize(e, t, r) { return this.source.resize(e, t, r), this } } const ig = new ne, ng = new xe, ag = [0, 0, 0, 0]; class Sl { constructor(e) { this._renderer = e } generateTexture(e) { var l; e instanceof ve && (e = { target: e, frame: void 0, textureSourceOptions: {}, resolution: void 0 }); const t = e.resolution || this._renderer.resolution, r = e.antialias || this._renderer.view.antialias, i = e.target; let n = e.clearColor; n ? n = Array.isArray(n) && n.length === 4 ? n : ie.shared.setValue(n).toArray() : n = ag; const a = ((l = e.frame) == null ? void 0 : l.copyTo(ig)) || yi(i, ng).rectangle; a.width = Math.max(a.width, 1 / t) | 0, a.height = Math.max(a.height, 1 / t) | 0; const o = Qi.create({ ...e.textureSourceOptions, width: a.width, height: a.height, resolution: t, antialias: r }), h = D.shared.translate(-a.x, -a.y); return this._renderer.render({ container: i, transform: h, target: o, clearColor: n }), o.source.updateMipmaps(), o } destroy() { this._renderer = null } } Sl.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "textureGenerator" }; function lr(s, e, t) { const r = (s >> 24 & 255) / 255; e[t++] = (s & 255) / 255 * r, e[t++] = (s >> 8 & 255) / 255 * r, e[t++] = (s >> 16 & 255) / 255 * r, e[t++] = r } class wl { constructor(e) { this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = e } reset() { this._stackIndex = 0; for (let e = 0; e < this._activeUniforms.length; e++)this._uniformsPool.push(this._activeUniforms[e]); for (let e = 0; e < this._activeBindGroups.length; e++)this._bindGroupPool.push(this._activeBindGroups[e]); this._activeUniforms.length = 0, this._activeBindGroups.length = 0 } start(e) { this.reset(), this.push(e) } bind({ size: e, projectionMatrix: t, worldTransformMatrix: r, worldColor: i, offset: n }) { const a = this._renderer.renderTarget.renderTarget, o = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : { worldTransformMatrix: new D, worldColor: 4294967295, offset: new oe }, h = { projectionMatrix: t || this._renderer.renderTarget.projectionMatrix, resolution: e || a.size, worldTransformMatrix: r || o.worldTransformMatrix, worldColor: i || o.worldColor, offset: n || o.offset, bindGroup: null }, l = this._uniformsPool.pop() || this._createUniforms(); this._activeUniforms.push(l); const c = l.uniforms; c.uProjectionMatrix = h.projectionMatrix, c.uResolution = h.resolution, c.uWorldTransformMatrix.copyFrom(h.worldTransformMatrix), c.uWorldTransformMatrix.tx -= h.offset.x, c.uWorldTransformMatrix.ty -= h.offset.y, lr(h.worldColor, c.uWorldColorAlpha, 0), l.update(); let u; this._renderer.renderPipes.uniformBatch ? u = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(l, !1) : (u = this._bindGroupPool.pop() || new qe, this._activeBindGroups.push(u), u.setResource(l, 0)), h.bindGroup = u, this._currentGlobalUniformData = h } push(e) { this.bind(e), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData } pop() { this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === De.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update() } get bindGroup() { return this._currentGlobalUniformData.bindGroup } get globalUniformData() { return this._currentGlobalUniformData } get uniformGroup() { return this._currentGlobalUniformData.bindGroup.resources[0] } _createUniforms() { return new be({ uProjectionMatrix: { value: new D, type: "mat3x3<f32>" }, uWorldTransformMatrix: { value: new D, type: "mat3x3<f32>" }, uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }, { isStatic: !0 }) } destroy() { this._renderer = null } } wl.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "globalUniforms" }; let og = 1; class Al { constructor() { this._tasks = [], this._offset = 0 } init() { Ve.system.add(this._update, this) } repeat(e, t, r = !0) { const i = og++; let n = 0; return r && (this._offset += 1e3, n = this._offset), this._tasks.push({ func: e, duration: t, start: performance.now(), offset: n, last: performance.now(), repeat: !0, id: i }), i } cancel(e) { for (let t = 0; t < this._tasks.length; t++)if (this._tasks[t].id === e) { this._tasks.splice(t, 1); return } } _update() { const e = performance.now(); for (let t = 0; t < this._tasks.length; t++) { const r = this._tasks[t]; if (e - r.offset - r.last >= r.duration) { const i = e - r.start; r.func(i), r.last = e } } } destroy() { Ve.system.remove(this._update, this), this._tasks.length = 0 } } Al.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "scheduler", priority: 0 }; let za = !1; function hg(s) {
  if (!za) {
    if (K.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      const e = [`%c  %c  %c  %c  %c PixiJS %c v${Nr} (${s}) http://www.pixijs.com/

`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"]; globalThis.console.log(...e)
    } else globalThis.console && globalThis.console.log(`PixiJS ${Nr} - ${s} - http://www.pixijs.com/`); za = !0
  }
} class Ji { constructor(e) { this._renderer = e } init(e) { if (e.hello) { let t = this._renderer.name; this._renderer.type === De.WEBGL && (t += ` ${this._renderer.context.webGLVersion}`), hg(t) } } } Ji.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "hello", priority: -2 }; Ji.defaultOptions = { hello: !1 }; function lg(s) { let e = !1; for (const r in s) if (s[r] == null) { e = !0; break } if (!e) return s; const t = Object.create(null); for (const r in s) { const i = s[r]; i && (t[r] = i) } return t } function cg(s) { let e = 0; for (let t = 0; t < s.length; t++)s[t] == null ? e++ : s[t - e] = s[t]; return s.length -= e, s } let ug = 0; const en = class Pl { constructor(e) { this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = e } init(e) { e = { ...Pl.defaultOptions, ...e }, this.maxUnusedTime = e.renderableGCMaxUnusedTime, this._frequency = e.renderableGCFrequency, this.enabled = e.renderableGCActive } get enabled() { return !!this._handler } set enabled(e) { this.enabled !== e && (e ? (this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, !1), this._hashHandler = this._renderer.scheduler.repeat(() => { for (const t of this._managedHashes) t.context[t.hash] = lg(t.context[t.hash]) }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(() => { for (const t of this._managedArrays) cg(t.context[t.hash]) }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler))) } addManagedHash(e, t) { this._managedHashes.push({ context: e, hash: t }) } addManagedArray(e, t) { this._managedArrays.push({ context: e, hash: t }) } prerender({ container: e }) { this._now = performance.now(), e.renderGroup.gcTick = ug++, this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick) } addRenderable(e) { this.enabled && (e._lastUsed === -1 && (this._managedRenderables.push(e), e.once("destroyed", this._removeRenderable, this)), e._lastUsed = this._now) } run() { var n; const e = this._now, t = this._managedRenderables, r = this._renderer.renderPipes; let i = 0; for (let a = 0; a < t.length; a++) { const o = t[a]; if (o === null) { i++; continue } const h = o.renderGroup ?? o.parentRenderGroup, l = ((n = h == null ? void 0 : h.instructionSet) == null ? void 0 : n.gcTick) ?? -1; if (((h == null ? void 0 : h.gcTick) ?? 0) === l && (o._lastUsed = e), e - o._lastUsed > this.maxUnusedTime) { if (!o.destroyed) { const c = r; h && (h.structureDidChange = !0), c[o.renderPipeId].destroyRenderable(o) } o._lastUsed = -1, i++, o.off("destroyed", this._removeRenderable, this) } else t[a - i] = o } t.length -= i } destroy() { this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0 } _removeRenderable(e) { const t = this._managedRenderables.indexOf(e); t >= 0 && (e.off("destroyed", this._removeRenderable, this), this._managedRenderables[t] = null) } _updateInstructionGCTick(e, t) { e.instructionSet.gcTick = t; for (const r of e.renderGroupChildren) this._updateInstructionGCTick(r, t) } }; en.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "renderableGC", priority: 0 }; en.defaultOptions = { renderableGCActive: !0, renderableGCMaxUnusedTime: 6e4, renderableGCFrequency: 3e4 }; let dg = en; const tn = class El { constructor(e) { this._renderer = e, this.count = 0, this.checkCount = 0 } init(e) { e = { ...El.defaultOptions, ...e }, this.checkCountMax = e.textureGCCheckCountMax, this.maxIdle = e.textureGCAMaxIdle ?? e.textureGCMaxIdle, this.active = e.textureGCActive } postrender() { this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run()))) } run() { const e = this._renderer.texture.managedTextures; for (let t = 0; t < e.length; t++) { const r = e[t]; r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1, r.unload()) } } destroy() { this._renderer = null } }; tn.extension = { type: [b.WebGLSystem, b.WebGPUSystem], name: "textureGC" }; tn.defaultOptions = { textureGCActive: !0, textureGCAMaxIdle: null, textureGCMaxIdle: 60 * 60, textureGCCheckCountMax: 600 }; let fg = tn; const rn = class Cl { get autoDensity() { return this.texture.source.autoDensity } set autoDensity(e) { this.texture.source.autoDensity = e } get resolution() { return this.texture.source._resolution } set resolution(e) { this.texture.source.resize(this.texture.source.width, this.texture.source.height, e) } init(e) { e = { ...Cl.defaultOptions, ...e }, e.view && (X(ee, "ViewSystem.view has been renamed to ViewSystem.canvas"), e.canvas = e.view), this.screen = new ne(0, 0, e.width, e.height), this.canvas = e.canvas || K.get().createCanvas(), this.antialias = !!e.antialias, this.texture = el(this.canvas, e), this.renderTarget = new hi({ colorTextures: [this.texture], depth: !!e.depth, isRoot: !0 }), this.texture.source.transparent = e.backgroundAlpha < 1, this.resolution = e.resolution } resize(e, t, r) { this.texture.source.resize(e, t, r), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height } destroy(e = !1) { (typeof e == "boolean" ? e : !!(e != null && e.removeView)) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas) } }; rn.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "view", priority: 0 }; rn.defaultOptions = { width: 800, height: 600, autoDensity: !1, antialias: !1 }; let pg = rn; const Ml = [rg, wl, Ji, pg, xl, fg, Sl, sg, Vo, dg, Al], Bl = [vl, Uh, yl, ml, Dh, Lh, Oh, pl], mg = [...Ml, Jh, um, am, Nh, ul, il, Vh, hl, ol, jh, Lm, Yh, Xh], gg = [...Bl], _g = [Ih, fl, dl], Rl = [], kl = [], Il = []; z.handleByNamedList(b.WebGLSystem, Rl); z.handleByNamedList(b.WebGLPipes, kl); z.handleByNamedList(b.WebGLPipesAdaptor, Il); z.add(...mg, ...gg, ..._g); class xg extends Yr { constructor() { const e = { name: "webgl", type: De.WEBGL, systems: Rl, renderPipes: kl, renderPipeAdaptors: Il }; super(e) } } const yg = Object.freeze(Object.defineProperty({ __proto__: null, WebGLRenderer: xg }, Symbol.toStringTag, { value: "Module" })); class Gl { constructor(e) { this._hash = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_hash") } contextChange(e) { this._gpu = e } getBindGroup(e, t, r) { return e._updateKey(), this._hash[e._key] || this._createBindGroup(e, t, r) } _createBindGroup(e, t, r) { const i = this._gpu.device, n = t.layout[r], a = [], o = this._renderer; for (const c in n) { const u = e.resources[c] ?? e.resources[n[c]]; let d; if (u._resourceType === "uniformGroup") { const f = u; o.ubo.updateUniformGroup(f); const p = f.buffer; d = { buffer: o.buffer.getGPUBuffer(p), offset: 0, size: p.descriptor.size } } else if (u._resourceType === "buffer") { const f = u; d = { buffer: o.buffer.getGPUBuffer(f), offset: 0, size: f.descriptor.size } } else if (u._resourceType === "bufferResource") { const f = u; d = { buffer: o.buffer.getGPUBuffer(f.buffer), offset: f.offset, size: f.size } } else if (u._resourceType === "textureSampler") { const f = u; d = o.texture.getGpuSampler(f) } else if (u._resourceType === "textureSource") { const f = u; d = o.texture.getGpuSource(f).createView({}) } a.push({ binding: n[c], resource: d }) } const h = o.shader.getProgramData(t).bindGroups[r], l = i.createBindGroup({ layout: h, entries: a }); return this._hash[e._key] = l, l } destroy() { for (const e of Object.keys(this._hash)) this._hash[e] = null; this._hash = null, this._renderer = null } } Gl.extension = { type: [b.WebGPUSystem], name: "bindGroup" }; class Fl { constructor(e) { this._gpuBuffers = Object.create(null), this._managedBuffers = [], e.renderableGC.addManagedHash(this, "_gpuBuffers") } contextChange(e) { this._gpu = e } getGPUBuffer(e) { return this._gpuBuffers[e.uid] || this.createGPUBuffer(e) } updateBuffer(e) { const t = this._gpuBuffers[e.uid] || this.createGPUBuffer(e), r = e.data; return e._updateID && r && (e._updateID = 0, this._gpu.device.queue.writeBuffer(t, 0, r.buffer, 0, (e._updateSize || r.byteLength) + 3 & -4)), t } destroyAll() { for (const e in this._gpuBuffers) this._gpuBuffers[e].destroy(); this._gpuBuffers = {} } createGPUBuffer(e) { this._gpuBuffers[e.uid] || (e.on("update", this.updateBuffer, this), e.on("change", this.onBufferChange, this), e.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(e)); const t = this._gpu.device.createBuffer(e.descriptor); return e._updateID = 0, e.data && (Js(e.data.buffer, t.getMappedRange()), t.unmap()), this._gpuBuffers[e.uid] = t, t } onBufferChange(e) { this._gpuBuffers[e.uid].destroy(), e._updateID = 0, this._gpuBuffers[e.uid] = this.createGPUBuffer(e) } onBufferDestroy(e) { this._managedBuffers.splice(this._managedBuffers.indexOf(e), 1), this._destroyBuffer(e) } destroy() { this._managedBuffers.forEach(e => this._destroyBuffer(e)), this._managedBuffers = null, this._gpuBuffers = null } _destroyBuffer(e) { this._gpuBuffers[e.uid].destroy(), e.off("update", this.updateBuffer, this), e.off("change", this.onBufferChange, this), e.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[e.uid] = null } } Fl.extension = { type: [b.WebGPUSystem], name: "buffer" }; class bg { constructor({ minUniformOffsetAlignment: e }) { this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = e, this.data = new Float32Array(65535) } clear() { this.byteIndex = 0 } addEmptyGroup(e) { if (e > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${e * 4}`); const t = this.byteIndex; let r = t + e * 4; if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, r > this.data.length * 4) throw new Error("UniformBufferBatch: ubo batch got too big"); return this.byteIndex = r, t } addGroup(e) { const t = this.addEmptyGroup(e.length); for (let r = 0; r < e.length; r++)this.data[t / 4 + r] = e[r]; return t } destroy() { this.data = null } } class Ul { constructor(e) { this._colorMaskCache = 15, this._renderer = e } setMask(e) { this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.pipeline.setColorMask(e)) } destroy() { this._renderer = null, this._colorMaskCache = null } } Ul.extension = { type: [b.WebGPUSystem], name: "colorMask" }; class sn { constructor(e) { this._renderer = e } async init(e) { return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(e).then(t => { this.gpu = t, this._renderer.runners.contextChange.emit(this.gpu) }), this._initPromise) } contextChange(e) { this._renderer.gpu = e } async _createDeviceAndAdaptor(e) { const t = await K.get().getNavigator().gpu.requestAdapter({ powerPreference: e.powerPreference, forceFallbackAdapter: e.forceFallbackAdapter }), r = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(n => t.features.has(n)), i = await t.requestDevice({ requiredFeatures: r }); return { adapter: t, device: i } } destroy() { this.gpu = null, this._renderer = null } } sn.extension = { type: [b.WebGPUSystem], name: "device" }; sn.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 }; class Dl { constructor(e) { this._boundBindGroup = Object.create(null), this._boundVertexBuffer = Object.create(null), this._renderer = e } renderStart() { this.commandFinished = new Promise(e => { this._resolveCommandFinished = e }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder() } beginRenderPass(e) { this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(e.descriptor) } endRenderPass() { this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null } setViewport(e) { this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1) } setPipelineFromGeometryProgramAndState(e, t, r, i) { const n = this._renderer.pipeline.getPipeline(e, t, r, i); this.setPipeline(n) } setPipeline(e) { this._boundPipeline !== e && (this._boundPipeline = e, this.renderPassEncoder.setPipeline(e)) } _setVertexBuffer(e, t) { this._boundVertexBuffer[e] !== t && (this._boundVertexBuffer[e] = t, this.renderPassEncoder.setVertexBuffer(e, this._renderer.buffer.updateBuffer(t))) } _setIndexBuffer(e) { if (this._boundIndexBuffer === e) return; this._boundIndexBuffer = e; const t = e.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32"; this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e), t) } resetBindGroup(e) { this._boundBindGroup[e] = null } setBindGroup(e, t, r) { if (this._boundBindGroup[e] === t) return; this._boundBindGroup[e] = t, t._touch(this._renderer.textureGC.count); const i = this._renderer.bindGroup.getBindGroup(t, r, e); this.renderPassEncoder.setBindGroup(e, i) } setGeometry(e, t) { const r = this._renderer.pipeline.getBufferNamesToBind(e, t); for (const i in r) this._setVertexBuffer(i, e.attributes[r[i]].buffer); e.indexBuffer && this._setIndexBuffer(e.indexBuffer) } _setShaderBindGroups(e, t) { for (const r in e.groups) { const i = e.groups[r]; t || this._syncBindGroup(i), this.setBindGroup(r, i, e.gpuProgram) } } _syncBindGroup(e) { for (const t in e.resources) { const r = e.resources[t]; r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r) } } draw(e) { const { geometry: t, shader: r, state: i, topology: n, size: a, start: o, instanceCount: h, skipSync: l } = e; this.setPipelineFromGeometryProgramAndState(t, r.gpuProgram, i, n), this.setGeometry(t, r.gpuProgram), this._setShaderBindGroups(r, l), t.indexBuffer ? this.renderPassEncoder.drawIndexed(a || t.indexBuffer.data.length, h ?? t.instanceCount, o || 0) : this.renderPassEncoder.draw(a || t.getSize(), h ?? t.instanceCount, o || 0) } finishRenderPass() { this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null) } postrender() { this.finishRenderPass(), this._gpu.device.queue.submit([this.commandEncoder.finish()]), this._resolveCommandFinished(), this.commandEncoder = null } restoreRenderPass() { const e = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]); this.renderPassEncoder = this.commandEncoder.beginRenderPass(e); const t = this._boundPipeline, r = { ...this._boundVertexBuffer }, i = this._boundIndexBuffer, n = { ...this._boundBindGroup }; this._clearCache(); const a = this._renderer.renderTarget.viewport; this.renderPassEncoder.setViewport(a.x, a.y, a.width, a.height, 0, 1), this.setPipeline(t); for (const o in r) this._setVertexBuffer(o, r[o]); for (const o in n) this.setBindGroup(o, n[o], null); this._setIndexBuffer(i) } _clearCache() { for (let e = 0; e < 16; e++)this._boundBindGroup[e] = null, this._boundVertexBuffer[e] = null; this._boundIndexBuffer = null, this._boundPipeline = null } destroy() { this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null } contextChange(e) { this._gpu = e } } Dl.extension = { type: [b.WebGPUSystem], name: "encoder", priority: 1 }; class Ol { constructor(e) { this._renderTargetStencilState = Object.create(null), this._renderer = e, e.renderTarget.onRenderTargetChange.add(this) } onRenderTargetChange(e) { let t = this._renderTargetStencilState[e.uid]; t || (t = this._renderTargetStencilState[e.uid] = { stencilMode: de.DISABLED, stencilReference: 0 }), this._activeRenderTarget = e, this.setStencilMode(t.stencilMode, t.stencilReference) } setStencilMode(e, t) { const r = this._renderTargetStencilState[this._activeRenderTarget.uid]; r.stencilMode = e, r.stencilReference = t; const i = this._renderer; i.pipeline.setStencilMode(e), i.encoder.renderPassEncoder.setStencilReference(t) } destroy() { this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null } } Ol.extension = { type: [b.WebGPUSystem], name: "stencil" }; const Gr = { i32: { align: 4, size: 4 }, u32: { align: 4, size: 4 }, f32: { align: 4, size: 4 }, f16: { align: 2, size: 2 }, "vec2<i32>": { align: 8, size: 8 }, "vec2<u32>": { align: 8, size: 8 }, "vec2<f32>": { align: 8, size: 8 }, "vec2<f16>": { align: 4, size: 4 }, "vec3<i32>": { align: 16, size: 12 }, "vec3<u32>": { align: 16, size: 12 }, "vec3<f32>": { align: 16, size: 12 }, "vec3<f16>": { align: 8, size: 6 }, "vec4<i32>": { align: 16, size: 16 }, "vec4<u32>": { align: 16, size: 16 }, "vec4<f32>": { align: 16, size: 16 }, "vec4<f16>": { align: 8, size: 8 }, "mat2x2<f32>": { align: 8, size: 16 }, "mat2x2<f16>": { align: 4, size: 8 }, "mat3x2<f32>": { align: 8, size: 24 }, "mat3x2<f16>": { align: 4, size: 12 }, "mat4x2<f32>": { align: 8, size: 32 }, "mat4x2<f16>": { align: 4, size: 16 }, "mat2x3<f32>": { align: 16, size: 32 }, "mat2x3<f16>": { align: 8, size: 16 }, "mat3x3<f32>": { align: 16, size: 48 }, "mat3x3<f16>": { align: 8, size: 24 }, "mat4x3<f32>": { align: 16, size: 64 }, "mat4x3<f16>": { align: 8, size: 32 }, "mat2x4<f32>": { align: 16, size: 32 }, "mat2x4<f16>": { align: 8, size: 16 }, "mat3x4<f32>": { align: 16, size: 48 }, "mat3x4<f16>": { align: 8, size: 24 }, "mat4x4<f32>": { align: 16, size: 64 }, "mat4x4<f16>": { align: 8, size: 32 } }; function vg(s) { const e = s.map(r => ({ data: r, offset: 0, size: 0 })); let t = 0; for (let r = 0; r < e.length; r++) { const i = e[r]; let n = Gr[i.data.type].size; const a = Gr[i.data.type].align; if (!Gr[i.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${i.data.type}`); i.data.size > 1 && (n = Math.max(n, a) * i.data.size), t = Math.ceil(t / a) * a, i.size = n, i.offset = t, t += n } return t = Math.ceil(t / 16) * 16, { uboElements: e, size: t } } function Tg(s, e) {
  const { size: t, align: r } = Gr[s.data.type], i = (r - t) / 4, n = s.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data"; return `
         v = uv.${s.data.name};
         ${e !== 0 ? `offset += ${e};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${s.data.size * (t / 4)}; i++)
         {
             for(var j = 0; j < ${t / 4}; j++)
             {
                 ${n}[arrayOffset++] = v[t++];
             }
             ${i !== 0 ? `arrayOffset += ${i};` : ""}
         }
     `} function Sg(s) { return Zh(s, "uboWgsl", Tg, pm) } class Ll extends Kh { constructor() { super({ createUboElements: vg, generateUboSync: Sg }) } } Ll.extension = { type: [b.WebGPUSystem], name: "ubo" }; const Qe = 128; class Nl { constructor(e) { this._bindGroupHash = Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"), this._batchBuffer = new bg({ minUniformOffsetAlignment: Qe }); const t = 256 / Qe; for (let r = 0; r < t; r++) { let i = Y.UNIFORM | Y.COPY_DST; r === 0 && (i |= Y.COPY_SRC), this._buffers.push(new Ee({ data: this._batchBuffer.data, usage: i })) } } renderEnd() { this._uploadBindGroups(), this._resetBindGroups() } _resetBindGroups() { for (const e in this._bindGroupHash) this._bindGroupHash[e] = null; this._batchBuffer.clear() } getUniformBindGroup(e, t) { if (!t && this._bindGroupHash[e.uid]) return this._bindGroupHash[e.uid]; this._renderer.ubo.ensureUniformGroup(e); const r = e.buffer.data, i = this._batchBuffer.addEmptyGroup(r.length); return this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, i / 4), this._bindGroupHash[e.uid] = this._getBindGroup(i / Qe), this._bindGroupHash[e.uid] } getUboResource(e) { this._renderer.ubo.updateUniformGroup(e); const t = e.buffer.data, r = this._batchBuffer.addGroup(t); return this._getBufferResource(r / Qe) } getArrayBindGroup(e) { const t = this._batchBuffer.addGroup(e); return this._getBindGroup(t / Qe) } getArrayBufferResource(e) { const r = this._batchBuffer.addGroup(e) / Qe; return this._getBufferResource(r) } _getBufferResource(e) { if (!this._bufferResources[e]) { const t = this._buffers[e % 2]; this._bufferResources[e] = new Ki({ buffer: t, offset: (e / 2 | 0) * 256, size: Qe }) } return this._bufferResources[e] } _getBindGroup(e) { if (!this._bindGroups[e]) { const t = new qe({ 0: this._getBufferResource(e) }); this._bindGroups[e] = t } return this._bindGroups[e] } _uploadBindGroups() { const e = this._renderer.buffer, t = this._buffers[0]; t.update(this._batchBuffer.byteIndex), e.updateBuffer(t); const r = this._renderer.gpu.device.createCommandEncoder(); for (let i = 1; i < this._buffers.length; i++) { const n = this._buffers[i]; r.copyBufferToBuffer(e.getGPUBuffer(t), Qe, e.getGPUBuffer(n), 0, this._batchBuffer.byteIndex) } this._renderer.gpu.device.queue.submit([r.finish()]) } destroy() { for (let e = 0; e < this._bindGroups.length; e++)this._bindGroups[e].destroy(); this._bindGroups = null, this._bindGroupHash = null; for (let e = 0; e < this._buffers.length; e++)this._buffers[e].destroy(); this._buffers = null; for (let e = 0; e < this._bufferResources.length; e++)this._bufferResources[e].destroy(); this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null } } Nl.extension = { type: [b.WebGPUPipes], name: "uniformBatch" }; const wg = { "point-list": 0, "line-list": 1, "line-strip": 2, "triangle-list": 3, "triangle-strip": 4 }; function Ag(s, e, t, r, i) { return s << 24 | e << 16 | t << 10 | r << 5 | i } function Pg(s, e, t, r) { return t << 6 | s << 3 | r << 1 | e } class Hl { constructor(e) { this._moduleCache = Object.create(null), this._bufferLayoutsCache = Object.create(null), this._bindingNamesCache = Object.create(null), this._pipeCache = Object.create(null), this._pipeStateCaches = Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = e } contextChange(e) { this._gpu = e, this.setStencilMode(de.DISABLED), this._updatePipeHash() } setMultisampleCount(e) { this._multisampleCount !== e && (this._multisampleCount = e, this._updatePipeHash()) } setRenderTarget(e) { this._multisampleCount = e.msaaSamples, this._depthStencilAttachment = e.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash() } setColorMask(e) { this._colorMask !== e && (this._colorMask = e, this._updatePipeHash()) } setStencilMode(e) { this._stencilMode !== e && (this._stencilMode = e, this._stencilState = at[e], this._updatePipeHash()) } setPipeline(e, t, r, i) { const n = this.getPipeline(e, t, r); i.setPipeline(n) } getPipeline(e, t, r, i) { e._layoutKey || (zh(e, t.attributeData), this._generateBufferKey(e)), i || (i = e.topology); const n = Ag(e._layoutKey, t._layoutKey, r.data, r._blendModeId, wg[i]); return this._pipeCache[n] ? this._pipeCache[n] : (this._pipeCache[n] = this._createPipeline(e, t, r, i), this._pipeCache[n]) } _createPipeline(e, t, r, i) { const n = this._gpu.device, a = this._createVertexBufferLayouts(e, t), o = this._renderer.state.getColorTargets(r); o[0].writeMask = this._stencilMode === de.RENDERING_MASK_ADD ? 0 : this._colorMask; const h = this._renderer.shader.getProgramData(t).pipeline, l = { vertex: { module: this._getModule(t.vertex.source), entryPoint: t.vertex.entryPoint, buffers: a }, fragment: { module: this._getModule(t.fragment.source), entryPoint: t.fragment.entryPoint, targets: o }, primitive: { topology: i, cullMode: r.cullMode }, layout: h, multisample: { count: this._multisampleCount }, label: "PIXI Pipeline" }; return this._depthStencilAttachment && (l.depthStencil = { ...this._stencilState, format: "depth24plus-stencil8", depthWriteEnabled: r.depthTest, depthCompare: r.depthTest ? "less" : "always" }), n.createRenderPipeline(l) } _getModule(e) { return this._moduleCache[e] || this._createModule(e) } _createModule(e) { const t = this._gpu.device; return this._moduleCache[e] = t.createShaderModule({ code: e }), this._moduleCache[e] } _generateBufferKey(e) { const t = []; let r = 0; const i = Object.keys(e.attributes).sort(); for (let a = 0; a < i.length; a++) { const o = e.attributes[i[a]]; t[r++] = o.offset, t[r++] = o.format, t[r++] = o.stride, t[r++] = o.instance } const n = t.join("|"); return e._layoutKey = Jt(n, "geometry"), e._layoutKey } _generateAttributeLocationsKey(e) { const t = []; let r = 0; const i = Object.keys(e.attributeData).sort(); for (let a = 0; a < i.length; a++) { const o = e.attributeData[i[a]]; t[r++] = o.location } const n = t.join("|"); return e._attributeLocationsKey = Jt(n, "programAttributes"), e._attributeLocationsKey } getBufferNamesToBind(e, t) { const r = e._layoutKey << 16 | t._attributeLocationsKey; if (this._bindingNamesCache[r]) return this._bindingNamesCache[r]; const i = this._createVertexBufferLayouts(e, t), n = Object.create(null), a = t.attributeData; for (let o = 0; o < i.length; o++) { const l = Object.values(i[o].attributes)[0].shaderLocation; for (const c in a) if (a[c].location === l) { n[o] = c; break } } return this._bindingNamesCache[r] = n, n } _createVertexBufferLayouts(e, t) { t._attributeLocationsKey || this._generateAttributeLocationsKey(t); const r = e._layoutKey << 16 | t._attributeLocationsKey; if (this._bufferLayoutsCache[r]) return this._bufferLayoutsCache[r]; const i = []; return e.buffers.forEach(n => { const a = { arrayStride: 0, stepMode: "vertex", attributes: [] }, o = a.attributes; for (const h in t.attributeData) { const l = e.attributes[h]; (l.divisor ?? 1) !== 1 && H(`Attribute ${h} has an invalid divisor value of '${l.divisor}'. WebGPU only supports a divisor value of 1`), l.buffer === n && (a.arrayStride = l.stride, a.stepMode = l.instance ? "instance" : "vertex", o.push({ shaderLocation: t.attributeData[h].location, offset: l.offset, format: l.format })) } o.length && i.push(a) }), this._bufferLayoutsCache[r] = i, i } _updatePipeHash() { const e = Pg(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment); this._pipeStateCaches[e] || (this._pipeStateCaches[e] = Object.create(null)), this._pipeCache = this._pipeStateCaches[e] } destroy() { this._renderer = null, this._bufferLayoutsCache = null } } Hl.extension = { type: [b.WebGPUSystem], name: "pipeline" }; class Eg { constructor() { this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1 } } class Cg { init(e, t) { this._renderer = e, this._renderTargetSystem = t } copyToTexture(e, t, r, i, n) { const a = this._renderer, o = this._getGpuColorTexture(e), h = a.texture.getGpuSource(t.source); return a.encoder.commandEncoder.copyTextureToTexture({ texture: o, origin: r }, { texture: h, origin: n }, i), t } startRenderPass(e, t = !0, r, i) { const a = this._renderTargetSystem.getGpuRenderTarget(e), o = this.getDescriptor(e, t, r); a.descriptor = o, this._renderer.pipeline.setRenderTarget(a), this._renderer.encoder.beginRenderPass(a), this._renderer.encoder.setViewport(i) } finishRenderPass() { this._renderer.encoder.endRenderPass() } _getGpuColorTexture(e) { const t = this._renderTargetSystem.getGpuRenderTarget(e); return t.contexts[0] ? t.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(e.colorTextures[0].source) } getDescriptor(e, t, r) { typeof t == "boolean" && (t = t ? Ae.ALL : Ae.NONE); const i = this._renderTargetSystem, n = i.getGpuRenderTarget(e), a = e.colorTextures.map((l, c) => { const u = n.contexts[c]; let d, f; u ? d = u.getCurrentTexture().createView() : d = this._renderer.texture.getGpuSource(l).createView({ mipLevelCount: 1 }), n.msaaTextures[c] && (f = d, d = this._renderer.texture.getTextureView(n.msaaTextures[c])); const p = t & Ae.COLOR ? "clear" : "load"; return r ?? (r = i.defaultClearColor), { view: d, resolveTarget: f, clearValue: r, storeOp: "store", loadOp: p } }); let o; if ((e.stencil || e.depth) && !e.depthStencilTexture && (e.ensureDepthStencilTexture(), e.depthStencilTexture.source.sampleCount = n.msaa ? 4 : 1), e.depthStencilTexture) { const l = t & Ae.STENCIL ? "clear" : "load", c = t & Ae.DEPTH ? "clear" : "load"; o = { view: this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(), stencilStoreOp: "store", stencilLoadOp: l, depthClearValue: 1, depthLoadOp: c, depthStoreOp: "store" } } return { colorAttachments: a, depthStencilAttachment: o } } clear(e, t = !0, r, i) { if (!t) return; const { gpu: n, encoder: a } = this._renderer, o = n.device; if (a.commandEncoder === null) { const l = o.createCommandEncoder(), c = this.getDescriptor(e, t, r), u = l.beginRenderPass(c); u.setViewport(i.x, i.y, i.width, i.height, 0, 1), u.end(); const d = l.finish(); o.queue.submit([d]) } else this.startRenderPass(e, t, r, i) } initGpuRenderTarget(e) { e.isRoot = !0; const t = new Eg; return e.colorTextures.forEach((r, i) => { if (Ke.test(r.resource)) { const n = r.resource.getContext("webgpu"), a = r.transparent ? "premultiplied" : "opaque"; try { n.configure({ device: this._renderer.gpu.device, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC, format: "bgra8unorm", alphaMode: a }) } catch (o) { console.error(o) } t.contexts[i] = n } if (t.msaa = r.source.antialias, r.source.antialias) { const n = new ge({ width: 0, height: 0, sampleCount: 4 }); t.msaaTextures[i] = n } }), t.msaa && (t.msaaSamples = 4, e.depthStencilTexture && (e.depthStencilTexture.source.sampleCount = 4)), t } destroyGpuRenderTarget(e) { e.contexts.forEach(t => { t.unconfigure() }), e.msaaTextures.forEach(t => { t.destroy() }), e.msaaTextures.length = 0, e.contexts.length = 0 } ensureDepthStencilTexture(e) { const t = this._renderTargetSystem.getGpuRenderTarget(e); e.depthStencilTexture && t.msaa && (e.depthStencilTexture.source.sampleCount = 4) } resizeGpuRenderTarget(e) { const t = this._renderTargetSystem.getGpuRenderTarget(e); t.width = e.width, t.height = e.height, t.msaa && e.colorTextures.forEach((r, i) => { const n = t.msaaTextures[i]; n == null || n.resize(r.source.width, r.source.height, r.source._resolution) }) } } class zl extends sl { constructor(e) { super(e), this.adaptor = new Cg, this.adaptor.init(e, this) } } zl.extension = { type: [b.WebGPUSystem], name: "renderTarget" }; class Wl { constructor() { this._gpuProgramData = Object.create(null) } contextChange(e) { this._gpu = e, this.maxTextures = e.device.limits.maxSampledTexturesPerShaderStage } getProgramData(e) { return this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e) } _createGPUProgramData(e) { const t = this._gpu.device, r = e.gpuLayout.map(n => t.createBindGroupLayout({ entries: n })), i = { bindGroupLayouts: r }; return this._gpuProgramData[e._layoutKey] = { bindGroups: r, pipeline: t.createPipelineLayout(i) }, this._gpuProgramData[e._layoutKey] } destroy() { this._gpu = null, this._gpuProgramData = null } } Wl.extension = { type: [b.WebGPUSystem], name: "shader" }; const Te = {}; Te.normal = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" } }; Te.add = { alpha: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one", operation: "add" } }; Te.multiply = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "dst", dstFactor: "one-minus-src-alpha", operation: "add" } }; Te.screen = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }; Te.overlay = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" } }; Te.none = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "zero", operation: "add" } }; Te["normal-npm"] = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" } }; Te["add-npm"] = { alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" } }; Te["screen-npm"] = { alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "src-alpha", dstFactor: "one-minus-src", operation: "add" } }; Te.erase = { alpha: { srcFactor: "zero", dstFactor: "one-minus-src-alpha", operation: "add" }, color: { srcFactor: "zero", dstFactor: "one-minus-src", operation: "add" } }; Te.min = { alpha: { srcFactor: "one", dstFactor: "one", operation: "min" }, color: { srcFactor: "one", dstFactor: "one", operation: "min" } }; Te.max = { alpha: { srcFactor: "one", dstFactor: "one", operation: "max" }, color: { srcFactor: "one", dstFactor: "one", operation: "max" } }; class Vl { constructor() { this.defaultState = new Oe, this.defaultState.blend = !0 } contextChange(e) { this.gpu = e } getColorTargets(e) { return [{ format: "bgra8unorm", writeMask: 0, blend: Te[e.blendMode] || Te.normal }] } destroy() { this.gpu = null } } Vl.extension = { type: [b.WebGPUSystem], name: "state" }; const Mg = { type: "image", upload(s, e, t) { const r = s.resource, i = (s.pixelWidth | 0) * (s.pixelHeight | 0), n = r.byteLength / i; t.device.queue.writeTexture({ texture: e }, r, { offset: 0, rowsPerImage: s.pixelHeight, bytesPerRow: s.pixelHeight * n }, { width: s.pixelWidth, height: s.pixelHeight, depthOrArrayLayers: 1 }) } }, $l = { "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 }, "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }, "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 } }, Bg = { blockBytes: 4, blockWidth: 1, blockHeight: 1 }, Rg = { type: "compressed", upload(s, e, t) { let r = s.pixelWidth, i = s.pixelHeight; const n = $l[s.format] || Bg; for (let a = 0; a < s.resource.length; a++) { const o = s.resource[a], h = Math.ceil(r / n.blockWidth) * n.blockBytes; t.device.queue.writeTexture({ texture: e, mipLevel: a }, o, { offset: 0, bytesPerRow: h }, { width: Math.ceil(r / n.blockWidth) * n.blockWidth, height: Math.ceil(i / n.blockHeight) * n.blockHeight, depthOrArrayLayers: 1 }), r = Math.max(r >> 1, 1), i = Math.max(i >> 1, 1) } } }, Xl = { type: "image", upload(s, e, t) { const r = s.resource; if (!r) return; const i = Math.min(e.width, s.resourceWidth || s.pixelWidth), n = Math.min(e.height, s.resourceHeight || s.pixelHeight), a = s.alphaMode === "premultiply-alpha-on-upload"; t.device.queue.copyExternalImageToTexture({ source: r }, { texture: e, premultipliedAlpha: a }, { width: i, height: n }) } }, kg = { type: "video", upload(s, e, t) { Xl.upload(s, e, t) } }; class Ig {
  constructor(e) { this.device = e, this.sampler = e.createSampler({ minFilter: "linear" }), this.pipelines = {} } _getMipmapPipeline(e) {
    let t = this.pipelines[e]; return t || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
      code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})), t = this.device.createRenderPipeline({ layout: "auto", vertex: { module: this.mipmapShaderModule, entryPoint: "vertexMain" }, fragment: { module: this.mipmapShaderModule, entryPoint: "fragmentMain", targets: [{ format: e }] } }), this.pipelines[e] = t), t
  } generateMipmap(e) { const t = this._getMipmapPipeline(e.format); if (e.dimension === "3d" || e.dimension === "1d") throw new Error("Generating mipmaps for non-2d textures is currently unsupported!"); let r = e; const i = e.depthOrArrayLayers || 1, n = e.usage & GPUTextureUsage.RENDER_ATTACHMENT; if (!n) { const h = { size: { width: Math.ceil(e.width / 2), height: Math.ceil(e.height / 2), depthOrArrayLayers: i }, format: e.format, usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT, mipLevelCount: e.mipLevelCount - 1 }; r = this.device.createTexture(h) } const a = this.device.createCommandEncoder({}), o = t.getBindGroupLayout(0); for (let h = 0; h < i; ++h) { let l = e.createView({ baseMipLevel: 0, mipLevelCount: 1, dimension: "2d", baseArrayLayer: h, arrayLayerCount: 1 }), c = n ? 1 : 0; for (let u = 1; u < e.mipLevelCount; ++u) { const d = r.createView({ baseMipLevel: c++, mipLevelCount: 1, dimension: "2d", baseArrayLayer: h, arrayLayerCount: 1 }), f = a.beginRenderPass({ colorAttachments: [{ view: d, storeOp: "store", loadOp: "clear", clearValue: { r: 0, g: 0, b: 0, a: 0 } }] }), p = this.device.createBindGroup({ layout: o, entries: [{ binding: 0, resource: this.sampler }, { binding: 1, resource: l }] }); f.setPipeline(t), f.setBindGroup(0, p), f.draw(3, 1, 0, 0), f.end(), l = d } } if (!n) { const h = { width: Math.ceil(e.width / 2), height: Math.ceil(e.height / 2), depthOrArrayLayers: i }; for (let l = 1; l < e.mipLevelCount; ++l)a.copyTextureToTexture({ texture: r, mipLevel: l - 1 }, { texture: e, mipLevel: l }, h), h.width = Math.ceil(h.width / 2), h.height = Math.ceil(h.height / 2) } return this.device.queue.submit([a.finish()]), n || r.destroy(), e }
} class jl { constructor(e) { this.managedTextures = [], this._gpuSources = Object.create(null), this._gpuSamplers = Object.create(null), this._bindGroupHash = Object.create(null), this._textureViewHash = Object.create(null), this._uploads = { image: Xl, buffer: Mg, video: kg, compressed: Rg }, this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuSources"), e.renderableGC.addManagedHash(this, "_gpuSamplers"), e.renderableGC.addManagedHash(this, "_bindGroupHash"), e.renderableGC.addManagedHash(this, "_textureViewHash") } contextChange(e) { this._gpu = e } initSource(e) { if (e.autoGenerateMipmaps) { const h = Math.max(e.pixelWidth, e.pixelHeight); e.mipLevelCount = Math.floor(Math.log2(h)) + 1 } let t = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST; e.uploadMethodId !== "compressed" && (t |= GPUTextureUsage.RENDER_ATTACHMENT, t |= GPUTextureUsage.COPY_SRC); const r = $l[e.format] || { blockWidth: 1, blockHeight: 1 }, i = Math.ceil(e.pixelWidth / r.blockWidth) * r.blockWidth, n = Math.ceil(e.pixelHeight / r.blockHeight) * r.blockHeight, a = { label: e.label, size: { width: i, height: n }, format: e.format, sampleCount: e.sampleCount, mipLevelCount: e.mipLevelCount, dimension: e.dimension, usage: t }, o = this._gpu.device.createTexture(a); return this._gpuSources[e.uid] = o, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceResize, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), o } onSourceUpdate(e) { const t = this.getGpuSource(e); t && (this._uploads[e.uploadMethodId] && this._uploads[e.uploadMethodId].upload(e, t, this._gpu), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e)) } onSourceUnload(e) { const t = this._gpuSources[e.uid]; t && (this._gpuSources[e.uid] = null, t.destroy()) } onUpdateMipmaps(e) { this._mipmapGenerator || (this._mipmapGenerator = new Ig(this._gpu.device)); const t = this.getGpuSource(e); this._mipmapGenerator.generateMipmap(t) } onSourceDestroy(e) { e.off("update", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("destroy", this.onSourceDestroy, this), e.off("resize", this.onSourceResize, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e) } onSourceResize(e) { const t = this._gpuSources[e.uid]; t ? (t.width !== e.pixelWidth || t.height !== e.pixelHeight) && (this._textureViewHash[e.uid] = null, this._bindGroupHash[e.uid] = null, this.onSourceUnload(e), this.initSource(e)) : this.initSource(e) } _initSampler(e) { return this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e), this._gpuSamplers[e._resourceId] } getGpuSampler(e) { return this._gpuSamplers[e._resourceId] || this._initSampler(e) } getGpuSource(e) { return this._gpuSources[e.uid] || this.initSource(e) } getTextureBindGroup(e) { return this._bindGroupHash[e.uid] ?? this._createTextureBindGroup(e) } _createTextureBindGroup(e) { const t = e.source; return this._bindGroupHash[e.uid] = new qe({ 0: t, 1: t.style, 2: new be({ uTextureMatrix: { type: "mat3x3<f32>", value: e.textureMatrix.mapCoord } }) }), this._bindGroupHash[e.uid] } getTextureView(e) { const t = e.source; return this._textureViewHash[t.uid] ?? this._createTextureView(t) } _createTextureView(e) { return this._textureViewHash[e.uid] = this.getGpuSource(e).createView(), this._textureViewHash[e.uid] } generateCanvas(e) { const t = this._renderer, r = t.gpu.device.createCommandEncoder(), i = K.get().createCanvas(); i.width = e.source.pixelWidth, i.height = e.source.pixelHeight; const n = i.getContext("webgpu"); return n.configure({ device: t.gpu.device, usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC, format: K.get().getNavigator().gpu.getPreferredCanvasFormat(), alphaMode: "premultiplied" }), r.copyTextureToTexture({ texture: t.texture.getGpuSource(e.source), origin: { x: 0, y: 0 } }, { texture: n.getCurrentTexture() }, { width: i.width, height: i.height }), t.gpu.device.queue.submit([r.finish()]), i } getPixels(e) { const t = this.generateCanvas(e), r = Ze.getOptimalCanvasAndContext(t.width, t.height), i = r.context; i.drawImage(t, 0, 0); const { width: n, height: a } = t, o = i.getImageData(0, 0, n, a), h = new Uint8ClampedArray(o.data.buffer); return Ze.returnCanvasAndContext(r), { pixels: h, width: n, height: a } } destroy() { this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)), this.managedTextures = null; for (const e of Object.keys(this._bindGroupHash)) { const t = Number(e), r = this._bindGroupHash[t]; r == null || r.destroy(), this._bindGroupHash[t] = null } this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null } } jl.extension = { type: [b.WebGPUSystem], name: "texture" }; class Yl { init() { const e = new be({ uTransformMatrix: { value: new D, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), t = nr({ name: "graphics", bits: [Ci, Bi(It()), em, or] }); this.shader = new ke({ gpuProgram: t, resources: { localUniforms: e } }) } execute(e, t) { const r = t.context, i = r.customShader || this.shader, n = e.renderer, a = n.graphicsContext, { batcher: o, instructions: h } = a.getContextRenderData(r), l = n.encoder; l.setGeometry(o.geometry, i.gpuProgram); const c = n.globalUniforms.bindGroup; l.setBindGroup(0, c, i.gpuProgram); const u = n.renderPipes.uniformBatch.getUniformBindGroup(i.resources.localUniforms, !0); l.setBindGroup(2, u, i.gpuProgram); const d = h.instructions; let f = null; for (let p = 0; p < h.instructionSize; p++) { const g = d[p]; if (g.topology !== f && (f = g.topology, l.setPipelineFromGeometryProgramAndState(o.geometry, i.gpuProgram, e.state, g.topology)), i.groups[1] = g.bindGroup, !g.gpuBindGroup) { const m = g.textures; g.bindGroup = Ei(m.textures, m.count), g.gpuBindGroup = n.bindGroup.getBindGroup(g.bindGroup, i.gpuProgram, 1) } l.setBindGroup(1, g.bindGroup, i.gpuProgram), l.renderPassEncoder.drawIndexed(g.size, 1, g.start) } } destroy() { this.shader.destroy(!0), this.shader = null } } Yl.extension = { type: [b.WebGPUPipesAdaptor], name: "graphics" }; class Kl { init() { const e = nr({ name: "mesh", bits: [qt, tm, or] }); this._shader = new ke({ gpuProgram: e, resources: { uTexture: F.EMPTY._source, uSampler: F.EMPTY._source.style, textureUniforms: { uTextureMatrix: { type: "mat3x3<f32>", value: new D } } } }) } execute(e, t) { const r = e.renderer; let i = t._shader; if (!i) i = this._shader, i.groups[2] = r.texture.getTextureBindGroup(t.texture); else if (!i.gpuProgram) { H("Mesh shader has no gpuProgram", t.shader); return } const n = i.gpuProgram; if (n.autoAssignGlobalUniforms && (i.groups[0] = r.globalUniforms.bindGroup), n.autoAssignLocalUniforms) { const a = e.localUniforms; i.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(a, !0) } r.encoder.draw({ geometry: t._geometry, shader: i, state: t.state }) } destroy() { this._shader.destroy(!0), this._shader = null } } Kl.extension = { type: [b.WebGPUPipesAdaptor], name: "mesh" }; const Gg = [...Ml, Ll, Dl, sn, Fl, jl, zl, Wl, Vl, Hl, Ul, Ol, Gl], Fg = [...Bl, Nl], Ug = [Gh, Kl, Yl], ql = [], Zl = [], Ql = []; z.handleByNamedList(b.WebGPUSystem, ql); z.handleByNamedList(b.WebGPUPipes, Zl); z.handleByNamedList(b.WebGPUPipesAdaptor, Ql); z.add(...Gg, ...Fg, ...Ug); class Dg extends Yr { constructor() { const e = { name: "webgpu", type: De.WEBGPU, systems: ql, renderPipes: Zl, renderPipeAdaptors: Ql }; super(e) } } const Og = Object.freeze(Object.defineProperty({ __proto__: null, WebGPURenderer: Dg }, Symbol.toStringTag, { value: "Module" })); class Jl { constructor(e, t) { this.state = Oe.for2d(), this._graphicsBatchesHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.renderer = e, this._adaptor = t, this._adaptor.init(), this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash") } validateRenderable(e) { const t = e.context, r = !!this._graphicsBatchesHash[e.uid], i = this.renderer.graphicsContext.updateGpuContext(t); return !!(i.isBatchable || r !== i.isBatchable) } addRenderable(e, t) { const r = this.renderer.graphicsContext.updateGpuContext(e.context); e.didViewUpdate && this._rebuild(e), r.isBatchable ? this._addToBatcher(e, t) : (this.renderer.renderPipes.batch.break(t), t.add(e)) } updateRenderable(e) { const t = this._graphicsBatchesHash[e.uid]; if (t) for (let r = 0; r < t.length; r++) { const i = t[r]; i._batcher.updateElement(i) } } destroyRenderable(e) { this._graphicsBatchesHash[e.uid] && this._removeBatchForRenderable(e.uid), e.off("destroyed", this._destroyRenderableBound) } execute(e) { if (!e.isRenderable) return; const t = this.renderer, r = e.context; if (!t.graphicsContext.getGpuContext(r).batches.length) return; const n = r.customShader || this._adaptor.shader; this.state.blendMode = e.groupBlendMode; const a = n.resources.localUniforms.uniforms; a.uTransformMatrix = e.groupTransform, a.uRound = t._roundPixels | e._roundPixels, lr(e.groupColorAlpha, a.uColor, 0), this._adaptor.execute(this, e) } _rebuild(e) { const t = !!this._graphicsBatchesHash[e.uid], r = this.renderer.graphicsContext.updateGpuContext(e.context); t && this._removeBatchForRenderable(e.uid), r.isBatchable && this._initBatchesForRenderable(e), e.batched = r.isBatchable } _addToBatcher(e, t) { const r = this.renderer.renderPipes.batch, i = this._getBatchesForRenderable(e); for (let n = 0; n < i.length; n++) { const a = i[n]; r.addToBatch(a, t) } } _getBatchesForRenderable(e) { return this._graphicsBatchesHash[e.uid] || this._initBatchesForRenderable(e) } _initBatchesForRenderable(e) { const t = e.context, r = this.renderer.graphicsContext.getGpuContext(t), i = this.renderer._roundPixels | e._roundPixels, n = r.batches.map(a => { const o = j.get(Gi); return a.copyTo(o), o.renderable = e, o.roundPixels = i, o }); return this._graphicsBatchesHash[e.uid] === void 0 && e.on("destroyed", this._destroyRenderableBound), this._graphicsBatchesHash[e.uid] = n, n } _removeBatchForRenderable(e) { this._graphicsBatchesHash[e].forEach(t => { j.return(t) }), this._graphicsBatchesHash[e] = null } destroy() { this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null; for (const e in this._graphicsBatchesHash) this._removeBatchForRenderable(e); this._graphicsBatchesHash = null } } Jl.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "graphics" }; const ec = class tc extends Wi { constructor(...e) { super({}); let t = e[0] ?? {}; typeof t == "number" && (X(ee, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), t = { width: t, height: e[1], verticesX: e[2], verticesY: e[3] }), this.build(t) } build(e) { e = { ...tc.defaultOptions, ...e }, this.verticesX = this.verticesX ?? e.verticesX, this.verticesY = this.verticesY ?? e.verticesY, this.width = this.width ?? e.width, this.height = this.height ?? e.height; const t = this.verticesX * this.verticesY, r = [], i = [], n = [], a = this.verticesX - 1, o = this.verticesY - 1, h = this.width / a, l = this.height / o; for (let u = 0; u < t; u++) { const d = u % this.verticesX, f = u / this.verticesX | 0; r.push(d * h, f * l), i.push(d / a, f / o) } const c = a * o; for (let u = 0; u < c; u++) { const d = u % a, f = u / a | 0, p = f * this.verticesX + d, g = f * this.verticesX + d + 1, m = (f + 1) * this.verticesX + d, y = (f + 1) * this.verticesX + d + 1; n.push(p, g, m, g, y, m) } this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(i), this.indexBuffer.data = new Uint32Array(n), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update() } }; ec.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 }; let Lg = ec; class nn { constructor() { this.batcherName = "default", this.packAsQuad = !1, this.indexOffset = 0, this.attributeOffset = 0, this.roundPixels = 0, this._batcher = null, this._batch = null, this._textureMatrixUpdateId = -1, this._uvUpdateId = -1 } get blendMode() { return this.renderable.groupBlendMode } get topology() { return this._topology || this.geometry.topology } set topology(e) { this._topology = e } reset() { this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.geometry = null, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1 } setTexture(e) { this.texture !== e && (this.texture = e, this._textureMatrixUpdateId = -1) } get uvs() { const t = this.geometry.getBuffer("aUV"), r = t.data; let i = r; const n = this.texture.textureMatrix; return n.isSimple || (i = this._transformedUvs, (this._textureMatrixUpdateId !== n._updateID || this._uvUpdateId !== t._updateID) && ((!i || i.length < r.length) && (i = this._transformedUvs = new Float32Array(r.length)), this._textureMatrixUpdateId = n._updateID, this._uvUpdateId = t._updateID, n.multiplyUvs(r, i))), i } get positions() { return this.geometry.positions } get indices() { return this.geometry.indices } get color() { return this.renderable.groupColorAlpha } get groupTransform() { return this.renderable.groupTransform } get attributeSize() { return this.geometry.positions.length / 2 } get indexSize() { return this.geometry.indices.length } } class rc { constructor(e, t) { this.localUniforms = new be({ uTransformMatrix: { value: new D, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), this.localUniformsBindGroup = new qe({ 0: this.localUniforms }), this._meshDataHash = Object.create(null), this._gpuBatchableMeshHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.renderer = e, this._adaptor = t, this._adaptor.init(), e.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash"), e.renderableGC.addManagedHash(this, "_meshDataHash") } validateRenderable(e) { const t = this._getMeshData(e), r = t.batched, i = e.batched; if (t.batched = i, r !== i) return !0; if (i) { const n = e._geometry; if (n.indices.length !== t.indexSize || n.positions.length !== t.vertexSize) return t.indexSize = n.indices.length, t.vertexSize = n.positions.length, !0; const a = this._getBatchableMesh(e); return a.texture.uid !== e._texture.uid && (a._textureMatrixUpdateId = -1), !a._batcher.checkAndUpdateTexture(a, e._texture) } return !1 } addRenderable(e, t) { const r = this.renderer.renderPipes.batch, { batched: i } = this._getMeshData(e); if (i) { const n = this._getBatchableMesh(e); n.setTexture(e._texture), n.geometry = e._geometry, r.addToBatch(n, t) } else r.break(t), t.add(e) } updateRenderable(e) { if (e.batched) { const t = this._gpuBatchableMeshHash[e.uid]; t.setTexture(e._texture), t.geometry = e._geometry, t._batcher.updateElement(t) } } destroyRenderable(e) { this._meshDataHash[e.uid] = null; const t = this._gpuBatchableMeshHash[e.uid]; t && (j.return(t), this._gpuBatchableMeshHash[e.uid] = null), e.off("destroyed", this._destroyRenderableBound) } execute(e) { if (!e.isRenderable) return; e.state.blendMode = er(e.groupBlendMode, e.texture._source); const t = this.localUniforms; t.uniforms.uTransformMatrix = e.groupTransform, t.uniforms.uRound = this.renderer._roundPixels | e._roundPixels, t.update(), lr(e.groupColorAlpha, t.uniforms.uColor, 0), this._adaptor.execute(this, e) } _getMeshData(e) { return this._meshDataHash[e.uid] || this._initMeshData(e) } _initMeshData(e) { var t, r; return this._meshDataHash[e.uid] = { batched: e.batched, indexSize: (t = e._geometry.indices) == null ? void 0 : t.length, vertexSize: (r = e._geometry.positions) == null ? void 0 : r.length }, e.on("destroyed", this._destroyRenderableBound), this._meshDataHash[e.uid] } _getBatchableMesh(e) { return this._gpuBatchableMeshHash[e.uid] || this._initBatchableMesh(e) } _initBatchableMesh(e) { const t = j.get(nn); return t.renderable = e, t.setTexture(e._texture), t.transform = e.groupTransform, t.roundPixels = this.renderer._roundPixels | e._roundPixels, this._gpuBatchableMeshHash[e.uid] = t, t } destroy() { for (const e in this._gpuBatchableMeshHash) this._gpuBatchableMeshHash[e] && j.return(this._gpuBatchableMeshHash[e]); this._gpuBatchableMeshHash = null, this._meshDataHash = null, this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null } } rc.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "mesh" }; class Ng { execute(e, t) { const r = e.state, i = e.renderer, n = t.shader || e.defaultShader; n.resources.uTexture = t.texture._source, n.resources.uniforms = e.localUniforms; const a = i.gl, o = e.getBuffers(t); i.shader.bind(n), i.state.set(r), i.geometry.bind(o.geometry, n.glProgram); const l = o.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? a.UNSIGNED_SHORT : a.UNSIGNED_INT; a.drawElements(a.TRIANGLES, t.particleChildren.length * 6, l, 0) } } class Hg { execute(e, t) { const r = e.renderer, i = t.shader || e.defaultShader; i.groups[0] = r.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms, !0), i.groups[1] = r.texture.getTextureBindGroup(t.texture); const n = e.state, a = e.getBuffers(t); r.encoder.draw({ geometry: a.geometry, shader: t.shader || e.defaultShader, state: n, size: t.particleChildren.length * 6 }) } } function Wa(s, e = null) { const t = s * 6; if (t > 65535 ? e || (e = new Uint32Array(t)) : e || (e = new Uint16Array(t)), e.length !== t) throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${t}`); for (let r = 0, i = 0; r < t; r += 6, i += 4)e[r + 0] = i + 0, e[r + 1] = i + 1, e[r + 2] = i + 2, e[r + 3] = i + 0, e[r + 4] = i + 2, e[r + 5] = i + 3; return e } function zg(s) { return { dynamicUpdate: Va(s, !0), staticUpdate: Va(s, !1) } } function Va(s, e) {
  const t = []; t.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `); let r = 0; for (const n in s) { const a = s[n]; if (e !== a.dynamic) continue; t.push(`offset = index + ${r}`), t.push(a.code); const o = rt(a.format); r += o.stride / 4 } t.push(`
            index += stride * 4;
        }
    `), t.unshift(`
        var stride = ${r};
    `); const i = t.join(`
`); return new Function("ps", "f32v", "u32v", i)
} class Wg { constructor(e) { this._size = 0, this._generateParticleUpdateCache = {}; const t = this._size = e.size ?? 1e3, r = e.properties; let i = 0, n = 0; for (const c in r) { const u = r[c], d = rt(u.format); u.dynamic ? n += d.stride : i += d.stride } this._dynamicStride = n / 4, this._staticStride = i / 4, this.staticAttributeBuffer = new Tt(t * 4 * i), this.dynamicAttributeBuffer = new Tt(t * 4 * n), this.indexBuffer = Wa(t); const a = new ir; let o = 0, h = 0; this._staticBuffer = new Ee({ data: new Float32Array(1), label: "static-particle-buffer", shrinkToFit: !1, usage: Y.VERTEX | Y.COPY_DST }), this._dynamicBuffer = new Ee({ data: new Float32Array(1), label: "dynamic-particle-buffer", shrinkToFit: !1, usage: Y.VERTEX | Y.COPY_DST }); for (const c in r) { const u = r[c], d = rt(u.format); u.dynamic ? (a.addAttribute(u.attributeName, { buffer: this._dynamicBuffer, stride: this._dynamicStride * 4, offset: o * 4, format: u.format }), o += d.size) : (a.addAttribute(u.attributeName, { buffer: this._staticBuffer, stride: this._staticStride * 4, offset: h * 4, format: u.format }), h += d.size) } a.addIndex(this.indexBuffer); const l = this.getParticleUpdate(r); this._dynamicUpload = l.dynamicUpdate, this._staticUpload = l.staticUpdate, this.geometry = a } getParticleUpdate(e) { const t = Vg(e); return this._generateParticleUpdateCache[t] ? this._generateParticleUpdateCache[t] : (this._generateParticleUpdateCache[t] = this.generateParticleUpdate(e), this._generateParticleUpdateCache[t]) } generateParticleUpdate(e) { return zg(e) } update(e, t) { e.length > this._size && (t = !0, this._size = Math.max(e.length, this._size * 1.5 | 0), this.staticAttributeBuffer = new Tt(this._size * this._staticStride * 4 * 4), this.dynamicAttributeBuffer = new Tt(this._size * this._dynamicStride * 4 * 4), this.indexBuffer = Wa(this._size), this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0)); const r = this.dynamicAttributeBuffer; if (this._dynamicUpload(e, r.float32View, r.uint32View), this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, e.length * this._dynamicStride * 4, !0), t) { const i = this.staticAttributeBuffer; this._staticUpload(e, i.float32View, i.uint32View), this._staticBuffer.setDataWithSize(i.float32View, e.length * this._staticStride * 4, !0) } } destroy() { this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy() } } function Vg(s) { const e = []; for (const t in s) { const r = s[t]; e.push(t, r.code, r.dynamic ? "d" : "s") } return e.join("_") } var $g = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`, Xg = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`, $a = `
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`; class jg extends ke { constructor() { const e = kt.from({ vertex: Xg, fragment: $g }), t = gt.from({ fragment: { source: $a, entryPoint: "mainFragment" }, vertex: { source: $a, entryPoint: "mainVertex" } }); super({ glProgram: e, gpuProgram: t, resources: { uTexture: F.WHITE.source, uSampler: new so({}), uniforms: { uTranslationMatrix: { value: new D, type: "mat3x3<f32>" }, uColor: { value: new ie(16777215), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } } } }) } } class sc { constructor(e, t) { this.state = Oe.for2d(), this._gpuBufferHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this.localUniforms = new be({ uTranslationMatrix: { value: new D, type: "mat3x3<f32>" }, uColor: { value: new Float32Array(4), type: "vec4<f32>" }, uRound: { value: 1, type: "f32" }, uResolution: { value: [0, 0], type: "vec2<f32>" } }), this.renderer = e, this.adaptor = t, this.defaultShader = new jg, this.state = Oe.for2d() } validateRenderable(e) { return !1 } addRenderable(e, t) { this.renderer.renderPipes.batch.break(t), t.add(e) } getBuffers(e) { return this._gpuBufferHash[e.uid] || this._initBuffer(e) } _initBuffer(e) { return this._gpuBufferHash[e.uid] = new Wg({ size: e.particleChildren.length, properties: e._properties }), e.on("destroyed", this._destroyRenderableBound), this._gpuBufferHash[e.uid] } updateRenderable(e) { } destroyRenderable(e) { this._gpuBufferHash[e.uid].destroy(), this._gpuBufferHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound) } execute(e) { const t = e.particleChildren; if (t.length === 0) return; const r = this.renderer, i = this.getBuffers(e); e.texture || (e.texture = t[0].texture); const n = this.state; i.update(t, e._childrenDirty), e._childrenDirty = !1, n.blendMode = er(e.blendMode, e.texture._source); const a = this.localUniforms.uniforms, o = a.uTranslationMatrix; e.worldTransform.copyTo(o), o.prepend(r.globalUniforms.globalUniformData.projectionMatrix), a.uResolution = r.globalUniforms.globalUniformData.resolution, a.uRound = r._roundPixels | e._roundPixels, lr(e.groupColorAlpha, a.uColor, 0), this.adaptor.execute(this, e) } destroy() { this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null) } } class ic extends sc { constructor(e) { super(e, new Ng) } } ic.extension = { type: [b.WebGLPipes], name: "particle" }; class nc extends sc { constructor(e) { super(e, new Hg) } } nc.extension = { type: [b.WebGPUPipes], name: "particle" }; const ac = class oc extends Lg { constructor(e = {}) { e = { ...oc.defaultOptions, ...e }, super({ width: e.width, height: e.height, verticesX: 4, verticesY: 4 }), this.update(e) } update(e) { var t, r; this.width = e.width ?? this.width, this.height = e.height ?? this.height, this._originalWidth = e.originalWidth ?? this._originalWidth, this._originalHeight = e.originalHeight ?? this._originalHeight, this._leftWidth = e.leftWidth ?? this._leftWidth, this._rightWidth = e.rightWidth ?? this._rightWidth, this._topHeight = e.topHeight ?? this._topHeight, this._bottomHeight = e.bottomHeight ?? this._bottomHeight, this._anchorX = (t = e.anchor) == null ? void 0 : t.x, this._anchorY = (r = e.anchor) == null ? void 0 : r.y, this.updateUvs(), this.updatePositions() } updatePositions() { const e = this.positions, { width: t, height: r, _leftWidth: i, _rightWidth: n, _topHeight: a, _bottomHeight: o, _anchorX: h, _anchorY: l } = this, c = i + n, u = t > c ? 1 : t / c, d = a + o, f = r > d ? 1 : r / d, p = Math.min(u, f), g = h * t, m = l * r; e[0] = e[8] = e[16] = e[24] = -g, e[2] = e[10] = e[18] = e[26] = i * p - g, e[4] = e[12] = e[20] = e[28] = t - n * p - g, e[6] = e[14] = e[22] = e[30] = t - g, e[1] = e[3] = e[5] = e[7] = -m, e[9] = e[11] = e[13] = e[15] = a * p - m, e[17] = e[19] = e[21] = e[23] = r - o * p - m, e[25] = e[27] = e[29] = e[31] = r - m, this.getBuffer("aPosition").update() } updateUvs() { const e = this.uvs; e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1; const t = 1 / this._originalWidth, r = 1 / this._originalHeight; e[2] = e[10] = e[18] = e[26] = t * this._leftWidth, e[9] = e[11] = e[13] = e[15] = r * this._topHeight, e[4] = e[12] = e[20] = e[28] = 1 - t * this._rightWidth, e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight, this.getBuffer("aUV").update() } }; ac.defaultOptions = { width: 100, height: 100, leftWidth: 10, topHeight: 10, rightWidth: 10, bottomHeight: 10, originalWidth: 100, originalHeight: 100 }; let Yg = ac; class hc { constructor(e) { this._gpuSpriteHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash") } addRenderable(e, t) { const r = this._getGpuSprite(e); e.didViewUpdate && this._updateBatchableSprite(e, r), this._renderer.renderPipes.batch.addToBatch(r, t) } updateRenderable(e) { const t = this._gpuSpriteHash[e.uid]; e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t) } validateRenderable(e) { const t = this._getGpuSprite(e); return !t._batcher.checkAndUpdateTexture(t, e._texture) } destroyRenderable(e) { const t = this._gpuSpriteHash[e.uid]; j.return(t.geometry), j.return(t), this._gpuSpriteHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound) } _updateBatchableSprite(e, t) { t.geometry.update(e), t.setTexture(e._texture) } _getGpuSprite(e) { return this._gpuSpriteHash[e.uid] || this._initGPUSprite(e) } _initGPUSprite(e) { const t = j.get(nn); return t.geometry = j.get(Yg), t.renderable = e, t.transform = e.groupTransform, t.texture = e._texture, t.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuSpriteHash[e.uid] = t, e.didViewUpdate || this._updateBatchableSprite(e, t), e.on("destroyed", this._destroyRenderableBound), t } destroy() { for (const e in this._gpuSpriteHash) this._gpuSpriteHash[e].geometry.destroy(); this._gpuSpriteHash = null, this._renderer = null } } hc.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "nineSliceSprite" }; const Kg = {
  name: "tiling-bit", vertex: {
    header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `, main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `}, fragment: {
    header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `, main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}
}, qg = {
  name: "tiling-bit", vertex: {
    header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `, main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `}, fragment: {
    header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `, main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `}
}; let Us, Ds; class Zg extends ke { constructor() { Us ?? (Us = nr({ name: "tiling-sprite-shader", bits: [qt, Kg, or] })), Ds ?? (Ds = ar({ name: "tiling-sprite-shader", bits: [Xi, qg, hr] })); const e = new be({ uMapCoord: { value: new D, type: "mat3x3<f32>" }, uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" }, uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" }, uTextureTransform: { value: new D, type: "mat3x3<f32>" }, uSizeAnchor: { value: new Float32Array([100, 100, .5, .5]), type: "vec4<f32>" } }); super({ glProgram: Ds, gpuProgram: Us, resources: { localUniforms: new be({ uTransformMatrix: { value: new D, type: "mat3x3<f32>" }, uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uRound: { value: 0, type: "f32" } }), tilingUniforms: e, uTexture: F.EMPTY.source, uSampler: F.EMPTY.source.style } }) } updateUniforms(e, t, r, i, n, a) { const o = this.resources.tilingUniforms, h = a.width, l = a.height, c = a.textureMatrix, u = o.uniforms.uTextureTransform; u.set(r.a * h / e, r.b * h / t, r.c * l / e, r.d * l / t, r.tx / e, r.ty / t), u.invert(), o.uniforms.uMapCoord = c.mapCoord, o.uniforms.uClampFrame = c.uClampFrame, o.uniforms.uClampOffset = c.uClampOffset, o.uniforms.uTextureTransform = u, o.uniforms.uSizeAnchor[0] = e, o.uniforms.uSizeAnchor[1] = t, o.uniforms.uSizeAnchor[2] = i, o.uniforms.uSizeAnchor[3] = n, a && (this.resources.uTexture = a.source, this.resources.uSampler = a.source.style) } } class Qg extends Wi { constructor() { super({ positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), indices: new Uint32Array([0, 1, 2, 0, 2, 3]) }) } } function Jg(s, e) { const t = s.anchor.x, r = s.anchor.y; e[0] = -t * s.width, e[1] = -r * s.height, e[2] = (1 - t) * s.width, e[3] = -r * s.height, e[4] = (1 - t) * s.width, e[5] = (1 - r) * s.height, e[6] = -t * s.width, e[7] = (1 - r) * s.height } function e_(s, e, t, r) { let i = 0; const n = s.length / e, a = r.a, o = r.b, h = r.c, l = r.d, c = r.tx, u = r.ty; for (t *= e; i < n;) { const d = s[t], f = s[t + 1]; s[t] = a * d + h * f + c, s[t + 1] = o * d + l * f + u, t += e, i++ } } function t_(s, e) { const t = s.texture, r = t.frame.width, i = t.frame.height; let n = 0, a = 0; s.applyAnchorToTexture && (n = s.anchor.x, a = s.anchor.y), e[0] = e[6] = -n, e[2] = e[4] = 1 - n, e[1] = e[3] = -a, e[5] = e[7] = 1 - a; const o = D.shared; o.copyFrom(s._tileTransform.matrix), o.tx /= s.width, o.ty /= s.height, o.invert(), o.scale(s.width / r, s.height / i), e_(e, 2, 0, o) } const Pr = new Qg; class lc { constructor(e) { this._state = Oe.default2d, this._tilingSpriteDataHash = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash") } validateRenderable(e) { const t = this._getTilingSpriteData(e), r = t.canBatch; this._updateCanBatch(e); const i = t.canBatch; if (i && i === r) { const { batchableMesh: n } = t; return !n._batcher.checkAndUpdateTexture(n, e.texture) } return r !== i } addRenderable(e, t) { const r = this._renderer.renderPipes.batch; this._updateCanBatch(e); const i = this._getTilingSpriteData(e), { geometry: n, canBatch: a } = i; if (a) { i.batchableMesh || (i.batchableMesh = new nn); const o = i.batchableMesh; e.didViewUpdate && (this._updateBatchableMesh(e), o.geometry = n, o.renderable = e, o.transform = e.groupTransform, o.setTexture(e._texture)), o.roundPixels = this._renderer._roundPixels | e._roundPixels, r.addToBatch(o, t) } else r.break(t), i.shader || (i.shader = new Zg), this.updateRenderable(e), t.add(e) } execute(e) { const { shader: t } = this._tilingSpriteDataHash[e.uid]; t.groups[0] = this._renderer.globalUniforms.bindGroup; const r = t.resources.localUniforms.uniforms; r.uTransformMatrix = e.groupTransform, r.uRound = this._renderer._roundPixels | e._roundPixels, lr(e.groupColorAlpha, r.uColor, 0), this._state.blendMode = er(e.groupBlendMode, e.texture._source), this._renderer.encoder.draw({ geometry: Pr, shader: t, state: this._state }) } updateRenderable(e) { const t = this._getTilingSpriteData(e), { canBatch: r } = t; if (r) { const { batchableMesh: i } = t; e.didViewUpdate && this._updateBatchableMesh(e), i._batcher.updateElement(i) } else if (e.didViewUpdate) { const { shader: i } = t; i.updateUniforms(e.width, e.height, e._tileTransform.matrix, e.anchor.x, e.anchor.y, e.texture) } } destroyRenderable(e) { var r; const t = this._getTilingSpriteData(e); t.batchableMesh = null, (r = t.shader) == null || r.destroy(), this._tilingSpriteDataHash[e.uid] = null, e.off("destroyed", this._destroyRenderableBound) } _getTilingSpriteData(e) { return this._tilingSpriteDataHash[e.uid] || this._initTilingSpriteData(e) } _initTilingSpriteData(e) { const t = new Wi({ indices: Pr.indices, positions: Pr.positions.slice(), uvs: Pr.uvs.slice() }); return this._tilingSpriteDataHash[e.uid] = { canBatch: !0, renderable: e, geometry: t }, e.on("destroyed", this._destroyRenderableBound), this._tilingSpriteDataHash[e.uid] } _updateBatchableMesh(e) { const t = this._getTilingSpriteData(e), { geometry: r } = t, i = e.texture.source.style; i.addressMode !== "repeat" && (i.addressMode = "repeat", i.update()), t_(e, r.uvs), Jg(e, r.positions) } destroy() { for (const e in this._tilingSpriteDataHash) this.destroyRenderable(this._tilingSpriteDataHash[e].renderable); this._tilingSpriteDataHash = null, this._renderer = null } _updateCanBatch(e) { const t = this._getTilingSpriteData(e), r = e.texture; let i = !0; return this._renderer.type === De.WEBGL && (i = this._renderer.context.supports.nonPowOf2wrapping), t.canBatch = r.textureMatrix.isSimple && (i || r.source.isPowerOfTwo), t.canBatch } } lc.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "tilingSprite" }; const r_ = {
  name: "local-uniform-msdf-bit", vertex: {
    header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `, main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `, end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}, fragment: {
    header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `, main: ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `}
}, s_ = {
  name: "local-uniform-msdf-bit", vertex: {
    header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `, main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `, end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}, fragment: {
    header: `
            uniform float uDistance;
         `, main: ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `}
}, i_ = {
  name: "msdf-bit", fragment: {
    header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `}
}, n_ = {
  name: "msdf-bit", fragment: {
    header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `}
}; let Os, Ls; class a_ extends ke { constructor() { const e = new be({ uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" }, uTransformMatrix: { value: new D, type: "mat3x3<f32>" }, uDistance: { value: 4, type: "f32" }, uRound: { value: 0, type: "f32" } }), t = It(); Os ?? (Os = nr({ name: "sdf-shader", bits: [Ci, Bi(t), r_, i_, or] })), Ls ?? (Ls = ar({ name: "sdf-shader", bits: [Mi, Ri(t), s_, n_, hr] })), super({ glProgram: Ls, gpuProgram: Os, resources: { localUniforms: e, batchSamplers: ki(t) } }) } } class cc { constructor(e) { this._gpuBitmapText = {}, this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText") } validateRenderable(e) { const t = this._getGpuBitmapText(e); return e._didTextUpdate && (e._didTextUpdate = !1, this._updateContext(e, t)), this._renderer.renderPipes.graphics.validateRenderable(t) } addRenderable(e, t) { const r = this._getGpuBitmapText(e); Xa(e, r), e._didTextUpdate && (e._didTextUpdate = !1, this._updateContext(e, r)), this._renderer.renderPipes.graphics.addRenderable(r, t), r.context.customShader && this._updateDistanceField(e) } destroyRenderable(e) { e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableByUid(e.uid) } _destroyRenderableByUid(e) { const t = this._gpuBitmapText[e].context; t.customShader && (j.return(t.customShader), t.customShader = null), j.return(this._gpuBitmapText[e]), this._gpuBitmapText[e] = null } updateRenderable(e) { const t = this._getGpuBitmapText(e); Xa(e, t), this._renderer.renderPipes.graphics.updateRenderable(t), t.context.customShader && this._updateDistanceField(e) } _updateContext(e, t) { const { context: r } = t, i = ii.getFont(e.text, e._style); r.clear(), i.distanceField.type !== "none" && (r.customShader || (r.customShader = j.get(a_))); const n = Array.from(e.text), a = e._style; let o = i.baseLineOffset; const h = gh(n, a, i, !0); let l = 0; const c = a.padding, u = h.scale; let d = h.width, f = h.height + h.offsetY; a._stroke && (d += a._stroke.width / u, f += a._stroke.width / u), r.translate(-e._anchor._x * d - c, -e._anchor._y * f - c).scale(u, u); const p = i.applyFillAsTint ? a._fill.color : 16777215; for (let g = 0; g < h.lines.length; g++) { const m = h.lines[g]; for (let y = 0; y < m.charPositions.length; y++) { const T = n[l++], S = i.chars[T]; S != null && S.texture && r.texture(S.texture, p || "black", Math.round(m.charPositions[y] + S.xOffset), Math.round(o + S.yOffset)) } o += i.lineHeight } } _getGpuBitmapText(e) { return this._gpuBitmapText[e.uid] || this.initGpuText(e) } initGpuText(e) { const t = j.get(rr); return this._gpuBitmapText[e.uid] = t, this._updateContext(e, t), e.on("destroyed", this._destroyRenderableBound), this._gpuBitmapText[e.uid] } _updateDistanceField(e) { const t = this._getGpuBitmapText(e).context, r = e._style.fontFamily, i = ae.get(`${r}-bitmap`), { a: n, b: a, c: o, d: h } = e.groupTransform, l = Math.sqrt(n * n + a * a), c = Math.sqrt(o * o + h * h), u = (Math.abs(l) + Math.abs(c)) / 2, d = i.baseRenderedFontSize / e._style.fontSize, f = u * i.distanceField.range * (1 / d); t.customShader.resources.localUniforms.uniforms.uDistance = f } destroy() { for (const e in this._gpuBitmapText) this._destroyRenderableByUid(e); this._gpuBitmapText = null, this._renderer = null } } cc.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "bitmapText" }; function Xa(s, e) { e.groupTransform = s.groupTransform, e.groupColorAlpha = s.groupColorAlpha, e.groupColor = s.groupColor, e.groupBlendMode = s.groupBlendMode, e.globalDisplayStatus = s.globalDisplayStatus, e.groupTransform = s.groupTransform, e.localDisplayStatus = s.localDisplayStatus, e.groupAlpha = s.groupAlpha, e._roundPixels = s._roundPixels } function di(s, e) { const { texture: t, bounds: r } = s; oo(r, e._anchor, t); const i = e._style.padding; r.minX -= i, r.minY -= i, r.maxX -= i, r.maxY -= i } class uc { constructor(e) { this._gpuText = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.runners.resolutionChange.add(this), this._renderer.renderableGC.addManagedHash(this, "_gpuText") } resolutionChange() { for (const e in this._gpuText) { const t = this._gpuText[e]; if (!t) continue; const r = t.batchableSprite.renderable; r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate()) } } validateRenderable(e) { const t = this._getGpuText(e), r = e._getKey(); return t.textureNeedsUploading ? (t.textureNeedsUploading = !1, !0) : t.currentKey !== r } addRenderable(e, t) { const i = this._getGpuText(e).batchableSprite; e._didTextUpdate && this._updateText(e), this._renderer.renderPipes.batch.addToBatch(i, t) } updateRenderable(e) { const r = this._getGpuText(e).batchableSprite; e._didTextUpdate && this._updateText(e), r._batcher.updateElement(r) } destroyRenderable(e) { e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(e.uid) } _destroyRenderableById(e) { const t = this._gpuText[e]; this._renderer.htmlText.decreaseReferenceCount(t.currentKey), j.return(t.batchableSprite), this._gpuText[e] = null } _updateText(e) { const t = e._getKey(), r = this._getGpuText(e), i = r.batchableSprite; r.currentKey !== t && this._updateGpuText(e).catch(n => { console.error(n) }), e._didTextUpdate = !1, di(i, e) } async _updateGpuText(e) { e._didTextUpdate = !1; const t = this._getGpuText(e); if (t.generatingTexture) return; const r = e._getKey(); this._renderer.htmlText.decreaseReferenceCount(t.currentKey), t.generatingTexture = !0, t.currentKey = r; const i = e.resolution ?? this._renderer.resolution, n = await this._renderer.htmlText.getManagedTexture(e.text, i, e._style, e._getKey()), a = t.batchableSprite; a.texture = t.texture = n, t.generatingTexture = !1, t.textureNeedsUploading = !0, e.onViewUpdate(), di(a, e) } _getGpuText(e) { return this._gpuText[e.uid] || this.initGpuText(e) } initGpuText(e) { const t = { texture: F.EMPTY, currentKey: "--", batchableSprite: j.get(Zr), textureNeedsUploading: !1, generatingTexture: !1 }, r = t.batchableSprite; return r.renderable = e, r.transform = e.groupTransform, r.texture = F.EMPTY, r.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, r.roundPixels = this._renderer._roundPixels | e._roundPixels, e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution, this._gpuText[e.uid] = t, e.on("destroyed", this._destroyRenderableBound), t } destroy() { for (const e in this._gpuText) this._destroyRenderableById(e); this._gpuText = null, this._renderer = null } } uc.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "htmlText" }; function o_() { const { userAgent: s } = K.get().getNavigator(); return /^((?!chrome|android).)*safari/i.test(s) } const h_ = new xe; function dc(s, e, t, r) { const i = h_; i.minX = 0, i.minY = 0, i.maxX = s.width / r | 0, i.maxY = s.height / r | 0; const n = _e.getOptimalTexture(i.width, i.height, r, !1); return n.source.uploadMethodId = "image", n.source.resource = s, n.source.alphaMode = "premultiply-alpha-on-upload", n.frame.width = e / r, n.frame.height = t / r, n.source.emit("update", n.source), n.updateUvs(), n } function l_(s, e) { const t = e.fontFamily, r = [], i = {}, n = /font-family:([^;"\s]+)/g, a = s.match(n); function o(h) { i[h] || (r.push(h), i[h] = !0) } if (Array.isArray(t)) for (let h = 0; h < t.length; h++)o(t[h]); else o(t); a && a.forEach(h => { const l = h.split(":")[1].trim(); o(l) }); for (const h in e.tagStyles) { const l = e.tagStyles[h].fontFamily; o(l) } return r } async function c_(s) { const t = await (await K.get().fetch(s)).blob(), r = new FileReader; return await new Promise((n, a) => { r.onloadend = () => n(r.result), r.onerror = a, r.readAsDataURL(t) }) } async function ja(s, e) {
  const t = await c_(e); return `@font-face {
        font-family: "${s.fontFamily}";
        src: url('${t}');
        font-weight: ${s.fontWeight};
        font-style: ${s.fontStyle};
    }`} const Er = new Map; async function u_(s, e, t) {
  const r = s.filter(i => ae.has(`${i}-and-url`)).map((i, n) => { if (!Er.has(i)) { const { url: a } = ae.get(`${i}-and-url`); n === 0 ? Er.set(i, ja({ fontWeight: e.fontWeight, fontStyle: e.fontStyle, fontFamily: i }, a)) : Er.set(i, ja({ fontWeight: t.fontWeight, fontStyle: t.fontStyle, fontFamily: i }, a)) } return Er.get(i) }); return (await Promise.all(r)).join(`
`)
} function d_(s, e, t, r, i) { const { domElement: n, styleElement: a, svgRoot: o } = i; n.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${s}</div>`, n.setAttribute("style", `transform: scale(${t});transform-origin: top left; display: inline-block`), a.textContent = r; const { width: h, height: l } = i.image; return o.setAttribute("width", h.toString()), o.setAttribute("height", l.toString()), new XMLSerializer().serializeToString(o) } function f_(s, e) { const t = Ze.getOptimalCanvasAndContext(s.width, s.height, e), { context: r } = t; return r.clearRect(0, 0, s.width, s.height), r.drawImage(s, 0, 0), t } function p_(s, e, t) { return new Promise(async r => { t && await new Promise(i => setTimeout(i, 100)), s.onload = () => { r() }, s.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`, s.crossOrigin = "anonymous" }) } class an { constructor(e) { this._activeTextures = {}, this._renderer = e, this._createCanvas = e.type === De.WEBGPU } getTexture(e) { return this._buildTexturePromise(e.text, e.resolution, e.style) } getManagedTexture(e, t, r, i) { if (this._activeTextures[i]) return this._increaseReferenceCount(i), this._activeTextures[i].promise; const n = this._buildTexturePromise(e, t, r).then(a => (this._activeTextures[i].texture = a, a)); return this._activeTextures[i] = { texture: null, promise: n, usageCount: 1 }, n } async _buildTexturePromise(e, t, r) { const i = j.get(kh), n = l_(e, r), a = await u_(n, r, Vi.defaultTextStyle), o = Jp(e, r, a, i), h = Math.ceil(Math.ceil(Math.max(1, o.width) + r.padding * 2) * t), l = Math.ceil(Math.ceil(Math.max(1, o.height) + r.padding * 2) * t), c = i.image, u = 2; c.width = (h | 0) + u, c.height = (l | 0) + u; const d = d_(e, r, t, a, i); await p_(c, d, o_() && n.length > 0); const f = c; let p; this._createCanvas && (p = f_(c, t)); const g = dc(p ? p.canvas : f, c.width - u, c.height - u, t); return this._createCanvas && (this._renderer.texture.initSource(g.source), Ze.returnCanvasAndContext(p)), j.return(i), g } _increaseReferenceCount(e) { this._activeTextures[e].usageCount++ } decreaseReferenceCount(e) { const t = this._activeTextures[e]; t && (t.usageCount--, t.usageCount === 0 && (t.texture ? this._cleanUp(t) : t.promise.then(r => { t.texture = r, this._cleanUp(t) }).catch(() => { H("HTMLTextSystem: Failed to clean texture") }), this._activeTextures[e] = null)) } _cleanUp(e) { _e.returnTexture(e.texture), e.texture.source.resource = null, e.texture.source.uploadMethodId = "unknown" } getReferenceCount(e) { return this._activeTextures[e].usageCount } destroy() { this._activeTextures = null } } an.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "htmlText" }; an.defaultFontOptions = { fontFamily: "Arial", fontStyle: "normal", fontWeight: "normal" }; class fc { constructor(e) { this._gpuText = Object.create(null), this._destroyRenderableBound = this.destroyRenderable.bind(this), this._renderer = e, this._renderer.runners.resolutionChange.add(this), this._renderer.renderableGC.addManagedHash(this, "_gpuText") } resolutionChange() { for (const e in this._gpuText) { const t = this._gpuText[e]; if (!t) continue; const r = t.batchableSprite.renderable; r._autoResolution && (r._resolution = this._renderer.resolution, r.onViewUpdate()) } } validateRenderable(e) { const t = this._getGpuText(e), r = e._getKey(); return t.currentKey !== r } addRenderable(e, t) { const i = this._getGpuText(e).batchableSprite; e._didTextUpdate && this._updateText(e), this._renderer.renderPipes.batch.addToBatch(i, t) } updateRenderable(e) { const r = this._getGpuText(e).batchableSprite; e._didTextUpdate && this._updateText(e), r._batcher.updateElement(r) } destroyRenderable(e) { e.off("destroyed", this._destroyRenderableBound), this._destroyRenderableById(e.uid) } _destroyRenderableById(e) { const t = this._gpuText[e]; this._renderer.canvasText.decreaseReferenceCount(t.currentKey), j.return(t.batchableSprite), this._gpuText[e] = null } _updateText(e) { const t = e._getKey(), r = this._getGpuText(e), i = r.batchableSprite; r.currentKey !== t && this._updateGpuText(e), e._didTextUpdate = !1, di(i, e) } _updateGpuText(e) { const t = this._getGpuText(e), r = t.batchableSprite; t.texture && this._renderer.canvasText.decreaseReferenceCount(t.currentKey), t.texture = r.texture = this._renderer.canvasText.getManagedTexture(e), t.currentKey = e._getKey(), r.texture = t.texture } _getGpuText(e) { return this._gpuText[e.uid] || this.initGpuText(e) } initGpuText(e) { const t = { texture: null, currentKey: "--", batchableSprite: j.get(Zr) }; return t.batchableSprite.renderable = e, t.batchableSprite.transform = e.groupTransform, t.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, t.batchableSprite.roundPixels = this._renderer._roundPixels | e._roundPixels, this._gpuText[e.uid] = t, e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution, this._updateText(e), e.on("destroyed", this._destroyRenderableBound), t } destroy() { for (const e in this._gpuText) this._destroyRenderableById(e); this._gpuText = null, this._renderer = null } } fc.extension = { type: [b.WebGLPipes, b.WebGPUPipes, b.CanvasPipes], name: "text" }; function Ya(s, e, t) { for (let r = 0, i = 4 * t * e; r < e; ++r, i += 4)if (s[i + 3] !== 0) return !1; return !0 } function Ka(s, e, t, r, i) { const n = 4 * e; for (let a = r, o = r * n + 4 * t; a <= i; ++a, o += n)if (s[o + 3] !== 0) return !1; return !0 } function m_(s, e = 1) { const { width: t, height: r } = s, i = s.getContext("2d", { willReadFrequently: !0 }); if (i === null) throw new TypeError("Failed to get canvas 2D context"); const a = i.getImageData(0, 0, t, r).data; let o = 0, h = 0, l = t - 1, c = r - 1; for (; h < r && Ya(a, t, h);)++h; if (h === r) return ne.EMPTY; for (; Ya(a, t, c);)--c; for (; Ka(a, t, o, h, c);)++o; for (; Ka(a, t, l, h, c);)--l; return ++l, ++c, new ne(o / e, h / e, (l - o) / e, (c - h) / e) } class pc { constructor(e) { this._activeTextures = {}, this._renderer = e } getTextureSize(e, t, r) { const i = Je.measureText(e || " ", r); let n = Math.ceil(Math.ceil(Math.max(1, i.width) + r.padding * 2) * t), a = Math.ceil(Math.ceil(Math.max(1, i.height) + r.padding * 2) * t); return n = Math.ceil(n - 1e-6), a = Math.ceil(a - 1e-6), n = Et(n), a = Et(a), { width: n, height: a } } getTexture(e, t, r, i) { typeof e == "string" && (X("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), e = { text: e, style: r, resolution: t }), e.style instanceof it || (e.style = new it(e.style)); const { texture: n, canvasAndContext: a } = this.createTextureAndCanvas(e); return this._renderer.texture.initSource(n._source), Ze.returnCanvasAndContext(a), n } createTextureAndCanvas(e) { const { text: t, style: r } = e, i = e.resolution ?? this._renderer.resolution, n = Je.measureText(t || " ", r), a = Math.ceil(Math.ceil(Math.max(1, n.width) + r.padding * 2) * i), o = Math.ceil(Math.ceil(Math.max(1, n.height) + r.padding * 2) * i), h = Ze.getOptimalCanvasAndContext(a, o), { canvas: l } = h; this.renderTextToCanvas(t, r, i, h); const c = dc(l, a, o, i); if (r.trim) { const u = m_(l, i); c.frame.copyFrom(u), c.updateUvs() } return { texture: c, canvasAndContext: h } } getManagedTexture(e) { e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution; const t = e._getKey(); if (this._activeTextures[t]) return this._increaseReferenceCount(t), this._activeTextures[t].texture; const { texture: r, canvasAndContext: i } = this.createTextureAndCanvas(e); return this._activeTextures[t] = { canvasAndContext: i, texture: r, usageCount: 1 }, r } _increaseReferenceCount(e) { this._activeTextures[e].usageCount++ } returnTexture(e) { const t = e.source; t.resource = null, t.uploadMethodId = "unknown", t.alphaMode = "no-premultiply-alpha", _e.returnTexture(e) } decreaseReferenceCount(e) { const t = this._activeTextures[e]; t.usageCount--, t.usageCount === 0 && (Ze.returnCanvasAndContext(t.canvasAndContext), this.returnTexture(t.texture), this._activeTextures[e] = null) } getReferenceCount(e) { return this._activeTextures[e].usageCount } renderTextToCanvas(e, t, r, i) { var T, S, A, R; const { canvas: n, context: a } = i, o = zr(t), h = Je.measureText(e || " ", t), l = h.lines, c = h.lineHeight, u = h.lineWidths, d = h.maxLineWidth, f = h.fontProperties, p = n.height; if (a.resetTransform(), a.scale(r, r), a.textBaseline = t.textBaseline, (T = t._stroke) != null && T.width) { const E = t._stroke; a.lineWidth = E.width, a.miterLimit = E.miterLimit, a.lineJoin = E.join, a.lineCap = E.cap } a.font = o; let g, m; const y = t.dropShadow ? 2 : 1; for (let E = 0; E < y; ++E) { const C = t.dropShadow && E === 0, L = C ? Math.ceil(Math.max(1, p) + t.padding * 2) : 0, N = L * r; if (C) { a.fillStyle = "black", a.strokeStyle = "black"; const V = t.dropShadow, Z = V.color, fe = V.alpha; a.shadowColor = ie.shared.setValue(Z).setAlpha(fe).toRgbaString(); const Ie = V.blur * r, _ = V.distance * r; a.shadowBlur = Ie, a.shadowOffsetX = Math.cos(V.angle) * _, a.shadowOffsetY = Math.sin(V.angle) * _ + N } else { if (a.fillStyle = t._fill ? Wr(t._fill, a, h) : null, (S = t._stroke) != null && S.width) { const V = t._stroke.width * t._stroke.alignment; a.strokeStyle = Wr(t._stroke, a, h, V) } a.shadowColor = "black" } let G = (c - f.fontSize) / 2; c - f.fontSize < 0 && (G = 0); const I = ((A = t._stroke) == null ? void 0 : A.width) ?? 0; for (let V = 0; V < l.length; V++)g = I / 2, m = I / 2 + V * c + f.ascent + G, t.align === "right" ? g += d - u[V] : t.align === "center" && (g += (d - u[V]) / 2), (R = t._stroke) != null && R.width && this._drawLetterSpacing(l[V], t, i, g + t.padding, m + t.padding - L, !0), t._fill !== void 0 && this._drawLetterSpacing(l[V], t, i, g + t.padding, m + t.padding - L) } } _drawLetterSpacing(e, t, r, i, n, a = !1) { const { context: o } = r, h = t.letterSpacing; let l = !1; if (Je.experimentalLetterSpacingSupported && (Je.experimentalLetterSpacing ? (o.letterSpacing = `${h}px`, o.textLetterSpacing = `${h}px`, l = !0) : (o.letterSpacing = "0px", o.textLetterSpacing = "0px")), h === 0 || l) { a ? o.strokeText(e, i, n) : o.fillText(e, i, n); return } let c = i; const u = Je.graphemeSegmenter(e); let d = o.measureText(e).width, f = 0; for (let p = 0; p < u.length; ++p) { const g = u[p]; a ? o.strokeText(g, c, n) : o.fillText(g, c, n); let m = ""; for (let y = p + 1; y < u.length; ++y)m += u[y]; f = o.measureText(m).width, c += d - f + h, d = f } } destroy() { this._activeTextures = null } } pc.extension = { type: [b.WebGLSystem, b.WebGPUSystem, b.CanvasSystem], name: "canvasText" }; z.add(vc, Tc); const qa = "#01FFFF", g_ = "#FF55FE", fi = "#000000", $t = 32, $r = 64, Cr = .1, mc = [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 2, 1, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 4, 3, 2, 1, 0, 0, 0, 2], [2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 2, 1, 0, 0, 0, 1, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 0, 0, 0, 0, 2], [2, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 1, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 2, 3, 2, 1, 0, 2], [2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 2, 2, 3, 4, 4, 3, 2, 1, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 3, 4, 4, 3, 2, 1, 0, 2], [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 2, 3, 3, 2, 2, 1, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 1, 0, 0, 0, 0, 2], [2, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]; class on { constructor(e, t) { Me(this, "asCartesian"); Me(this, "asIsometric"); this.asCartesian = { x: e, y: t }, this.asIsometric = { x: e * $t - t * $t, y: e * $t / 2 + t * $t / 2 } } add(e) { this.asIsometric = { x: this.asIsometric.x + e.x, y: this.asIsometric.y + e.y } } } class __ { constructor(e, t, r) { Me(this, "container"); Me(this, "graphicsContext"); Me(this, "spriteTiles", []); Me(this, "rows"); Me(this, "cols"); Me(this, "tileSize"); this.container = new ve, this.graphicsContext = new rr, this.container.addChild(this.graphicsContext), this.rows = e, this.cols = t, this.tileSize = r } async initSpriteTiles(e, t) { try { const r = await St.load("/assets/bunny.png"); if (!r) { console.error("Failed to load texture."); return } this.spriteTiles = Array.from({ length: e }, () => Array.from({ length: t }, () => new qp({ texture: r, width: 64, height: 64 }))); for (let i = 0; i < e; i++)for (let n = 0; n < t; n++)this.spriteTiles[i][n].anchor.set(.5), this.container.addChild(this.spriteTiles[i][n]) } catch (r) { console.error("Error initializing sprite tiles:", r) } } drawIsometricTile(e, t, r, i, n) { e.poly([t.x, t.y, t.x + r, t.y + i / 2, t.x, t.y + i, t.x - r, t.y + i / 2, t.x, t.y]), n ? (e.fill(fi), e.stroke({ color: qa })) : (e.fill(fi), e.stroke({ color: g_ })) } async createGridFromMap(e) { for (let t = 0; t < this.rows; t++)for (let r = 0; r < this.cols; r++) { let i = new on(r, t); i.asIsometric.y -= e[t][r] * this.tileSize / 2, e[t][r] != 0 && (this.graphicsContext.moveTo(i.asIsometric.x, i.asIsometric.y + this.tileSize).lineTo(i.asIsometric.x, i.asIsometric.y + this.tileSize * (e[t][r] + 1)), this.graphicsContext.moveTo(i.asIsometric.x - this.tileSize, i.asIsometric.y + this.tileSize / 2).lineTo(i.asIsometric.x - this.tileSize, i.asIsometric.y + this.tileSize / 2 * (e[t][r] + 1)), this.graphicsContext.moveTo(i.asIsometric.x + this.tileSize, i.asIsometric.y + this.tileSize / 2).lineTo(i.asIsometric.x + this.tileSize, i.asIsometric.y + this.tileSize / 2 * (e[t][r] + 1)), this.graphicsContext.stroke({ color: qa })), e[t][r] != 0 ? this.drawIsometricTile(this.graphicsContext, i.asIsometric, this.tileSize, this.tileSize, !0) : this.drawIsometricTile(this.graphicsContext, i.asIsometric, this.tileSize, this.tileSize, !1) } } moveMap(e) { this.container.x += e.x, this.container.y += e.y } getContainer() { return this.container } } class x_ { constructor(e, t, r) { Me(this, "id"); Me(this, "position"); Me(this, "context"); this.context = new pt(r), this.position = t, this.id = e } updatePosition(e) { this.position = new on(e.x, e.y), this.context.x = this.position.asIsometric.x, this.context.y = this.position.asIsometric.y } getId() { return this.id } getPosition() { return this.position.asCartesian } getContext() { return this.context } } function y_(s, e, t) { if (!t) return; let r = window.innerWidth * .1, i = window.innerHeight * .1, n = { x: 0, y: 0 }, a = 5; if (s.x >= window.innerWidth - r) { let o = (s.x - (window.innerWidth - r)) / r; n.x -= o * a } if (s.x <= r) { let o = (r - s.x) / r; n.x += o * a } if (s.y <= i) { let o = (i - s.y) / i; n.y += o * a } if (s.y >= window.innerHeight - i) { let o = (s.y - (window.innerHeight - i)) / i; n.y -= o * a } e.moveMap(n) } function b_(s, e) { window.addEventListener("wheel", t => { let r = .05, i = .75, n = 2, a = t.deltaY / Math.abs(t.deltaY), o; (l => { l[l.Up = -1] = "Up", l[l.Down = 1] = "Down" })(o || (o = {})); let h = e.getContainer(); if (a == -1 && h.scale.x < n) { const l = 1 - h.scale.x / (h.scale.x + r); h.scale.x += r, h.scale.y += r, h.x -= (s.x - h.x) * l, h.y -= (s.y - h.y) * l } else if (a == 1 && h.scale.x > i) { const l = 1 - h.scale.x / (h.scale.x + r); h.scale.x -= r, h.scale.y -= r, h.x += (s.x - h.x) * l, h.y += (s.y - h.y) * l } }) } let wt = {}; window.addEventListener("keydown", s => { wt[s.code] = !0 }); window.addEventListener("keyup", s => { wt[s.code] = !1 }); function v_(s, e) { let t = { x: s.position.asCartesian.x, y: s.position.asCartesian.y }; wt.KeyW ? t.y -= Cr * e : wt.KeyS ? t.y += Cr * e : wt.KeyA ? t.x -= Cr * e : wt.KeyD && (t.x += Cr * e); let r = Math.ceil(t.x), i = Math.ceil(t.y); r >= 0 && r < $r && i >= 0 && i < $r && mc[i][r] === 0 && s.updatePosition(t) } let hn = !0, Xr = { x: 0, y: 0 }; window.addEventListener("pointermove", s => { Xr.x = s.clientX, Xr.y = s.clientY }); window.addEventListener("blur", () => { hn = !1 }); window.addEventListener("focus", () => { hn = !0 }); async function T_() { const s = new Xo, e = document.getElementById("pixi-container"); await s.init({ background: fi, width: e == null ? void 0 : e.clientWidth, height: e == null ? void 0 : e.clientHeight }), e == null || e.appendChild(s.canvas); const t = new __($r, $r, $t), r = await St.load("/assets/bunny.png"), i = new x_(1, new on(2, 2), r), n = t.getContainer(); return t.createGridFromMap(mc), s.stage.addChild(n), n.addChild(i.getContext()), s.stage.eventMode = "static", s.stage.hitArea = s.screen, b_(Xr, t), s.ticker.add(a => { y_(Xr, t, hn), v_(i, a.deltaTime) }), s } T_().then(s => { console.log("Pixi app initialized:", s) }); z.add(Bu); z.mixin(ve, Ru); z.add(jo); z.add(Yo); z.add(wh); z.mixin(ve, Wp); z.add(Sh); z.add(Jl); z.add(Ui); z.add(rc); z.add(ic); z.add(nc); z.add(pc); z.add(fc); z.add(cc); z.add(an); z.add(uc); z.add(lc); z.add(hc); z.add(Ph); z.add(Ah); const S_ = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), w_ = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" }));
