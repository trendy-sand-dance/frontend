var Ws=Object.defineProperty;var xs=Wr=>{throw TypeError(Wr)};var Vs=(Wr,ze,Gr)=>ze in Wr?Ws(Wr,ze,{enumerable:!0,configurable:!0,writable:!0,value:Gr}):Wr[ze]=Gr;var Gi=(Wr,ze,Gr)=>Vs(Wr,typeof ze!="symbol"?ze+"":ze,Gr),ys=(Wr,ze,Gr)=>ze.has(Wr)||xs("Cannot "+Gr);var is=(Wr,ze,Gr)=>(ys(Wr,ze,"read from private field"),Gr?Gr.call(Wr):ze.get(Wr)),ls=(Wr,ze,Gr)=>ze.has(Wr)?xs("Cannot add the same private member more than once"):ze instanceof WeakSet?ze.add(Wr):ze.set(Wr,Gr),cs=(Wr,ze,Gr,Yr)=>(ys(Wr,ze,"write to private field"),Yr?Yr.call(Wr,Gr):ze.set(Wr,Gr),Gr);function _mergeNamespaces(Wr,ze){for(var Gr=0;Gr<ze.length;Gr++){const Yr=ze[Gr];if(typeof Yr!="string"&&!Array.isArray(Yr)){for(const Kr in Yr)if(Kr!=="default"&&!(Kr in Wr)){const Zr=Object.getOwnPropertyDescriptor(Yr,Kr);Zr&&Object.defineProperty(Wr,Kr,Zr.get?Zr:{enumerable:!0,get:()=>Yr[Kr]})}}}return Object.freeze(Object.defineProperty(Wr,Symbol.toStringTag,{value:"Module"}))}(function(){const ze=document.createElement("link").relList;if(ze&&ze.supports&&ze.supports("modulepreload"))return;for(const Kr of document.querySelectorAll('link[rel="modulepreload"]'))Yr(Kr);new MutationObserver(Kr=>{for(const Zr of Kr)if(Zr.type==="childList")for(const Qr of Zr.addedNodes)Qr.tagName==="LINK"&&Qr.rel==="modulepreload"&&Yr(Qr)}).observe(document,{childList:!0,subtree:!0});function Gr(Kr){const Zr={};return Kr.integrity&&(Zr.integrity=Kr.integrity),Kr.referrerPolicy&&(Zr.referrerPolicy=Kr.referrerPolicy),Kr.crossOrigin==="use-credentials"?Zr.credentials="include":Kr.crossOrigin==="anonymous"?Zr.credentials="omit":Zr.credentials="same-origin",Zr}function Yr(Kr){if(Kr.ep)return;Kr.ep=!0;const Zr=Gr(Kr);fetch(Kr.href,Zr)}})();const scriptRel="modulepreload",assetsURL=function(Wr){return"/"+Wr},seen={},__vitePreload=function(ze,Gr,Yr){let Kr=Promise.resolve();if(Gr&&Gr.length>0){document.getElementsByTagName("link");const Qr=document.querySelector("meta[property=csp-nonce]"),Jr=(Qr==null?void 0:Qr.nonce)||(Qr==null?void 0:Qr.getAttribute("nonce"));Kr=Promise.allSettled(Gr.map(ei=>{if(ei=assetsURL(ei),ei in seen)return;seen[ei]=!0;const ti=ei.endsWith(".css"),ri=ti?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${ei}"]${ri}`))return;const ii=document.createElement("link");if(ii.rel=ti?"stylesheet":scriptRel,ti||(ii.as="script"),ii.crossOrigin="",ii.href=ei,Jr&&ii.setAttribute("nonce",Jr),document.head.appendChild(ii),ti)return new Promise((si,ni)=>{ii.addEventListener("load",si),ii.addEventListener("error",()=>ni(new Error(`Unable to preload CSS for ${ei}`)))})}))}function Zr(Qr){const Jr=new Event("vite:preloadError",{cancelable:!0});if(Jr.payload=Qr,window.dispatchEvent(Jr),!Jr.defaultPrevented)throw Qr}return Kr.then(Qr=>{for(const Jr of Qr||[])Jr.status==="rejected"&&Zr(Jr.reason);return ze().catch(Zr)})};var ExtensionType=(Wr=>(Wr.Application="application",Wr.WebGLPipes="webgl-pipes",Wr.WebGLPipesAdaptor="webgl-pipes-adaptor",Wr.WebGLSystem="webgl-system",Wr.WebGPUPipes="webgpu-pipes",Wr.WebGPUPipesAdaptor="webgpu-pipes-adaptor",Wr.WebGPUSystem="webgpu-system",Wr.CanvasSystem="canvas-system",Wr.CanvasPipesAdaptor="canvas-pipes-adaptor",Wr.CanvasPipes="canvas-pipes",Wr.Asset="asset",Wr.LoadParser="load-parser",Wr.ResolveParser="resolve-parser",Wr.CacheParser="cache-parser",Wr.DetectionParser="detection-parser",Wr.MaskEffect="mask-effect",Wr.BlendMode="blend-mode",Wr.TextureSource="texture-source",Wr.Environment="environment",Wr.ShapeBuilder="shape-builder",Wr.Batcher="batcher",Wr))(ExtensionType||{});const normalizeExtension=Wr=>{if(typeof Wr=="function"||typeof Wr=="object"&&Wr.extension){if(!Wr.extension)throw new Error("Extension class must have an extension object");Wr={...typeof Wr.extension!="object"?{type:Wr.extension}:Wr.extension,ref:Wr}}if(typeof Wr=="object")Wr={...Wr};else throw new Error("Invalid extension type");return typeof Wr.type=="string"&&(Wr.type=[Wr.type]),Wr},normalizeExtensionPriority=(Wr,ze)=>normalizeExtension(Wr).priority??ze,extensions={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...Wr){return Wr.map(normalizeExtension).forEach(ze=>{ze.type.forEach(Gr=>{var Yr,Kr;return(Kr=(Yr=this._removeHandlers)[Gr])==null?void 0:Kr.call(Yr,ze)})}),this},add(...Wr){return Wr.map(normalizeExtension).forEach(ze=>{ze.type.forEach(Gr=>{var Zr,Qr;const Yr=this._addHandlers,Kr=this._queue;Yr[Gr]?(Qr=Yr[Gr])==null||Qr.call(Yr,ze):(Kr[Gr]=Kr[Gr]||[],(Zr=Kr[Gr])==null||Zr.push(ze))})}),this},handle(Wr,ze,Gr){var Qr;const Yr=this._addHandlers,Kr=this._removeHandlers;if(Yr[Wr]||Kr[Wr])throw new Error(`Extension type ${Wr} already has a handler`);Yr[Wr]=ze,Kr[Wr]=Gr;const Zr=this._queue;return Zr[Wr]&&((Qr=Zr[Wr])==null||Qr.forEach(Jr=>ze(Jr)),delete Zr[Wr]),this},handleByMap(Wr,ze){return this.handle(Wr,Gr=>{Gr.name&&(ze[Gr.name]=Gr.ref)},Gr=>{Gr.name&&delete ze[Gr.name]})},handleByNamedList(Wr,ze,Gr=-1){return this.handle(Wr,Yr=>{ze.findIndex(Zr=>Zr.name===Yr.name)>=0||(ze.push({name:Yr.name,value:Yr.ref}),ze.sort((Zr,Qr)=>normalizeExtensionPriority(Qr.value,Gr)-normalizeExtensionPriority(Zr.value,Gr)))},Yr=>{const Kr=ze.findIndex(Zr=>Zr.name===Yr.name);Kr!==-1&&ze.splice(Kr,1)})},handleByList(Wr,ze,Gr=-1){return this.handle(Wr,Yr=>{ze.includes(Yr.ref)||(ze.push(Yr.ref),ze.sort((Kr,Zr)=>normalizeExtensionPriority(Zr,Gr)-normalizeExtensionPriority(Kr,Gr)))},Yr=>{const Kr=ze.indexOf(Yr.ref);Kr!==-1&&ze.splice(Kr,1)})},mixin(Wr,...ze){for(const Gr of ze)Object.defineProperties(Wr.prototype,Object.getOwnPropertyDescriptors(Gr))}},browserExt={extension:{type:ExtensionType.Environment,name:"browser",priority:-1},test:()=>!0,load:async()=>{await __vitePreload(()=>Promise.resolve().then(()=>browserAll),void 0)}},webworkerExt={extension:{type:ExtensionType.Environment,name:"webworker",priority:0},test:()=>typeof self<"u"&&self.WorkerGlobalScope!==void 0,load:async()=>{await __vitePreload(()=>Promise.resolve().then(()=>webworkerAll),void 0)}};class ObservablePoint{constructor(ze,Gr,Yr){this._x=Gr||0,this._y=Yr||0,this._observer=ze}clone(ze){return new ObservablePoint(ze??this._observer,this._x,this._y)}set(ze=0,Gr=ze){return(this._x!==ze||this._y!==Gr)&&(this._x=ze,this._y=Gr,this._observer._onUpdate(this)),this}copyFrom(ze){return(this._x!==ze.x||this._y!==ze.y)&&(this._x=ze.x,this._y=ze.y,this._observer._onUpdate(this)),this}copyTo(ze){return ze.set(this._x,this._y),ze}equals(ze){return ze.x===this._x&&ze.y===this._y}toString(){return`[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`}get x(){return this._x}set x(ze){this._x!==ze&&(this._x=ze,this._observer._onUpdate(this))}get y(){return this._y}set y(ze){this._y!==ze&&(this._y=ze,this._observer._onUpdate(this))}}function getDefaultExportFromCjs(Wr){return Wr&&Wr.__esModule&&Object.prototype.hasOwnProperty.call(Wr,"default")?Wr.default:Wr}var eventemitter3={exports:{}},hasRequiredEventemitter3;function requireEventemitter3(){return hasRequiredEventemitter3||(hasRequiredEventemitter3=1,function(Wr){var ze=Object.prototype.hasOwnProperty,Gr="~";function Yr(){}Object.create&&(Yr.prototype=Object.create(null),new Yr().__proto__||(Gr=!1));function Kr(ei,ti,ri){this.fn=ei,this.context=ti,this.once=ri||!1}function Zr(ei,ti,ri,ii,si){if(typeof ri!="function")throw new TypeError("The listener must be a function");var ni=new Kr(ri,ii||ei,si),oi=Gr?Gr+ti:ti;return ei._events[oi]?ei._events[oi].fn?ei._events[oi]=[ei._events[oi],ni]:ei._events[oi].push(ni):(ei._events[oi]=ni,ei._eventsCount++),ei}function Qr(ei,ti){--ei._eventsCount===0?ei._events=new Yr:delete ei._events[ti]}function Jr(){this._events=new Yr,this._eventsCount=0}Jr.prototype.eventNames=function(){var ti=[],ri,ii;if(this._eventsCount===0)return ti;for(ii in ri=this._events)ze.call(ri,ii)&&ti.push(Gr?ii.slice(1):ii);return Object.getOwnPropertySymbols?ti.concat(Object.getOwnPropertySymbols(ri)):ti},Jr.prototype.listeners=function(ti){var ri=Gr?Gr+ti:ti,ii=this._events[ri];if(!ii)return[];if(ii.fn)return[ii.fn];for(var si=0,ni=ii.length,oi=new Array(ni);si<ni;si++)oi[si]=ii[si].fn;return oi},Jr.prototype.listenerCount=function(ti){var ri=Gr?Gr+ti:ti,ii=this._events[ri];return ii?ii.fn?1:ii.length:0},Jr.prototype.emit=function(ti,ri,ii,si,ni,oi){var li=Gr?Gr+ti:ti;if(!this._events[li])return!1;var ai=this._events[li],ui=arguments.length,fi,pi;if(ai.fn){switch(ai.once&&this.removeListener(ti,ai.fn,void 0,!0),ui){case 1:return ai.fn.call(ai.context),!0;case 2:return ai.fn.call(ai.context,ri),!0;case 3:return ai.fn.call(ai.context,ri,ii),!0;case 4:return ai.fn.call(ai.context,ri,ii,si),!0;case 5:return ai.fn.call(ai.context,ri,ii,si,ni),!0;case 6:return ai.fn.call(ai.context,ri,ii,si,ni,oi),!0}for(pi=1,fi=new Array(ui-1);pi<ui;pi++)fi[pi-1]=arguments[pi];ai.fn.apply(ai.context,fi)}else{var mi=ai.length,Ti;for(pi=0;pi<mi;pi++)switch(ai[pi].once&&this.removeListener(ti,ai[pi].fn,void 0,!0),ui){case 1:ai[pi].fn.call(ai[pi].context);break;case 2:ai[pi].fn.call(ai[pi].context,ri);break;case 3:ai[pi].fn.call(ai[pi].context,ri,ii);break;case 4:ai[pi].fn.call(ai[pi].context,ri,ii,si);break;default:if(!fi)for(Ti=1,fi=new Array(ui-1);Ti<ui;Ti++)fi[Ti-1]=arguments[Ti];ai[pi].fn.apply(ai[pi].context,fi)}}return!0},Jr.prototype.on=function(ti,ri,ii){return Zr(this,ti,ri,ii,!1)},Jr.prototype.once=function(ti,ri,ii){return Zr(this,ti,ri,ii,!0)},Jr.prototype.removeListener=function(ti,ri,ii,si){var ni=Gr?Gr+ti:ti;if(!this._events[ni])return this;if(!ri)return Qr(this,ni),this;var oi=this._events[ni];if(oi.fn)oi.fn===ri&&(!si||oi.once)&&(!ii||oi.context===ii)&&Qr(this,ni);else{for(var li=0,ai=[],ui=oi.length;li<ui;li++)(oi[li].fn!==ri||si&&!oi[li].once||ii&&oi[li].context!==ii)&&ai.push(oi[li]);ai.length?this._events[ni]=ai.length===1?ai[0]:ai:Qr(this,ni)}return this},Jr.prototype.removeAllListeners=function(ti){var ri;return ti?(ri=Gr?Gr+ti:ti,this._events[ri]&&Qr(this,ri)):(this._events=new Yr,this._eventsCount=0),this},Jr.prototype.off=Jr.prototype.removeListener,Jr.prototype.addListener=Jr.prototype.on,Jr.prefixed=Gr,Jr.EventEmitter=Jr,Wr.exports=Jr}(eventemitter3)),eventemitter3.exports}var eventemitter3Exports=requireEventemitter3();const EventEmitter=getDefaultExportFromCjs(eventemitter3Exports),PI_2=Math.PI*2,RAD_TO_DEG=180/Math.PI,DEG_TO_RAD=Math.PI/180;let Point$1=class bs{constructor(ze=0,Gr=0){this.x=0,this.y=0,this.x=ze,this.y=Gr}clone(){return new bs(this.x,this.y)}copyFrom(ze){return this.set(ze.x,ze.y),this}copyTo(ze){return ze.set(this.x,this.y),ze}equals(ze){return ze.x===this.x&&ze.y===this.y}set(ze=0,Gr=ze){return this.x=ze,this.y=Gr,this}toString(){return`[pixi.js/math:Point x=${this.x} y=${this.y}]`}static get shared(){return tempPoint.x=0,tempPoint.y=0,tempPoint}};const tempPoint=new Point$1;class Matrix{constructor(ze=1,Gr=0,Yr=0,Kr=1,Zr=0,Qr=0){this.array=null,this.a=ze,this.b=Gr,this.c=Yr,this.d=Kr,this.tx=Zr,this.ty=Qr}fromArray(ze){this.a=ze[0],this.b=ze[1],this.c=ze[3],this.d=ze[4],this.tx=ze[2],this.ty=ze[5]}set(ze,Gr,Yr,Kr,Zr,Qr){return this.a=ze,this.b=Gr,this.c=Yr,this.d=Kr,this.tx=Zr,this.ty=Qr,this}toArray(ze,Gr){this.array||(this.array=new Float32Array(9));const Yr=Gr||this.array;return ze?(Yr[0]=this.a,Yr[1]=this.b,Yr[2]=0,Yr[3]=this.c,Yr[4]=this.d,Yr[5]=0,Yr[6]=this.tx,Yr[7]=this.ty,Yr[8]=1):(Yr[0]=this.a,Yr[1]=this.c,Yr[2]=this.tx,Yr[3]=this.b,Yr[4]=this.d,Yr[5]=this.ty,Yr[6]=0,Yr[7]=0,Yr[8]=1),Yr}apply(ze,Gr){Gr=Gr||new Point$1;const Yr=ze.x,Kr=ze.y;return Gr.x=this.a*Yr+this.c*Kr+this.tx,Gr.y=this.b*Yr+this.d*Kr+this.ty,Gr}applyInverse(ze,Gr){Gr=Gr||new Point$1;const Yr=this.a,Kr=this.b,Zr=this.c,Qr=this.d,Jr=this.tx,ei=this.ty,ti=1/(Yr*Qr+Zr*-Kr),ri=ze.x,ii=ze.y;return Gr.x=Qr*ti*ri+-Zr*ti*ii+(ei*Zr-Jr*Qr)*ti,Gr.y=Yr*ti*ii+-Kr*ti*ri+(-ei*Yr+Jr*Kr)*ti,Gr}translate(ze,Gr){return this.tx+=ze,this.ty+=Gr,this}scale(ze,Gr){return this.a*=ze,this.d*=Gr,this.c*=ze,this.b*=Gr,this.tx*=ze,this.ty*=Gr,this}rotate(ze){const Gr=Math.cos(ze),Yr=Math.sin(ze),Kr=this.a,Zr=this.c,Qr=this.tx;return this.a=Kr*Gr-this.b*Yr,this.b=Kr*Yr+this.b*Gr,this.c=Zr*Gr-this.d*Yr,this.d=Zr*Yr+this.d*Gr,this.tx=Qr*Gr-this.ty*Yr,this.ty=Qr*Yr+this.ty*Gr,this}append(ze){const Gr=this.a,Yr=this.b,Kr=this.c,Zr=this.d;return this.a=ze.a*Gr+ze.b*Kr,this.b=ze.a*Yr+ze.b*Zr,this.c=ze.c*Gr+ze.d*Kr,this.d=ze.c*Yr+ze.d*Zr,this.tx=ze.tx*Gr+ze.ty*Kr+this.tx,this.ty=ze.tx*Yr+ze.ty*Zr+this.ty,this}appendFrom(ze,Gr){const Yr=ze.a,Kr=ze.b,Zr=ze.c,Qr=ze.d,Jr=ze.tx,ei=ze.ty,ti=Gr.a,ri=Gr.b,ii=Gr.c,si=Gr.d;return this.a=Yr*ti+Kr*ii,this.b=Yr*ri+Kr*si,this.c=Zr*ti+Qr*ii,this.d=Zr*ri+Qr*si,this.tx=Jr*ti+ei*ii+Gr.tx,this.ty=Jr*ri+ei*si+Gr.ty,this}setTransform(ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti){return this.a=Math.cos(Jr+ti)*Zr,this.b=Math.sin(Jr+ti)*Zr,this.c=-Math.sin(Jr-ei)*Qr,this.d=Math.cos(Jr-ei)*Qr,this.tx=ze-(Yr*this.a+Kr*this.c),this.ty=Gr-(Yr*this.b+Kr*this.d),this}prepend(ze){const Gr=this.tx;if(ze.a!==1||ze.b!==0||ze.c!==0||ze.d!==1){const Yr=this.a,Kr=this.c;this.a=Yr*ze.a+this.b*ze.c,this.b=Yr*ze.b+this.b*ze.d,this.c=Kr*ze.a+this.d*ze.c,this.d=Kr*ze.b+this.d*ze.d}return this.tx=Gr*ze.a+this.ty*ze.c+ze.tx,this.ty=Gr*ze.b+this.ty*ze.d+ze.ty,this}decompose(ze){const Gr=this.a,Yr=this.b,Kr=this.c,Zr=this.d,Qr=ze.pivot,Jr=-Math.atan2(-Kr,Zr),ei=Math.atan2(Yr,Gr),ti=Math.abs(Jr+ei);return ti<1e-5||Math.abs(PI_2-ti)<1e-5?(ze.rotation=ei,ze.skew.x=ze.skew.y=0):(ze.rotation=0,ze.skew.x=Jr,ze.skew.y=ei),ze.scale.x=Math.sqrt(Gr*Gr+Yr*Yr),ze.scale.y=Math.sqrt(Kr*Kr+Zr*Zr),ze.position.x=this.tx+(Qr.x*Gr+Qr.y*Kr),ze.position.y=this.ty+(Qr.x*Yr+Qr.y*Zr),ze}invert(){const ze=this.a,Gr=this.b,Yr=this.c,Kr=this.d,Zr=this.tx,Qr=ze*Kr-Gr*Yr;return this.a=Kr/Qr,this.b=-Gr/Qr,this.c=-Yr/Qr,this.d=ze/Qr,this.tx=(Yr*this.ty-Kr*Zr)/Qr,this.ty=-(ze*this.ty-Gr*Zr)/Qr,this}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.tx===0&&this.ty===0}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const ze=new Matrix;return ze.a=this.a,ze.b=this.b,ze.c=this.c,ze.d=this.d,ze.tx=this.tx,ze.ty=this.ty,ze}copyTo(ze){return ze.a=this.a,ze.b=this.b,ze.c=this.c,ze.d=this.d,ze.tx=this.tx,ze.ty=this.ty,ze}copyFrom(ze){return this.a=ze.a,this.b=ze.b,this.c=ze.c,this.d=ze.d,this.tx=ze.tx,this.ty=ze.ty,this}equals(ze){return ze.a===this.a&&ze.b===this.b&&ze.c===this.c&&ze.d===this.d&&ze.tx===this.tx&&ze.ty===this.ty}toString(){return`[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`}static get IDENTITY(){return identityMatrix$1.identity()}static get shared(){return tempMatrix$5.identity()}}const tempMatrix$5=new Matrix,identityMatrix$1=new Matrix,ux=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],uy=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],vx=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],vy=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],rotationCayley=[],rotationMatrices=[],signum=Math.sign;function init(){for(let Wr=0;Wr<16;Wr++){const ze=[];rotationCayley.push(ze);for(let Gr=0;Gr<16;Gr++){const Yr=signum(ux[Wr]*ux[Gr]+vx[Wr]*uy[Gr]),Kr=signum(uy[Wr]*ux[Gr]+vy[Wr]*uy[Gr]),Zr=signum(ux[Wr]*vx[Gr]+vx[Wr]*vy[Gr]),Qr=signum(uy[Wr]*vx[Gr]+vy[Wr]*vy[Gr]);for(let Jr=0;Jr<16;Jr++)if(ux[Jr]===Yr&&uy[Jr]===Kr&&vx[Jr]===Zr&&vy[Jr]===Qr){ze.push(Jr);break}}}for(let Wr=0;Wr<16;Wr++){const ze=new Matrix;ze.set(ux[Wr],uy[Wr],vx[Wr],vy[Wr],0,0),rotationMatrices.push(ze)}}init();const groupD8={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:Wr=>ux[Wr],uY:Wr=>uy[Wr],vX:Wr=>vx[Wr],vY:Wr=>vy[Wr],inv:Wr=>Wr&8?Wr&15:-Wr&7,add:(Wr,ze)=>rotationCayley[Wr][ze],sub:(Wr,ze)=>rotationCayley[Wr][groupD8.inv(ze)],rotate180:Wr=>Wr^4,isVertical:Wr=>(Wr&3)===2,byDirection:(Wr,ze)=>Math.abs(Wr)*2<=Math.abs(ze)?ze>=0?groupD8.S:groupD8.N:Math.abs(ze)*2<=Math.abs(Wr)?Wr>0?groupD8.E:groupD8.W:ze>0?Wr>0?groupD8.SE:groupD8.SW:Wr>0?groupD8.NE:groupD8.NW,matrixAppendRotationInv:(Wr,ze,Gr=0,Yr=0)=>{const Kr=rotationMatrices[groupD8.inv(ze)];Kr.tx=Gr,Kr.ty=Yr,Wr.append(Kr)}},tempPoints=[new Point$1,new Point$1,new Point$1,new Point$1];class Rectangle{constructor(ze=0,Gr=0,Yr=0,Kr=0){this.type="rectangle",this.x=Number(ze),this.y=Number(Gr),this.width=Number(Yr),this.height=Number(Kr)}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}isEmpty(){return this.left===this.right||this.top===this.bottom}static get EMPTY(){return new Rectangle(0,0,0,0)}clone(){return new Rectangle(this.x,this.y,this.width,this.height)}copyFromBounds(ze){return this.x=ze.minX,this.y=ze.minY,this.width=ze.maxX-ze.minX,this.height=ze.maxY-ze.minY,this}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.width=ze.width,this.height=ze.height,this}copyTo(ze){return ze.copyFrom(this),ze}contains(ze,Gr){return this.width<=0||this.height<=0?!1:ze>=this.x&&ze<this.x+this.width&&Gr>=this.y&&Gr<this.y+this.height}strokeContains(ze,Gr,Yr,Kr=.5){const{width:Zr,height:Qr}=this;if(Zr<=0||Qr<=0)return!1;const Jr=this.x,ei=this.y,ti=Yr*(1-Kr),ri=Yr-ti,ii=Jr-ti,si=Jr+Zr+ti,ni=ei-ti,oi=ei+Qr+ti,li=Jr+ri,ai=Jr+Zr-ri,ui=ei+ri,fi=ei+Qr-ri;return ze>=ii&&ze<=si&&Gr>=ni&&Gr<=oi&&!(ze>li&&ze<ai&&Gr>ui&&Gr<fi)}intersects(ze,Gr){if(!Gr){const Ci=this.x<ze.x?ze.x:this.x;if((this.right>ze.right?ze.right:this.right)<=Ci)return!1;const Pi=this.y<ze.y?ze.y:this.y;return(this.bottom>ze.bottom?ze.bottom:this.bottom)>Pi}const Yr=this.left,Kr=this.right,Zr=this.top,Qr=this.bottom;if(Kr<=Yr||Qr<=Zr)return!1;const Jr=tempPoints[0].set(ze.left,ze.top),ei=tempPoints[1].set(ze.left,ze.bottom),ti=tempPoints[2].set(ze.right,ze.top),ri=tempPoints[3].set(ze.right,ze.bottom);if(ti.x<=Jr.x||ei.y<=Jr.y)return!1;const ii=Math.sign(Gr.a*Gr.d-Gr.b*Gr.c);if(ii===0||(Gr.apply(Jr,Jr),Gr.apply(ei,ei),Gr.apply(ti,ti),Gr.apply(ri,ri),Math.max(Jr.x,ei.x,ti.x,ri.x)<=Yr||Math.min(Jr.x,ei.x,ti.x,ri.x)>=Kr||Math.max(Jr.y,ei.y,ti.y,ri.y)<=Zr||Math.min(Jr.y,ei.y,ti.y,ri.y)>=Qr))return!1;const si=ii*(ei.y-Jr.y),ni=ii*(Jr.x-ei.x),oi=si*Yr+ni*Zr,li=si*Kr+ni*Zr,ai=si*Yr+ni*Qr,ui=si*Kr+ni*Qr;if(Math.max(oi,li,ai,ui)<=si*Jr.x+ni*Jr.y||Math.min(oi,li,ai,ui)>=si*ri.x+ni*ri.y)return!1;const fi=ii*(Jr.y-ti.y),pi=ii*(ti.x-Jr.x),mi=fi*Yr+pi*Zr,Ti=fi*Kr+pi*Zr,yi=fi*Yr+pi*Qr,_i=fi*Kr+pi*Qr;return!(Math.max(mi,Ti,yi,_i)<=fi*Jr.x+pi*Jr.y||Math.min(mi,Ti,yi,_i)>=fi*ri.x+pi*ri.y)}pad(ze=0,Gr=ze){return this.x-=ze,this.y-=Gr,this.width+=ze*2,this.height+=Gr*2,this}fit(ze){const Gr=Math.max(this.x,ze.x),Yr=Math.min(this.x+this.width,ze.x+ze.width),Kr=Math.max(this.y,ze.y),Zr=Math.min(this.y+this.height,ze.y+ze.height);return this.x=Gr,this.width=Math.max(Yr-Gr,0),this.y=Kr,this.height=Math.max(Zr-Kr,0),this}ceil(ze=1,Gr=.001){const Yr=Math.ceil((this.x+this.width-Gr)*ze)/ze,Kr=Math.ceil((this.y+this.height-Gr)*ze)/ze;return this.x=Math.floor((this.x+Gr)*ze)/ze,this.y=Math.floor((this.y+Gr)*ze)/ze,this.width=Yr-this.x,this.height=Kr-this.y,this}enlarge(ze){const Gr=Math.min(this.x,ze.x),Yr=Math.max(this.x+this.width,ze.x+ze.width),Kr=Math.min(this.y,ze.y),Zr=Math.max(this.y+this.height,ze.y+ze.height);return this.x=Gr,this.width=Yr-Gr,this.y=Kr,this.height=Zr-Kr,this}getBounds(ze){return ze||(ze=new Rectangle),ze.copyFrom(this),ze}containsRect(ze){if(this.width<=0||this.height<=0)return!1;const Gr=ze.x,Yr=ze.y,Kr=ze.x+ze.width,Zr=ze.y+ze.height;return Gr>=this.x&&Gr<this.x+this.width&&Yr>=this.y&&Yr<this.y+this.height&&Kr>=this.x&&Kr<this.x+this.width&&Zr>=this.y&&Zr<this.y+this.height}toString(){return`[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`}}const uidCache={default:-1};function uid$1(Wr="default"){return uidCache[Wr]===void 0&&(uidCache[Wr]=-1),++uidCache[Wr]}const warnings={},v8_0_0="8.0.0",v8_3_4="8.3.4";function deprecation(Wr,ze,Gr=3){if(warnings[ze])return;let Yr=new Error().stack;typeof Yr>"u"?console.warn("PixiJS Deprecation Warning: ",`${ze}
Deprecated since v${Wr}`):(Yr=Yr.split(`
`).splice(Gr).join(`
`),console.groupCollapsed?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",`${ze}
Deprecated since v${Wr}`),console.warn(Yr),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",`${ze}
Deprecated since v${Wr}`),console.warn(Yr))),warnings[ze]=!0}const NOOP=()=>{};function nextPow2(Wr){return Wr+=Wr===0?1:0,--Wr,Wr|=Wr>>>1,Wr|=Wr>>>2,Wr|=Wr>>>4,Wr|=Wr>>>8,Wr|=Wr>>>16,Wr+1}function isPow2(Wr){return!(Wr&Wr-1)&&!!Wr}function definedProps(Wr){const ze={};for(const Gr in Wr)Wr[Gr]!==void 0&&(ze[Gr]=Wr[Gr]);return ze}const idHash$1=Object.create(null);function createResourceIdFromString(Wr){const ze=idHash$1[Wr];return ze===void 0&&(idHash$1[Wr]=uid$1("resource")),ze}const _TextureStyle=class vs extends EventEmitter{constructor(ze={}){super(),this._resourceType="textureSampler",this._touched=0,this._maxAnisotropy=1,this.destroyed=!1,ze={...vs.defaultOptions,...ze},this.addressMode=ze.addressMode,this.addressModeU=ze.addressModeU??this.addressModeU,this.addressModeV=ze.addressModeV??this.addressModeV,this.addressModeW=ze.addressModeW??this.addressModeW,this.scaleMode=ze.scaleMode,this.magFilter=ze.magFilter??this.magFilter,this.minFilter=ze.minFilter??this.minFilter,this.mipmapFilter=ze.mipmapFilter??this.mipmapFilter,this.lodMinClamp=ze.lodMinClamp,this.lodMaxClamp=ze.lodMaxClamp,this.compare=ze.compare,this.maxAnisotropy=ze.maxAnisotropy??1}set addressMode(ze){this.addressModeU=ze,this.addressModeV=ze,this.addressModeW=ze}get addressMode(){return this.addressModeU}set wrapMode(ze){deprecation(v8_0_0,"TextureStyle.wrapMode is now TextureStyle.addressMode"),this.addressMode=ze}get wrapMode(){return this.addressMode}set scaleMode(ze){this.magFilter=ze,this.minFilter=ze,this.mipmapFilter=ze}get scaleMode(){return this.magFilter}set maxAnisotropy(ze){this._maxAnisotropy=Math.min(ze,16),this._maxAnisotropy>1&&(this.scaleMode="linear")}get maxAnisotropy(){return this._maxAnisotropy}get _resourceId(){return this._sharedResourceId||this._generateResourceId()}update(){this.emit("change",this),this._sharedResourceId=null}_generateResourceId(){const ze=`${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;return this._sharedResourceId=createResourceIdFromString(ze),this._resourceId}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this.removeAllListeners()}};_TextureStyle.defaultOptions={addressMode:"clamp-to-edge",scaleMode:"linear"};let TextureStyle=_TextureStyle;const _TextureSource=class Ts extends EventEmitter{constructor(ze={}){super(),this.options=ze,this.uid=uid$1("textureSource"),this._resourceType="textureSource",this._resourceId=uid$1("resource"),this.uploadMethodId="unknown",this._resolution=1,this.pixelWidth=1,this.pixelHeight=1,this.width=1,this.height=1,this.sampleCount=1,this.mipLevelCount=1,this.autoGenerateMipmaps=!1,this.format="rgba8unorm",this.dimension="2d",this.antialias=!1,this._touched=0,this._batchTick=-1,this._textureBindLocation=-1,ze={...Ts.defaultOptions,...ze},this.label=ze.label??"",this.resource=ze.resource,this.autoGarbageCollect=ze.autoGarbageCollect,this._resolution=ze.resolution,ze.width?this.pixelWidth=ze.width*this._resolution:this.pixelWidth=this.resource?this.resourceWidth??1:1,ze.height?this.pixelHeight=ze.height*this._resolution:this.pixelHeight=this.resource?this.resourceHeight??1:1,this.width=this.pixelWidth/this._resolution,this.height=this.pixelHeight/this._resolution,this.format=ze.format,this.dimension=ze.dimensions,this.mipLevelCount=ze.mipLevelCount,this.autoGenerateMipmaps=ze.autoGenerateMipmaps,this.sampleCount=ze.sampleCount,this.antialias=ze.antialias,this.alphaMode=ze.alphaMode,this.style=new TextureStyle(definedProps(ze)),this.destroyed=!1,this._refreshPOT()}get source(){return this}get style(){return this._style}set style(ze){var Gr,Yr;this.style!==ze&&((Gr=this._style)==null||Gr.off("change",this._onStyleChange,this),this._style=ze,(Yr=this._style)==null||Yr.on("change",this._onStyleChange,this),this._onStyleChange())}get addressMode(){return this._style.addressMode}set addressMode(ze){this._style.addressMode=ze}get repeatMode(){return this._style.addressMode}set repeatMode(ze){this._style.addressMode=ze}get magFilter(){return this._style.magFilter}set magFilter(ze){this._style.magFilter=ze}get minFilter(){return this._style.minFilter}set minFilter(ze){this._style.minFilter=ze}get mipmapFilter(){return this._style.mipmapFilter}set mipmapFilter(ze){this._style.mipmapFilter=ze}get lodMinClamp(){return this._style.lodMinClamp}set lodMinClamp(ze){this._style.lodMinClamp=ze}get lodMaxClamp(){return this._style.lodMaxClamp}set lodMaxClamp(ze){this._style.lodMaxClamp=ze}_onStyleChange(){this.emit("styleChange",this)}update(){if(this.resource){const ze=this._resolution;if(this.resize(this.resourceWidth/ze,this.resourceHeight/ze))return}this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._style&&(this._style.destroy(),this._style=null),this.uploadMethodId=null,this.resource=null,this.removeAllListeners()}unload(){this._resourceId=uid$1("resource"),this.emit("change",this),this.emit("unload",this)}get resourceWidth(){const{resource:ze}=this;return ze.naturalWidth||ze.videoWidth||ze.displayWidth||ze.width}get resourceHeight(){const{resource:ze}=this;return ze.naturalHeight||ze.videoHeight||ze.displayHeight||ze.height}get resolution(){return this._resolution}set resolution(ze){this._resolution!==ze&&(this._resolution=ze,this.width=this.pixelWidth/ze,this.height=this.pixelHeight/ze)}resize(ze,Gr,Yr){Yr||(Yr=this._resolution),ze||(ze=this.width),Gr||(Gr=this.height);const Kr=Math.round(ze*Yr),Zr=Math.round(Gr*Yr);return this.width=Kr/Yr,this.height=Zr/Yr,this._resolution=Yr,this.pixelWidth===Kr&&this.pixelHeight===Zr?!1:(this._refreshPOT(),this.pixelWidth=Kr,this.pixelHeight=Zr,this.emit("resize",this),this._resourceId=uid$1("resource"),this.emit("change",this),!0)}updateMipmaps(){this.autoGenerateMipmaps&&this.mipLevelCount>1&&this.emit("updateMipmaps",this)}set wrapMode(ze){this._style.wrapMode=ze}get wrapMode(){return this._style.wrapMode}set scaleMode(ze){this._style.scaleMode=ze}get scaleMode(){return this._style.scaleMode}_refreshPOT(){this.isPowerOfTwo=isPow2(this.pixelWidth)&&isPow2(this.pixelHeight)}static test(ze){throw new Error("Unimplemented")}};_TextureSource.defaultOptions={resolution:1,format:"bgra8unorm",alphaMode:"premultiply-alpha-on-upload",dimensions:"2d",mipLevelCount:1,autoGenerateMipmaps:!1,sampleCount:1,antialias:!1,autoGarbageCollect:!1};let TextureSource=_TextureSource;class BufferImageSource extends TextureSource{constructor(ze){const Gr=ze.resource||new Float32Array(ze.width*ze.height*4);let Yr=ze.format;Yr||(Gr instanceof Float32Array?Yr="rgba32float":Gr instanceof Int32Array||Gr instanceof Uint32Array?Yr="rgba32uint":Gr instanceof Int16Array||Gr instanceof Uint16Array?Yr="rgba16uint":(Gr instanceof Int8Array,Yr="bgra8unorm")),super({...ze,resource:Gr,format:Yr}),this.uploadMethodId="buffer"}static test(ze){return ze instanceof Int8Array||ze instanceof Uint8Array||ze instanceof Uint8ClampedArray||ze instanceof Int16Array||ze instanceof Uint16Array||ze instanceof Int32Array||ze instanceof Uint32Array||ze instanceof Float32Array}}BufferImageSource.extension=ExtensionType.TextureSource;const tempMat=new Matrix;class TextureMatrix{constructor(ze,Gr){this.mapCoord=new Matrix,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,typeof Gr>"u"?this.clampMargin=ze.width<10?0:.5:this.clampMargin=Gr,this.isSimple=!1,this.texture=ze}get texture(){return this._texture}set texture(ze){var Gr;this.texture!==ze&&((Gr=this._texture)==null||Gr.removeListener("update",this.update,this),this._texture=ze,this._texture.addListener("update",this.update,this),this.update())}multiplyUvs(ze,Gr){Gr===void 0&&(Gr=ze);const Yr=this.mapCoord;for(let Kr=0;Kr<ze.length;Kr+=2){const Zr=ze[Kr],Qr=ze[Kr+1];Gr[Kr]=Zr*Yr.a+Qr*Yr.c+Yr.tx,Gr[Kr+1]=Zr*Yr.b+Qr*Yr.d+Yr.ty}return Gr}update(){const ze=this._texture;this._updateID++;const Gr=ze.uvs;this.mapCoord.set(Gr.x1-Gr.x0,Gr.y1-Gr.y0,Gr.x3-Gr.x0,Gr.y3-Gr.y0,Gr.x0,Gr.y0);const Yr=ze.orig,Kr=ze.trim;Kr&&(tempMat.set(Yr.width/Kr.width,0,0,Yr.height/Kr.height,-Kr.x/Kr.width,-Kr.y/Kr.height),this.mapCoord.append(tempMat));const Zr=ze.source,Qr=this.uClampFrame,Jr=this.clampMargin/Zr._resolution,ei=this.clampOffset/Zr._resolution;return Qr[0]=(ze.frame.x+Jr+ei)/Zr.width,Qr[1]=(ze.frame.y+Jr+ei)/Zr.height,Qr[2]=(ze.frame.x+ze.frame.width-Jr+ei)/Zr.width,Qr[3]=(ze.frame.y+ze.frame.height-Jr+ei)/Zr.height,this.uClampOffset[0]=this.clampOffset/Zr.pixelWidth,this.uClampOffset[1]=this.clampOffset/Zr.pixelHeight,this.isSimple=ze.frame.width===Zr.width&&ze.frame.height===Zr.height&&ze.rotate===0,!0}}class Texture extends EventEmitter{constructor({source:ze,label:Gr,frame:Yr,orig:Kr,trim:Zr,defaultAnchor:Qr,defaultBorders:Jr,rotate:ei,dynamic:ti}={}){if(super(),this.uid=uid$1("texture"),this.uvs={x0:0,y0:0,x1:0,y1:0,x2:0,y2:0,x3:0,y3:0},this.frame=new Rectangle,this.noFrame=!1,this.dynamic=!1,this.isTexture=!0,this.label=Gr,this.source=(ze==null?void 0:ze.source)??new TextureSource,this.noFrame=!Yr,Yr)this.frame.copyFrom(Yr);else{const{width:ri,height:ii}=this._source;this.frame.width=ri,this.frame.height=ii}this.orig=Kr||this.frame,this.trim=Zr,this.rotate=ei??0,this.defaultAnchor=Qr,this.defaultBorders=Jr,this.destroyed=!1,this.dynamic=ti||!1,this.updateUvs()}set source(ze){this._source&&this._source.off("resize",this.update,this),this._source=ze,ze.on("resize",this.update,this),this.emit("update",this)}get source(){return this._source}get textureMatrix(){return this._textureMatrix||(this._textureMatrix=new TextureMatrix(this)),this._textureMatrix}get width(){return this.orig.width}get height(){return this.orig.height}updateUvs(){const{uvs:ze,frame:Gr}=this,{width:Yr,height:Kr}=this._source,Zr=Gr.x/Yr,Qr=Gr.y/Kr,Jr=Gr.width/Yr,ei=Gr.height/Kr;let ti=this.rotate;if(ti){const ri=Jr/2,ii=ei/2,si=Zr+ri,ni=Qr+ii;ti=groupD8.add(ti,groupD8.NW),ze.x0=si+ri*groupD8.uX(ti),ze.y0=ni+ii*groupD8.uY(ti),ti=groupD8.add(ti,2),ze.x1=si+ri*groupD8.uX(ti),ze.y1=ni+ii*groupD8.uY(ti),ti=groupD8.add(ti,2),ze.x2=si+ri*groupD8.uX(ti),ze.y2=ni+ii*groupD8.uY(ti),ti=groupD8.add(ti,2),ze.x3=si+ri*groupD8.uX(ti),ze.y3=ni+ii*groupD8.uY(ti)}else ze.x0=Zr,ze.y0=Qr,ze.x1=Zr+Jr,ze.y1=Qr,ze.x2=Zr+Jr,ze.y2=Qr+ei,ze.x3=Zr,ze.y3=Qr+ei}destroy(ze=!1){this._source&&ze&&(this._source.destroy(),this._source=null),this._textureMatrix=null,this.destroyed=!0,this.emit("destroy",this),this.removeAllListeners()}update(){this.noFrame&&(this.frame.width=this._source.width,this.frame.height=this._source.height),this.updateUvs(),this.emit("update",this)}get baseTexture(){return deprecation(v8_0_0,"Texture.baseTexture is now Texture.source"),this._source}}Texture.EMPTY=new Texture({label:"EMPTY",source:new TextureSource({label:"EMPTY"})});Texture.EMPTY.destroy=NOOP;Texture.WHITE=new Texture({source:new BufferImageSource({resource:new Uint8Array([255,255,255,255]),width:1,height:1,alphaMode:"premultiply-alpha-on-upload",label:"WHITE"}),label:"WHITE"});Texture.WHITE.destroy=NOOP;function updateQuadBounds(Wr,ze,Gr){const{width:Yr,height:Kr}=Gr.orig,Zr=Gr.trim;if(Zr){const Qr=Zr.width,Jr=Zr.height;Wr.minX=Zr.x-ze._x*Yr,Wr.maxX=Wr.minX+Qr,Wr.minY=Zr.y-ze._y*Kr,Wr.maxY=Wr.minY+Jr}else Wr.minX=-ze._x*Yr,Wr.maxX=Wr.minX+Yr,Wr.minY=-ze._y*Kr,Wr.maxY=Wr.minY+Kr}const defaultMatrix=new Matrix;class Bounds{constructor(ze=1/0,Gr=1/0,Yr=-1/0,Kr=-1/0){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=defaultMatrix,this.minX=ze,this.minY=Gr,this.maxX=Yr,this.maxY=Kr}isEmpty(){return this.minX>this.maxX||this.minY>this.maxY}get rectangle(){this._rectangle||(this._rectangle=new Rectangle);const ze=this._rectangle;return this.minX>this.maxX||this.minY>this.maxY?(ze.x=0,ze.y=0,ze.width=0,ze.height=0):ze.copyFromBounds(this),ze}clear(){return this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=defaultMatrix,this}set(ze,Gr,Yr,Kr){this.minX=ze,this.minY=Gr,this.maxX=Yr,this.maxY=Kr}addFrame(ze,Gr,Yr,Kr,Zr){Zr||(Zr=this.matrix);const Qr=Zr.a,Jr=Zr.b,ei=Zr.c,ti=Zr.d,ri=Zr.tx,ii=Zr.ty;let si=this.minX,ni=this.minY,oi=this.maxX,li=this.maxY,ai=Qr*ze+ei*Gr+ri,ui=Jr*ze+ti*Gr+ii;ai<si&&(si=ai),ui<ni&&(ni=ui),ai>oi&&(oi=ai),ui>li&&(li=ui),ai=Qr*Yr+ei*Gr+ri,ui=Jr*Yr+ti*Gr+ii,ai<si&&(si=ai),ui<ni&&(ni=ui),ai>oi&&(oi=ai),ui>li&&(li=ui),ai=Qr*ze+ei*Kr+ri,ui=Jr*ze+ti*Kr+ii,ai<si&&(si=ai),ui<ni&&(ni=ui),ai>oi&&(oi=ai),ui>li&&(li=ui),ai=Qr*Yr+ei*Kr+ri,ui=Jr*Yr+ti*Kr+ii,ai<si&&(si=ai),ui<ni&&(ni=ui),ai>oi&&(oi=ai),ui>li&&(li=ui),this.minX=si,this.minY=ni,this.maxX=oi,this.maxY=li}addRect(ze,Gr){this.addFrame(ze.x,ze.y,ze.x+ze.width,ze.y+ze.height,Gr)}addBounds(ze,Gr){this.addFrame(ze.minX,ze.minY,ze.maxX,ze.maxY,Gr)}addBoundsMask(ze){this.minX=this.minX>ze.minX?this.minX:ze.minX,this.minY=this.minY>ze.minY?this.minY:ze.minY,this.maxX=this.maxX<ze.maxX?this.maxX:ze.maxX,this.maxY=this.maxY<ze.maxY?this.maxY:ze.maxY}applyMatrix(ze){const Gr=this.minX,Yr=this.minY,Kr=this.maxX,Zr=this.maxY,{a:Qr,b:Jr,c:ei,d:ti,tx:ri,ty:ii}=ze;let si=Qr*Gr+ei*Yr+ri,ni=Jr*Gr+ti*Yr+ii;this.minX=si,this.minY=ni,this.maxX=si,this.maxY=ni,si=Qr*Kr+ei*Yr+ri,ni=Jr*Kr+ti*Yr+ii,this.minX=si<this.minX?si:this.minX,this.minY=ni<this.minY?ni:this.minY,this.maxX=si>this.maxX?si:this.maxX,this.maxY=ni>this.maxY?ni:this.maxY,si=Qr*Gr+ei*Zr+ri,ni=Jr*Gr+ti*Zr+ii,this.minX=si<this.minX?si:this.minX,this.minY=ni<this.minY?ni:this.minY,this.maxX=si>this.maxX?si:this.maxX,this.maxY=ni>this.maxY?ni:this.maxY,si=Qr*Kr+ei*Zr+ri,ni=Jr*Kr+ti*Zr+ii,this.minX=si<this.minX?si:this.minX,this.minY=ni<this.minY?ni:this.minY,this.maxX=si>this.maxX?si:this.maxX,this.maxY=ni>this.maxY?ni:this.maxY}fit(ze){return this.minX<ze.left&&(this.minX=ze.left),this.maxX>ze.right&&(this.maxX=ze.right),this.minY<ze.top&&(this.minY=ze.top),this.maxY>ze.bottom&&(this.maxY=ze.bottom),this}fitBounds(ze,Gr,Yr,Kr){return this.minX<ze&&(this.minX=ze),this.maxX>Gr&&(this.maxX=Gr),this.minY<Yr&&(this.minY=Yr),this.maxY>Kr&&(this.maxY=Kr),this}pad(ze,Gr=ze){return this.minX-=ze,this.maxX+=ze,this.minY-=Gr,this.maxY+=Gr,this}ceil(){return this.minX=Math.floor(this.minX),this.minY=Math.floor(this.minY),this.maxX=Math.ceil(this.maxX),this.maxY=Math.ceil(this.maxY),this}clone(){return new Bounds(this.minX,this.minY,this.maxX,this.maxY)}scale(ze,Gr=ze){return this.minX*=ze,this.minY*=Gr,this.maxX*=ze,this.maxY*=Gr,this}get x(){return this.minX}set x(ze){const Gr=this.maxX-this.minX;this.minX=ze,this.maxX=ze+Gr}get y(){return this.minY}set y(ze){const Gr=this.maxY-this.minY;this.minY=ze,this.maxY=ze+Gr}get width(){return this.maxX-this.minX}set width(ze){this.maxX=this.minX+ze}get height(){return this.maxY-this.minY}set height(ze){this.maxY=this.minY+ze}get left(){return this.minX}get right(){return this.maxX}get top(){return this.minY}get bottom(){return this.maxY}get isPositive(){return this.maxX-this.minX>0&&this.maxY-this.minY>0}get isValid(){return this.minX+this.minY!==1/0}addVertexData(ze,Gr,Yr,Kr){let Zr=this.minX,Qr=this.minY,Jr=this.maxX,ei=this.maxY;Kr||(Kr=this.matrix);const ti=Kr.a,ri=Kr.b,ii=Kr.c,si=Kr.d,ni=Kr.tx,oi=Kr.ty;for(let li=Gr;li<Yr;li+=2){const ai=ze[li],ui=ze[li+1],fi=ti*ai+ii*ui+ni,pi=ri*ai+si*ui+oi;Zr=fi<Zr?fi:Zr,Qr=pi<Qr?pi:Qr,Jr=fi>Jr?fi:Jr,ei=pi>ei?pi:ei}this.minX=Zr,this.minY=Qr,this.maxX=Jr,this.maxY=ei}containsPoint(ze,Gr){return this.minX<=ze&&this.minY<=Gr&&this.maxX>=ze&&this.maxY>=Gr}toString(){return`[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`}copyFrom(ze){return this.minX=ze.minX,this.minY=ze.minY,this.maxX=ze.maxX,this.maxY=ze.maxY,this}}var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(Wr){return typeof Wr=="string"?Wr.length>0:typeof Wr=="number"},n=function(Wr,ze,Gr){return ze===void 0&&(ze=0),Gr===void 0&&(Gr=Math.pow(10,ze)),Math.round(Gr*Wr)/Gr+0},e=function(Wr,ze,Gr){return ze===void 0&&(ze=0),Gr===void 0&&(Gr=1),Wr>Gr?Gr:Wr>ze?Wr:ze},u=function(Wr){return(Wr=isFinite(Wr)?Wr%360:0)>0?Wr:Wr+360},a=function(Wr){return{r:e(Wr.r,0,255),g:e(Wr.g,0,255),b:e(Wr.b,0,255),a:e(Wr.a)}},o=function(Wr){return{r:n(Wr.r),g:n(Wr.g),b:n(Wr.b),a:n(Wr.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(Wr){var ze=Wr.toString(16);return ze.length<2?"0"+ze:ze},h=function(Wr){var ze=Wr.r,Gr=Wr.g,Yr=Wr.b,Kr=Wr.a,Zr=Math.max(ze,Gr,Yr),Qr=Zr-Math.min(ze,Gr,Yr),Jr=Qr?Zr===ze?(Gr-Yr)/Qr:Zr===Gr?2+(Yr-ze)/Qr:4+(ze-Gr)/Qr:0;return{h:60*(Jr<0?Jr+6:Jr),s:Zr?Qr/Zr*100:0,v:Zr/255*100,a:Kr}},b=function(Wr){var ze=Wr.h,Gr=Wr.s,Yr=Wr.v,Kr=Wr.a;ze=ze/360*6,Gr/=100,Yr/=100;var Zr=Math.floor(ze),Qr=Yr*(1-Gr),Jr=Yr*(1-(ze-Zr)*Gr),ei=Yr*(1-(1-ze+Zr)*Gr),ti=Zr%6;return{r:255*[Yr,Jr,Qr,Qr,ei,Yr][ti],g:255*[ei,Yr,Yr,Jr,Qr,Qr][ti],b:255*[Qr,Qr,ei,Yr,Yr,Jr][ti],a:Kr}},g=function(Wr){return{h:u(Wr.h),s:e(Wr.s,0,100),l:e(Wr.l,0,100),a:e(Wr.a)}},d=function(Wr){return{h:n(Wr.h),s:n(Wr.s),l:n(Wr.l),a:n(Wr.a,3)}},f=function(Wr){return b((Gr=(ze=Wr).s,{h:ze.h,s:(Gr*=((Yr=ze.l)<50?Yr:100-Yr)/100)>0?2*Gr/(Yr+Gr)*100:0,v:Yr+Gr,a:ze.a}));var ze,Gr,Yr},c=function(Wr){return{h:(ze=h(Wr)).h,s:(Kr=(200-(Gr=ze.s))*(Yr=ze.v)/100)>0&&Kr<200?Gr*Yr/100/(Kr<=100?Kr:200-Kr)*100:0,l:Kr/2,a:ze.a};var ze,Gr,Yr,Kr},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(Wr){var ze=i.exec(Wr);return ze?(Wr=ze[1]).length<=4?{r:parseInt(Wr[0]+Wr[0],16),g:parseInt(Wr[1]+Wr[1],16),b:parseInt(Wr[2]+Wr[2],16),a:Wr.length===4?n(parseInt(Wr[3]+Wr[3],16)/255,2):1}:Wr.length===6||Wr.length===8?{r:parseInt(Wr.substr(0,2),16),g:parseInt(Wr.substr(2,2),16),b:parseInt(Wr.substr(4,2),16),a:Wr.length===8?n(parseInt(Wr.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(Wr){var ze=v.exec(Wr)||m.exec(Wr);return ze?ze[2]!==ze[4]||ze[4]!==ze[6]?null:a({r:Number(ze[1])/(ze[2]?100/255:1),g:Number(ze[3])/(ze[4]?100/255:1),b:Number(ze[5])/(ze[6]?100/255:1),a:ze[7]===void 0?1:Number(ze[7])/(ze[8]?100:1)}):null},"rgb"],[function(Wr){var ze=l.exec(Wr)||p.exec(Wr);if(!ze)return null;var Gr,Yr,Kr=g({h:(Gr=ze[1],Yr=ze[2],Yr===void 0&&(Yr="deg"),Number(Gr)*(r[Yr]||1)),s:Number(ze[3]),l:Number(ze[4]),a:ze[5]===void 0?1:Number(ze[5])/(ze[6]?100:1)});return f(Kr)},"hsl"]],object:[[function(Wr){var ze=Wr.r,Gr=Wr.g,Yr=Wr.b,Kr=Wr.a,Zr=Kr===void 0?1:Kr;return t(ze)&&t(Gr)&&t(Yr)?a({r:Number(ze),g:Number(Gr),b:Number(Yr),a:Number(Zr)}):null},"rgb"],[function(Wr){var ze=Wr.h,Gr=Wr.s,Yr=Wr.l,Kr=Wr.a,Zr=Kr===void 0?1:Kr;if(!t(ze)||!t(Gr)||!t(Yr))return null;var Qr=g({h:Number(ze),s:Number(Gr),l:Number(Yr),a:Number(Zr)});return f(Qr)},"hsl"],[function(Wr){var ze=Wr.h,Gr=Wr.s,Yr=Wr.v,Kr=Wr.a,Zr=Kr===void 0?1:Kr;if(!t(ze)||!t(Gr)||!t(Yr))return null;var Qr=function(Jr){return{h:u(Jr.h),s:e(Jr.s,0,100),v:e(Jr.v,0,100),a:e(Jr.a)}}({h:Number(ze),s:Number(Gr),v:Number(Yr),a:Number(Zr)});return b(Qr)},"hsv"]]},N=function(Wr,ze){for(var Gr=0;Gr<ze.length;Gr++){var Yr=ze[Gr][0](Wr);if(Yr)return[Yr,ze[Gr][1]]}return[null,void 0]},x=function(Wr){return typeof Wr=="string"?N(Wr.trim(),y.string):typeof Wr=="object"&&Wr!==null?N(Wr,y.object):[null,void 0]},M=function(Wr,ze){var Gr=c(Wr);return{h:Gr.h,s:e(Gr.s+100*ze,0,100),l:Gr.l,a:Gr.a}},H=function(Wr){return(299*Wr.r+587*Wr.g+114*Wr.b)/1e3/255},$=function(Wr,ze){var Gr=c(Wr);return{h:Gr.h,s:Gr.s,l:e(Gr.l+100*ze,0,100),a:Gr.a}},j=function(){function Wr(ze){this.parsed=x(ze)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return Wr.prototype.isValid=function(){return this.parsed!==null},Wr.prototype.brightness=function(){return n(H(this.rgba),2)},Wr.prototype.isDark=function(){return H(this.rgba)<.5},Wr.prototype.isLight=function(){return H(this.rgba)>=.5},Wr.prototype.toHex=function(){return ze=o(this.rgba),Gr=ze.r,Yr=ze.g,Kr=ze.b,Qr=(Zr=ze.a)<1?s(n(255*Zr)):"","#"+s(Gr)+s(Yr)+s(Kr)+Qr;var ze,Gr,Yr,Kr,Zr,Qr},Wr.prototype.toRgb=function(){return o(this.rgba)},Wr.prototype.toRgbString=function(){return ze=o(this.rgba),Gr=ze.r,Yr=ze.g,Kr=ze.b,(Zr=ze.a)<1?"rgba("+Gr+", "+Yr+", "+Kr+", "+Zr+")":"rgb("+Gr+", "+Yr+", "+Kr+")";var ze,Gr,Yr,Kr,Zr},Wr.prototype.toHsl=function(){return d(c(this.rgba))},Wr.prototype.toHslString=function(){return ze=d(c(this.rgba)),Gr=ze.h,Yr=ze.s,Kr=ze.l,(Zr=ze.a)<1?"hsla("+Gr+", "+Yr+"%, "+Kr+"%, "+Zr+")":"hsl("+Gr+", "+Yr+"%, "+Kr+"%)";var ze,Gr,Yr,Kr,Zr},Wr.prototype.toHsv=function(){return ze=h(this.rgba),{h:n(ze.h),s:n(ze.s),v:n(ze.v),a:n(ze.a,3)};var ze},Wr.prototype.invert=function(){return w({r:255-(ze=this.rgba).r,g:255-ze.g,b:255-ze.b,a:ze.a});var ze},Wr.prototype.saturate=function(ze){return ze===void 0&&(ze=.1),w(M(this.rgba,ze))},Wr.prototype.desaturate=function(ze){return ze===void 0&&(ze=.1),w(M(this.rgba,-ze))},Wr.prototype.grayscale=function(){return w(M(this.rgba,-1))},Wr.prototype.lighten=function(ze){return ze===void 0&&(ze=.1),w($(this.rgba,ze))},Wr.prototype.darken=function(ze){return ze===void 0&&(ze=.1),w($(this.rgba,-ze))},Wr.prototype.rotate=function(ze){return ze===void 0&&(ze=15),this.hue(this.hue()+ze)},Wr.prototype.alpha=function(ze){return typeof ze=="number"?w({r:(Gr=this.rgba).r,g:Gr.g,b:Gr.b,a:ze}):n(this.rgba.a,3);var Gr},Wr.prototype.hue=function(ze){var Gr=c(this.rgba);return typeof ze=="number"?w({h:ze,s:Gr.s,l:Gr.l,a:Gr.a}):n(Gr.h)},Wr.prototype.isEqual=function(ze){return this.toHex()===w(ze).toHex()},Wr}(),w=function(Wr){return Wr instanceof j?Wr:new j(Wr)},S=[],k=function(Wr){Wr.forEach(function(ze){S.indexOf(ze)<0&&(ze(j,y),S.push(ze))})};function namesPlugin(Wr,ze){var Gr={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},Yr={};for(var Kr in Gr)Yr[Gr[Kr]]=Kr;var Zr={};Wr.prototype.toName=function(Qr){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var Jr,ei,ti=Yr[this.toHex()];if(ti)return ti;if(Qr!=null&&Qr.closest){var ri=this.toRgb(),ii=1/0,si="black";if(!Zr.length)for(var ni in Gr)Zr[ni]=new Wr(Gr[ni]).toRgb();for(var oi in Gr){var li=(Jr=ri,ei=Zr[oi],Math.pow(Jr.r-ei.r,2)+Math.pow(Jr.g-ei.g,2)+Math.pow(Jr.b-ei.b,2));li<ii&&(ii=li,si=oi)}return si}},ze.string.push([function(Qr){var Jr=Qr.toLowerCase(),ei=Jr==="transparent"?"#0000":Gr[Jr];return ei?new Wr(ei).toRgb():null},"name"])}k([namesPlugin]);const _Color=class ss{constructor(ze=16777215){this._value=null,this._components=new Float32Array(4),this._components.fill(1),this._int=16777215,this.value=ze}get red(){return this._components[0]}get green(){return this._components[1]}get blue(){return this._components[2]}get alpha(){return this._components[3]}setValue(ze){return this.value=ze,this}set value(ze){if(ze instanceof ss)this._value=this._cloneSource(ze._value),this._int=ze._int,this._components.set(ze._components);else{if(ze===null)throw new Error("Cannot set Color#value to null");(this._value===null||!this._isSourceEqual(this._value,ze))&&(this._value=this._cloneSource(ze),this._normalize(this._value))}}get value(){return this._value}_cloneSource(ze){return typeof ze=="string"||typeof ze=="number"||ze instanceof Number||ze===null?ze:Array.isArray(ze)||ArrayBuffer.isView(ze)?ze.slice(0):typeof ze=="object"&&ze!==null?{...ze}:ze}_isSourceEqual(ze,Gr){const Yr=typeof ze;if(Yr!==typeof Gr)return!1;if(Yr==="number"||Yr==="string"||ze instanceof Number)return ze===Gr;if(Array.isArray(ze)&&Array.isArray(Gr)||ArrayBuffer.isView(ze)&&ArrayBuffer.isView(Gr))return ze.length!==Gr.length?!1:ze.every((Zr,Qr)=>Zr===Gr[Qr]);if(ze!==null&&Gr!==null){const Zr=Object.keys(ze),Qr=Object.keys(Gr);return Zr.length!==Qr.length?!1:Zr.every(Jr=>ze[Jr]===Gr[Jr])}return ze===Gr}toRgba(){const[ze,Gr,Yr,Kr]=this._components;return{r:ze,g:Gr,b:Yr,a:Kr}}toRgb(){const[ze,Gr,Yr]=this._components;return{r:ze,g:Gr,b:Yr}}toRgbaString(){const[ze,Gr,Yr]=this.toUint8RgbArray();return`rgba(${ze},${Gr},${Yr},${this.alpha})`}toUint8RgbArray(ze){const[Gr,Yr,Kr]=this._components;return this._arrayRgb||(this._arrayRgb=[]),ze||(ze=this._arrayRgb),ze[0]=Math.round(Gr*255),ze[1]=Math.round(Yr*255),ze[2]=Math.round(Kr*255),ze}toArray(ze){this._arrayRgba||(this._arrayRgba=[]),ze||(ze=this._arrayRgba);const[Gr,Yr,Kr,Zr]=this._components;return ze[0]=Gr,ze[1]=Yr,ze[2]=Kr,ze[3]=Zr,ze}toRgbArray(ze){this._arrayRgb||(this._arrayRgb=[]),ze||(ze=this._arrayRgb);const[Gr,Yr,Kr]=this._components;return ze[0]=Gr,ze[1]=Yr,ze[2]=Kr,ze}toNumber(){return this._int}toBgrNumber(){const[ze,Gr,Yr]=this.toUint8RgbArray();return(Yr<<16)+(Gr<<8)+ze}toLittleEndianNumber(){const ze=this._int;return(ze>>16)+(ze&65280)+((ze&255)<<16)}multiply(ze){const[Gr,Yr,Kr,Zr]=ss._temp.setValue(ze)._components;return this._components[0]*=Gr,this._components[1]*=Yr,this._components[2]*=Kr,this._components[3]*=Zr,this._refreshInt(),this._value=null,this}premultiply(ze,Gr=!0){return Gr&&(this._components[0]*=ze,this._components[1]*=ze,this._components[2]*=ze),this._components[3]=ze,this._refreshInt(),this._value=null,this}toPremultiplied(ze,Gr=!0){if(ze===1)return(255<<24)+this._int;if(ze===0)return Gr?0:this._int;let Yr=this._int>>16&255,Kr=this._int>>8&255,Zr=this._int&255;return Gr&&(Yr=Yr*ze+.5|0,Kr=Kr*ze+.5|0,Zr=Zr*ze+.5|0),(ze*255<<24)+(Yr<<16)+(Kr<<8)+Zr}toHex(){const ze=this._int.toString(16);return`#${"000000".substring(0,6-ze.length)+ze}`}toHexa(){const Gr=Math.round(this._components[3]*255).toString(16);return this.toHex()+"00".substring(0,2-Gr.length)+Gr}setAlpha(ze){return this._components[3]=this._clamp(ze),this}_normalize(ze){let Gr,Yr,Kr,Zr;if((typeof ze=="number"||ze instanceof Number)&&ze>=0&&ze<=16777215){const Qr=ze;Gr=(Qr>>16&255)/255,Yr=(Qr>>8&255)/255,Kr=(Qr&255)/255,Zr=1}else if((Array.isArray(ze)||ze instanceof Float32Array)&&ze.length>=3&&ze.length<=4)ze=this._clamp(ze),[Gr,Yr,Kr,Zr=1]=ze;else if((ze instanceof Uint8Array||ze instanceof Uint8ClampedArray)&&ze.length>=3&&ze.length<=4)ze=this._clamp(ze,0,255),[Gr,Yr,Kr,Zr=255]=ze,Gr/=255,Yr/=255,Kr/=255,Zr/=255;else if(typeof ze=="string"||typeof ze=="object"){if(typeof ze=="string"){const Jr=ss.HEX_PATTERN.exec(ze);Jr&&(ze=`#${Jr[2]}`)}const Qr=w(ze);Qr.isValid()&&({r:Gr,g:Yr,b:Kr,a:Zr}=Qr.rgba,Gr/=255,Yr/=255,Kr/=255)}if(Gr!==void 0)this._components[0]=Gr,this._components[1]=Yr,this._components[2]=Kr,this._components[3]=Zr,this._refreshInt();else throw new Error(`Unable to convert color ${ze}`)}_refreshInt(){this._clamp(this._components);const[ze,Gr,Yr]=this._components;this._int=(ze*255<<16)+(Gr*255<<8)+(Yr*255|0)}_clamp(ze,Gr=0,Yr=1){return typeof ze=="number"?Math.min(Math.max(ze,Gr),Yr):(ze.forEach((Kr,Zr)=>{ze[Zr]=Math.min(Math.max(Kr,Gr),Yr)}),ze)}static isColorLike(ze){return typeof ze=="number"||typeof ze=="string"||ze instanceof Number||ze instanceof ss||Array.isArray(ze)||ze instanceof Uint8Array||ze instanceof Uint8ClampedArray||ze instanceof Float32Array||ze.r!==void 0&&ze.g!==void 0&&ze.b!==void 0||ze.r!==void 0&&ze.g!==void 0&&ze.b!==void 0&&ze.a!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.l!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.l!==void 0&&ze.a!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.v!==void 0||ze.h!==void 0&&ze.s!==void 0&&ze.v!==void 0&&ze.a!==void 0}};_Color.shared=new _Color;_Color._temp=new _Color;_Color.HEX_PATTERN=/^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;let Color=_Color;const cullingMixin={cullArea:null,cullable:!1,cullableChildren:!0};class Pool{constructor(ze,Gr){this._pool=[],this._count=0,this._index=0,this._classType=ze,Gr&&this.prepopulate(Gr)}prepopulate(ze){for(let Gr=0;Gr<ze;Gr++)this._pool[this._index++]=new this._classType;this._count+=ze}get(ze){var Yr;let Gr;return this._index>0?Gr=this._pool[--this._index]:Gr=new this._classType,(Yr=Gr.init)==null||Yr.call(Gr,ze),Gr}return(ze){var Gr;(Gr=ze.reset)==null||Gr.call(ze),this._pool[this._index++]=ze}get totalSize(){return this._count}get totalFree(){return this._index}get totalUsed(){return this._count-this._index}clear(){this._pool.length=0,this._index=0}}class PoolGroupClass{constructor(){this._poolsByClass=new Map}prepopulate(ze,Gr){this.getPool(ze).prepopulate(Gr)}get(ze,Gr){return this.getPool(ze).get(Gr)}return(ze){this.getPool(ze.constructor).return(ze)}getPool(ze){return this._poolsByClass.has(ze)||this._poolsByClass.set(ze,new Pool(ze)),this._poolsByClass.get(ze)}stats(){const ze={};return this._poolsByClass.forEach(Gr=>{const Yr=ze[Gr._classType.name]?Gr._classType.name+Gr._classType.ID:Gr._classType.name;ze[Yr]={free:Gr.totalFree,used:Gr.totalUsed,size:Gr.totalSize}}),ze}}const BigPool=new PoolGroupClass,cacheAsTextureMixin={get isCachedAsTexture(){var Wr;return!!((Wr=this.renderGroup)!=null&&Wr.isCachedAsTexture)},cacheAsTexture(Wr){typeof Wr=="boolean"&&Wr===!1?this.disableRenderGroup():(this.enableRenderGroup(),this.renderGroup.enableCacheAsTexture(Wr===!0?{}:Wr))},updateCacheTexture(){var Wr;(Wr=this.renderGroup)==null||Wr.updateCacheTexture()},get cacheAsBitmap(){return this.isCachedAsTexture},set cacheAsBitmap(Wr){deprecation("v8.6.0","cacheAsBitmap is deprecated, use cacheAsTexture instead."),this.cacheAsTexture(Wr)}};function removeItems(Wr,ze,Gr){const Yr=Wr.length;let Kr;if(ze>=Yr||Gr===0)return;Gr=ze+Gr>Yr?Yr-ze:Gr;const Zr=Yr-Gr;for(Kr=ze;Kr<Zr;++Kr)Wr[Kr]=Wr[Kr+Gr];Wr.length=Zr}const childrenHelperMixin={allowChildren:!0,removeChildren(Wr=0,ze){const Gr=ze??this.children.length,Yr=Gr-Wr,Kr=[];if(Yr>0&&Yr<=Gr){for(let Qr=Gr-1;Qr>=Wr;Qr--){const Jr=this.children[Qr];Jr&&(Kr.push(Jr),Jr.parent=null)}removeItems(this.children,Wr,Gr);const Zr=this.renderGroup||this.parentRenderGroup;Zr&&Zr.removeChildren(Kr);for(let Qr=0;Qr<Kr.length;++Qr)this.emit("childRemoved",Kr[Qr],this,Qr),Kr[Qr].emit("removed",this);return Kr.length>0&&this._didViewChangeTick++,Kr}else if(Yr===0&&this.children.length===0)return Kr;throw new RangeError("removeChildren: numeric values are outside the acceptable range.")},removeChildAt(Wr){const ze=this.getChildAt(Wr);return this.removeChild(ze)},getChildAt(Wr){if(Wr<0||Wr>=this.children.length)throw new Error(`getChildAt: Index (${Wr}) does not exist.`);return this.children[Wr]},setChildIndex(Wr,ze){if(ze<0||ze>=this.children.length)throw new Error(`The index ${ze} supplied is out of bounds ${this.children.length}`);this.getChildIndex(Wr),this.addChildAt(Wr,ze)},getChildIndex(Wr){const ze=this.children.indexOf(Wr);if(ze===-1)throw new Error("The supplied Container must be a child of the caller");return ze},addChildAt(Wr,ze){this.allowChildren||deprecation(v8_0_0,"addChildAt: Only Containers will be allowed to add children in v8.0.0");const{children:Gr}=this;if(ze<0||ze>Gr.length)throw new Error(`${Wr}addChildAt: The index ${ze} supplied is out of bounds ${Gr.length}`);if(Wr.parent){const Kr=Wr.parent.children.indexOf(Wr);if(Wr.parent===this&&Kr===ze)return Wr;Kr!==-1&&Wr.parent.children.splice(Kr,1)}ze===Gr.length?Gr.push(Wr):Gr.splice(ze,0,Wr),Wr.parent=this,Wr.didChange=!0,Wr._updateFlags=15;const Yr=this.renderGroup||this.parentRenderGroup;return Yr&&Yr.addChild(Wr),this.sortableChildren&&(this.sortDirty=!0),this.emit("childAdded",Wr,this,ze),Wr.emit("added",this),Wr},swapChildren(Wr,ze){if(Wr===ze)return;const Gr=this.getChildIndex(Wr),Yr=this.getChildIndex(ze);this.children[Gr]=ze,this.children[Yr]=Wr;const Kr=this.renderGroup||this.parentRenderGroup;Kr&&(Kr.structureDidChange=!0),this._didContainerChangeTick++},removeFromParent(){var Wr;(Wr=this.parent)==null||Wr.removeChild(this)},reparentChild(...Wr){return Wr.length===1?this.reparentChildAt(Wr[0],this.children.length):(Wr.forEach(ze=>this.reparentChildAt(ze,this.children.length)),Wr[0])},reparentChildAt(Wr,ze){if(Wr.parent===this)return this.setChildIndex(Wr,ze),Wr;const Gr=Wr.worldTransform.clone();Wr.removeFromParent(),this.addChildAt(Wr,ze);const Yr=this.worldTransform.clone();return Yr.invert(),Gr.prepend(Yr),Wr.setFromMatrix(Gr),Wr}},collectRenderablesMixin={collectRenderables(Wr,ze,Gr){this.parentRenderLayer&&this.parentRenderLayer!==Gr||this.globalDisplayStatus<7||!this.includeInBuild||(this.sortableChildren&&this.sortChildren(),this.isSimple?this.collectRenderablesSimple(Wr,ze,Gr):this.renderGroup?ze.renderPipes.renderGroup.addRenderGroup(this.renderGroup,Wr):this.collectRenderablesWithEffects(Wr,ze,Gr))},collectRenderablesSimple(Wr,ze,Gr){const Yr=this.children,Kr=Yr.length;for(let Zr=0;Zr<Kr;Zr++)Yr[Zr].collectRenderables(Wr,ze,Gr)},collectRenderablesWithEffects(Wr,ze,Gr){const{renderPipes:Yr}=ze;for(let Kr=0;Kr<this.effects.length;Kr++){const Zr=this.effects[Kr];Yr[Zr.pipe].push(Zr,this,Wr)}this.collectRenderablesSimple(Wr,ze,Gr);for(let Kr=this.effects.length-1;Kr>=0;Kr--){const Zr=this.effects[Kr];Yr[Zr.pipe].pop(Zr,this,Wr)}}};class FilterEffect{constructor(){this.pipe="filter",this.priority=1}destroy(){for(let ze=0;ze<this.filters.length;ze++)this.filters[ze].destroy();this.filters=null,this.filterArea=null}}class MaskEffectManagerClass{constructor(){this._effectClasses=[],this._tests=[],this._initialized=!1}init(){this._initialized||(this._initialized=!0,this._effectClasses.forEach(ze=>{this.add({test:ze.test,maskClass:ze})}))}add(ze){this._tests.push(ze)}getMaskEffect(ze){this._initialized||this.init();for(let Gr=0;Gr<this._tests.length;Gr++){const Yr=this._tests[Gr];if(Yr.test(ze))return BigPool.get(Yr.maskClass,ze)}return ze}returnMaskEffect(ze){BigPool.return(ze)}}const MaskEffectManager=new MaskEffectManagerClass;extensions.handleByList(ExtensionType.MaskEffect,MaskEffectManager._effectClasses);const effectsMixin={_maskEffect:null,_maskOptions:{inverse:!1},_filterEffect:null,effects:[],_markStructureAsChanged(){const Wr=this.renderGroup||this.parentRenderGroup;Wr&&(Wr.structureDidChange=!0)},addEffect(Wr){this.effects.indexOf(Wr)===-1&&(this.effects.push(Wr),this.effects.sort((Gr,Yr)=>Gr.priority-Yr.priority),this._markStructureAsChanged(),this._updateIsSimple())},removeEffect(Wr){const ze=this.effects.indexOf(Wr);ze!==-1&&(this.effects.splice(ze,1),this._markStructureAsChanged(),this._updateIsSimple())},set mask(Wr){const ze=this._maskEffect;(ze==null?void 0:ze.mask)!==Wr&&(ze&&(this.removeEffect(ze),MaskEffectManager.returnMaskEffect(ze),this._maskEffect=null),Wr!=null&&(this._maskEffect=MaskEffectManager.getMaskEffect(Wr),this.addEffect(this._maskEffect)))},setMask(Wr){this._maskOptions={...this._maskOptions,...Wr},Wr.mask&&(this.mask=Wr.mask),this._markStructureAsChanged()},get mask(){var Wr;return(Wr=this._maskEffect)==null?void 0:Wr.mask},set filters(Wr){var Zr;!Array.isArray(Wr)&&Wr&&(Wr=[Wr]);const ze=this._filterEffect||(this._filterEffect=new FilterEffect);Wr=Wr;const Gr=(Wr==null?void 0:Wr.length)>0,Yr=((Zr=ze.filters)==null?void 0:Zr.length)>0,Kr=Gr!==Yr;Wr=Array.isArray(Wr)?Wr.slice(0):Wr,ze.filters=Object.freeze(Wr),Kr&&(Gr?this.addEffect(ze):(this.removeEffect(ze),ze.filters=Wr??null))},get filters(){var Wr;return(Wr=this._filterEffect)==null?void 0:Wr.filters},set filterArea(Wr){this._filterEffect||(this._filterEffect=new FilterEffect),this._filterEffect.filterArea=Wr},get filterArea(){var Wr;return(Wr=this._filterEffect)==null?void 0:Wr.filterArea}},findMixin={label:null,get name(){return deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label},set name(Wr){deprecation(v8_0_0,"Container.name property has been removed, use Container.label instead"),this.label=Wr},getChildByName(Wr,ze=!1){return this.getChildByLabel(Wr,ze)},getChildByLabel(Wr,ze=!1){const Gr=this.children;for(let Yr=0;Yr<Gr.length;Yr++){const Kr=Gr[Yr];if(Kr.label===Wr||Wr instanceof RegExp&&Wr.test(Kr.label))return Kr}if(ze)for(let Yr=0;Yr<Gr.length;Yr++){const Zr=Gr[Yr].getChildByLabel(Wr,!0);if(Zr)return Zr}return null},getChildrenByLabel(Wr,ze=!1,Gr=[]){const Yr=this.children;for(let Kr=0;Kr<Yr.length;Kr++){const Zr=Yr[Kr];(Zr.label===Wr||Wr instanceof RegExp&&Wr.test(Zr.label))&&Gr.push(Zr)}if(ze)for(let Kr=0;Kr<Yr.length;Kr++)Yr[Kr].getChildrenByLabel(Wr,!0,Gr);return Gr}},matrixPool=new Pool(Matrix),boundsPool=new Pool(Bounds),tempMatrix$4=new Matrix,getFastGlobalBoundsMixin={getFastGlobalBounds(Wr,ze){ze||(ze=new Bounds),ze.clear(),this._getGlobalBoundsRecursive(!!Wr,ze,this.parentRenderLayer),ze.isValid||ze.set(0,0,0,0);const Gr=this.renderGroup||this.parentRenderGroup;return ze.applyMatrix(Gr.worldTransform),ze},_getGlobalBoundsRecursive(Wr,ze,Gr){let Yr=ze;if(Wr&&this.parentRenderLayer&&this.parentRenderLayer!==Gr||this.localDisplayStatus!==7||!this.measurable)return;const Kr=!!this.effects.length;if((this.renderGroup||Kr)&&(Yr=boundsPool.get().clear()),this.boundsArea)ze.addRect(this.boundsArea,this.worldTransform);else{if(this.renderPipeId){const Qr=this.bounds;Yr.addFrame(Qr.minX,Qr.minY,Qr.maxX,Qr.maxY,this.groupTransform)}const Zr=this.children;for(let Qr=0;Qr<Zr.length;Qr++)Zr[Qr]._getGlobalBoundsRecursive(Wr,Yr,Gr)}if(Kr){let Zr=!1;const Qr=this.renderGroup||this.parentRenderGroup;for(let Jr=0;Jr<this.effects.length;Jr++)this.effects[Jr].addBounds&&(Zr||(Zr=!0,Yr.applyMatrix(Qr.worldTransform)),this.effects[Jr].addBounds(Yr,!0));Zr&&(Yr.applyMatrix(Qr.worldTransform.copyTo(tempMatrix$4).invert()),ze.addBounds(Yr,this.relativeGroupTransform)),ze.addBounds(Yr),boundsPool.return(Yr)}else this.renderGroup&&(ze.addBounds(Yr,this.relativeGroupTransform),boundsPool.return(Yr))}};function getGlobalBounds(Wr,ze,Gr){Gr.clear();let Yr,Kr;return Wr.parent?ze?Yr=Wr.parent.worldTransform:(Kr=matrixPool.get().identity(),Yr=updateTransformBackwards(Wr,Kr)):Yr=Matrix.IDENTITY,_getGlobalBounds(Wr,Gr,Yr,ze),Kr&&matrixPool.return(Kr),Gr.isValid||Gr.set(0,0,0,0),Gr}function _getGlobalBounds(Wr,ze,Gr,Yr){var Jr,ei;if(!Wr.visible||!Wr.measurable)return;let Kr;Yr?Kr=Wr.worldTransform:(Wr.updateLocalTransform(),Kr=matrixPool.get(),Kr.appendFrom(Wr.localTransform,Gr));const Zr=ze,Qr=!!Wr.effects.length;if(Qr&&(ze=boundsPool.get().clear()),Wr.boundsArea)ze.addRect(Wr.boundsArea,Kr);else{Wr.bounds&&(ze.matrix=Kr,ze.addBounds(Wr.bounds));for(let ti=0;ti<Wr.children.length;ti++)_getGlobalBounds(Wr.children[ti],ze,Kr,Yr)}if(Qr){for(let ti=0;ti<Wr.effects.length;ti++)(ei=(Jr=Wr.effects[ti]).addBounds)==null||ei.call(Jr,ze);Zr.addBounds(ze,Matrix.IDENTITY),boundsPool.return(ze)}Yr||matrixPool.return(Kr)}function updateTransformBackwards(Wr,ze){const Gr=Wr.parent;return Gr&&(updateTransformBackwards(Gr,ze),Gr.updateLocalTransform(),ze.append(Gr.localTransform)),ze}function multiplyHexColors(Wr,ze){if(Wr===16777215||!ze)return ze;if(ze===16777215||!Wr)return Wr;const Gr=Wr>>16&255,Yr=Wr>>8&255,Kr=Wr&255,Zr=ze>>16&255,Qr=ze>>8&255,Jr=ze&255,ei=Gr*Zr/255|0,ti=Yr*Qr/255|0,ri=Kr*Jr/255|0;return(ei<<16)+(ti<<8)+ri}const WHITE_BGR=16777215;function multiplyColors(Wr,ze){return Wr===WHITE_BGR?ze:ze===WHITE_BGR?Wr:multiplyHexColors(Wr,ze)}function bgr2rgb(Wr){return((Wr&255)<<16)+(Wr&65280)+(Wr>>16&255)}const getGlobalMixin={getGlobalAlpha(Wr){if(Wr)return this.renderGroup?this.renderGroup.worldAlpha:this.parentRenderGroup?this.parentRenderGroup.worldAlpha*this.alpha:this.alpha;let ze=this.alpha,Gr=this.parent;for(;Gr;)ze*=Gr.alpha,Gr=Gr.parent;return ze},getGlobalTransform(Wr,ze){if(ze)return Wr.copyFrom(this.worldTransform);this.updateLocalTransform();const Gr=updateTransformBackwards(this,matrixPool.get().identity());return Wr.appendFrom(this.localTransform,Gr),matrixPool.return(Gr),Wr},getGlobalTint(Wr){if(Wr)return this.renderGroup?bgr2rgb(this.renderGroup.worldColor):this.parentRenderGroup?bgr2rgb(multiplyColors(this.localColor,this.parentRenderGroup.worldColor)):this.tint;let ze=this.localColor,Gr=this.parent;for(;Gr;)ze=multiplyColors(ze,Gr.localColor),Gr=Gr.parent;return bgr2rgb(ze)}};let warnCount=0;const maxWarnings=500;function warn(...Wr){warnCount!==maxWarnings&&(warnCount++,warnCount===maxWarnings?console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."):console.warn("PixiJS Warning: ",...Wr))}function getLocalBounds(Wr,ze,Gr){return ze.clear(),Gr||(Gr=Matrix.IDENTITY),_getLocalBounds(Wr,ze,Gr,Wr,!0),ze.isValid||ze.set(0,0,0,0),ze}function _getLocalBounds(Wr,ze,Gr,Yr,Kr){var ei,ti;let Zr;if(Kr)Zr=matrixPool.get(),Zr=Gr.copyTo(Zr);else{if(!Wr.visible||!Wr.measurable)return;Wr.updateLocalTransform();const ri=Wr.localTransform;Zr=matrixPool.get(),Zr.appendFrom(ri,Gr)}const Qr=ze,Jr=!!Wr.effects.length;if(Jr&&(ze=boundsPool.get().clear()),Wr.boundsArea)ze.addRect(Wr.boundsArea,Zr);else{Wr.renderPipeId&&(ze.matrix=Zr,ze.addBounds(Wr.bounds));const ri=Wr.children;for(let ii=0;ii<ri.length;ii++)_getLocalBounds(ri[ii],ze,Zr,Yr,!1)}if(Jr){for(let ri=0;ri<Wr.effects.length;ri++)(ti=(ei=Wr.effects[ri]).addLocalBounds)==null||ti.call(ei,ze,Yr);Qr.addBounds(ze,Matrix.IDENTITY),boundsPool.return(ze)}matrixPool.return(Zr)}function checkChildrenDidChange(Wr,ze){const Gr=Wr.children;for(let Yr=0;Yr<Gr.length;Yr++){const Kr=Gr[Yr],Zr=Kr.uid,Qr=(Kr._didViewChangeTick&65535)<<16|Kr._didContainerChangeTick&65535,Jr=ze.index;(ze.data[Jr]!==Zr||ze.data[Jr+1]!==Qr)&&(ze.data[ze.index]=Zr,ze.data[ze.index+1]=Qr,ze.didChange=!0),ze.index=Jr+2,Kr.children.length&&checkChildrenDidChange(Kr,ze)}return ze.didChange}const tempMatrix$3=new Matrix,measureMixin={_localBoundsCacheId:-1,_localBoundsCacheData:null,_setWidth(Wr,ze){const Gr=Math.sign(this.scale.x)||1;ze!==0?this.scale.x=Wr/ze*Gr:this.scale.x=Gr},_setHeight(Wr,ze){const Gr=Math.sign(this.scale.y)||1;ze!==0?this.scale.y=Wr/ze*Gr:this.scale.y=Gr},getLocalBounds(){this._localBoundsCacheData||(this._localBoundsCacheData={data:[],index:1,didChange:!1,localBounds:new Bounds});const Wr=this._localBoundsCacheData;return Wr.index=1,Wr.didChange=!1,Wr.data[0]!==this._didViewChangeTick&&(Wr.didChange=!0,Wr.data[0]=this._didViewChangeTick),checkChildrenDidChange(this,Wr),Wr.didChange&&getLocalBounds(this,Wr.localBounds,tempMatrix$3),Wr.localBounds},getBounds(Wr,ze){return getGlobalBounds(this,Wr,ze||new Bounds)}},onRenderMixin={_onRender:null,set onRender(Wr){const ze=this.renderGroup||this.parentRenderGroup;if(!Wr){this._onRender&&(ze==null||ze.removeOnRender(this)),this._onRender=null;return}this._onRender||ze==null||ze.addOnRender(this),this._onRender=Wr},get onRender(){return this._onRender}},sortMixin={_zIndex:0,sortDirty:!1,sortableChildren:!1,get zIndex(){return this._zIndex},set zIndex(Wr){this._zIndex!==Wr&&(this._zIndex=Wr,this.depthOfChildModified())},depthOfChildModified(){this.parent&&(this.parent.sortableChildren=!0,this.parent.sortDirty=!0),this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0)},sortChildren(){this.sortDirty&&(this.sortDirty=!1,this.children.sort(sortChildren))}};function sortChildren(Wr,ze){return Wr._zIndex-ze._zIndex}const toLocalGlobalMixin={getGlobalPosition(Wr=new Point$1,ze=!1){return this.parent?this.parent.toGlobal(this._position,Wr,ze):(Wr.x=this._position.x,Wr.y=this._position.y),Wr},toGlobal(Wr,ze,Gr=!1){const Yr=this.getGlobalTransform(matrixPool.get(),Gr);return ze=Yr.apply(Wr,ze),matrixPool.return(Yr),ze},toLocal(Wr,ze,Gr,Yr){ze&&(Wr=ze.toGlobal(Wr,Gr,Yr));const Kr=this.getGlobalTransform(matrixPool.get(),Yr);return Gr=Kr.applyInverse(Wr,Gr),matrixPool.return(Kr),Gr}};class InstructionSet{constructor(){this.uid=uid$1("instructionSet"),this.instructions=[],this.instructionSize=0,this.renderables=[],this.gcTick=0}reset(){this.instructionSize=0}add(ze){this.instructions[this.instructionSize++]=ze}log(){this.instructions.length=this.instructionSize,console.table(this.instructions,["type","action"])}}let count=0;class TexturePoolClass{constructor(ze){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=ze||{},this.enableFullScreen=!1}createTexture(ze,Gr,Yr){const Kr=new TextureSource({...this.textureOptions,width:ze,height:Gr,resolution:1,antialias:Yr,autoGarbageCollect:!1});return new Texture({source:Kr,label:`texturePool_${count++}`})}getOptimalTexture(ze,Gr,Yr=1,Kr){let Zr=Math.ceil(ze*Yr-1e-6),Qr=Math.ceil(Gr*Yr-1e-6);Zr=nextPow2(Zr),Qr=nextPow2(Qr);const Jr=(Zr<<17)+(Qr<<1)+(Kr?1:0);this._texturePool[Jr]||(this._texturePool[Jr]=[]);let ei=this._texturePool[Jr].pop();return ei||(ei=this.createTexture(Zr,Qr,Kr)),ei.source._resolution=Yr,ei.source.width=Zr/Yr,ei.source.height=Qr/Yr,ei.source.pixelWidth=Zr,ei.source.pixelHeight=Qr,ei.frame.x=0,ei.frame.y=0,ei.frame.width=ze,ei.frame.height=Gr,ei.updateUvs(),this._poolKeyHash[ei.uid]=Jr,ei}getSameSizeTexture(ze,Gr=!1){const Yr=ze.source;return this.getOptimalTexture(ze.width,ze.height,Yr._resolution,Gr)}returnTexture(ze){const Gr=this._poolKeyHash[ze.uid];this._texturePool[Gr].push(ze)}clear(ze){if(ze=ze!==!1,ze)for(const Gr in this._texturePool){const Yr=this._texturePool[Gr];if(Yr)for(let Kr=0;Kr<Yr.length;Kr++)Yr[Kr].destroy(!0)}this._texturePool={}}}const TexturePool=new TexturePoolClass;class RenderGroup{constructor(){this.renderPipeId="renderGroup",this.root=null,this.canBundle=!1,this.renderGroupParent=null,this.renderGroupChildren=[],this.worldTransform=new Matrix,this.worldColorAlpha=4294967295,this.worldColor=16777215,this.worldAlpha=1,this.childrenToUpdate=Object.create(null),this.updateTick=0,this.gcTick=0,this.childrenRenderablesToUpdate={list:[],index:0},this.structureDidChange=!0,this.instructionSet=new InstructionSet,this._onRenderContainers=[],this.textureNeedsUpdate=!0,this.isCachedAsTexture=!1,this._matrixDirty=7}init(ze){this.root=ze,ze._onRender&&this.addOnRender(ze),ze.didChange=!0;const Gr=ze.children;for(let Yr=0;Yr<Gr.length;Yr++){const Kr=Gr[Yr];Kr._updateFlags=15,this.addChild(Kr)}}enableCacheAsTexture(ze={}){this.textureOptions=ze,this.isCachedAsTexture=!0,this.textureNeedsUpdate=!0}disableCacheAsTexture(){this.isCachedAsTexture=!1,this.texture&&(TexturePool.returnTexture(this.texture),this.texture=null)}updateCacheTexture(){this.textureNeedsUpdate=!0}reset(){this.renderGroupChildren.length=0;for(const ze in this.childrenToUpdate){const Gr=this.childrenToUpdate[ze];Gr.list.fill(null),Gr.index=0}this.childrenRenderablesToUpdate.index=0,this.childrenRenderablesToUpdate.list.fill(null),this.root=null,this.updateTick=0,this.structureDidChange=!0,this._onRenderContainers.length=0,this.renderGroupParent=null,this.disableCacheAsTexture()}get localTransform(){return this.root.localTransform}addRenderGroupChild(ze){ze.renderGroupParent&&ze.renderGroupParent._removeRenderGroupChild(ze),ze.renderGroupParent=this,this.renderGroupChildren.push(ze)}_removeRenderGroupChild(ze){const Gr=this.renderGroupChildren.indexOf(ze);Gr>-1&&this.renderGroupChildren.splice(Gr,1),ze.renderGroupParent=null}addChild(ze){if(this.structureDidChange=!0,ze.parentRenderGroup=this,ze.updateTick=-1,ze.parent===this.root?ze.relativeRenderGroupDepth=1:ze.relativeRenderGroupDepth=ze.parent.relativeRenderGroupDepth+1,ze.didChange=!0,this.onChildUpdate(ze),ze.renderGroup){this.addRenderGroupChild(ze.renderGroup);return}ze._onRender&&this.addOnRender(ze);const Gr=ze.children;for(let Yr=0;Yr<Gr.length;Yr++)this.addChild(Gr[Yr])}removeChild(ze){if(this.structureDidChange=!0,ze._onRender&&(ze.renderGroup||this.removeOnRender(ze)),ze.parentRenderGroup=null,ze.renderGroup){this._removeRenderGroupChild(ze.renderGroup);return}const Gr=ze.children;for(let Yr=0;Yr<Gr.length;Yr++)this.removeChild(Gr[Yr])}removeChildren(ze){for(let Gr=0;Gr<ze.length;Gr++)this.removeChild(ze[Gr])}onChildUpdate(ze){let Gr=this.childrenToUpdate[ze.relativeRenderGroupDepth];Gr||(Gr=this.childrenToUpdate[ze.relativeRenderGroupDepth]={index:0,list:[]}),Gr.list[Gr.index++]=ze}updateRenderable(ze){ze.globalDisplayStatus<7||(this.instructionSet.renderPipes[ze.renderPipeId].updateRenderable(ze),ze.didViewUpdate=!1)}onChildViewUpdate(ze){this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++]=ze}get isRenderable(){return this.root.localDisplayStatus===7&&this.worldAlpha>0}addOnRender(ze){this._onRenderContainers.push(ze)}removeOnRender(ze){this._onRenderContainers.splice(this._onRenderContainers.indexOf(ze),1)}runOnRender(ze){for(let Gr=0;Gr<this._onRenderContainers.length;Gr++)this._onRenderContainers[Gr]._onRender(ze)}destroy(){this.disableCacheAsTexture(),this.renderGroupParent=null,this.root=null,this.childrenRenderablesToUpdate=null,this.childrenToUpdate=null,this.renderGroupChildren=null,this._onRenderContainers=null,this.instructionSet=null}getChildren(ze=[]){const Gr=this.root.children;for(let Yr=0;Yr<Gr.length;Yr++)this._getChildren(Gr[Yr],ze);return ze}_getChildren(ze,Gr=[]){if(Gr.push(ze),ze.renderGroup)return Gr;const Yr=ze.children;for(let Kr=0;Kr<Yr.length;Kr++)this._getChildren(Yr[Kr],Gr);return Gr}invalidateMatrices(){this._matrixDirty=7}get inverseWorldTransform(){return(this._matrixDirty&1)===0?this._inverseWorldTransform:(this._matrixDirty&=-2,this._inverseWorldTransform||(this._inverseWorldTransform=new Matrix),this._inverseWorldTransform.copyFrom(this.worldTransform).invert())}get textureOffsetInverseTransform(){return(this._matrixDirty&2)===0?this._textureOffsetInverseTransform:(this._matrixDirty&=-3,this._textureOffsetInverseTransform||(this._textureOffsetInverseTransform=new Matrix),this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x,-this._textureBounds.y))}get inverseParentTextureTransform(){if((this._matrixDirty&4)===0)return this._inverseParentTextureTransform;this._matrixDirty&=-5;const ze=this._parentCacheAsTextureRenderGroup;return ze?(this._inverseParentTextureTransform||(this._inverseParentTextureTransform=new Matrix),this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(ze.inverseWorldTransform).translate(-ze._textureBounds.x,-ze._textureBounds.y)):this.worldTransform}get cacheToLocalTransform(){return this._parentCacheAsTextureRenderGroup?this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform:null}}function assignWithIgnore(Wr,ze,Gr={}){for(const Yr in ze)!Gr[Yr]&&ze[Yr]!==void 0&&(Wr[Yr]=ze[Yr])}const defaultSkew=new ObservablePoint(null),defaultPivot=new ObservablePoint(null),defaultScale=new ObservablePoint(null,1,1),UPDATE_COLOR=1,UPDATE_BLEND=2,UPDATE_VISIBLE=4;class Container extends EventEmitter{constructor(ze={}){var Gr,Yr;super(),this.uid=uid$1("renderable"),this._updateFlags=15,this.renderGroup=null,this.parentRenderGroup=null,this.parentRenderGroupIndex=0,this.didChange=!1,this.didViewUpdate=!1,this.relativeRenderGroupDepth=0,this.children=[],this.parent=null,this.includeInBuild=!0,this.measurable=!0,this.isSimple=!0,this.updateTick=-1,this.localTransform=new Matrix,this.relativeGroupTransform=new Matrix,this.groupTransform=this.relativeGroupTransform,this.destroyed=!1,this._position=new ObservablePoint(this,0,0),this._scale=defaultScale,this._pivot=defaultPivot,this._skew=defaultSkew,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._rotation=0,this.localColor=16777215,this.localAlpha=1,this.groupAlpha=1,this.groupColor=16777215,this.groupColorAlpha=4294967295,this.localBlendMode="inherit",this.groupBlendMode="normal",this.localDisplayStatus=7,this.globalDisplayStatus=7,this._didContainerChangeTick=0,this._didViewChangeTick=0,this._didLocalTransformChangeId=-1,this.effects=[],assignWithIgnore(this,ze,{children:!0,parent:!0,effects:!0}),(Gr=ze.children)==null||Gr.forEach(Kr=>this.addChild(Kr)),(Yr=ze.parent)==null||Yr.addChild(this)}static mixin(ze){deprecation("8.8.0","Container.mixin is deprecated, please use extensions.mixin instead."),extensions.mixin(Container,ze)}set _didChangeId(ze){this._didViewChangeTick=ze>>12&4095,this._didContainerChangeTick=ze&4095}get _didChangeId(){return this._didContainerChangeTick&4095|(this._didViewChangeTick&4095)<<12}addChild(...ze){if(this.allowChildren||deprecation(v8_0_0,"addChild: Only Containers will be allowed to add children in v8.0.0"),ze.length>1){for(let Kr=0;Kr<ze.length;Kr++)this.addChild(ze[Kr]);return ze[0]}const Gr=ze[0],Yr=this.renderGroup||this.parentRenderGroup;return Gr.parent===this?(this.children.splice(this.children.indexOf(Gr),1),this.children.push(Gr),Yr&&(Yr.structureDidChange=!0),Gr):(Gr.parent&&Gr.parent.removeChild(Gr),this.children.push(Gr),this.sortableChildren&&(this.sortDirty=!0),Gr.parent=this,Gr.didChange=!0,Gr._updateFlags=15,Yr&&Yr.addChild(Gr),this.emit("childAdded",Gr,this,this.children.length-1),Gr.emit("added",this),this._didViewChangeTick++,Gr._zIndex!==0&&Gr.depthOfChildModified(),Gr)}removeChild(...ze){if(ze.length>1){for(let Kr=0;Kr<ze.length;Kr++)this.removeChild(ze[Kr]);return ze[0]}const Gr=ze[0],Yr=this.children.indexOf(Gr);return Yr>-1&&(this._didViewChangeTick++,this.children.splice(Yr,1),this.renderGroup?this.renderGroup.removeChild(Gr):this.parentRenderGroup&&this.parentRenderGroup.removeChild(Gr),Gr.parentRenderLayer&&Gr.parentRenderLayer.detach(Gr),Gr.parent=null,this.emit("childRemoved",Gr,this,Yr),Gr.emit("removed",this)),Gr}_onUpdate(ze){ze&&ze===this._skew&&this._updateSkew(),this._didContainerChangeTick++,!this.didChange&&(this.didChange=!0,this.parentRenderGroup&&this.parentRenderGroup.onChildUpdate(this))}set isRenderGroup(ze){!!this.renderGroup!==ze&&(ze?this.enableRenderGroup():this.disableRenderGroup())}get isRenderGroup(){return!!this.renderGroup}enableRenderGroup(){if(this.renderGroup)return;const ze=this.parentRenderGroup;ze==null||ze.removeChild(this),this.renderGroup=BigPool.get(RenderGroup,this),this.groupTransform=Matrix.IDENTITY,ze==null||ze.addChild(this),this._updateIsSimple()}disableRenderGroup(){if(!this.renderGroup)return;const ze=this.parentRenderGroup;ze==null||ze.removeChild(this),BigPool.return(this.renderGroup),this.renderGroup=null,this.groupTransform=this.relativeGroupTransform,ze==null||ze.addChild(this),this._updateIsSimple()}_updateIsSimple(){this.isSimple=!this.renderGroup&&this.effects.length===0}get worldTransform(){return this._worldTransform||(this._worldTransform=new Matrix),this.renderGroup?this._worldTransform.copyFrom(this.renderGroup.worldTransform):this.parentRenderGroup&&this._worldTransform.appendFrom(this.relativeGroupTransform,this.parentRenderGroup.worldTransform),this._worldTransform}get x(){return this._position.x}set x(ze){this._position.x=ze}get y(){return this._position.y}set y(ze){this._position.y=ze}get position(){return this._position}set position(ze){this._position.copyFrom(ze)}get rotation(){return this._rotation}set rotation(ze){this._rotation!==ze&&(this._rotation=ze,this._onUpdate(this._skew))}get angle(){return this.rotation*RAD_TO_DEG}set angle(ze){this.rotation=ze*DEG_TO_RAD}get pivot(){return this._pivot===defaultPivot&&(this._pivot=new ObservablePoint(this,0,0)),this._pivot}set pivot(ze){this._pivot===defaultPivot&&(this._pivot=new ObservablePoint(this,0,0)),typeof ze=="number"?this._pivot.set(ze):this._pivot.copyFrom(ze)}get skew(){return this._skew===defaultSkew&&(this._skew=new ObservablePoint(this,0,0)),this._skew}set skew(ze){this._skew===defaultSkew&&(this._skew=new ObservablePoint(this,0,0)),this._skew.copyFrom(ze)}get scale(){return this._scale===defaultScale&&(this._scale=new ObservablePoint(this,1,1)),this._scale}set scale(ze){this._scale===defaultScale&&(this._scale=new ObservablePoint(this,0,0)),typeof ze=="number"?this._scale.set(ze):this._scale.copyFrom(ze)}get width(){return Math.abs(this.scale.x*this.getLocalBounds().width)}set width(ze){const Gr=this.getLocalBounds().width;this._setWidth(ze,Gr)}get height(){return Math.abs(this.scale.y*this.getLocalBounds().height)}set height(ze){const Gr=this.getLocalBounds().height;this._setHeight(ze,Gr)}getSize(ze){ze||(ze={});const Gr=this.getLocalBounds();return ze.width=Math.abs(this.scale.x*Gr.width),ze.height=Math.abs(this.scale.y*Gr.height),ze}setSize(ze,Gr){const Yr=this.getLocalBounds();typeof ze=="object"?(Gr=ze.height??ze.width,ze=ze.width):Gr??(Gr=ze),ze!==void 0&&this._setWidth(ze,Yr.width),Gr!==void 0&&this._setHeight(Gr,Yr.height)}_updateSkew(){const ze=this._rotation,Gr=this._skew;this._cx=Math.cos(ze+Gr._y),this._sx=Math.sin(ze+Gr._y),this._cy=-Math.sin(ze-Gr._x),this._sy=Math.cos(ze-Gr._x)}updateTransform(ze){return this.position.set(typeof ze.x=="number"?ze.x:this.position.x,typeof ze.y=="number"?ze.y:this.position.y),this.scale.set(typeof ze.scaleX=="number"?ze.scaleX||1:this.scale.x,typeof ze.scaleY=="number"?ze.scaleY||1:this.scale.y),this.rotation=typeof ze.rotation=="number"?ze.rotation:this.rotation,this.skew.set(typeof ze.skewX=="number"?ze.skewX:this.skew.x,typeof ze.skewY=="number"?ze.skewY:this.skew.y),this.pivot.set(typeof ze.pivotX=="number"?ze.pivotX:this.pivot.x,typeof ze.pivotY=="number"?ze.pivotY:this.pivot.y),this}setFromMatrix(ze){ze.decompose(this)}updateLocalTransform(){const ze=this._didContainerChangeTick;if(this._didLocalTransformChangeId===ze)return;this._didLocalTransformChangeId=ze;const Gr=this.localTransform,Yr=this._scale,Kr=this._pivot,Zr=this._position,Qr=Yr._x,Jr=Yr._y,ei=Kr._x,ti=Kr._y;Gr.a=this._cx*Qr,Gr.b=this._sx*Qr,Gr.c=this._cy*Jr,Gr.d=this._sy*Jr,Gr.tx=Zr._x-(ei*Gr.a+ti*Gr.c),Gr.ty=Zr._y-(ei*Gr.b+ti*Gr.d)}set alpha(ze){ze!==this.localAlpha&&(this.localAlpha=ze,this._updateFlags|=UPDATE_COLOR,this._onUpdate())}get alpha(){return this.localAlpha}set tint(ze){const Yr=Color.shared.setValue(ze??16777215).toBgrNumber();Yr!==this.localColor&&(this.localColor=Yr,this._updateFlags|=UPDATE_COLOR,this._onUpdate())}get tint(){return bgr2rgb(this.localColor)}set blendMode(ze){this.localBlendMode!==ze&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_BLEND,this.localBlendMode=ze,this._onUpdate())}get blendMode(){return this.localBlendMode}get visible(){return!!(this.localDisplayStatus&2)}set visible(ze){const Gr=ze?2:0;(this.localDisplayStatus&2)!==Gr&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=2,this._onUpdate())}get culled(){return!(this.localDisplayStatus&4)}set culled(ze){const Gr=ze?0:4;(this.localDisplayStatus&4)!==Gr&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=4,this._onUpdate())}get renderable(){return!!(this.localDisplayStatus&1)}set renderable(ze){const Gr=ze?1:0;(this.localDisplayStatus&1)!==Gr&&(this._updateFlags|=UPDATE_VISIBLE,this.localDisplayStatus^=1,this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._onUpdate())}get isRenderable(){return this.localDisplayStatus===7&&this.groupAlpha>0}destroy(ze=!1){var Kr;if(this.destroyed)return;this.destroyed=!0;let Gr;if(this.children.length&&(Gr=this.removeChildren(0,this.children.length)),this.removeFromParent(),this.parent=null,this._maskEffect=null,this._filterEffect=null,this.effects=null,this._position=null,this._scale=null,this._pivot=null,this._skew=null,this.emit("destroyed",this),this.removeAllListeners(),(typeof ze=="boolean"?ze:ze==null?void 0:ze.children)&&Gr)for(let Zr=0;Zr<Gr.length;++Zr)Gr[Zr].destroy(ze);(Kr=this.renderGroup)==null||Kr.destroy(),this.renderGroup=null}}extensions.mixin(Container,childrenHelperMixin,getFastGlobalBoundsMixin,toLocalGlobalMixin,onRenderMixin,measureMixin,effectsMixin,findMixin,sortMixin,cullingMixin,cacheAsTextureMixin,getGlobalMixin,collectRenderablesMixin);class ViewContainer extends Container{constructor(ze){super(ze),this.canBundle=!0,this.allowChildren=!1,this._roundPixels=0,this._lastUsed=-1,this._bounds=new Bounds(0,1,0,0),this._boundsDirty=!0}get bounds(){return this._boundsDirty?(this.updateBounds(),this._boundsDirty=!1,this._bounds):this._bounds}get roundPixels(){return!!this._roundPixels}set roundPixels(ze){this._roundPixels=ze?1:0}containsPoint(ze){const Gr=this.bounds,{x:Yr,y:Kr}=ze;return Yr>=Gr.minX&&Yr<=Gr.maxX&&Kr>=Gr.minY&&Kr<=Gr.maxY}onViewUpdate(){if(this._didViewChangeTick++,this._boundsDirty=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const ze=this.renderGroup||this.parentRenderGroup;ze&&ze.onChildViewUpdate(this)}destroy(ze){super.destroy(ze),this._bounds=null}collectRenderablesSimple(ze,Gr,Yr){const{renderPipes:Kr,renderableGC:Zr}=Gr;Kr.blendMode.setBlendMode(this,this.groupBlendMode,ze),Kr[this.renderPipeId].addRenderable(this,ze),Zr.addRenderable(this),this.didViewUpdate=!1;const Jr=this.children,ei=Jr.length;for(let ti=0;ti<ei;ti++)Jr[ti].collectRenderables(ze,Gr,Yr)}}class Sprite extends ViewContainer{constructor(ze=Texture.EMPTY){ze instanceof Texture&&(ze={texture:ze});const{texture:Gr=Texture.EMPTY,anchor:Yr,roundPixels:Kr,width:Zr,height:Qr,...Jr}=ze;super({label:"Sprite",...Jr}),this.renderPipeId="sprite",this.batched=!0,this._visualBounds={minX:0,maxX:1,minY:0,maxY:0},this._anchor=new ObservablePoint({_onUpdate:()=>{this.onViewUpdate()}}),Yr?this.anchor=Yr:Gr.defaultAnchor&&(this.anchor=Gr.defaultAnchor),this.texture=Gr,this.allowChildren=!1,this.roundPixels=Kr??!1,Zr!==void 0&&(this.width=Zr),Qr!==void 0&&(this.height=Qr)}static from(ze,Gr=!1){return ze instanceof Texture?new Sprite(ze):new Sprite(Texture.from(ze,Gr))}set texture(ze){ze||(ze=Texture.EMPTY);const Gr=this._texture;Gr!==ze&&(Gr&&Gr.dynamic&&Gr.off("update",this.onViewUpdate,this),ze.dynamic&&ze.on("update",this.onViewUpdate,this),this._texture=ze,this._width&&this._setWidth(this._width,this._texture.orig.width),this._height&&this._setHeight(this._height,this._texture.orig.height),this.onViewUpdate())}get texture(){return this._texture}get visualBounds(){return updateQuadBounds(this._visualBounds,this._anchor,this._texture),this._visualBounds}get sourceBounds(){return deprecation("8.6.1","Sprite.sourceBounds is deprecated, use visualBounds instead."),this.visualBounds}updateBounds(){const ze=this._anchor,Gr=this._texture,Yr=this._bounds,{width:Kr,height:Zr}=Gr.orig;Yr.minX=-ze._x*Kr,Yr.maxX=Yr.minX+Kr,Yr.minY=-ze._y*Zr,Yr.maxY=Yr.minY+Zr}destroy(ze=!1){if(super.destroy(ze),typeof ze=="boolean"?ze:ze==null?void 0:ze.texture){const Yr=typeof ze=="boolean"?ze:ze==null?void 0:ze.textureSource;this._texture.destroy(Yr)}this._texture=null,this._visualBounds=null,this._bounds=null,this._anchor=null}get anchor(){return this._anchor}set anchor(ze){typeof ze=="number"?this._anchor.set(ze):this._anchor.copyFrom(ze)}get width(){return Math.abs(this.scale.x)*this._texture.orig.width}set width(ze){this._setWidth(ze,this._texture.orig.width),this._width=ze}get height(){return Math.abs(this.scale.y)*this._texture.orig.height}set height(ze){this._setHeight(ze,this._texture.orig.height),this._height=ze}getSize(ze){return ze||(ze={}),ze.width=Math.abs(this.scale.x)*this._texture.orig.width,ze.height=Math.abs(this.scale.y)*this._texture.orig.height,ze}setSize(ze,Gr){typeof ze=="object"?(Gr=ze.height??ze.width,ze=ze.width):Gr??(Gr=ze),ze!==void 0&&this._setWidth(ze,this._texture.orig.width),Gr!==void 0&&this._setHeight(Gr,this._texture.orig.height)}}const tempBounds$3=new Bounds;function addMaskBounds(Wr,ze,Gr){const Yr=tempBounds$3;Wr.measurable=!0,getGlobalBounds(Wr,Gr,Yr),ze.addBoundsMask(Yr),Wr.measurable=!1}function addMaskLocalBounds(Wr,ze,Gr){const Yr=boundsPool.get();Wr.measurable=!0;const Kr=matrixPool.get().identity(),Zr=getMatrixRelativeToParent(Wr,Gr,Kr);getLocalBounds(Wr,Yr,Zr),Wr.measurable=!1,ze.addBoundsMask(Yr),matrixPool.return(Kr),boundsPool.return(Yr)}function getMatrixRelativeToParent(Wr,ze,Gr){return Wr?(Wr!==ze&&(getMatrixRelativeToParent(Wr.parent,ze,Gr),Wr.updateLocalTransform(),Gr.append(Wr.localTransform)),Gr):(warn("Mask bounds, renderable is not inside the root container"),Gr)}class AlphaMask{constructor(ze){this.priority=0,this.inverse=!1,this.pipe="alphaMask",ze!=null&&ze.mask&&this.init(ze.mask)}init(ze){this.mask=ze,this.renderMaskToTexture=!(ze instanceof Sprite),this.mask.renderable=this.renderMaskToTexture,this.mask.includeInBuild=!this.renderMaskToTexture,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask=null}addBounds(ze,Gr){this.inverse||addMaskBounds(this.mask,ze,Gr)}addLocalBounds(ze,Gr){addMaskLocalBounds(this.mask,ze,Gr)}containsPoint(ze,Gr){const Yr=this.mask;return Gr(Yr,ze)}destroy(){this.reset()}static test(ze){return ze instanceof Sprite}}AlphaMask.extension=ExtensionType.MaskEffect;class ColorMask{constructor(ze){this.priority=0,this.pipe="colorMask",ze!=null&&ze.mask&&this.init(ze.mask)}init(ze){this.mask=ze}destroy(){}static test(ze){return typeof ze=="number"}}ColorMask.extension=ExtensionType.MaskEffect;class StencilMask{constructor(ze){this.priority=0,this.pipe="stencilMask",ze!=null&&ze.mask&&this.init(ze.mask)}init(ze){this.mask=ze,this.mask.includeInBuild=!1,this.mask.measurable=!1}reset(){this.mask.measurable=!0,this.mask.includeInBuild=!0,this.mask=null}addBounds(ze,Gr){addMaskBounds(this.mask,ze,Gr)}addLocalBounds(ze,Gr){addMaskLocalBounds(this.mask,ze,Gr)}containsPoint(ze,Gr){const Yr=this.mask;return Gr(Yr,ze)}destroy(){this.reset()}static test(ze){return ze instanceof Container}}StencilMask.extension=ExtensionType.MaskEffect;const BrowserAdapter={createCanvas:(Wr,ze)=>{const Gr=document.createElement("canvas");return Gr.width=Wr,Gr.height=ze,Gr},getCanvasRenderingContext2D:()=>CanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>document.baseURI??window.location.href,getFontFaceSet:()=>document.fonts,fetch:(Wr,ze)=>fetch(Wr,ze),parseXML:Wr=>new DOMParser().parseFromString(Wr,"text/xml")};let currentAdapter=BrowserAdapter;const DOMAdapter={get(){return currentAdapter},set(Wr){currentAdapter=Wr}};class CanvasSource extends TextureSource{constructor(ze){ze.resource||(ze.resource=DOMAdapter.get().createCanvas()),ze.width||(ze.width=ze.resource.width,ze.autoDensity||(ze.width/=ze.resolution)),ze.height||(ze.height=ze.resource.height,ze.autoDensity||(ze.height/=ze.resolution)),super(ze),this.uploadMethodId="image",this.autoDensity=ze.autoDensity,this.resizeCanvas(),this.transparent=!!ze.transparent}resizeCanvas(){this.autoDensity&&"style"in this.resource&&(this.resource.style.width=`${this.width}px`,this.resource.style.height=`${this.height}px`),(this.resource.width!==this.pixelWidth||this.resource.height!==this.pixelHeight)&&(this.resource.width=this.pixelWidth,this.resource.height=this.pixelHeight)}resize(ze=this.width,Gr=this.height,Yr=this._resolution){const Kr=super.resize(ze,Gr,Yr);return Kr&&this.resizeCanvas(),Kr}static test(ze){return globalThis.HTMLCanvasElement&&ze instanceof HTMLCanvasElement||globalThis.OffscreenCanvas&&ze instanceof OffscreenCanvas}get context2D(){return this._context2D||(this._context2D=this.resource.getContext("2d"))}}CanvasSource.extension=ExtensionType.TextureSource;class ImageSource extends TextureSource{constructor(ze){if(ze.resource&&globalThis.HTMLImageElement&&ze.resource instanceof HTMLImageElement){const Gr=DOMAdapter.get().createCanvas(ze.resource.width,ze.resource.height);Gr.getContext("2d").drawImage(ze.resource,0,0,ze.resource.width,ze.resource.height),ze.resource=Gr,warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.")}super(ze),this.uploadMethodId="image",this.autoGarbageCollect=!0}static test(ze){return globalThis.HTMLImageElement&&ze instanceof HTMLImageElement||typeof ImageBitmap<"u"&&ze instanceof ImageBitmap||globalThis.VideoFrame&&ze instanceof VideoFrame}}ImageSource.extension=ExtensionType.TextureSource;var UPDATE_PRIORITY=(Wr=>(Wr[Wr.INTERACTION=50]="INTERACTION",Wr[Wr.HIGH=25]="HIGH",Wr[Wr.NORMAL=0]="NORMAL",Wr[Wr.LOW=-25]="LOW",Wr[Wr.UTILITY=-50]="UTILITY",Wr))(UPDATE_PRIORITY||{});class TickerListener{constructor(ze,Gr=null,Yr=0,Kr=!1){this.next=null,this.previous=null,this._destroyed=!1,this._fn=ze,this._context=Gr,this.priority=Yr,this._once=Kr}match(ze,Gr=null){return this._fn===ze&&this._context===Gr}emit(ze){this._fn&&(this._context?this._fn.call(this._context,ze):this._fn(ze));const Gr=this.next;return this._once&&this.destroy(!0),this._destroyed&&(this.next=null),Gr}connect(ze){this.previous=ze,ze.next&&(ze.next.previous=this),this.next=ze.next,ze.next=this}destroy(ze=!1){this._destroyed=!0,this._fn=null,this._context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);const Gr=this.next;return this.next=ze?null:Gr,this.previous=null,Gr}}const _Ticker=class Yi{constructor(){this.autoStart=!1,this.deltaTime=1,this.lastTime=-1,this.speed=1,this.started=!1,this._requestId=null,this._maxElapsedMS=100,this._minElapsedMS=0,this._protected=!1,this._lastFrame=-1,this._head=new TickerListener(null,null,1/0),this.deltaMS=1/Yi.targetFPMS,this.elapsedMS=1/Yi.targetFPMS,this._tick=ze=>{this._requestId=null,this.started&&(this.update(ze),this.started&&this._requestId===null&&this._head.next&&(this._requestId=requestAnimationFrame(this._tick)))}}_requestIfNeeded(){this._requestId===null&&this._head.next&&(this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))}_cancelIfNeeded(){this._requestId!==null&&(cancelAnimationFrame(this._requestId),this._requestId=null)}_startIfPossible(){this.started?this._requestIfNeeded():this.autoStart&&this.start()}add(ze,Gr,Yr=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(ze,Gr,Yr))}addOnce(ze,Gr,Yr=UPDATE_PRIORITY.NORMAL){return this._addListener(new TickerListener(ze,Gr,Yr,!0))}_addListener(ze){let Gr=this._head.next,Yr=this._head;if(!Gr)ze.connect(Yr);else{for(;Gr;){if(ze.priority>Gr.priority){ze.connect(Yr);break}Yr=Gr,Gr=Gr.next}ze.previous||ze.connect(Yr)}return this._startIfPossible(),this}remove(ze,Gr){let Yr=this._head.next;for(;Yr;)Yr.match(ze,Gr)?Yr=Yr.destroy():Yr=Yr.next;return this._head.next||this._cancelIfNeeded(),this}get count(){if(!this._head)return 0;let ze=0,Gr=this._head;for(;Gr=Gr.next;)ze++;return ze}start(){this.started||(this.started=!0,this._requestIfNeeded())}stop(){this.started&&(this.started=!1,this._cancelIfNeeded())}destroy(){if(!this._protected){this.stop();let ze=this._head.next;for(;ze;)ze=ze.destroy(!0);this._head.destroy(),this._head=null}}update(ze=performance.now()){let Gr;if(ze>this.lastTime){if(Gr=this.elapsedMS=ze-this.lastTime,Gr>this._maxElapsedMS&&(Gr=this._maxElapsedMS),Gr*=this.speed,this._minElapsedMS){const Zr=ze-this._lastFrame|0;if(Zr<this._minElapsedMS)return;this._lastFrame=ze-Zr%this._minElapsedMS}this.deltaMS=Gr,this.deltaTime=this.deltaMS*Yi.targetFPMS;const Yr=this._head;let Kr=Yr.next;for(;Kr;)Kr=Kr.emit(this);Yr.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=ze}get FPS(){return 1e3/this.elapsedMS}get minFPS(){return 1e3/this._maxElapsedMS}set minFPS(ze){const Gr=Math.min(this.maxFPS,ze),Yr=Math.min(Math.max(0,Gr)/1e3,Yi.targetFPMS);this._maxElapsedMS=1/Yr}get maxFPS(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0}set maxFPS(ze){if(ze===0)this._minElapsedMS=0;else{const Gr=Math.max(this.minFPS,ze);this._minElapsedMS=1/(Gr/1e3)}}static get shared(){if(!Yi._shared){const ze=Yi._shared=new Yi;ze.autoStart=!0,ze._protected=!0}return Yi._shared}static get system(){if(!Yi._system){const ze=Yi._system=new Yi;ze.autoStart=!0,ze._protected=!0}return Yi._system}};_Ticker.targetFPMS=.06;let Ticker=_Ticker,promise;async function detectVideoAlphaMode(){return promise??(promise=(async()=>{var Qr;const ze=document.createElement("canvas").getContext("webgl");if(!ze)return"premultiply-alpha-on-upload";const Gr=await new Promise(Jr=>{const ei=document.createElement("video");ei.onloadeddata=()=>Jr(ei),ei.onerror=()=>Jr(null),ei.autoplay=!1,ei.crossOrigin="anonymous",ei.preload="auto",ei.src="data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",ei.load()});if(!Gr)return"premultiply-alpha-on-upload";const Yr=ze.createTexture();ze.bindTexture(ze.TEXTURE_2D,Yr);const Kr=ze.createFramebuffer();ze.bindFramebuffer(ze.FRAMEBUFFER,Kr),ze.framebufferTexture2D(ze.FRAMEBUFFER,ze.COLOR_ATTACHMENT0,ze.TEXTURE_2D,Yr,0),ze.pixelStorei(ze.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),ze.pixelStorei(ze.UNPACK_COLORSPACE_CONVERSION_WEBGL,ze.NONE),ze.texImage2D(ze.TEXTURE_2D,0,ze.RGBA,ze.RGBA,ze.UNSIGNED_BYTE,Gr);const Zr=new Uint8Array(4);return ze.readPixels(0,0,1,1,ze.RGBA,ze.UNSIGNED_BYTE,Zr),ze.deleteFramebuffer(Kr),ze.deleteTexture(Yr),(Qr=ze.getExtension("WEBGL_lose_context"))==null||Qr.loseContext(),Zr[0]<=Zr[3]?"premultiplied-alpha":"premultiply-alpha-on-upload"})()),promise}const _VideoSource=class Ss extends TextureSource{constructor(ze){super(ze),this.isReady=!1,this.uploadMethodId="video",ze={...Ss.defaultOptions,...ze},this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=ze.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=ze.autoPlay!==!1,this.alphaMode=ze.alphaMode??"premultiply-alpha-on-upload",this._videoFrameRequestCallback=this._videoFrameRequestCallback.bind(this),this._videoFrameRequestCallbackHandle=null,this._load=null,this._resolve=null,this._reject=null,this._onCanPlay=this._onCanPlay.bind(this),this._onCanPlayThrough=this._onCanPlayThrough.bind(this),this._onError=this._onError.bind(this),this._onPlayStart=this._onPlayStart.bind(this),this._onPlayStop=this._onPlayStop.bind(this),this._onSeeked=this._onSeeked.bind(this),ze.autoLoad!==!1&&this.load()}updateFrame(){if(!this.destroyed){if(this._updateFPS){const ze=Ticker.shared.elapsedMS*this.resource.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-ze)}(!this._updateFPS||this._msToNextUpdate<=0)&&(this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0),this.isValid&&this.update()}}_videoFrameRequestCallback(){this.updateFrame(),this.destroyed?this._videoFrameRequestCallbackHandle=null:this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)}get isValid(){return!!this.resource.videoWidth&&!!this.resource.videoHeight}async load(){if(this._load)return this._load;const ze=this.resource,Gr=this.options;return(ze.readyState===ze.HAVE_ENOUGH_DATA||ze.readyState===ze.HAVE_FUTURE_DATA)&&ze.width&&ze.height&&(ze.complete=!0),ze.addEventListener("play",this._onPlayStart),ze.addEventListener("pause",this._onPlayStop),ze.addEventListener("seeked",this._onSeeked),this._isSourceReady()?this._mediaReady():(Gr.preload||ze.addEventListener("canplay",this._onCanPlay),ze.addEventListener("canplaythrough",this._onCanPlayThrough),ze.addEventListener("error",this._onError,!0)),this.alphaMode=await detectVideoAlphaMode(),this._load=new Promise((Yr,Kr)=>{this.isValid?Yr(this):(this._resolve=Yr,this._reject=Kr,Gr.preloadTimeoutMs!==void 0&&(this._preloadTimeout=setTimeout(()=>{this._onError(new ErrorEvent(`Preload exceeded timeout of ${Gr.preloadTimeoutMs}ms`))})),ze.load())}),this._load}_onError(ze){this.resource.removeEventListener("error",this._onError,!0),this.emit("error",ze),this._reject&&(this._reject(ze),this._reject=null,this._resolve=null)}_isSourcePlaying(){const ze=this.resource;return!ze.paused&&!ze.ended}_isSourceReady(){return this.resource.readyState>2}_onPlayStart(){this.isValid||this._mediaReady(),this._configureAutoUpdate()}_onPlayStop(){this._configureAutoUpdate()}_onSeeked(){this._autoUpdate&&!this._isSourcePlaying()&&(this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0)}_onCanPlay(){this.resource.removeEventListener("canplay",this._onCanPlay),this._mediaReady()}_onCanPlayThrough(){this.resource.removeEventListener("canplaythrough",this._onCanPlay),this._preloadTimeout&&(clearTimeout(this._preloadTimeout),this._preloadTimeout=void 0),this._mediaReady()}_mediaReady(){const ze=this.resource;this.isValid&&(this.isReady=!0,this.resize(ze.videoWidth,ze.videoHeight)),this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0,this._resolve&&(this._resolve(this),this._resolve=null,this._reject=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&this.resource.play()}destroy(){this._configureAutoUpdate();const ze=this.resource;ze&&(ze.removeEventListener("play",this._onPlayStart),ze.removeEventListener("pause",this._onPlayStop),ze.removeEventListener("seeked",this._onSeeked),ze.removeEventListener("canplay",this._onCanPlay),ze.removeEventListener("canplaythrough",this._onCanPlayThrough),ze.removeEventListener("error",this._onError,!0),ze.pause(),ze.src="",ze.load()),super.destroy()}get autoUpdate(){return this._autoUpdate}set autoUpdate(ze){ze!==this._autoUpdate&&(this._autoUpdate=ze,this._configureAutoUpdate())}get updateFPS(){return this._updateFPS}set updateFPS(ze){ze!==this._updateFPS&&(this._updateFPS=ze,this._configureAutoUpdate())}_configureAutoUpdate(){this._autoUpdate&&this._isSourcePlaying()?!this._updateFPS&&this.resource.requestVideoFrameCallback?(this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0),this._videoFrameRequestCallbackHandle===null&&(this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker||(Ticker.shared.add(this.updateFrame,this),this._isConnectedToTicker=!0,this._msToNextUpdate=0)):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker&&(Ticker.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0))}static test(ze){return globalThis.HTMLVideoElement&&ze instanceof HTMLVideoElement}};_VideoSource.extension=ExtensionType.TextureSource;_VideoSource.defaultOptions={...TextureSource.defaultOptions,autoLoad:!0,autoPlay:!0,updateFPS:0,crossorigin:!0,loop:!1,muted:!0,playsinline:!0,preload:!1};_VideoSource.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};let VideoSource=_VideoSource;const convertToList=(Wr,ze,Gr=!1)=>(Array.isArray(Wr)||(Wr=[Wr]),ze?Wr.map(Yr=>typeof Yr=="string"||Gr?ze(Yr):Yr):Wr);class CacheClass{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(ze){return this._cache.has(ze)}get(ze){const Gr=this._cache.get(ze);return Gr||warn(`[Assets] Asset id ${ze} was not found in the Cache`),Gr}set(ze,Gr){const Yr=convertToList(ze);let Kr;for(let ei=0;ei<this.parsers.length;ei++){const ti=this.parsers[ei];if(ti.test(Gr)){Kr=ti.getCacheableAssets(Yr,Gr);break}}const Zr=new Map(Object.entries(Kr||{}));Kr||Yr.forEach(ei=>{Zr.set(ei,Gr)});const Qr=[...Zr.keys()],Jr={cacheKeys:Qr,keys:Yr};Yr.forEach(ei=>{this._cacheMap.set(ei,Jr)}),Qr.forEach(ei=>{const ti=Kr?Kr[ei]:Gr;this._cache.has(ei)&&this._cache.get(ei)!==ti&&warn("[Cache] already has key:",ei),this._cache.set(ei,Zr.get(ei))})}remove(ze){if(!this._cacheMap.has(ze)){warn(`[Assets] Asset id ${ze} was not found in the Cache`);return}const Gr=this._cacheMap.get(ze);Gr.cacheKeys.forEach(Kr=>{this._cache.delete(Kr)}),Gr.keys.forEach(Kr=>{this._cacheMap.delete(Kr)})}get parsers(){return this._parsers}}const Cache=new CacheClass,sources=[];extensions.handleByList(ExtensionType.TextureSource,sources);function textureSourceFrom(Wr={}){const ze=Wr&&Wr.resource,Gr=ze?Wr.resource:Wr,Yr=ze?Wr:{resource:Wr};for(let Kr=0;Kr<sources.length;Kr++){const Zr=sources[Kr];if(Zr.test(Gr))return new Zr(Yr)}throw new Error(`Could not find a source type for resource: ${Yr.resource}`)}function resourceToTexture(Wr={},ze=!1){const Gr=Wr&&Wr.resource,Yr=Gr?Wr.resource:Wr,Kr=Gr?Wr:{resource:Wr};if(!ze&&Cache.has(Yr))return Cache.get(Yr);const Zr=new Texture({source:textureSourceFrom(Kr)});return Zr.on("destroy",()=>{Cache.has(Yr)&&Cache.remove(Yr)}),ze||Cache.set(Yr,Zr),Zr}function textureFrom(Wr,ze=!1){return typeof Wr=="string"?Cache.get(Wr):Wr instanceof TextureSource?new Texture({source:Wr}):resourceToTexture(Wr,ze)}Texture.from=textureFrom;TextureSource.from=textureSourceFrom;extensions.add(AlphaMask,ColorMask,StencilMask,VideoSource,ImageSource,CanvasSource,BufferImageSource);var LoaderParserPriority=(Wr=>(Wr[Wr.Low=0]="Low",Wr[Wr.Normal=1]="Normal",Wr[Wr.High=2]="High",Wr))(LoaderParserPriority||{});function assertPath(Wr){if(typeof Wr!="string")throw new TypeError(`Path must be a string. Received ${JSON.stringify(Wr)}`)}function removeUrlParams(Wr){return Wr.split("?")[0].split("#")[0]}function escapeRegExp(Wr){return Wr.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function replaceAll(Wr,ze,Gr){return Wr.replace(new RegExp(escapeRegExp(ze),"g"),Gr)}function normalizeStringPosix(Wr,ze){let Gr="",Yr=0,Kr=-1,Zr=0,Qr=-1;for(let Jr=0;Jr<=Wr.length;++Jr){if(Jr<Wr.length)Qr=Wr.charCodeAt(Jr);else{if(Qr===47)break;Qr=47}if(Qr===47){if(!(Kr===Jr-1||Zr===1))if(Kr!==Jr-1&&Zr===2){if(Gr.length<2||Yr!==2||Gr.charCodeAt(Gr.length-1)!==46||Gr.charCodeAt(Gr.length-2)!==46){if(Gr.length>2){const ei=Gr.lastIndexOf("/");if(ei!==Gr.length-1){ei===-1?(Gr="",Yr=0):(Gr=Gr.slice(0,ei),Yr=Gr.length-1-Gr.lastIndexOf("/")),Kr=Jr,Zr=0;continue}}else if(Gr.length===2||Gr.length===1){Gr="",Yr=0,Kr=Jr,Zr=0;continue}}}else Gr.length>0?Gr+=`/${Wr.slice(Kr+1,Jr)}`:Gr=Wr.slice(Kr+1,Jr),Yr=Jr-Kr-1;Kr=Jr,Zr=0}else Qr===46&&Zr!==-1?++Zr:Zr=-1}return Gr}const path={toPosix(Wr){return replaceAll(Wr,"\\","/")},isUrl(Wr){return/^https?:/.test(this.toPosix(Wr))},isDataUrl(Wr){return/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(Wr)},isBlobUrl(Wr){return Wr.startsWith("blob:")},hasProtocol(Wr){return/^[^/:]+:/.test(this.toPosix(Wr))},getProtocol(Wr){assertPath(Wr),Wr=this.toPosix(Wr);const ze=/^file:\/\/\//.exec(Wr);if(ze)return ze[0];const Gr=/^[^/:]+:\/{0,2}/.exec(Wr);return Gr?Gr[0]:""},toAbsolute(Wr,ze,Gr){if(assertPath(Wr),this.isDataUrl(Wr)||this.isBlobUrl(Wr))return Wr;const Yr=removeUrlParams(this.toPosix(ze??DOMAdapter.get().getBaseUrl())),Kr=removeUrlParams(this.toPosix(Gr??this.rootname(Yr)));return Wr=this.toPosix(Wr),Wr.startsWith("/")?path.join(Kr,Wr.slice(1)):this.isAbsolute(Wr)?Wr:this.join(Yr,Wr)},normalize(Wr){if(assertPath(Wr),Wr.length===0)return".";if(this.isDataUrl(Wr)||this.isBlobUrl(Wr))return Wr;Wr=this.toPosix(Wr);let ze="";const Gr=Wr.startsWith("/");this.hasProtocol(Wr)&&(ze=this.rootname(Wr),Wr=Wr.slice(ze.length));const Yr=Wr.endsWith("/");return Wr=normalizeStringPosix(Wr),Wr.length>0&&Yr&&(Wr+="/"),Gr?`/${Wr}`:ze+Wr},isAbsolute(Wr){return assertPath(Wr),Wr=this.toPosix(Wr),this.hasProtocol(Wr)?!0:Wr.startsWith("/")},join(...Wr){if(Wr.length===0)return".";let ze;for(let Gr=0;Gr<Wr.length;++Gr){const Yr=Wr[Gr];if(assertPath(Yr),Yr.length>0)if(ze===void 0)ze=Yr;else{const Kr=Wr[Gr-1]??"";this.joinExtensions.includes(this.extname(Kr).toLowerCase())?ze+=`/../${Yr}`:ze+=`/${Yr}`}}return ze===void 0?".":this.normalize(ze)},dirname(Wr){if(assertPath(Wr),Wr.length===0)return".";Wr=this.toPosix(Wr);let ze=Wr.charCodeAt(0);const Gr=ze===47;let Yr=-1,Kr=!0;const Zr=this.getProtocol(Wr),Qr=Wr;Wr=Wr.slice(Zr.length);for(let Jr=Wr.length-1;Jr>=1;--Jr)if(ze=Wr.charCodeAt(Jr),ze===47){if(!Kr){Yr=Jr;break}}else Kr=!1;return Yr===-1?Gr?"/":this.isUrl(Qr)?Zr+Wr:Zr:Gr&&Yr===1?"//":Zr+Wr.slice(0,Yr)},rootname(Wr){assertPath(Wr),Wr=this.toPosix(Wr);let ze="";if(Wr.startsWith("/")?ze="/":ze=this.getProtocol(Wr),this.isUrl(Wr)){const Gr=Wr.indexOf("/",ze.length);Gr!==-1?ze=Wr.slice(0,Gr):ze=Wr,ze.endsWith("/")||(ze+="/")}return ze},basename(Wr,ze){assertPath(Wr),ze&&assertPath(ze),Wr=removeUrlParams(this.toPosix(Wr));let Gr=0,Yr=-1,Kr=!0,Zr;if(ze!==void 0&&ze.length>0&&ze.length<=Wr.length){if(ze.length===Wr.length&&ze===Wr)return"";let Qr=ze.length-1,Jr=-1;for(Zr=Wr.length-1;Zr>=0;--Zr){const ei=Wr.charCodeAt(Zr);if(ei===47){if(!Kr){Gr=Zr+1;break}}else Jr===-1&&(Kr=!1,Jr=Zr+1),Qr>=0&&(ei===ze.charCodeAt(Qr)?--Qr===-1&&(Yr=Zr):(Qr=-1,Yr=Jr))}return Gr===Yr?Yr=Jr:Yr===-1&&(Yr=Wr.length),Wr.slice(Gr,Yr)}for(Zr=Wr.length-1;Zr>=0;--Zr)if(Wr.charCodeAt(Zr)===47){if(!Kr){Gr=Zr+1;break}}else Yr===-1&&(Kr=!1,Yr=Zr+1);return Yr===-1?"":Wr.slice(Gr,Yr)},extname(Wr){assertPath(Wr),Wr=removeUrlParams(this.toPosix(Wr));let ze=-1,Gr=0,Yr=-1,Kr=!0,Zr=0;for(let Qr=Wr.length-1;Qr>=0;--Qr){const Jr=Wr.charCodeAt(Qr);if(Jr===47){if(!Kr){Gr=Qr+1;break}continue}Yr===-1&&(Kr=!1,Yr=Qr+1),Jr===46?ze===-1?ze=Qr:Zr!==1&&(Zr=1):ze!==-1&&(Zr=-1)}return ze===-1||Yr===-1||Zr===0||Zr===1&&ze===Yr-1&&ze===Gr+1?"":Wr.slice(ze,Yr)},parse(Wr){assertPath(Wr);const ze={root:"",dir:"",base:"",ext:"",name:""};if(Wr.length===0)return ze;Wr=removeUrlParams(this.toPosix(Wr));let Gr=Wr.charCodeAt(0);const Yr=this.isAbsolute(Wr);let Kr;ze.root=this.rootname(Wr),Yr||this.hasProtocol(Wr)?Kr=1:Kr=0;let Zr=-1,Qr=0,Jr=-1,ei=!0,ti=Wr.length-1,ri=0;for(;ti>=Kr;--ti){if(Gr=Wr.charCodeAt(ti),Gr===47){if(!ei){Qr=ti+1;break}continue}Jr===-1&&(ei=!1,Jr=ti+1),Gr===46?Zr===-1?Zr=ti:ri!==1&&(ri=1):Zr!==-1&&(ri=-1)}return Zr===-1||Jr===-1||ri===0||ri===1&&Zr===Jr-1&&Zr===Qr+1?Jr!==-1&&(Qr===0&&Yr?ze.base=ze.name=Wr.slice(1,Jr):ze.base=ze.name=Wr.slice(Qr,Jr)):(Qr===0&&Yr?(ze.name=Wr.slice(1,Zr),ze.base=Wr.slice(1,Jr)):(ze.name=Wr.slice(Qr,Zr),ze.base=Wr.slice(Qr,Jr)),ze.ext=Wr.slice(Zr,Jr)),ze.dir=this.dirname(Wr),ze},sep:"/",delimiter:":",joinExtensions:[".html"]};function processX(Wr,ze,Gr,Yr,Kr){const Zr=ze[Gr];for(let Qr=0;Qr<Zr.length;Qr++){const Jr=Zr[Qr];Gr<ze.length-1?processX(Wr.replace(Yr[Gr],Jr),ze,Gr+1,Yr,Kr):Kr.push(Wr.replace(Yr[Gr],Jr))}}function createStringVariations(Wr){const ze=/\{(.*?)\}/g,Gr=Wr.match(ze),Yr=[];if(Gr){const Kr=[];Gr.forEach(Zr=>{const Qr=Zr.substring(1,Zr.length-1).split(",");Kr.push(Qr)}),processX(Wr,Kr,0,Gr,Yr)}else Yr.push(Wr);return Yr}const isSingleItem=Wr=>!Array.isArray(Wr);class Resolver{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(ze,Gr)=>`${ze}${this._bundleIdConnector}${Gr}`,extractAssetIdFromBundle:(ze,Gr)=>Gr.replace(`${ze}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(ze){if(this._bundleIdConnector=ze.connector??this._bundleIdConnector,this._createBundleAssetId=ze.createBundleAssetId??this._createBundleAssetId,this._extractAssetIdFromBundle=ze.extractAssetIdFromBundle??this._extractAssetIdFromBundle,this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar"))!=="bar")throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...ze){ze.forEach(Gr=>{this._preferredOrder.push(Gr),Gr.priority||(Gr.priority=Object.keys(Gr.params))}),this._resolverHash={}}set basePath(ze){this._basePath=ze}get basePath(){return this._basePath}set rootPath(ze){this._rootPath=ze}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(ze){if(typeof ze=="string")this._defaultSearchParams=ze;else{const Gr=ze;this._defaultSearchParams=Object.keys(Gr).map(Yr=>`${encodeURIComponent(Yr)}=${encodeURIComponent(Gr[Yr])}`).join("&")}}getAlias(ze){const{alias:Gr,src:Yr}=ze;return convertToList(Gr||Yr,Zr=>typeof Zr=="string"?Zr:Array.isArray(Zr)?Zr.map(Qr=>(Qr==null?void 0:Qr.src)??Qr):Zr!=null&&Zr.src?Zr.src:Zr,!0)}addManifest(ze){this._manifest&&warn("[Resolver] Manifest already exists, this will be overwritten"),this._manifest=ze,ze.bundles.forEach(Gr=>{this.addBundle(Gr.name,Gr.assets)})}addBundle(ze,Gr){const Yr=[];let Kr=Gr;Array.isArray(Gr)||(Kr=Object.entries(Gr).map(([Zr,Qr])=>typeof Qr=="string"||Array.isArray(Qr)?{alias:Zr,src:Qr}:{alias:Zr,...Qr})),Kr.forEach(Zr=>{const Qr=Zr.src,Jr=Zr.alias;let ei;if(typeof Jr=="string"){const ti=this._createBundleAssetId(ze,Jr);Yr.push(ti),ei=[Jr,ti]}else{const ti=Jr.map(ri=>this._createBundleAssetId(ze,ri));Yr.push(...ti),ei=[...Jr,...ti]}this.add({...Zr,alias:ei,src:Qr})}),this._bundles[ze]=Yr}add(ze){const Gr=[];Array.isArray(ze)?Gr.push(...ze):Gr.push(ze);let Yr;Yr=Zr=>{this.hasKey(Zr)&&warn(`[Resolver] already has key: ${Zr} overwriting`)},convertToList(Gr).forEach(Zr=>{const{src:Qr}=Zr;let{data:Jr,format:ei,loadParser:ti}=Zr;const ri=convertToList(Qr).map(ni=>typeof ni=="string"?createStringVariations(ni):Array.isArray(ni)?ni:[ni]),ii=this.getAlias(Zr);Array.isArray(ii)?ii.forEach(Yr):Yr(ii);const si=[];ri.forEach(ni=>{ni.forEach(oi=>{let li={};if(typeof oi!="object"){li.src=oi;for(let ai=0;ai<this._parsers.length;ai++){const ui=this._parsers[ai];if(ui.test(oi)){li=ui.parse(oi);break}}}else Jr=oi.data??Jr,ei=oi.format??ei,ti=oi.loadParser??ti,li={...li,...oi};if(!ii)throw new Error(`[Resolver] alias is undefined for this asset: ${li.src}`);li=this._buildResolvedAsset(li,{aliases:ii,data:Jr,format:ei,loadParser:ti}),si.push(li)})}),ii.forEach(ni=>{this._assetMap[ni]=si})})}resolveBundle(ze){const Gr=isSingleItem(ze);ze=convertToList(ze);const Yr={};return ze.forEach(Kr=>{const Zr=this._bundles[Kr];if(Zr){const Qr=this.resolve(Zr),Jr={};for(const ei in Qr){const ti=Qr[ei];Jr[this._extractAssetIdFromBundle(Kr,ei)]=ti}Yr[Kr]=Jr}}),Gr?Yr[ze[0]]:Yr}resolveUrl(ze){const Gr=this.resolve(ze);if(typeof ze!="string"){const Yr={};for(const Kr in Gr)Yr[Kr]=Gr[Kr].src;return Yr}return Gr.src}resolve(ze){const Gr=isSingleItem(ze);ze=convertToList(ze);const Yr={};return ze.forEach(Kr=>{if(!this._resolverHash[Kr])if(this._assetMap[Kr]){let Zr=this._assetMap[Kr];const Qr=this._getPreferredOrder(Zr);Qr==null||Qr.priority.forEach(Jr=>{Qr.params[Jr].forEach(ei=>{const ti=Zr.filter(ri=>ri[Jr]?ri[Jr]===ei:!1);ti.length&&(Zr=ti)})}),this._resolverHash[Kr]=Zr[0]}else this._resolverHash[Kr]=this._buildResolvedAsset({alias:[Kr],src:Kr},{});Yr[Kr]=this._resolverHash[Kr]}),Gr?Yr[ze[0]]:Yr}hasKey(ze){return!!this._assetMap[ze]}hasBundle(ze){return!!this._bundles[ze]}_getPreferredOrder(ze){for(let Gr=0;Gr<ze.length;Gr++){const Yr=ze[Gr],Kr=this._preferredOrder.find(Zr=>Zr.params.format.includes(Yr.format));if(Kr)return Kr}return this._preferredOrder[0]}_appendDefaultSearchParams(ze){if(!this._defaultSearchParams)return ze;const Gr=/\?/.test(ze)?"&":"?";return`${ze}${Gr}${this._defaultSearchParams}`}_buildResolvedAsset(ze,Gr){const{aliases:Yr,data:Kr,loadParser:Zr,format:Qr}=Gr;return(this._basePath||this._rootPath)&&(ze.src=path.toAbsolute(ze.src,this._basePath,this._rootPath)),ze.alias=Yr??ze.alias??[ze.src],ze.src=this._appendDefaultSearchParams(ze.src),ze.data={...Kr||{},...ze.data},ze.loadParser=Zr??ze.loadParser,ze.format=Qr??ze.format??getUrlExtension(ze.src),ze}}Resolver.RETINA_PREFIX=/@([0-9\.]+)x/;function getUrlExtension(Wr){return Wr.split(".").pop().split("?").shift().split("#").shift()}const copySearchParams=(Wr,ze)=>{const Gr=ze.split("?")[1];return Gr&&(Wr+=`?${Gr}`),Wr},_Spritesheet=class ns{constructor(ze,Gr){this.linkedSheets=[],this._texture=ze instanceof Texture?ze:null,this.textureSource=ze.source,this.textures={},this.animations={},this.data=Gr;const Yr=parseFloat(Gr.meta.scale);Yr?(this.resolution=Yr,ze.source.resolution=this.resolution):this.resolution=ze.source._resolution,this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}parse(){return new Promise(ze=>{this._callback=ze,this._batchIndex=0,this._frameKeys.length<=ns.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()})}_processFrames(ze){let Gr=ze;const Yr=ns.BATCH_SIZE;for(;Gr-ze<Yr&&Gr<this._frameKeys.length;){const Kr=this._frameKeys[Gr],Zr=this._frames[Kr],Qr=Zr.frame;if(Qr){let Jr=null,ei=null;const ti=Zr.trimmed!==!1&&Zr.sourceSize?Zr.sourceSize:Zr.frame,ri=new Rectangle(0,0,Math.floor(ti.w)/this.resolution,Math.floor(ti.h)/this.resolution);Zr.rotated?Jr=new Rectangle(Math.floor(Qr.x)/this.resolution,Math.floor(Qr.y)/this.resolution,Math.floor(Qr.h)/this.resolution,Math.floor(Qr.w)/this.resolution):Jr=new Rectangle(Math.floor(Qr.x)/this.resolution,Math.floor(Qr.y)/this.resolution,Math.floor(Qr.w)/this.resolution,Math.floor(Qr.h)/this.resolution),Zr.trimmed!==!1&&Zr.spriteSourceSize&&(ei=new Rectangle(Math.floor(Zr.spriteSourceSize.x)/this.resolution,Math.floor(Zr.spriteSourceSize.y)/this.resolution,Math.floor(Qr.w)/this.resolution,Math.floor(Qr.h)/this.resolution)),this.textures[Kr]=new Texture({source:this.textureSource,frame:Jr,orig:ri,trim:ei,rotate:Zr.rotated?2:0,defaultAnchor:Zr.anchor,defaultBorders:Zr.borders,label:Kr.toString()})}Gr++}}_processAnimations(){const ze=this.data.animations||{};for(const Gr in ze){this.animations[Gr]=[];for(let Yr=0;Yr<ze[Gr].length;Yr++){const Kr=ze[Gr][Yr];this.animations[Gr].push(this.textures[Kr])}}}_parseComplete(){const ze=this._callback;this._callback=null,this._batchIndex=0,ze.call(this,this.textures)}_nextBatch(){this._processFrames(this._batchIndex*ns.BATCH_SIZE),this._batchIndex++,setTimeout(()=>{this._batchIndex*ns.BATCH_SIZE<this._frameKeys.length?this._nextBatch():(this._processAnimations(),this._parseComplete())},0)}destroy(ze=!1){var Gr;for(const Yr in this.textures)this.textures[Yr].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,ze&&((Gr=this._texture)==null||Gr.destroy(),this.textureSource.destroy()),this._texture=null,this.textureSource=null,this.linkedSheets=[]}};_Spritesheet.BATCH_SIZE=1e3;let Spritesheet=_Spritesheet;const validImages=["jpg","png","jpeg","avif","webp","basis","etc2","bc7","bc6h","bc5","bc4","bc3","bc2","bc1","eac","astc"];function getCacheableAssets(Wr,ze,Gr){const Yr={};if(Wr.forEach(Kr=>{Yr[Kr]=ze}),Object.keys(ze.textures).forEach(Kr=>{Yr[Kr]=ze.textures[Kr]}),!Gr){const Kr=path.dirname(Wr[0]);ze.linkedSheets.forEach((Zr,Qr)=>{const Jr=getCacheableAssets([`${Kr}/${ze.data.meta.related_multi_packs[Qr]}`],Zr,!0);Object.assign(Yr,Jr)})}return Yr}const spritesheetAsset={extension:ExtensionType.Asset,cache:{test:Wr=>Wr instanceof Spritesheet,getCacheableAssets:(Wr,ze)=>getCacheableAssets(Wr,ze,!1)},resolver:{extension:{type:ExtensionType.ResolveParser,name:"resolveSpritesheet"},test:Wr=>{const Gr=Wr.split("?")[0].split("."),Yr=Gr.pop(),Kr=Gr.pop();return Yr==="json"&&validImages.includes(Kr)},parse:Wr=>{var Gr;const ze=Wr.split(".");return{resolution:parseFloat(((Gr=Resolver.RETINA_PREFIX.exec(Wr))==null?void 0:Gr[1])??"1"),format:ze[ze.length-2],src:Wr}}},loader:{name:"spritesheetLoader",extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Normal,name:"spritesheetLoader"},async testParse(Wr,ze){return path.extname(ze.src).toLowerCase()===".json"&&!!Wr.frames},async parse(Wr,ze,Gr){var ri,ii;const{texture:Yr,imageFilename:Kr,textureOptions:Zr}=(ze==null?void 0:ze.data)??{};let Qr=path.dirname(ze.src);Qr&&Qr.lastIndexOf("/")!==Qr.length-1&&(Qr+="/");let Jr;if(Yr instanceof Texture)Jr=Yr;else{const si=copySearchParams(Qr+(Kr??Wr.meta.image),ze.src);Jr=(await Gr.load([{src:si,data:Zr}]))[si]}const ei=new Spritesheet(Jr.source,Wr);await ei.parse();const ti=(ri=Wr==null?void 0:Wr.meta)==null?void 0:ri.related_multi_packs;if(Array.isArray(ti)){const si=[];for(const oi of ti){if(typeof oi!="string")continue;let li=Qr+oi;(ii=ze.data)!=null&&ii.ignoreMultiPack||(li=copySearchParams(li,ze.src),si.push(Gr.load({src:li,data:{textureOptions:Zr,ignoreMultiPack:!0}})))}const ni=await Promise.all(si);ei.linkedSheets=ni,ni.forEach(oi=>{oi.linkedSheets=[ei].concat(ei.linkedSheets.filter(li=>li!==oi))})}return ei},async unload(Wr,ze,Gr){await Gr.unload(Wr.textureSource._sourceOrigin),Wr.destroy(!1)}}};extensions.add(spritesheetAsset);class FederatedEvent{constructor(ze){this.bubbles=!0,this.cancelBubble=!0,this.cancelable=!1,this.composed=!1,this.defaultPrevented=!1,this.eventPhase=FederatedEvent.prototype.NONE,this.propagationStopped=!1,this.propagationImmediatelyStopped=!1,this.layer=new Point$1,this.page=new Point$1,this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.manager=ze}get layerX(){return this.layer.x}get layerY(){return this.layer.y}get pageX(){return this.page.x}get pageY(){return this.page.y}get data(){return this}composedPath(){return this.manager&&(!this.path||this.path[this.path.length-1]!==this.target)&&(this.path=this.target?this.manager.propagationPath(this.target):[]),this.path}initEvent(ze,Gr,Yr){throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}initUIEvent(ze,Gr,Yr,Kr,Zr){throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}preventDefault(){this.nativeEvent instanceof Event&&this.nativeEvent.cancelable&&this.nativeEvent.preventDefault(),this.defaultPrevented=!0}stopImmediatePropagation(){this.propagationImmediatelyStopped=!0}stopPropagation(){this.propagationStopped=!0}}var appleIphone=/iPhone/i,appleIpod=/iPod/i,appleTablet=/iPad/i,appleUniversal=/\biOS-universal(?:.+)Mac\b/i,androidPhone=/\bAndroid(?:.+)Mobile\b/i,androidTablet=/Android/i,amazonPhone=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,amazonTablet=/Silk/i,windowsPhone=/Windows Phone/i,windowsTablet=/\bWindows(?:.+)ARM\b/i,otherBlackBerry=/BlackBerry/i,otherBlackBerry10=/BB10/i,otherOpera=/Opera Mini/i,otherChrome=/\b(CriOS|Chrome)(?:.+)Mobile/i,otherFirefox=/Mobile(?:.+)Firefox\b/i,isAppleTabletOnIos13=function(Wr){return typeof Wr<"u"&&Wr.platform==="MacIntel"&&typeof Wr.maxTouchPoints=="number"&&Wr.maxTouchPoints>1&&typeof MSStream>"u"};function createMatch(Wr){return function(ze){return ze.test(Wr)}}function isMobile$1(Wr){var ze={userAgent:"",platform:"",maxTouchPoints:0};!Wr&&typeof navigator<"u"?ze={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0}:typeof Wr=="string"?ze.userAgent=Wr:Wr&&Wr.userAgent&&(ze={userAgent:Wr.userAgent,platform:Wr.platform,maxTouchPoints:Wr.maxTouchPoints||0});var Gr=ze.userAgent,Yr=Gr.split("[FBAN");typeof Yr[1]<"u"&&(Gr=Yr[0]),Yr=Gr.split("Twitter"),typeof Yr[1]<"u"&&(Gr=Yr[0]);var Kr=createMatch(Gr),Zr={apple:{phone:Kr(appleIphone)&&!Kr(windowsPhone),ipod:Kr(appleIpod),tablet:!Kr(appleIphone)&&(Kr(appleTablet)||isAppleTabletOnIos13(ze))&&!Kr(windowsPhone),universal:Kr(appleUniversal),device:(Kr(appleIphone)||Kr(appleIpod)||Kr(appleTablet)||Kr(appleUniversal)||isAppleTabletOnIos13(ze))&&!Kr(windowsPhone)},amazon:{phone:Kr(amazonPhone),tablet:!Kr(amazonPhone)&&Kr(amazonTablet),device:Kr(amazonPhone)||Kr(amazonTablet)},android:{phone:!Kr(windowsPhone)&&Kr(amazonPhone)||!Kr(windowsPhone)&&Kr(androidPhone),tablet:!Kr(windowsPhone)&&!Kr(amazonPhone)&&!Kr(androidPhone)&&(Kr(amazonTablet)||Kr(androidTablet)),device:!Kr(windowsPhone)&&(Kr(amazonPhone)||Kr(amazonTablet)||Kr(androidPhone)||Kr(androidTablet))||Kr(/\bokhttp\b/i)},windows:{phone:Kr(windowsPhone),tablet:Kr(windowsTablet),device:Kr(windowsPhone)||Kr(windowsTablet)},other:{blackberry:Kr(otherBlackBerry),blackberry10:Kr(otherBlackBerry10),opera:Kr(otherOpera),firefox:Kr(otherFirefox),chrome:Kr(otherChrome),device:Kr(otherBlackBerry)||Kr(otherBlackBerry10)||Kr(otherOpera)||Kr(otherFirefox)||Kr(otherChrome)},any:!1,phone:!1,tablet:!1};return Zr.any=Zr.apple.device||Zr.android.device||Zr.windows.device||Zr.other.device,Zr.phone=Zr.apple.phone||Zr.android.phone||Zr.windows.phone,Zr.tablet=Zr.apple.tablet||Zr.android.tablet||Zr.windows.tablet,Zr}const isMobileCall=isMobile$1.default??isMobile$1,isMobile=isMobileCall(globalThis.navigator),KEY_CODE_TAB=9,DIV_TOUCH_SIZE=100,DIV_TOUCH_POS_X=0,DIV_TOUCH_POS_Y=0,DIV_TOUCH_ZINDEX=2,DIV_HOOK_SIZE=1,DIV_HOOK_POS_X=-1e3,DIV_HOOK_POS_Y=-1e3,DIV_HOOK_ZINDEX=2,_AccessibilitySystem=class Ps{constructor(ze,Gr=isMobile){this._mobileInfo=Gr,this.debug=!1,this._activateOnTab=!0,this._deactivateOnMouseMove=!0,this._isActive=!1,this._isMobileAccessibility=!1,this._div=null,this._pool=[],this._renderId=0,this._children=[],this._androidUpdateCount=0,this._androidUpdateFrequency=500,this._hookDiv=null,(Gr.tablet||Gr.phone)&&this._createTouchHook(),this._renderer=ze}get isActive(){return this._isActive}get isMobileAccessibility(){return this._isMobileAccessibility}get hookDiv(){return this._hookDiv}_createTouchHook(){const ze=document.createElement("button");ze.style.width=`${DIV_HOOK_SIZE}px`,ze.style.height=`${DIV_HOOK_SIZE}px`,ze.style.position="absolute",ze.style.top=`${DIV_HOOK_POS_X}px`,ze.style.left=`${DIV_HOOK_POS_Y}px`,ze.style.zIndex=DIV_HOOK_ZINDEX.toString(),ze.style.backgroundColor="#FF0000",ze.title="select to enable accessibility for this content",ze.addEventListener("focus",()=>{this._isMobileAccessibility=!0,this._activate(),this._destroyTouchHook()}),document.body.appendChild(ze),this._hookDiv=ze}_destroyTouchHook(){this._hookDiv&&(document.body.removeChild(this._hookDiv),this._hookDiv=null)}_activate(){if(this._isActive)return;this._isActive=!0,this._div||(this._div=document.createElement("div"),this._div.style.width=`${DIV_TOUCH_SIZE}px`,this._div.style.height=`${DIV_TOUCH_SIZE}px`,this._div.style.position="absolute",this._div.style.top=`${DIV_TOUCH_POS_X}px`,this._div.style.left=`${DIV_TOUCH_POS_Y}px`,this._div.style.zIndex=DIV_TOUCH_ZINDEX.toString(),this._div.style.pointerEvents="none"),this._activateOnTab&&(this._onKeyDown=this._onKeyDown.bind(this),globalThis.addEventListener("keydown",this._onKeyDown,!1)),this._deactivateOnMouseMove&&(this._onMouseMove=this._onMouseMove.bind(this),globalThis.document.addEventListener("mousemove",this._onMouseMove,!0));const ze=this._renderer.view.canvas;if(ze.parentNode)ze.parentNode.appendChild(this._div),this._initAccessibilitySetup();else{const Gr=new MutationObserver(()=>{ze.parentNode&&(ze.parentNode.appendChild(this._div),Gr.disconnect(),this._initAccessibilitySetup())});Gr.observe(document.body,{childList:!0,subtree:!0})}}_initAccessibilitySetup(){this._renderer.runners.postrender.add(this),this._renderer.lastObjectRendered&&this._updateAccessibleObjects(this._renderer.lastObjectRendered)}_deactivate(){if(!(!this._isActive||this._isMobileAccessibility)){this._isActive=!1,globalThis.document.removeEventListener("mousemove",this._onMouseMove,!0),this._activateOnTab&&globalThis.addEventListener("keydown",this._onKeyDown,!1),this._renderer.runners.postrender.remove(this);for(const ze of this._children)ze._accessibleDiv&&ze._accessibleDiv.parentNode&&(ze._accessibleDiv.parentNode.removeChild(ze._accessibleDiv),ze._accessibleDiv=null),ze._accessibleActive=!1;this._pool.forEach(ze=>{ze.parentNode&&ze.parentNode.removeChild(ze)}),this._div&&this._div.parentNode&&this._div.parentNode.removeChild(this._div),this._pool=[],this._children=[]}}_updateAccessibleObjects(ze){if(!ze.visible||!ze.accessibleChildren)return;ze.accessible&&(ze._accessibleActive||this._addChild(ze),ze._renderId=this._renderId);const Gr=ze.children;if(Gr)for(let Yr=0;Yr<Gr.length;Yr++)this._updateAccessibleObjects(Gr[Yr])}init(ze){const Yr={accessibilityOptions:{...Ps.defaultOptions,...(ze==null?void 0:ze.accessibilityOptions)||{}}};this.debug=Yr.accessibilityOptions.debug,this._activateOnTab=Yr.accessibilityOptions.activateOnTab,this._deactivateOnMouseMove=Yr.accessibilityOptions.deactivateOnMouseMove,Yr.accessibilityOptions.enabledByDefault?this._activate():this._activateOnTab&&(this._onKeyDown=this._onKeyDown.bind(this),globalThis.addEventListener("keydown",this._onKeyDown,!1)),this._renderer.runners.postrender.remove(this)}postrender(){const ze=performance.now();if(this._mobileInfo.android.device&&ze<this._androidUpdateCount||(this._androidUpdateCount=ze+this._androidUpdateFrequency,!this._renderer.renderingToScreen||!this._renderer.view.canvas))return;const Gr=new Set;if(this._renderer.lastObjectRendered){this._updateAccessibleObjects(this._renderer.lastObjectRendered);for(const Yr of this._children)Yr._renderId===this._renderId&&Gr.add(this._children.indexOf(Yr))}for(let Yr=this._children.length-1;Yr>=0;Yr--){const Kr=this._children[Yr];Gr.has(Yr)||(Kr._accessibleDiv&&Kr._accessibleDiv.parentNode&&(Kr._accessibleDiv.parentNode.removeChild(Kr._accessibleDiv),this._pool.push(Kr._accessibleDiv),Kr._accessibleDiv=null),Kr._accessibleActive=!1,removeItems(this._children,Yr,1))}if(this._renderer.renderingToScreen){const{x:Yr,y:Kr,width:Zr,height:Qr}=this._renderer.screen,Jr=this._div;Jr.style.left=`${Yr}px`,Jr.style.top=`${Kr}px`,Jr.style.width=`${Zr}px`,Jr.style.height=`${Qr}px`}for(let Yr=0;Yr<this._children.length;Yr++){const Kr=this._children[Yr];if(!Kr._accessibleActive||!Kr._accessibleDiv)continue;const Zr=Kr._accessibleDiv,Qr=Kr.hitArea||Kr.getBounds().rectangle;if(Kr.hitArea){const Jr=Kr.worldTransform,ei=this._renderer.resolution,ti=this._renderer.resolution;Zr.style.left=`${(Jr.tx+Qr.x*Jr.a)*ei}px`,Zr.style.top=`${(Jr.ty+Qr.y*Jr.d)*ti}px`,Zr.style.width=`${Qr.width*Jr.a*ei}px`,Zr.style.height=`${Qr.height*Jr.d*ti}px`}else{this._capHitArea(Qr);const Jr=this._renderer.resolution,ei=this._renderer.resolution;Zr.style.left=`${Qr.x*Jr}px`,Zr.style.top=`${Qr.y*ei}px`,Zr.style.width=`${Qr.width*Jr}px`,Zr.style.height=`${Qr.height*ei}px`}}this._renderId++}_updateDebugHTML(ze){ze.innerHTML=`type: ${ze.type}</br> title : ${ze.title}</br> tabIndex: ${ze.tabIndex}`}_capHitArea(ze){ze.x<0&&(ze.width+=ze.x,ze.x=0),ze.y<0&&(ze.height+=ze.y,ze.y=0);const{width:Gr,height:Yr}=this._renderer;ze.x+ze.width>Gr&&(ze.width=Gr-ze.x),ze.y+ze.height>Yr&&(ze.height=Yr-ze.y)}_addChild(ze){let Gr=this._pool.pop();Gr||(ze.accessibleType==="button"?Gr=document.createElement("button"):(Gr=document.createElement(ze.accessibleType),Gr.style.cssText=`
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `,ze.accessibleText&&(Gr.innerText=ze.accessibleText)),Gr.style.width=`${DIV_TOUCH_SIZE}px`,Gr.style.height=`${DIV_TOUCH_SIZE}px`,Gr.style.backgroundColor=this.debug?"rgba(255,255,255,0.5)":"transparent",Gr.style.position="absolute",Gr.style.zIndex=DIV_TOUCH_ZINDEX.toString(),Gr.style.borderStyle="none",navigator.userAgent.toLowerCase().includes("chrome")?Gr.setAttribute("aria-live","off"):Gr.setAttribute("aria-live","polite"),navigator.userAgent.match(/rv:.*Gecko\//)?Gr.setAttribute("aria-relevant","additions"):Gr.setAttribute("aria-relevant","text"),Gr.addEventListener("click",this._onClick.bind(this)),Gr.addEventListener("focus",this._onFocus.bind(this)),Gr.addEventListener("focusout",this._onFocusOut.bind(this))),Gr.style.pointerEvents=ze.accessiblePointerEvents,Gr.type=ze.accessibleType,ze.accessibleTitle&&ze.accessibleTitle!==null?Gr.title=ze.accessibleTitle:(!ze.accessibleHint||ze.accessibleHint===null)&&(Gr.title=`container ${ze.tabIndex}`),ze.accessibleHint&&ze.accessibleHint!==null&&Gr.setAttribute("aria-label",ze.accessibleHint),this.debug&&this._updateDebugHTML(Gr),ze._accessibleActive=!0,ze._accessibleDiv=Gr,Gr.container=ze,this._children.push(ze),this._div.appendChild(ze._accessibleDiv),ze.interactive&&(ze._accessibleDiv.tabIndex=ze.tabIndex)}_dispatchEvent(ze,Gr){const{container:Yr}=ze.target,Kr=this._renderer.events.rootBoundary,Zr=Object.assign(new FederatedEvent(Kr),{target:Yr});Kr.rootTarget=this._renderer.lastObjectRendered,Gr.forEach(Qr=>Kr.dispatchEvent(Zr,Qr))}_onClick(ze){this._dispatchEvent(ze,["click","pointertap","tap"])}_onFocus(ze){ze.target.getAttribute("aria-live")||ze.target.setAttribute("aria-live","assertive"),this._dispatchEvent(ze,["mouseover"])}_onFocusOut(ze){ze.target.getAttribute("aria-live")||ze.target.setAttribute("aria-live","polite"),this._dispatchEvent(ze,["mouseout"])}_onKeyDown(ze){ze.keyCode!==KEY_CODE_TAB||!this._activateOnTab||this._activate()}_onMouseMove(ze){ze.movementX===0&&ze.movementY===0||this._deactivate()}destroy(){this._deactivate(),this._destroyTouchHook(),this._div=null,this._pool=null,this._children=null,this._renderer=null,this._activateOnTab&&globalThis.removeEventListener("keydown",this._onKeyDown)}setAccessibilityEnabled(ze){ze?this._activate():this._deactivate()}};_AccessibilitySystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"accessibility"};_AccessibilitySystem.defaultOptions={enabledByDefault:!1,debug:!1,activateOnTab:!0,deactivateOnMouseMove:!0};let AccessibilitySystem=_AccessibilitySystem;const accessibilityTarget={accessible:!1,accessibleTitle:null,accessibleHint:null,tabIndex:0,_accessibleActive:!1,_accessibleDiv:null,accessibleType:"button",accessibleText:null,accessiblePointerEvents:"auto",accessibleChildren:!0,_renderId:-1},idCounts=Object.create(null),idHash=Object.create(null);function createIdFromString(Wr,ze){let Gr=idHash[Wr];return Gr===void 0&&(idCounts[ze]===void 0&&(idCounts[ze]=1),idHash[Wr]=Gr=idCounts[ze]++),Gr}let context;function getTestContext(){return(!context||context!=null&&context.isContextLost())&&(context=DOMAdapter.get().createCanvas().getContext("webgl",{})),context}let maxFragmentPrecision;function getMaxFragmentPrecision(){if(!maxFragmentPrecision){maxFragmentPrecision="mediump";const Wr=getTestContext();Wr&&Wr.getShaderPrecisionFormat&&(maxFragmentPrecision=Wr.getShaderPrecisionFormat(Wr.FRAGMENT_SHADER,Wr.HIGH_FLOAT).precision?"highp":"mediump")}return maxFragmentPrecision}function addProgramDefines(Wr,ze,Gr){return ze?Wr:Gr?(Wr=Wr.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${Wr}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${Wr}
        `}function ensurePrecision(Wr,ze,Gr){const Yr=Gr?ze.maxSupportedFragmentPrecision:ze.maxSupportedVertexPrecision;if(Wr.substring(0,9)!=="precision"){let Kr=Gr?ze.requestedFragmentPrecision:ze.requestedVertexPrecision;return Kr==="highp"&&Yr!=="highp"&&(Kr="mediump"),`precision ${Kr} float;
${Wr}`}else if(Yr!=="highp"&&Wr.substring(0,15)==="precision highp")return Wr.replace("precision highp","precision mediump");return Wr}function insertVersion(Wr,ze){return ze?`#version 300 es
${Wr}`:Wr}const fragmentNameCache={},VertexNameCache={};function setProgramName(Wr,{name:ze="pixi-program"},Gr=!0){ze=ze.replace(/\s+/g,"-"),ze+=Gr?"-fragment":"-vertex";const Yr=Gr?fragmentNameCache:VertexNameCache;return Yr[ze]?(Yr[ze]++,ze+=`-${Yr[ze]}`):Yr[ze]=1,Wr.indexOf("#define SHADER_NAME")!==-1?Wr:`${`#define SHADER_NAME ${ze}`}
${Wr}`}function stripVersion(Wr,ze){return ze?Wr.replace("#version 300 es",""):Wr}const processes={stripVersion,ensurePrecision,addProgramDefines,setProgramName,insertVersion},programCache$1=Object.create(null),_GlProgram=class hs{constructor(ze){ze={...hs.defaultOptions,...ze};const Gr=ze.fragment.indexOf("#version 300 es")!==-1,Yr={stripVersion:Gr,ensurePrecision:{requestedFragmentPrecision:ze.preferredFragmentPrecision,requestedVertexPrecision:ze.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:getMaxFragmentPrecision()},setProgramName:{name:ze.name},addProgramDefines:Gr,insertVersion:Gr};let Kr=ze.fragment,Zr=ze.vertex;Object.keys(processes).forEach(Qr=>{const Jr=Yr[Qr];Kr=processes[Qr](Kr,Jr,!0),Zr=processes[Qr](Zr,Jr,!1)}),this.fragment=Kr,this.vertex=Zr,this.transformFeedbackVaryings=ze.transformFeedbackVaryings,this._key=createIdFromString(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(ze){const Gr=`${ze.vertex}:${ze.fragment}`;return programCache$1[Gr]||(programCache$1[Gr]=new hs(ze)),programCache$1[Gr]}};_GlProgram.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let GlProgram=_GlProgram;const attributeFormatData={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function getAttributeInfoFromFormat(Wr){return attributeFormatData[Wr]??attributeFormatData.float32}const WGSL_TO_VERTEX_TYPES={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function extractAttributesFromGpuProgram({source:Wr,entryPoint:ze}){const Gr={},Yr=Wr.indexOf(`fn ${ze}`);if(Yr!==-1){const Kr=Wr.indexOf("->",Yr);if(Kr!==-1){const Zr=Wr.substring(Yr,Kr),Qr=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let Jr;for(;(Jr=Qr.exec(Zr))!==null;){const ei=WGSL_TO_VERTEX_TYPES[Jr[3]]??"float32";Gr[Jr[2]]={location:parseInt(Jr[1],10),format:ei,stride:getAttributeInfoFromFormat(ei).stride,offset:0,instance:!1,start:0}}}}return Gr}function extractStructAndGroups(Wr){var ii,si;const ze=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,Gr=/@group\((\d+)\)/,Yr=/@binding\((\d+)\)/,Kr=/var(<[^>]+>)? (\w+)/,Zr=/:\s*(\w+)/,Qr=/struct\s+(\w+)\s*{([^}]+)}/g,Jr=/(\w+)\s*:\s*([\w\<\>]+)/g,ei=/struct\s+(\w+)/,ti=(ii=Wr.match(ze))==null?void 0:ii.map(ni=>({group:parseInt(ni.match(Gr)[1],10),binding:parseInt(ni.match(Yr)[1],10),name:ni.match(Kr)[2],isUniform:ni.match(Kr)[1]==="<uniform>",type:ni.match(Zr)[1]}));if(!ti)return{groups:[],structs:[]};const ri=((si=Wr.match(Qr))==null?void 0:si.map(ni=>{const oi=ni.match(ei)[1],li=ni.match(Jr).reduce((ai,ui)=>{const[fi,pi]=ui.split(":");return ai[fi.trim()]=pi.trim(),ai},{});return li?{name:oi,members:li}:null}).filter(({name:ni})=>ti.some(oi=>oi.type===ni)))??[];return{groups:ti,structs:ri}}var ShaderStage=(Wr=>(Wr[Wr.VERTEX=1]="VERTEX",Wr[Wr.FRAGMENT=2]="FRAGMENT",Wr[Wr.COMPUTE=4]="COMPUTE",Wr))(ShaderStage||{});function generateGpuLayoutGroups({groups:Wr}){const ze=[];for(let Gr=0;Gr<Wr.length;Gr++){const Yr=Wr[Gr];ze[Yr.group]||(ze[Yr.group]=[]),Yr.isUniform?ze[Yr.group].push({binding:Yr.binding,visibility:ShaderStage.VERTEX|ShaderStage.FRAGMENT,buffer:{type:"uniform"}}):Yr.type==="sampler"?ze[Yr.group].push({binding:Yr.binding,visibility:ShaderStage.FRAGMENT,sampler:{type:"filtering"}}):Yr.type==="texture_2d"&&ze[Yr.group].push({binding:Yr.binding,visibility:ShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return ze}function generateLayoutHash({groups:Wr}){const ze=[];for(let Gr=0;Gr<Wr.length;Gr++){const Yr=Wr[Gr];ze[Yr.group]||(ze[Yr.group]={}),ze[Yr.group][Yr.name]=Yr.binding}return ze}function removeStructAndGroupDuplicates(Wr,ze){const Gr=new Set,Yr=new Set,Kr=[...Wr.structs,...ze.structs].filter(Qr=>Gr.has(Qr.name)?!1:(Gr.add(Qr.name),!0)),Zr=[...Wr.groups,...ze.groups].filter(Qr=>{const Jr=`${Qr.name}-${Qr.binding}`;return Yr.has(Jr)?!1:(Yr.add(Jr),!0)});return{structs:Kr,groups:Zr}}const programCache=Object.create(null);class GpuProgram{constructor(ze){var Jr,ei;this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:Gr,vertex:Yr,layout:Kr,gpuLayout:Zr,name:Qr}=ze;if(this.name=Qr,this.fragment=Gr,this.vertex=Yr,Gr.source===Yr.source){const ti=extractStructAndGroups(Gr.source);this.structsAndGroups=ti}else{const ti=extractStructAndGroups(Yr.source),ri=extractStructAndGroups(Gr.source);this.structsAndGroups=removeStructAndGroupDuplicates(ti,ri)}this.layout=Kr??generateLayoutHash(this.structsAndGroups),this.gpuLayout=Zr??generateGpuLayoutGroups(this.structsAndGroups),this.autoAssignGlobalUniforms=((Jr=this.layout[0])==null?void 0:Jr.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((ei=this.layout[1])==null?void 0:ei.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:ze,fragment:Gr}=this,Yr=ze.source+Gr.source+ze.entryPoint+Gr.entryPoint;this._layoutKey=createIdFromString(Yr,"program")}get attributeData(){return this._attributeData??(this._attributeData=extractAttributesFromGpuProgram(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(ze){const Gr=`${ze.vertex.source}:${ze.fragment.source}:${ze.fragment.entryPoint}:${ze.vertex.entryPoint}`;return programCache[Gr]||(programCache[Gr]=new GpuProgram(ze)),programCache[Gr]}}const UNIFORM_TYPES_VALUES=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>","vec2<i32>","vec3<i32>","vec4<i32>"],UNIFORM_TYPES_MAP=UNIFORM_TYPES_VALUES.reduce((Wr,ze)=>(Wr[ze]=!0,Wr),{});function getDefaultUniformValue(Wr,ze){switch(Wr){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*ze);case"vec3<f32>":return new Float32Array(3*ze);case"vec4<f32>":return new Float32Array(4*ze);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const _UniformGroup=class Es{constructor(ze,Gr){this._touched=0,this.uid=uid$1("uniform"),this._resourceType="uniformGroup",this._resourceId=uid$1("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,Gr={...Es.defaultOptions,...Gr},this.uniformStructures=ze;const Yr={};for(const Kr in ze){const Zr=ze[Kr];if(Zr.name=Kr,Zr.size=Zr.size??1,!UNIFORM_TYPES_MAP[Zr.type])throw new Error(`Uniform type ${Zr.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);Zr.value??(Zr.value=getDefaultUniformValue(Zr.type,Zr.size)),Yr[Kr]=Zr.value}this.uniforms=Yr,this._dirtyId=1,this.ubo=Gr.ubo,this.isStatic=Gr.isStatic,this._signature=createIdFromString(Object.keys(Yr).map(Kr=>`${Kr}-${ze[Kr].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};_UniformGroup.defaultOptions={ubo:!1,isStatic:!1};let UniformGroup=_UniformGroup;class BindGroup{constructor(ze){this.resources=Object.create(null),this._dirty=!0;let Gr=0;for(const Yr in ze){const Kr=ze[Yr];this.setResource(Kr,Gr++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const ze=[];let Gr=0;for(const Yr in this.resources)ze[Gr++]=this.resources[Yr]._resourceId;this._key=ze.join("|")}setResource(ze,Gr){var Kr,Zr;const Yr=this.resources[Gr];ze!==Yr&&(Yr&&((Kr=ze.off)==null||Kr.call(ze,"change",this.onResourceChange,this)),(Zr=ze.on)==null||Zr.call(ze,"change",this.onResourceChange,this),this.resources[Gr]=ze,this._dirty=!0)}getResource(ze){return this.resources[ze]}_touch(ze){const Gr=this.resources;for(const Yr in Gr)Gr[Yr]._touched=ze}destroy(){var Gr;const ze=this.resources;for(const Yr in ze){const Kr=ze[Yr];(Gr=Kr.off)==null||Gr.call(Kr,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(ze){if(this._dirty=!0,ze.destroyed){const Gr=this.resources;for(const Yr in Gr)Gr[Yr]===ze&&(Gr[Yr]=null)}else this._updateKey()}}var RendererType=(Wr=>(Wr[Wr.WEBGL=1]="WEBGL",Wr[Wr.WEBGPU=2]="WEBGPU",Wr[Wr.BOTH=3]="BOTH",Wr))(RendererType||{});class Shader extends EventEmitter{constructor(ze){super(),this.uid=uid$1("shader"),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:Gr,glProgram:Yr,groups:Kr,resources:Zr,compatibleRenderers:Qr,groupMap:Jr}=ze;this.gpuProgram=Gr,this.glProgram=Yr,Qr===void 0&&(Qr=0,Gr&&(Qr|=RendererType.WEBGPU),Yr&&(Qr|=RendererType.WEBGL)),this.compatibleRenderers=Qr;const ei={};if(!Zr&&!Kr&&(Zr={}),Zr&&Kr)throw new Error("[Shader] Cannot have both resources and groups");if(!Gr&&Kr&&!Jr)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!Gr&&Kr&&Jr)for(const ti in Jr)for(const ri in Jr[ti]){const ii=Jr[ti][ri];ei[ii]={group:ti,binding:ri,name:ii}}else if(Gr&&Kr&&!Jr){const ti=Gr.structsAndGroups.groups;Jr={},ti.forEach(ri=>{Jr[ri.group]=Jr[ri.group]||{},Jr[ri.group][ri.binding]=ri.name,ei[ri.name]=ri})}else if(Zr){Kr={},Jr={},Gr&&Gr.structsAndGroups.groups.forEach(ii=>{Jr[ii.group]=Jr[ii.group]||{},Jr[ii.group][ii.binding]=ii.name,ei[ii.name]=ii});let ti=0;for(const ri in Zr)ei[ri]||(Kr[99]||(Kr[99]=new BindGroup,this._ownedBindGroups.push(Kr[99])),ei[ri]={group:99,binding:ti,name:ri},Jr[99]=Jr[99]||{},Jr[99][ti]=ri,ti++);for(const ri in Zr){const ii=ri;let si=Zr[ri];!si.source&&!si._resourceType&&(si=new UniformGroup(si));const ni=ei[ii];ni&&(Kr[ni.group]||(Kr[ni.group]=new BindGroup,this._ownedBindGroups.push(Kr[ni.group])),Kr[ni.group].setResource(si,ni.binding))}}this.groups=Kr,this._uniformBindMap=Jr,this.resources=this._buildResourceAccessor(Kr,ei)}addResource(ze,Gr,Yr){var Kr,Zr;(Kr=this._uniformBindMap)[Gr]||(Kr[Gr]={}),(Zr=this._uniformBindMap[Gr])[Yr]||(Zr[Yr]=ze),this.groups[Gr]||(this.groups[Gr]=new BindGroup,this._ownedBindGroups.push(this.groups[Gr]))}_buildResourceAccessor(ze,Gr){const Yr={};for(const Kr in Gr){const Zr=Gr[Kr];Object.defineProperty(Yr,Zr.name,{get(){return ze[Zr.group].getResource(Zr.binding)},set(Qr){ze[Zr.group].setResource(Qr,Zr.binding)}})}return Yr}destroy(ze=!1){var Gr,Yr;this.emit("destroy",this),ze&&((Gr=this.gpuProgram)==null||Gr.destroy(),(Yr=this.glProgram)==null||Yr.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(Kr=>{Kr.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(ze){const{gpu:Gr,gl:Yr,...Kr}=ze;let Zr,Qr;return Gr&&(Zr=GpuProgram.from(Gr)),Yr&&(Qr=GlProgram.from(Yr)),new Shader({gpuProgram:Zr,glProgram:Qr,...Kr})}}const blendModeIds={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},BLEND$1=0,OFFSET$1=1,CULLING$1=2,DEPTH_TEST$1=3,WINDING$1=4,DEPTH_MASK$1=5,_State=class ws{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<BLEND$1)}set blend(ze){!!(this.data&1<<BLEND$1)!==ze&&(this.data^=1<<BLEND$1)}get offsets(){return!!(this.data&1<<OFFSET$1)}set offsets(ze){!!(this.data&1<<OFFSET$1)!==ze&&(this.data^=1<<OFFSET$1)}set cullMode(ze){if(ze==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=ze==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<CULLING$1)}set culling(ze){!!(this.data&1<<CULLING$1)!==ze&&(this.data^=1<<CULLING$1)}get depthTest(){return!!(this.data&1<<DEPTH_TEST$1)}set depthTest(ze){!!(this.data&1<<DEPTH_TEST$1)!==ze&&(this.data^=1<<DEPTH_TEST$1)}get depthMask(){return!!(this.data&1<<DEPTH_MASK$1)}set depthMask(ze){!!(this.data&1<<DEPTH_MASK$1)!==ze&&(this.data^=1<<DEPTH_MASK$1)}get clockwiseFrontFace(){return!!(this.data&1<<WINDING$1)}set clockwiseFrontFace(ze){!!(this.data&1<<WINDING$1)!==ze&&(this.data^=1<<WINDING$1)}get blendMode(){return this._blendMode}set blendMode(ze){this.blend=ze!=="none",this._blendMode=ze,this._blendModeId=blendModeIds[ze]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(ze){this.offsets=!!ze,this._polygonOffset=ze}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const ze=new ws;return ze.depthTest=!1,ze.blend=!0,ze}};_State.default2d=_State.for2d();let State=_State;const _Filter=class us extends Shader{constructor(ze){ze={...us.defaultOptions,...ze},super(ze),this.enabled=!0,this._state=State.for2d(),this.blendMode=ze.blendMode,this.padding=ze.padding,typeof ze.antialias=="boolean"?this.antialias=ze.antialias?"on":"off":this.antialias=ze.antialias,this.resolution=ze.resolution,this.blendRequired=ze.blendRequired,this.clipToViewport=ze.clipToViewport,this.addResource("uTexture",0,1)}apply(ze,Gr,Yr,Kr){ze.applyFilter(this,Gr,Yr,Kr)}get blendMode(){return this._state.blendMode}set blendMode(ze){this._state.blendMode=ze}static from(ze){const{gpu:Gr,gl:Yr,...Kr}=ze;let Zr,Qr;return Gr&&(Zr=GpuProgram.from(Gr)),Yr&&(Qr=GlProgram.from(Yr)),new us({gpuProgram:Zr,glProgram:Qr,...Kr})}};_Filter.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let Filter=_Filter;const environments=[];extensions.handleByNamedList(ExtensionType.Environment,environments);async function loadEnvironmentExtensions(Wr){if(!Wr)for(let ze=0;ze<environments.length;ze++){const Gr=environments[ze];if(Gr.value.test()){await Gr.value.load();return}}}let unsafeEval;function unsafeEvalSupported(){if(typeof unsafeEval=="boolean")return unsafeEval;try{unsafeEval=new Function("param1","param2","param3","return param1[param2] === param3;")({a:"b"},"a","b")===!0}catch{unsafeEval=!1}return unsafeEval}var earcut$1={exports:{}},hasRequiredEarcut;function requireEarcut(){if(hasRequiredEarcut)return earcut$1.exports;hasRequiredEarcut=1,earcut$1.exports=Wr,earcut$1.exports.default=Wr;function Wr(ci,hi,di){di=di||2;var gi=hi&&hi.length,xi=gi?hi[0]*di:ci.length,bi=ze(ci,0,xi,di,!0),vi=[];if(!bi||bi.next===bi.prev)return vi;var Ei,Ri,wi,Di,Ni,Fi,Hi;if(gi&&(bi=ei(ci,hi,bi,di)),ci.length>80*di){Ei=wi=ci[0],Ri=Di=ci[1];for(var Oi=di;Oi<xi;Oi+=di)Ni=ci[Oi],Fi=ci[Oi+1],Ni<Ei&&(Ei=Ni),Fi<Ri&&(Ri=Fi),Ni>wi&&(wi=Ni),Fi>Di&&(Di=Fi);Hi=Math.max(wi-Ei,Di-Ri),Hi=Hi!==0?32767/Hi:0}return Yr(bi,vi,di,Ei,Ri,Hi,0),vi}function ze(ci,hi,di,gi,xi){var bi,vi;if(xi===Li(ci,hi,di,gi)>0)for(bi=hi;bi<di;bi+=gi)vi=Mi(bi,ci[bi],ci[bi+1],vi);else for(bi=di-gi;bi>=hi;bi-=gi)vi=Mi(bi,ci[bi],ci[bi+1],vi);return vi&&mi(vi,vi.next)&&(ki(vi),vi=vi.next),vi}function Gr(ci,hi){if(!ci)return ci;hi||(hi=ci);var di=ci,gi;do if(gi=!1,!di.steiner&&(mi(di,di.next)||pi(di.prev,di,di.next)===0)){if(ki(di),di=hi=di.prev,di===di.next)break;gi=!0}else di=di.next;while(gi||di!==hi);return hi}function Yr(ci,hi,di,gi,xi,bi,vi){if(ci){!vi&&bi&&ni(ci,gi,xi,bi);for(var Ei=ci,Ri,wi;ci.prev!==ci.next;){if(Ri=ci.prev,wi=ci.next,bi?Zr(ci,gi,xi,bi):Kr(ci)){hi.push(Ri.i/di|0),hi.push(ci.i/di|0),hi.push(wi.i/di|0),ki(ci),ci=wi.next,Ei=wi.next;continue}if(ci=wi,ci===Ei){vi?vi===1?(ci=Qr(Gr(ci),hi,di),Yr(ci,hi,di,gi,xi,bi,2)):vi===2&&Jr(ci,hi,di,gi,xi,bi):Yr(Gr(ci),hi,di,gi,xi,bi,1);break}}}}function Kr(ci){var hi=ci.prev,di=ci,gi=ci.next;if(pi(hi,di,gi)>=0)return!1;for(var xi=hi.x,bi=di.x,vi=gi.x,Ei=hi.y,Ri=di.y,wi=gi.y,Di=xi<bi?xi<vi?xi:vi:bi<vi?bi:vi,Ni=Ei<Ri?Ei<wi?Ei:wi:Ri<wi?Ri:wi,Fi=xi>bi?xi>vi?xi:vi:bi>vi?bi:vi,Hi=Ei>Ri?Ei>wi?Ei:wi:Ri>wi?Ri:wi,Oi=gi.next;Oi!==hi;){if(Oi.x>=Di&&Oi.x<=Fi&&Oi.y>=Ni&&Oi.y<=Hi&&ui(xi,Ei,bi,Ri,vi,wi,Oi.x,Oi.y)&&pi(Oi.prev,Oi,Oi.next)>=0)return!1;Oi=Oi.next}return!0}function Zr(ci,hi,di,gi){var xi=ci.prev,bi=ci,vi=ci.next;if(pi(xi,bi,vi)>=0)return!1;for(var Ei=xi.x,Ri=bi.x,wi=vi.x,Di=xi.y,Ni=bi.y,Fi=vi.y,Hi=Ei<Ri?Ei<wi?Ei:wi:Ri<wi?Ri:wi,Oi=Di<Ni?Di<Fi?Di:Fi:Ni<Fi?Ni:Fi,ji=Ei>Ri?Ei>wi?Ei:wi:Ri>wi?Ri:wi,zi=Di>Ni?Di>Fi?Di:Fi:Ni>Fi?Ni:Fi,Vi=li(Hi,Oi,hi,di,gi),$i=li(ji,zi,hi,di,gi),Ii=ci.prevZ,Ui=ci.nextZ;Ii&&Ii.z>=Vi&&Ui&&Ui.z<=$i;){if(Ii.x>=Hi&&Ii.x<=ji&&Ii.y>=Oi&&Ii.y<=zi&&Ii!==xi&&Ii!==vi&&ui(Ei,Di,Ri,Ni,wi,Fi,Ii.x,Ii.y)&&pi(Ii.prev,Ii,Ii.next)>=0||(Ii=Ii.prevZ,Ui.x>=Hi&&Ui.x<=ji&&Ui.y>=Oi&&Ui.y<=zi&&Ui!==xi&&Ui!==vi&&ui(Ei,Di,Ri,Ni,wi,Fi,Ui.x,Ui.y)&&pi(Ui.prev,Ui,Ui.next)>=0))return!1;Ui=Ui.nextZ}for(;Ii&&Ii.z>=Vi;){if(Ii.x>=Hi&&Ii.x<=ji&&Ii.y>=Oi&&Ii.y<=zi&&Ii!==xi&&Ii!==vi&&ui(Ei,Di,Ri,Ni,wi,Fi,Ii.x,Ii.y)&&pi(Ii.prev,Ii,Ii.next)>=0)return!1;Ii=Ii.prevZ}for(;Ui&&Ui.z<=$i;){if(Ui.x>=Hi&&Ui.x<=ji&&Ui.y>=Oi&&Ui.y<=zi&&Ui!==xi&&Ui!==vi&&ui(Ei,Di,Ri,Ni,wi,Fi,Ui.x,Ui.y)&&pi(Ui.prev,Ui,Ui.next)>=0)return!1;Ui=Ui.nextZ}return!0}function Qr(ci,hi,di){var gi=ci;do{var xi=gi.prev,bi=gi.next.next;!mi(xi,bi)&&Ti(xi,gi,gi.next,bi)&&Bi(xi,bi)&&Bi(bi,xi)&&(hi.push(xi.i/di|0),hi.push(gi.i/di|0),hi.push(bi.i/di|0),ki(gi),ki(gi.next),gi=ci=bi),gi=gi.next}while(gi!==ci);return Gr(gi)}function Jr(ci,hi,di,gi,xi,bi){var vi=ci;do{for(var Ei=vi.next.next;Ei!==vi.prev;){if(vi.i!==Ei.i&&fi(vi,Ei)){var Ri=Si(vi,Ei);vi=Gr(vi,vi.next),Ri=Gr(Ri,Ri.next),Yr(vi,hi,di,gi,xi,bi,0),Yr(Ri,hi,di,gi,xi,bi,0);return}Ei=Ei.next}vi=vi.next}while(vi!==ci)}function ei(ci,hi,di,gi){var xi=[],bi,vi,Ei,Ri,wi;for(bi=0,vi=hi.length;bi<vi;bi++)Ei=hi[bi]*gi,Ri=bi<vi-1?hi[bi+1]*gi:ci.length,wi=ze(ci,Ei,Ri,gi,!1),wi===wi.next&&(wi.steiner=!0),xi.push(ai(wi));for(xi.sort(ti),bi=0;bi<xi.length;bi++)di=ri(xi[bi],di);return di}function ti(ci,hi){return ci.x-hi.x}function ri(ci,hi){var di=ii(ci,hi);if(!di)return hi;var gi=Si(di,ci);return Gr(gi,gi.next),Gr(di,di.next)}function ii(ci,hi){var di=hi,gi=ci.x,xi=ci.y,bi=-1/0,vi;do{if(xi<=di.y&&xi>=di.next.y&&di.next.y!==di.y){var Ei=di.x+(xi-di.y)*(di.next.x-di.x)/(di.next.y-di.y);if(Ei<=gi&&Ei>bi&&(bi=Ei,vi=di.x<di.next.x?di:di.next,Ei===gi))return vi}di=di.next}while(di!==hi);if(!vi)return null;var Ri=vi,wi=vi.x,Di=vi.y,Ni=1/0,Fi;di=vi;do gi>=di.x&&di.x>=wi&&gi!==di.x&&ui(xi<Di?gi:bi,xi,wi,Di,xi<Di?bi:gi,xi,di.x,di.y)&&(Fi=Math.abs(xi-di.y)/(gi-di.x),Bi(di,ci)&&(Fi<Ni||Fi===Ni&&(di.x>vi.x||di.x===vi.x&&si(vi,di)))&&(vi=di,Ni=Fi)),di=di.next;while(di!==Ri);return vi}function si(ci,hi){return pi(ci.prev,ci,hi.prev)<0&&pi(hi.next,ci,ci.next)<0}function ni(ci,hi,di,gi){var xi=ci;do xi.z===0&&(xi.z=li(xi.x,xi.y,hi,di,gi)),xi.prevZ=xi.prev,xi.nextZ=xi.next,xi=xi.next;while(xi!==ci);xi.prevZ.nextZ=null,xi.prevZ=null,oi(xi)}function oi(ci){var hi,di,gi,xi,bi,vi,Ei,Ri,wi=1;do{for(di=ci,ci=null,bi=null,vi=0;di;){for(vi++,gi=di,Ei=0,hi=0;hi<wi&&(Ei++,gi=gi.nextZ,!!gi);hi++);for(Ri=wi;Ei>0||Ri>0&&gi;)Ei!==0&&(Ri===0||!gi||di.z<=gi.z)?(xi=di,di=di.nextZ,Ei--):(xi=gi,gi=gi.nextZ,Ri--),bi?bi.nextZ=xi:ci=xi,xi.prevZ=bi,bi=xi;di=gi}bi.nextZ=null,wi*=2}while(vi>1);return ci}function li(ci,hi,di,gi,xi){return ci=(ci-di)*xi|0,hi=(hi-gi)*xi|0,ci=(ci|ci<<8)&16711935,ci=(ci|ci<<4)&252645135,ci=(ci|ci<<2)&858993459,ci=(ci|ci<<1)&1431655765,hi=(hi|hi<<8)&16711935,hi=(hi|hi<<4)&252645135,hi=(hi|hi<<2)&858993459,hi=(hi|hi<<1)&1431655765,ci|hi<<1}function ai(ci){var hi=ci,di=ci;do(hi.x<di.x||hi.x===di.x&&hi.y<di.y)&&(di=hi),hi=hi.next;while(hi!==ci);return di}function ui(ci,hi,di,gi,xi,bi,vi,Ei){return(xi-vi)*(hi-Ei)>=(ci-vi)*(bi-Ei)&&(ci-vi)*(gi-Ei)>=(di-vi)*(hi-Ei)&&(di-vi)*(bi-Ei)>=(xi-vi)*(gi-Ei)}function fi(ci,hi){return ci.next.i!==hi.i&&ci.prev.i!==hi.i&&!Ci(ci,hi)&&(Bi(ci,hi)&&Bi(hi,ci)&&Pi(ci,hi)&&(pi(ci.prev,ci,hi.prev)||pi(ci,hi.prev,hi))||mi(ci,hi)&&pi(ci.prev,ci,ci.next)>0&&pi(hi.prev,hi,hi.next)>0)}function pi(ci,hi,di){return(hi.y-ci.y)*(di.x-hi.x)-(hi.x-ci.x)*(di.y-hi.y)}function mi(ci,hi){return ci.x===hi.x&&ci.y===hi.y}function Ti(ci,hi,di,gi){var xi=_i(pi(ci,hi,di)),bi=_i(pi(ci,hi,gi)),vi=_i(pi(di,gi,ci)),Ei=_i(pi(di,gi,hi));return!!(xi!==bi&&vi!==Ei||xi===0&&yi(ci,di,hi)||bi===0&&yi(ci,gi,hi)||vi===0&&yi(di,ci,gi)||Ei===0&&yi(di,hi,gi))}function yi(ci,hi,di){return hi.x<=Math.max(ci.x,di.x)&&hi.x>=Math.min(ci.x,di.x)&&hi.y<=Math.max(ci.y,di.y)&&hi.y>=Math.min(ci.y,di.y)}function _i(ci){return ci>0?1:ci<0?-1:0}function Ci(ci,hi){var di=ci;do{if(di.i!==ci.i&&di.next.i!==ci.i&&di.i!==hi.i&&di.next.i!==hi.i&&Ti(di,di.next,ci,hi))return!0;di=di.next}while(di!==ci);return!1}function Bi(ci,hi){return pi(ci.prev,ci,ci.next)<0?pi(ci,hi,ci.next)>=0&&pi(ci,ci.prev,hi)>=0:pi(ci,hi,ci.prev)<0||pi(ci,ci.next,hi)<0}function Pi(ci,hi){var di=ci,gi=!1,xi=(ci.x+hi.x)/2,bi=(ci.y+hi.y)/2;do di.y>bi!=di.next.y>bi&&di.next.y!==di.y&&xi<(di.next.x-di.x)*(bi-di.y)/(di.next.y-di.y)+di.x&&(gi=!gi),di=di.next;while(di!==ci);return gi}function Si(ci,hi){var di=new Wi(ci.i,ci.x,ci.y),gi=new Wi(hi.i,hi.x,hi.y),xi=ci.next,bi=hi.prev;return ci.next=hi,hi.prev=ci,di.next=xi,xi.prev=di,gi.next=di,di.prev=gi,bi.next=gi,gi.prev=bi,gi}function Mi(ci,hi,di,gi){var xi=new Wi(ci,hi,di);return gi?(xi.next=gi.next,xi.prev=gi,gi.next.prev=xi,gi.next=xi):(xi.prev=xi,xi.next=xi),xi}function ki(ci){ci.next.prev=ci.prev,ci.prev.next=ci.next,ci.prevZ&&(ci.prevZ.nextZ=ci.nextZ),ci.nextZ&&(ci.nextZ.prevZ=ci.prevZ)}function Wi(ci,hi,di){this.i=ci,this.x=hi,this.y=di,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}Wr.deviation=function(ci,hi,di,gi){var xi=hi&&hi.length,bi=xi?hi[0]*di:ci.length,vi=Math.abs(Li(ci,0,bi,di));if(xi)for(var Ei=0,Ri=hi.length;Ei<Ri;Ei++){var wi=hi[Ei]*di,Di=Ei<Ri-1?hi[Ei+1]*di:ci.length;vi-=Math.abs(Li(ci,wi,Di,di))}var Ni=0;for(Ei=0;Ei<gi.length;Ei+=3){var Fi=gi[Ei]*di,Hi=gi[Ei+1]*di,Oi=gi[Ei+2]*di;Ni+=Math.abs((ci[Fi]-ci[Oi])*(ci[Hi+1]-ci[Fi+1])-(ci[Fi]-ci[Hi])*(ci[Oi+1]-ci[Fi+1]))}return vi===0&&Ni===0?0:Math.abs((Ni-vi)/vi)};function Li(ci,hi,di,gi){for(var xi=0,bi=hi,vi=di-gi;bi<di;bi+=gi)xi+=(ci[vi]-ci[bi])*(ci[bi+1]+ci[vi+1]),vi=bi;return xi}return Wr.flatten=function(ci){for(var hi=ci[0][0].length,di={vertices:[],holes:[],dimensions:hi},gi=0,xi=0;xi<ci.length;xi++){for(var bi=0;bi<ci[xi].length;bi++)for(var vi=0;vi<hi;vi++)di.vertices.push(ci[xi][bi][vi]);xi>0&&(gi+=ci[xi-1].length,di.holes.push(gi))}return di},earcut$1.exports}var earcutExports=requireEarcut();const earcut=getDefaultExportFromCjs(earcutExports);var CLEAR=(Wr=>(Wr[Wr.NONE=0]="NONE",Wr[Wr.COLOR=16384]="COLOR",Wr[Wr.STENCIL=1024]="STENCIL",Wr[Wr.DEPTH=256]="DEPTH",Wr[Wr.COLOR_DEPTH=16640]="COLOR_DEPTH",Wr[Wr.COLOR_STENCIL=17408]="COLOR_STENCIL",Wr[Wr.DEPTH_STENCIL=1280]="DEPTH_STENCIL",Wr[Wr.ALL=17664]="ALL",Wr))(CLEAR||{});class SystemRunner{constructor(ze){this.items=[],this._name=ze}emit(ze,Gr,Yr,Kr,Zr,Qr,Jr,ei){const{name:ti,items:ri}=this;for(let ii=0,si=ri.length;ii<si;ii++)ri[ii][ti](ze,Gr,Yr,Kr,Zr,Qr,Jr,ei);return this}add(ze){return ze[this._name]&&(this.remove(ze),this.items.push(ze)),this}remove(ze){const Gr=this.items.indexOf(ze);return Gr!==-1&&this.items.splice(Gr,1),this}contains(ze){return this.items.indexOf(ze)!==-1}removeAll(){return this.items.length=0,this}destroy(){this.removeAll(),this.items=null,this._name=null}get empty(){return this.items.length===0}get name(){return this._name}}const defaultRunners=["init","destroy","contextChange","resolutionChange","resetState","renderEnd","renderStart","render","update","postrender","prerender"],_AbstractRenderer=class Cs extends EventEmitter{constructor(ze){super(),this.runners=Object.create(null),this.renderPipes=Object.create(null),this._initOptions={},this._systemsHash=Object.create(null),this.type=ze.type,this.name=ze.name,this.config=ze;const Gr=[...defaultRunners,...this.config.runners??[]];this._addRunners(...Gr),this._unsafeEvalCheck()}async init(ze={}){const Gr=ze.skipExtensionImports===!0?!0:ze.manageImports===!1;await loadEnvironmentExtensions(Gr),this._addSystems(this.config.systems),this._addPipes(this.config.renderPipes,this.config.renderPipeAdaptors);for(const Yr in this._systemsHash)ze={...this._systemsHash[Yr].constructor.defaultOptions,...ze};ze={...Cs.defaultOptions,...ze},this._roundPixels=ze.roundPixels?1:0;for(let Yr=0;Yr<this.runners.init.items.length;Yr++)await this.runners.init.items[Yr].init(ze);this._initOptions=ze}render(ze,Gr){let Yr=ze;if(Yr instanceof Container&&(Yr={container:Yr},Gr&&(deprecation(v8_0_0,"passing a second argument is deprecated, please use render options instead"),Yr.target=Gr.renderTexture)),Yr.target||(Yr.target=this.view.renderTarget),Yr.target===this.view.renderTarget&&(this._lastObjectRendered=Yr.container,Yr.clearColor??(Yr.clearColor=this.background.colorRgba),Yr.clear??(Yr.clear=this.background.clearBeforeRender)),Yr.clearColor){const Kr=Array.isArray(Yr.clearColor)&&Yr.clearColor.length===4;Yr.clearColor=Kr?Yr.clearColor:Color.shared.setValue(Yr.clearColor).toArray()}Yr.transform||(Yr.container.updateLocalTransform(),Yr.transform=Yr.container.localTransform),Yr.container.enableRenderGroup(),this.runners.prerender.emit(Yr),this.runners.renderStart.emit(Yr),this.runners.render.emit(Yr),this.runners.renderEnd.emit(Yr),this.runners.postrender.emit(Yr)}resize(ze,Gr,Yr){const Kr=this.view.resolution;this.view.resize(ze,Gr,Yr),this.emit("resize",this.view.screen.width,this.view.screen.height,this.view.resolution),Yr!==void 0&&Yr!==Kr&&this.runners.resolutionChange.emit(Yr)}clear(ze={}){const Gr=this;ze.target||(ze.target=Gr.renderTarget.renderTarget),ze.clearColor||(ze.clearColor=this.background.colorRgba),ze.clear??(ze.clear=CLEAR.ALL);const{clear:Yr,clearColor:Kr,target:Zr}=ze;Color.shared.setValue(Kr??this.background.colorRgba),Gr.renderTarget.clear(Zr,Yr,Color.shared.toArray())}get resolution(){return this.view.resolution}set resolution(ze){this.view.resolution=ze,this.runners.resolutionChange.emit(ze)}get width(){return this.view.texture.frame.width}get height(){return this.view.texture.frame.height}get canvas(){return this.view.canvas}get lastObjectRendered(){return this._lastObjectRendered}get renderingToScreen(){return this.renderTarget.renderingToScreen}get screen(){return this.view.screen}_addRunners(...ze){ze.forEach(Gr=>{this.runners[Gr]=new SystemRunner(Gr)})}_addSystems(ze){let Gr;for(Gr in ze){const Yr=ze[Gr];this._addSystem(Yr.value,Yr.name)}}_addSystem(ze,Gr){const Yr=new ze(this);if(this[Gr])throw new Error(`Whoops! The name "${Gr}" is already in use`);this[Gr]=Yr,this._systemsHash[Gr]=Yr;for(const Kr in this.runners)this.runners[Kr].add(Yr);return this}_addPipes(ze,Gr){const Yr=Gr.reduce((Kr,Zr)=>(Kr[Zr.name]=Zr.value,Kr),{});ze.forEach(Kr=>{const Zr=Kr.value,Qr=Kr.name,Jr=Yr[Qr];this.renderPipes[Qr]=new Zr(this,Jr?new Jr:null)})}destroy(ze=!1){this.runners.destroy.items.reverse(),this.runners.destroy.emit(ze),Object.values(this.runners).forEach(Gr=>{Gr.destroy()}),this._systemsHash=null,this.renderPipes=null}generateTexture(ze){return this.textureGenerator.generateTexture(ze)}get roundPixels(){return!!this._roundPixels}_unsafeEvalCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}resetState(){this.runners.resetState.emit()}};_AbstractRenderer.defaultOptions={resolution:1,failIfMajorPerformanceCaveat:!1,roundPixels:!1};let AbstractRenderer=_AbstractRenderer,_isWebGLSupported;function isWebGLSupported(Wr){return _isWebGLSupported!==void 0||(_isWebGLSupported=(()=>{var Gr;const ze={stencil:!0,failIfMajorPerformanceCaveat:Wr??AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat};try{if(!DOMAdapter.get().getWebGLRenderingContext())return!1;let Kr=DOMAdapter.get().createCanvas().getContext("webgl",ze);const Zr=!!((Gr=Kr==null?void 0:Kr.getContextAttributes())!=null&&Gr.stencil);if(Kr){const Qr=Kr.getExtension("WEBGL_lose_context");Qr&&Qr.loseContext()}return Kr=null,Zr}catch{return!1}})()),_isWebGLSupported}let _isWebGPUSupported;async function isWebGPUSupported(Wr={}){return _isWebGPUSupported!==void 0||(_isWebGPUSupported=await(async()=>{const ze=DOMAdapter.get().getNavigator().gpu;if(!ze)return!1;try{return await(await ze.requestAdapter(Wr)).requestDevice(),!0}catch{return!1}})()),_isWebGPUSupported}const renderPriority=["webgl","webgpu","canvas"];async function autoDetectRenderer(Wr){let ze=[];Wr.preference?(ze.push(Wr.preference),renderPriority.forEach(Zr=>{Zr!==Wr.preference&&ze.push(Zr)})):ze=renderPriority.slice();let Gr,Yr={};for(let Zr=0;Zr<ze.length;Zr++){const Qr=ze[Zr];if(Qr==="webgpu"&&await isWebGPUSupported()){const{WebGPURenderer:Jr}=await __vitePreload(async()=>{const{WebGPURenderer:ei}=await Promise.resolve().then(()=>WebGPURenderer$1);return{WebGPURenderer:ei}},void 0);Gr=Jr,Yr={...Wr,...Wr.webgpu};break}else if(Qr==="webgl"&&isWebGLSupported(Wr.failIfMajorPerformanceCaveat??AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat)){const{WebGLRenderer:Jr}=await __vitePreload(async()=>{const{WebGLRenderer:ei}=await Promise.resolve().then(()=>WebGLRenderer$1);return{WebGLRenderer:ei}},void 0);Gr=Jr,Yr={...Wr,...Wr.webgl};break}else if(Qr==="canvas")throw Yr={...Wr},new Error("CanvasRenderer is not yet implemented")}if(delete Yr.webgpu,delete Yr.webgl,!Gr)throw new Error("No available renderer for the current environment");const Kr=new Gr;return await Kr.init(Yr),Kr}const VERSION="8.9.1";class ApplicationInitHook{static init(){var ze;(ze=globalThis.__PIXI_APP_INIT__)==null||ze.call(globalThis,this,VERSION)}static destroy(){}}ApplicationInitHook.extension=ExtensionType.Application;class RendererInitHook{constructor(ze){this._renderer=ze}init(){var ze;(ze=globalThis.__PIXI_RENDERER_INIT__)==null||ze.call(globalThis,this._renderer,VERSION)}destroy(){this._renderer=null}}RendererInitHook.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"initHook",priority:-10};const _Application=class ds{constructor(...ze){this.stage=new Container,ze[0]!==void 0&&deprecation(v8_0_0,"Application constructor options are deprecated, please use Application.init() instead.")}async init(ze){ze={...ze},this.renderer=await autoDetectRenderer(ze),ds._plugins.forEach(Gr=>{Gr.init.call(this,ze)})}render(){this.renderer.render({container:this.stage})}get canvas(){return this.renderer.canvas}get view(){return deprecation(v8_0_0,"Application.view is deprecated, please use Application.canvas instead."),this.renderer.canvas}get screen(){return this.renderer.screen}destroy(ze=!1,Gr=!1){const Yr=ds._plugins.slice(0);Yr.reverse(),Yr.forEach(Kr=>{Kr.destroy.call(this)}),this.stage.destroy(Gr),this.stage=null,this.renderer.destroy(ze),this.renderer=null}};_Application._plugins=[];let Application=_Application;extensions.handleByList(ExtensionType.Application,Application._plugins);extensions.add(ApplicationInitHook);class ResizePlugin{static init(ze){Object.defineProperty(this,"resizeTo",{set(Gr){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=Gr,Gr&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let Gr,Yr;if(this._resizeTo===globalThis.window)Gr=globalThis.innerWidth,Yr=globalThis.innerHeight;else{const{clientWidth:Kr,clientHeight:Zr}=this._resizeTo;Gr=Kr,Yr=Zr}this.renderer.resize(Gr,Yr),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=ze.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}ResizePlugin.extension=ExtensionType.Application;class TickerPlugin{static init(ze){ze=Object.assign({autoStart:!0,sharedTicker:!1},ze),Object.defineProperty(this,"ticker",{set(Gr){this._ticker&&this._ticker.remove(this.render,this),this._ticker=Gr,Gr&&Gr.add(this.render,this,UPDATE_PRIORITY.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=ze.sharedTicker?Ticker.shared:new Ticker,ze.autoStart&&this.start()}static destroy(){if(this._ticker){const ze=this._ticker;this.ticker=null,ze.destroy()}}}TickerPlugin.extension=ExtensionType.Application;class AbstractBitmapFont extends EventEmitter{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return deprecation(v8_0_0,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return deprecation(v8_0_0,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return deprecation(v8_0_0,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return deprecation(v8_0_0,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(ze=!1){var Gr;this.emit("destroy",this),this.removeAllListeners();for(const Yr in this.chars)(Gr=this.chars[Yr].texture)==null||Gr.destroy();this.chars=null,ze&&(this.pages.forEach(Yr=>Yr.texture.destroy(!0)),this.pages=null)}}const emptyColorStops=[{offset:0,color:"white"},{offset:1,color:"black"}],_FillGradient=class fs{constructor(...ze){this.uid=uid$1("fillGradient"),this.type="linear",this.colorStops=[];let Gr=ensureGradientOptions(ze);Gr={...Gr.type==="radial"?fs.defaultRadialOptions:fs.defaultLinearOptions,...definedProps(Gr)},this._textureSize=Gr.textureSize,Gr.type==="radial"?(this.center=Gr.center,this.outerCenter=Gr.outerCenter??this.center,this.innerRadius=Gr.innerRadius,this.outerRadius=Gr.outerRadius,this.scale=Gr.scale,this.rotation=Gr.rotation):(this.start=Gr.start,this.end=Gr.end),this.textureSpace=Gr.textureSpace,this.type=Gr.type,Gr.colorStops.forEach(Kr=>{this.addColorStop(Kr.offset,Kr.color)})}addColorStop(ze,Gr){return this.colorStops.push({offset:ze,color:Color.shared.setValue(Gr).toHexa()}),this}buildLinearGradient(){if(this.texture)return;const ze=this.colorStops.length?this.colorStops:emptyColorStops,Gr=this._textureSize,{canvas:Yr,context:Kr}=getCanvas(Gr,1),Zr=Kr.createLinearGradient(0,0,this._textureSize,0);addColorStops(Zr,ze),Kr.fillStyle=Zr,Kr.fillRect(0,0,Gr,1),this.texture=new Texture({source:new ImageSource({resource:Yr})});const{x:Qr,y:Jr}=this.start,{x:ei,y:ti}=this.end,ri=new Matrix,ii=ei-Qr,si=ti-Jr,ni=Math.sqrt(ii*ii+si*si),oi=Math.atan2(si,ii);ri.scale(ni/Gr,1),ri.rotate(oi),ri.translate(Qr,Jr),this.textureSpace==="local"&&ri.scale(Gr,Gr),this.transform=ri}buildGradient(){this.type==="linear"?this.buildLinearGradient():this.buildRadialGradient()}buildRadialGradient(){if(this.texture)return;const ze=this.colorStops.length?this.colorStops:emptyColorStops,Gr=this._textureSize,{canvas:Yr,context:Kr}=getCanvas(Gr,Gr),{x:Zr,y:Qr}=this.center,{x:Jr,y:ei}=this.outerCenter,ti=this.innerRadius,ri=this.outerRadius,ii=Jr-ri,si=ei-ri,ni=Gr/(ri*2),oi=(Zr-ii)*ni,li=(Qr-si)*ni,ai=Kr.createRadialGradient(oi,li,ti*ni,(Jr-ii)*ni,(ei-si)*ni,ri*ni);addColorStops(ai,ze),Kr.fillStyle=ze[ze.length-1].color,Kr.fillRect(0,0,Gr,Gr),Kr.fillStyle=ai,Kr.translate(oi,li),Kr.rotate(this.rotation),Kr.scale(1,this.scale),Kr.translate(-oi,-li),Kr.fillRect(0,0,Gr,Gr),this.texture=new Texture({source:new ImageSource({resource:Yr,addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"})});const ui=new Matrix;ui.scale(1/ni,1/ni),ui.translate(ii,si),this.textureSpace==="local"&&ui.scale(Gr,Gr),this.transform=ui}get styleKey(){return this.uid}destroy(){var ze;(ze=this.texture)==null||ze.destroy(!0),this.texture=null}};_FillGradient.defaultLinearOptions={start:{x:0,y:0},end:{x:0,y:1},colorStops:[],textureSpace:"local",type:"linear",textureSize:256};_FillGradient.defaultRadialOptions={center:{x:.5,y:.5},innerRadius:0,outerRadius:.5,colorStops:[],scale:1,textureSpace:"local",type:"radial",textureSize:256};let FillGradient=_FillGradient;function addColorStops(Wr,ze){for(let Gr=0;Gr<ze.length;Gr++){const Yr=ze[Gr];Wr.addColorStop(Yr.offset,Yr.color)}}function getCanvas(Wr,ze){const Gr=DOMAdapter.get().createCanvas(Wr,ze),Yr=Gr.getContext("2d");return{canvas:Gr,context:Yr}}function ensureGradientOptions(Wr){let ze=Wr[0]??{};return(typeof ze=="number"||Wr[1])&&(deprecation("8.5.2","use options object instead"),ze={type:"linear",start:{x:Wr[0],y:Wr[1]},end:{x:Wr[2],y:Wr[3]},textureSpace:Wr[4],textureSize:Wr[5]??FillGradient.defaultLinearOptions.textureSize}),ze}const repetitionMap={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class FillPattern{constructor(ze,Gr){this.uid=uid$1("fillPattern"),this.transform=new Matrix,this._styleKey=null,this.texture=ze,this.transform.scale(1/ze.frame.width,1/ze.frame.height),Gr&&(ze.source.style.addressModeU=repetitionMap[Gr].addressModeU,ze.source.style.addressModeV=repetitionMap[Gr].addressModeV)}setTransform(ze){const Gr=this.texture;this.transform.copyFrom(ze),this.transform.invert(),this.transform.scale(1/Gr.frame.width,1/Gr.frame.height),this._styleKey=null}get styleKey(){return this._styleKey?this._styleKey:(this._styleKey=`fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`,this._styleKey)}}var parseSvgPath,hasRequiredParseSvgPath;function requireParseSvgPath(){if(hasRequiredParseSvgPath)return parseSvgPath;hasRequiredParseSvgPath=1,parseSvgPath=Gr;var Wr={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},ze=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function Gr(Zr){var Qr=[];return Zr.replace(ze,function(Jr,ei,ti){var ri=ei.toLowerCase();for(ti=Kr(ti),ri=="m"&&ti.length>2&&(Qr.push([ei].concat(ti.splice(0,2))),ri="l",ei=ei=="m"?"l":"L");;){if(ti.length==Wr[ri])return ti.unshift(ei),Qr.push(ti);if(ti.length<Wr[ri])throw new Error("malformed path data");Qr.push([ei].concat(ti.splice(0,Wr[ri])))}}),Qr}var Yr=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function Kr(Zr){var Qr=Zr.match(Yr);return Qr?Qr.map(Number):[]}return parseSvgPath}var parseSvgPathExports=requireParseSvgPath();const parse=getDefaultExportFromCjs(parseSvgPathExports);function parseSVGPath(Wr,ze){const Gr=parse(Wr),Yr=[];let Kr=null,Zr=0,Qr=0;for(let Jr=0;Jr<Gr.length;Jr++){const ei=Gr[Jr],ti=ei[0],ri=ei;switch(ti){case"M":Zr=ri[1],Qr=ri[2],ze.moveTo(Zr,Qr);break;case"m":Zr+=ri[1],Qr+=ri[2],ze.moveTo(Zr,Qr);break;case"H":Zr=ri[1],ze.lineTo(Zr,Qr);break;case"h":Zr+=ri[1],ze.lineTo(Zr,Qr);break;case"V":Qr=ri[1],ze.lineTo(Zr,Qr);break;case"v":Qr+=ri[1],ze.lineTo(Zr,Qr);break;case"L":Zr=ri[1],Qr=ri[2],ze.lineTo(Zr,Qr);break;case"l":Zr+=ri[1],Qr+=ri[2],ze.lineTo(Zr,Qr);break;case"C":Zr=ri[5],Qr=ri[6],ze.bezierCurveTo(ri[1],ri[2],ri[3],ri[4],Zr,Qr);break;case"c":ze.bezierCurveTo(Zr+ri[1],Qr+ri[2],Zr+ri[3],Qr+ri[4],Zr+ri[5],Qr+ri[6]),Zr+=ri[5],Qr+=ri[6];break;case"S":Zr=ri[3],Qr=ri[4],ze.bezierCurveToShort(ri[1],ri[2],Zr,Qr);break;case"s":ze.bezierCurveToShort(Zr+ri[1],Qr+ri[2],Zr+ri[3],Qr+ri[4]),Zr+=ri[3],Qr+=ri[4];break;case"Q":Zr=ri[3],Qr=ri[4],ze.quadraticCurveTo(ri[1],ri[2],Zr,Qr);break;case"q":ze.quadraticCurveTo(Zr+ri[1],Qr+ri[2],Zr+ri[3],Qr+ri[4]),Zr+=ri[3],Qr+=ri[4];break;case"T":Zr=ri[1],Qr=ri[2],ze.quadraticCurveToShort(Zr,Qr);break;case"t":Zr+=ri[1],Qr+=ri[2],ze.quadraticCurveToShort(Zr,Qr);break;case"A":Zr=ri[6],Qr=ri[7],ze.arcToSvg(ri[1],ri[2],ri[3],ri[4],ri[5],Zr,Qr);break;case"a":Zr+=ri[6],Qr+=ri[7],ze.arcToSvg(ri[1],ri[2],ri[3],ri[4],ri[5],Zr,Qr);break;case"Z":case"z":ze.closePath(),Yr.length>0&&(Kr=Yr.pop(),Kr?(Zr=Kr.startX,Qr=Kr.startY):(Zr=0,Qr=0)),Kr=null;break;default:warn(`Unknown SVG path command: ${ti}`)}ti!=="Z"&&ti!=="z"&&Kr===null&&(Kr={startX:Zr,startY:Qr},Yr.push(Kr))}return ze}class Circle{constructor(ze=0,Gr=0,Yr=0){this.type="circle",this.x=ze,this.y=Gr,this.radius=Yr}clone(){return new Circle(this.x,this.y,this.radius)}contains(ze,Gr){if(this.radius<=0)return!1;const Yr=this.radius*this.radius;let Kr=this.x-ze,Zr=this.y-Gr;return Kr*=Kr,Zr*=Zr,Kr+Zr<=Yr}strokeContains(ze,Gr,Yr,Kr=.5){if(this.radius===0)return!1;const Zr=this.x-ze,Qr=this.y-Gr,Jr=this.radius,ei=(1-Kr)*Yr,ti=Math.sqrt(Zr*Zr+Qr*Qr);return ti<=Jr+ei&&ti>Jr-(Yr-ei)}getBounds(ze){return ze||(ze=new Rectangle),ze.x=this.x-this.radius,ze.y=this.y-this.radius,ze.width=this.radius*2,ze.height=this.radius*2,ze}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.radius=ze.radius,this}copyTo(ze){return ze.copyFrom(this),ze}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class Ellipse{constructor(ze=0,Gr=0,Yr=0,Kr=0){this.type="ellipse",this.x=ze,this.y=Gr,this.halfWidth=Yr,this.halfHeight=Kr}clone(){return new Ellipse(this.x,this.y,this.halfWidth,this.halfHeight)}contains(ze,Gr){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let Yr=(ze-this.x)/this.halfWidth,Kr=(Gr-this.y)/this.halfHeight;return Yr*=Yr,Kr*=Kr,Yr+Kr<=1}strokeContains(ze,Gr,Yr,Kr=.5){const{halfWidth:Zr,halfHeight:Qr}=this;if(Zr<=0||Qr<=0)return!1;const Jr=Yr*(1-Kr),ei=Yr-Jr,ti=Zr-ei,ri=Qr-ei,ii=Zr+Jr,si=Qr+Jr,ni=ze-this.x,oi=Gr-this.y,li=ni*ni/(ti*ti)+oi*oi/(ri*ri),ai=ni*ni/(ii*ii)+oi*oi/(si*si);return li>1&&ai<=1}getBounds(ze){return ze||(ze=new Rectangle),ze.x=this.x-this.halfWidth,ze.y=this.y-this.halfHeight,ze.width=this.halfWidth*2,ze.height=this.halfHeight*2,ze}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.halfWidth=ze.halfWidth,this.halfHeight=ze.halfHeight,this}copyTo(ze){return ze.copyFrom(this),ze}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function squaredDistanceToLineSegment(Wr,ze,Gr,Yr,Kr,Zr){const Qr=Wr-Gr,Jr=ze-Yr,ei=Kr-Gr,ti=Zr-Yr,ri=Qr*ei+Jr*ti,ii=ei*ei+ti*ti;let si=-1;ii!==0&&(si=ri/ii);let ni,oi;si<0?(ni=Gr,oi=Yr):si>1?(ni=Kr,oi=Zr):(ni=Gr+si*ei,oi=Yr+si*ti);const li=Wr-ni,ai=ze-oi;return li*li+ai*ai}let tempRect$3,tempRect2;class Polygon{constructor(...ze){this.type="polygon";let Gr=Array.isArray(ze[0])?ze[0]:ze;if(typeof Gr[0]!="number"){const Yr=[];for(let Kr=0,Zr=Gr.length;Kr<Zr;Kr++)Yr.push(Gr[Kr].x,Gr[Kr].y);Gr=Yr}this.points=Gr,this.closePath=!0}isClockwise(){let ze=0;const Gr=this.points,Yr=Gr.length;for(let Kr=0;Kr<Yr;Kr+=2){const Zr=Gr[Kr],Qr=Gr[Kr+1],Jr=Gr[(Kr+2)%Yr],ei=Gr[(Kr+3)%Yr];ze+=(Jr-Zr)*(ei+Qr)}return ze<0}containsPolygon(ze){const Gr=this.getBounds(tempRect$3),Yr=ze.getBounds(tempRect2);if(!Gr.containsRect(Yr))return!1;const Kr=ze.points;for(let Zr=0;Zr<Kr.length;Zr+=2){const Qr=Kr[Zr],Jr=Kr[Zr+1];if(!this.contains(Qr,Jr))return!1}return!0}clone(){const ze=this.points.slice(),Gr=new Polygon(ze);return Gr.closePath=this.closePath,Gr}contains(ze,Gr){let Yr=!1;const Kr=this.points.length/2;for(let Zr=0,Qr=Kr-1;Zr<Kr;Qr=Zr++){const Jr=this.points[Zr*2],ei=this.points[Zr*2+1],ti=this.points[Qr*2],ri=this.points[Qr*2+1];ei>Gr!=ri>Gr&&ze<(ti-Jr)*((Gr-ei)/(ri-ei))+Jr&&(Yr=!Yr)}return Yr}strokeContains(ze,Gr,Yr,Kr=.5){const Zr=Yr*Yr,Qr=Zr*(1-Kr),Jr=Zr-Qr,{points:ei}=this,ti=ei.length-(this.closePath?0:2);for(let ri=0;ri<ti;ri+=2){const ii=ei[ri],si=ei[ri+1],ni=ei[(ri+2)%ei.length],oi=ei[(ri+3)%ei.length],li=squaredDistanceToLineSegment(ze,Gr,ii,si,ni,oi),ai=Math.sign((ni-ii)*(Gr-si)-(oi-si)*(ze-ii));if(li<=(ai<0?Jr:Qr))return!0}return!1}getBounds(ze){ze||(ze=new Rectangle);const Gr=this.points;let Yr=1/0,Kr=-1/0,Zr=1/0,Qr=-1/0;for(let Jr=0,ei=Gr.length;Jr<ei;Jr+=2){const ti=Gr[Jr],ri=Gr[Jr+1];Yr=ti<Yr?ti:Yr,Kr=ti>Kr?ti:Kr,Zr=ri<Zr?ri:Zr,Qr=ri>Qr?ri:Qr}return ze.x=Yr,ze.width=Kr-Yr,ze.y=Zr,ze.height=Qr-Zr,ze}copyFrom(ze){return this.points=ze.points.slice(),this.closePath=ze.closePath,this}copyTo(ze){return ze.copyFrom(this),ze}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((ze,Gr)=>`${ze}, ${Gr}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}const isCornerWithinStroke=(Wr,ze,Gr,Yr,Kr,Zr,Qr)=>{const Jr=Wr-Gr,ei=ze-Yr,ti=Math.sqrt(Jr*Jr+ei*ei);return ti>=Kr-Zr&&ti<=Kr+Qr};class RoundedRectangle{constructor(ze=0,Gr=0,Yr=0,Kr=0,Zr=20){this.type="roundedRectangle",this.x=ze,this.y=Gr,this.width=Yr,this.height=Kr,this.radius=Zr}getBounds(ze){return ze||(ze=new Rectangle),ze.x=this.x,ze.y=this.y,ze.width=this.width,ze.height=this.height,ze}clone(){return new RoundedRectangle(this.x,this.y,this.width,this.height,this.radius)}copyFrom(ze){return this.x=ze.x,this.y=ze.y,this.width=ze.width,this.height=ze.height,this}copyTo(ze){return ze.copyFrom(this),ze}contains(ze,Gr){if(this.width<=0||this.height<=0)return!1;if(ze>=this.x&&ze<=this.x+this.width&&Gr>=this.y&&Gr<=this.y+this.height){const Yr=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(Gr>=this.y+Yr&&Gr<=this.y+this.height-Yr||ze>=this.x+Yr&&ze<=this.x+this.width-Yr)return!0;let Kr=ze-(this.x+Yr),Zr=Gr-(this.y+Yr);const Qr=Yr*Yr;if(Kr*Kr+Zr*Zr<=Qr||(Kr=ze-(this.x+this.width-Yr),Kr*Kr+Zr*Zr<=Qr)||(Zr=Gr-(this.y+this.height-Yr),Kr*Kr+Zr*Zr<=Qr)||(Kr=ze-(this.x+Yr),Kr*Kr+Zr*Zr<=Qr))return!0}return!1}strokeContains(ze,Gr,Yr,Kr=.5){const{x:Zr,y:Qr,width:Jr,height:ei,radius:ti}=this,ri=Yr*(1-Kr),ii=Yr-ri,si=Zr+ti,ni=Qr+ti,oi=Jr-ti*2,li=ei-ti*2,ai=Zr+Jr,ui=Qr+ei;return(ze>=Zr-ri&&ze<=Zr+ii||ze>=ai-ii&&ze<=ai+ri)&&Gr>=ni&&Gr<=ni+li||(Gr>=Qr-ri&&Gr<=Qr+ii||Gr>=ui-ii&&Gr<=ui+ri)&&ze>=si&&ze<=si+oi?!0:ze<si&&Gr<ni&&isCornerWithinStroke(ze,Gr,si,ni,ti,ii,ri)||ze>ai-ti&&Gr<ni&&isCornerWithinStroke(ze,Gr,ai-ti,ni,ti,ii,ri)||ze>ai-ti&&Gr>ui-ti&&isCornerWithinStroke(ze,Gr,ai-ti,ui-ti,ti,ii,ri)||ze<si&&Gr>ui-ti&&isCornerWithinStroke(ze,Gr,si,ui-ti,ti,ii,ri)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}const fragTemplate=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join(`
`);function generateIfTestSrc(Wr){let ze="";for(let Gr=0;Gr<Wr;++Gr)Gr>0&&(ze+=`
else `),Gr<Wr-1&&(ze+=`if(test == ${Gr}.0){}`);return ze}function checkMaxIfStatementsInShader(Wr,ze){if(Wr===0)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const Gr=ze.createShader(ze.FRAGMENT_SHADER);try{for(;;){const Yr=fragTemplate.replace(/%forloop%/gi,generateIfTestSrc(Wr));if(ze.shaderSource(Gr,Yr),ze.compileShader(Gr),!ze.getShaderParameter(Gr,ze.COMPILE_STATUS))Wr=Wr/2|0;else break}}finally{ze.deleteShader(Gr)}return Wr}let maxTexturesPerBatchCache=null;function getMaxTexturesPerBatch(){var ze;if(maxTexturesPerBatchCache)return maxTexturesPerBatchCache;const Wr=getTestContext();return maxTexturesPerBatchCache=Wr.getParameter(Wr.MAX_TEXTURE_IMAGE_UNITS),maxTexturesPerBatchCache=checkMaxIfStatementsInShader(maxTexturesPerBatchCache,Wr),(ze=Wr.getExtension("WEBGL_lose_context"))==null||ze.loseContext(),maxTexturesPerBatchCache}const cachedGroups={};function getTextureBatchBindGroup(Wr,ze){let Gr=2166136261;for(let Yr=0;Yr<ze;Yr++)Gr^=Wr[Yr].uid,Gr=Math.imul(Gr,16777619),Gr>>>=0;return cachedGroups[Gr]||generateTextureBatchBindGroup(Wr,ze,Gr)}let maxTextures=0;function generateTextureBatchBindGroup(Wr,ze,Gr){const Yr={};let Kr=0;maxTextures||(maxTextures=getMaxTexturesPerBatch());for(let Qr=0;Qr<maxTextures;Qr++){const Jr=Qr<ze?Wr[Qr]:Texture.EMPTY.source;Yr[Kr++]=Jr.source,Yr[Kr++]=Jr.style}const Zr=new BindGroup(Yr);return cachedGroups[Gr]=Zr,Zr}class ViewableBuffer{constructor(ze){typeof ze=="number"?this.rawBinaryData=new ArrayBuffer(ze):ze instanceof Uint8Array?this.rawBinaryData=ze.buffer:this.rawBinaryData=ze,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(ze){return this[`${ze}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(ze){switch(ze){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${ze} isn't a valid view type`)}}}function fastCopy(Wr,ze){const Gr=Wr.byteLength/8|0,Yr=new Float64Array(Wr,0,Gr);new Float64Array(ze,0,Gr).set(Yr);const Zr=Wr.byteLength-Gr*8;if(Zr>0){const Qr=new Uint8Array(Wr,Gr*8,Zr);new Uint8Array(ze,Gr*8,Zr).set(Qr)}}const BLEND_TO_NPM={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};var STENCIL_MODES=(Wr=>(Wr[Wr.DISABLED=0]="DISABLED",Wr[Wr.RENDERING_MASK_ADD=1]="RENDERING_MASK_ADD",Wr[Wr.MASK_ACTIVE=2]="MASK_ACTIVE",Wr[Wr.INVERSE_MASK_ACTIVE=3]="INVERSE_MASK_ACTIVE",Wr[Wr.RENDERING_MASK_REMOVE=4]="RENDERING_MASK_REMOVE",Wr[Wr.NONE=5]="NONE",Wr))(STENCIL_MODES||{});function getAdjustedBlendModeBlend(Wr,ze){return ze.alphaMode==="no-premultiply-alpha"&&BLEND_TO_NPM[Wr]||Wr}class BatchTextureArray{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let ze=0;ze<this.count;ze++){const Gr=this.textures[ze];this.textures[ze]=null,this.ids[Gr.uid]=null}this.count=0}}class Batch{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.textures=new BatchTextureArray,this.blendMode="normal",this.topology="triangle-strip",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}const batchPool=[];let batchPoolIndex=0;function getBatchFromPool(){return batchPoolIndex>0?batchPool[--batchPoolIndex]:new Batch}function returnBatchToPool(Wr){batchPool[batchPoolIndex++]=Wr}let BATCH_TICK=0;const _Batcher=class os{constructor(ze={}){this.uid=uid$1("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._elements=[],os.defaultOptions.maxTextures=os.defaultOptions.maxTextures??getMaxTexturesPerBatch(),ze={...os.defaultOptions,...ze};const{maxTextures:Gr,attributesInitialSize:Yr,indicesInitialSize:Kr}=ze;this.attributeBuffer=new ViewableBuffer(Yr*4),this.indexBuffer=new Uint16Array(Kr),this.maxTextures=Gr}begin(){this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0;for(let ze=0;ze<this.batchIndex;ze++)returnBatchToPool(this.batches[ze]);this.batchIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(ze){this._elements[this.elementSize++]=ze,ze._indexStart=this.indexSize,ze._attributeStart=this.attributeSize,ze._batcher=this,this.indexSize+=ze.indexSize,this.attributeSize+=ze.attributeSize*this.vertexSize}checkAndUpdateTexture(ze,Gr){const Yr=ze._batch.textures.ids[Gr._source.uid];return!Yr&&Yr!==0?!1:(ze._textureId=Yr,ze.texture=Gr,!0)}updateElement(ze){this.dirty=!0;const Gr=this.attributeBuffer;ze.packAsQuad?this.packQuadAttributes(ze,Gr.float32View,Gr.uint32View,ze._attributeStart,ze._textureId):this.packAttributes(ze,Gr.float32View,Gr.uint32View,ze._attributeStart,ze._textureId)}break(ze){const Gr=this._elements;if(!Gr[this.elementStart])return;let Yr=getBatchFromPool(),Kr=Yr.textures;Kr.clear();const Zr=Gr[this.elementStart];let Qr=getAdjustedBlendModeBlend(Zr.blendMode,Zr.texture._source),Jr=Zr.topology;this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const ei=this.attributeBuffer.float32View,ti=this.attributeBuffer.uint32View,ri=this.indexBuffer;let ii=this._batchIndexSize,si=this._batchIndexStart,ni="startBatch";const oi=this.maxTextures;for(let li=this.elementStart;li<this.elementSize;++li){const ai=Gr[li];Gr[li]=null;const fi=ai.texture._source,pi=getAdjustedBlendModeBlend(ai.blendMode,fi),mi=Qr!==pi||Jr!==ai.topology;if(fi._batchTick===BATCH_TICK&&!mi){ai._textureId=fi._textureBindLocation,ii+=ai.indexSize,ai.packAsQuad?(this.packQuadAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packQuadIndex(ri,ai._indexStart,ai._attributeStart/this.vertexSize)):(this.packAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packIndex(ai,ri,ai._indexStart,ai._attributeStart/this.vertexSize)),ai._batch=Yr;continue}fi._batchTick=BATCH_TICK,(Kr.count>=oi||mi)&&(this._finishBatch(Yr,si,ii-si,Kr,Qr,Jr,ze,ni),ni="renderBatch",si=ii,Qr=pi,Jr=ai.topology,Yr=getBatchFromPool(),Kr=Yr.textures,Kr.clear(),++BATCH_TICK),ai._textureId=fi._textureBindLocation=Kr.count,Kr.ids[fi.uid]=Kr.count,Kr.textures[Kr.count++]=fi,ai._batch=Yr,ii+=ai.indexSize,ai.packAsQuad?(this.packQuadAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packQuadIndex(ri,ai._indexStart,ai._attributeStart/this.vertexSize)):(this.packAttributes(ai,ei,ti,ai._attributeStart,ai._textureId),this.packIndex(ai,ri,ai._indexStart,ai._attributeStart/this.vertexSize))}Kr.count>0&&(this._finishBatch(Yr,si,ii-si,Kr,Qr,Jr,ze,ni),si=ii,++BATCH_TICK),this.elementStart=this.elementSize,this._batchIndexStart=si,this._batchIndexSize=ii}_finishBatch(ze,Gr,Yr,Kr,Zr,Qr,Jr,ei){ze.gpuBindGroup=null,ze.bindGroup=null,ze.action=ei,ze.batcher=this,ze.textures=Kr,ze.blendMode=Zr,ze.topology=Qr,ze.start=Gr,ze.size=Yr,++BATCH_TICK,this.batches[this.batchIndex++]=ze,Jr.add(ze)}finish(ze){this.break(ze)}ensureAttributeBuffer(ze){ze*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(ze*4)}ensureIndexBuffer(ze){ze<=this.indexBuffer.length||this._resizeIndexBuffer(ze)}_resizeAttributeBuffer(ze){const Gr=Math.max(ze,this.attributeBuffer.size*2),Yr=new ViewableBuffer(Gr);fastCopy(this.attributeBuffer.rawBinaryData,Yr.rawBinaryData),this.attributeBuffer=Yr}_resizeIndexBuffer(ze){const Gr=this.indexBuffer;let Yr=Math.max(ze,Gr.length*1.5);Yr+=Yr%2;const Kr=Yr>65535?new Uint32Array(Yr):new Uint16Array(Yr);if(Kr.BYTES_PER_ELEMENT!==Gr.BYTES_PER_ELEMENT)for(let Zr=0;Zr<Gr.length;Zr++)Kr[Zr]=Gr[Zr];else fastCopy(Gr.buffer,Kr.buffer);this.indexBuffer=Kr}packQuadIndex(ze,Gr,Yr){ze[Gr]=Yr+0,ze[Gr+1]=Yr+1,ze[Gr+2]=Yr+2,ze[Gr+3]=Yr+0,ze[Gr+4]=Yr+2,ze[Gr+5]=Yr+3}packIndex(ze,Gr,Yr,Kr){const Zr=ze.indices,Qr=ze.indexSize,Jr=ze.indexOffset,ei=ze.attributeOffset;for(let ti=0;ti<Qr;ti++)Gr[Yr++]=Kr+Zr[ti+Jr]-ei}destroy(){for(let ze=0;ze<this.batches.length;ze++)returnBatchToPool(this.batches[ze]);this.batches=null;for(let ze=0;ze<this._elements.length;ze++)this._elements[ze]._batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};_Batcher.defaultOptions={maxTextures:null,attributesInitialSize:4,indicesInitialSize:6};let Batcher=_Batcher;var BufferUsage=(Wr=>(Wr[Wr.MAP_READ=1]="MAP_READ",Wr[Wr.MAP_WRITE=2]="MAP_WRITE",Wr[Wr.COPY_SRC=4]="COPY_SRC",Wr[Wr.COPY_DST=8]="COPY_DST",Wr[Wr.INDEX=16]="INDEX",Wr[Wr.VERTEX=32]="VERTEX",Wr[Wr.UNIFORM=64]="UNIFORM",Wr[Wr.STORAGE=128]="STORAGE",Wr[Wr.INDIRECT=256]="INDIRECT",Wr[Wr.QUERY_RESOLVE=512]="QUERY_RESOLVE",Wr[Wr.STATIC=1024]="STATIC",Wr))(BufferUsage||{});class Buffer extends EventEmitter{constructor(ze){let{data:Gr,size:Yr}=ze;const{usage:Kr,label:Zr,shrinkToFit:Qr}=ze;super(),this.uid=uid$1("buffer"),this._resourceType="buffer",this._resourceId=uid$1("resource"),this._touched=0,this._updateID=1,this._dataInt32=null,this.shrinkToFit=!0,this.destroyed=!1,Gr instanceof Array&&(Gr=new Float32Array(Gr)),this._data=Gr,Yr??(Yr=Gr==null?void 0:Gr.byteLength);const Jr=!!Gr;this.descriptor={size:Yr,usage:Kr,mappedAtCreation:Jr,label:Zr},this.shrinkToFit=Qr??!0}get data(){return this._data}set data(ze){this.setDataWithSize(ze,ze.length,!0)}get dataInt32(){return this._dataInt32||(this._dataInt32=new Int32Array(this.data.buffer)),this._dataInt32}get static(){return!!(this.descriptor.usage&BufferUsage.STATIC)}set static(ze){ze?this.descriptor.usage|=BufferUsage.STATIC:this.descriptor.usage&=~BufferUsage.STATIC}setDataWithSize(ze,Gr,Yr){if(this._updateID++,this._updateSize=Gr*ze.BYTES_PER_ELEMENT,this._data===ze){Yr&&this.emit("update",this);return}const Kr=this._data;if(this._data=ze,this._dataInt32=null,!Kr||Kr.length!==ze.length){!this.shrinkToFit&&Kr&&ze.byteLength<Kr.byteLength?Yr&&this.emit("update",this):(this.descriptor.size=ze.byteLength,this._resourceId=uid$1("resource"),this.emit("change",this));return}Yr&&this.emit("update",this)}update(ze){this._updateSize=ze??this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function ensureIsBuffer(Wr,ze){if(!(Wr instanceof Buffer)){let Gr=ze?BufferUsage.INDEX:BufferUsage.VERTEX;Wr instanceof Array&&(ze?(Wr=new Uint32Array(Wr),Gr=BufferUsage.INDEX|BufferUsage.COPY_DST):(Wr=new Float32Array(Wr),Gr=BufferUsage.VERTEX|BufferUsage.COPY_DST)),Wr=new Buffer({data:Wr,label:ze?"index-mesh-buffer":"vertex-mesh-buffer",usage:Gr})}return Wr}function getGeometryBounds(Wr,ze,Gr){const Yr=Wr.getAttribute(ze);if(!Yr)return Gr.minX=0,Gr.minY=0,Gr.maxX=0,Gr.maxY=0,Gr;const Kr=Yr.buffer.data;let Zr=1/0,Qr=1/0,Jr=-1/0,ei=-1/0;const ti=Kr.BYTES_PER_ELEMENT,ri=(Yr.offset||0)/ti,ii=(Yr.stride||2*4)/ti;for(let si=ri;si<Kr.length;si+=ii){const ni=Kr[si],oi=Kr[si+1];ni>Jr&&(Jr=ni),oi>ei&&(ei=oi),ni<Zr&&(Zr=ni),oi<Qr&&(Qr=oi)}return Gr.minX=Zr,Gr.minY=Qr,Gr.maxX=Jr,Gr.maxY=ei,Gr}function ensureIsAttribute(Wr){return(Wr instanceof Buffer||Array.isArray(Wr)||Wr.BYTES_PER_ELEMENT)&&(Wr={buffer:Wr}),Wr.buffer=ensureIsBuffer(Wr.buffer,!1),Wr}class Geometry extends EventEmitter{constructor(ze={}){super(),this.uid=uid$1("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new Bounds,this._boundsDirty=!0;const{attributes:Gr,indexBuffer:Yr,topology:Kr}=ze;if(this.buffers=[],this.attributes={},Gr)for(const Zr in Gr)this.addAttribute(Zr,Gr[Zr]);this.instanceCount=ze.instanceCount??1,Yr&&this.addIndex(Yr),this.topology=Kr||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(ze){return this.attributes[ze]}getIndex(){return this.indexBuffer}getBuffer(ze){return this.getAttribute(ze).buffer}getSize(){for(const ze in this.attributes){const Gr=this.attributes[ze];return Gr.buffer.data.length/(Gr.stride/4||Gr.size)}return 0}addAttribute(ze,Gr){const Yr=ensureIsAttribute(Gr);this.buffers.indexOf(Yr.buffer)===-1&&(this.buffers.push(Yr.buffer),Yr.buffer.on("update",this.onBufferUpdate,this),Yr.buffer.on("change",this.onBufferUpdate,this)),this.attributes[ze]=Yr}addIndex(ze){this.indexBuffer=ensureIsBuffer(ze,!0),this.buffers.push(this.indexBuffer)}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,getGeometryBounds(this,"aPosition",this._bounds)):this._bounds}destroy(ze=!1){this.emit("destroy",this),this.removeAllListeners(),ze&&this.buffers.forEach(Gr=>Gr.destroy()),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}const placeHolderBufferData=new Float32Array(1),placeHolderIndexData=new Uint32Array(1);class BatchGeometry extends Geometry{constructor(){const Gr=new Buffer({data:placeHolderBufferData,label:"attribute-batch-buffer",usage:BufferUsage.VERTEX|BufferUsage.COPY_DST,shrinkToFit:!1}),Yr=new Buffer({data:placeHolderIndexData,label:"index-batch-buffer",usage:BufferUsage.INDEX|BufferUsage.COPY_DST,shrinkToFit:!1}),Kr=6*4;super({attributes:{aPosition:{buffer:Gr,format:"float32x2",stride:Kr,offset:0},aUV:{buffer:Gr,format:"float32x2",stride:Kr,offset:2*4},aColor:{buffer:Gr,format:"unorm8x4",stride:Kr,offset:4*4},aTextureIdAndRound:{buffer:Gr,format:"uint16x2",stride:Kr,offset:5*4}},indexBuffer:Yr})}}function addBits(Wr,ze,Gr){if(Wr)for(const Yr in Wr){const Kr=Yr.toLocaleLowerCase(),Zr=ze[Kr];if(Zr){let Qr=Wr[Yr];Yr==="header"&&(Qr=Qr.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),Gr&&Zr.push(`//----${Gr}----//`),Zr.push(Qr)}else warn(`${Yr} placement hook does not exist in shader`)}}const findHooksRx=/\{\{(.*?)\}\}/g;function compileHooks(Wr){var Yr;const ze={};return(((Yr=Wr.match(findHooksRx))==null?void 0:Yr.map(Kr=>Kr.replace(/[{()}]/g,"")))??[]).forEach(Kr=>{ze[Kr]=[]}),ze}function extractInputs(Wr,ze){let Gr;const Yr=/@in\s+([^;]+);/g;for(;(Gr=Yr.exec(Wr))!==null;)ze.push(Gr[1])}function compileInputs(Wr,ze,Gr=!1){const Yr=[];extractInputs(ze,Yr),Wr.forEach(Jr=>{Jr.header&&extractInputs(Jr.header,Yr)});const Kr=Yr;Gr&&Kr.sort();const Zr=Kr.map((Jr,ei)=>`       @location(${ei}) ${Jr},`).join(`
`);let Qr=ze.replace(/@in\s+[^;]+;\s*/g,"");return Qr=Qr.replace("{{in}}",`
${Zr}
`),Qr}function extractOutputs(Wr,ze){let Gr;const Yr=/@out\s+([^;]+);/g;for(;(Gr=Yr.exec(Wr))!==null;)ze.push(Gr[1])}function extractVariableName(Wr){const Gr=/\b(\w+)\s*:/g.exec(Wr);return Gr?Gr[1]:""}function stripVariable(Wr){const ze=/@.*?\s+/g;return Wr.replace(ze,"")}function compileOutputs(Wr,ze){const Gr=[];extractOutputs(ze,Gr),Wr.forEach(ei=>{ei.header&&extractOutputs(ei.header,Gr)});let Yr=0;const Kr=Gr.sort().map(ei=>ei.indexOf("builtin")>-1?ei:`@location(${Yr++}) ${ei}`).join(`,
`),Zr=Gr.sort().map(ei=>`       var ${stripVariable(ei)};`).join(`
`),Qr=`return VSOutput(
            ${Gr.sort().map(ei=>` ${extractVariableName(ei)}`).join(`,
`)});`;let Jr=ze.replace(/@out\s+[^;]+;\s*/g,"");return Jr=Jr.replace("{{struct}}",`
${Kr}
`),Jr=Jr.replace("{{start}}",`
${Zr}
`),Jr=Jr.replace("{{return}}",`
${Qr}
`),Jr}function injectBits(Wr,ze){let Gr=Wr;for(const Yr in ze){const Kr=ze[Yr];Kr.join(`
`).length?Gr=Gr.replace(`{{${Yr}}}`,`//-----${Yr} START-----//
${Kr.join(`
`)}
//----${Yr} FINISH----//`):Gr=Gr.replace(`{{${Yr}}}`,"")}return Gr}const cacheMap=Object.create(null),bitCacheMap=new Map;let CACHE_UID=0;function compileHighShader({template:Wr,bits:ze}){const Gr=generateCacheId(Wr,ze);if(cacheMap[Gr])return cacheMap[Gr];const{vertex:Yr,fragment:Kr}=compileInputsAndOutputs(Wr,ze);return cacheMap[Gr]=compileBits(Yr,Kr,ze),cacheMap[Gr]}function compileHighShaderGl({template:Wr,bits:ze}){const Gr=generateCacheId(Wr,ze);return cacheMap[Gr]||(cacheMap[Gr]=compileBits(Wr.vertex,Wr.fragment,ze)),cacheMap[Gr]}function compileInputsAndOutputs(Wr,ze){const Gr=ze.map(Qr=>Qr.vertex).filter(Qr=>!!Qr),Yr=ze.map(Qr=>Qr.fragment).filter(Qr=>!!Qr);let Kr=compileInputs(Gr,Wr.vertex,!0);Kr=compileOutputs(Gr,Kr);const Zr=compileInputs(Yr,Wr.fragment,!0);return{vertex:Kr,fragment:Zr}}function generateCacheId(Wr,ze){return ze.map(Gr=>(bitCacheMap.has(Gr)||bitCacheMap.set(Gr,CACHE_UID++),bitCacheMap.get(Gr))).sort((Gr,Yr)=>Gr-Yr).join("-")+Wr.vertex+Wr.fragment}function compileBits(Wr,ze,Gr){const Yr=compileHooks(Wr),Kr=compileHooks(ze);return Gr.forEach(Zr=>{addBits(Zr.vertex,Yr,Zr.name),addBits(Zr.fragment,Kr,Zr.name)}),{vertex:injectBits(Wr,Yr),fragment:injectBits(ze,Kr)}}const vertexGPUTemplate=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,fragmentGPUTemplate=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,vertexGlTemplate=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,fragmentGlTemplate=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
        
        {{end}}
    }
`,globalUniformsBit={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},globalUniformsBitGl={name:"global-uniforms-bit",vertex:{header:`
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}};function compileHighShaderGpuProgram({bits:Wr,name:ze}){const Gr=compileHighShader({template:{fragment:fragmentGPUTemplate,vertex:vertexGPUTemplate},bits:[globalUniformsBit,...Wr]});return GpuProgram.from({name:ze,vertex:{source:Gr.vertex,entryPoint:"main"},fragment:{source:Gr.fragment,entryPoint:"main"}})}function compileHighShaderGlProgram({bits:Wr,name:ze}){return new GlProgram({name:ze,...compileHighShaderGl({template:{vertex:vertexGlTemplate,fragment:fragmentGlTemplate},bits:[globalUniformsBitGl,...Wr]})})}const colorBit={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},colorBitGl={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},textureBatchBitGpuCache={};function generateBindingSrc(Wr){const ze=[];if(Wr===1)ze.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),ze.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let Gr=0;for(let Yr=0;Yr<Wr;Yr++)ze.push(`@group(1) @binding(${Gr++}) var textureSource${Yr+1}: texture_2d<f32>;`),ze.push(`@group(1) @binding(${Gr++}) var textureSampler${Yr+1}: sampler;`)}return ze.join(`
`)}function generateSampleSrc(Wr){const ze=[];if(Wr===1)ze.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{ze.push("switch vTextureId {");for(let Gr=0;Gr<Wr;Gr++)Gr===Wr-1?ze.push("  default:{"):ze.push(`  case ${Gr}:{`),ze.push(`      outColor = textureSampleGrad(textureSource${Gr+1}, textureSampler${Gr+1}, vUV, uvDx, uvDy);`),ze.push("      break;}");ze.push("}")}return ze.join(`
`)}function generateTextureBatchBit(Wr){return textureBatchBitGpuCache[Wr]||(textureBatchBitGpuCache[Wr]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(Wr)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(Wr)}
            `}}),textureBatchBitGpuCache[Wr]}const textureBatchBitGlCache={};function generateSampleGlSrc(Wr){const ze=[];for(let Gr=0;Gr<Wr;Gr++)Gr>0&&ze.push("else"),Gr<Wr-1&&ze.push(`if(vTextureId < ${Gr}.5)`),ze.push("{"),ze.push(`	outColor = texture(uTextures[${Gr}], vUV);`),ze.push("}");return ze.join(`
`)}function generateTextureBatchBitGl(Wr){return textureBatchBitGlCache[Wr]||(textureBatchBitGlCache[Wr]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;

                uniform sampler2D uTextures[${Wr}];

            `,main:`

                ${generateSampleGlSrc(Wr)}
            `}}),textureBatchBitGlCache[Wr]}const roundPixelsBit={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},roundPixelsBitGl={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},batchSamplersUniformGroupHash={};function getBatchSamplersUniformGroup(Wr){let ze=batchSamplersUniformGroupHash[Wr];if(ze)return ze;const Gr=new Int32Array(Wr);for(let Yr=0;Yr<Wr;Yr++)Gr[Yr]=Yr;return ze=batchSamplersUniformGroupHash[Wr]=new UniformGroup({uTextures:{value:Gr,type:"i32",size:Wr}},{isStatic:!0}),ze}class DefaultShader extends Shader{constructor(ze){const Gr=compileHighShaderGlProgram({name:"batch",bits:[colorBitGl,generateTextureBatchBitGl(ze),roundPixelsBitGl]}),Yr=compileHighShaderGpuProgram({name:"batch",bits:[colorBit,generateTextureBatchBit(ze),roundPixelsBit]});super({glProgram:Gr,gpuProgram:Yr,resources:{batchSamplers:getBatchSamplersUniformGroup(ze)}})}}let defaultShader=null;const _DefaultBatcher=class As extends Batcher{constructor(){super(...arguments),this.geometry=new BatchGeometry,this.shader=defaultShader||(defaultShader=new DefaultShader(this.maxTextures)),this.name=As.extension.name,this.vertexSize=6}packAttributes(ze,Gr,Yr,Kr,Zr){const Qr=Zr<<16|ze.roundPixels&65535,Jr=ze.transform,ei=Jr.a,ti=Jr.b,ri=Jr.c,ii=Jr.d,si=Jr.tx,ni=Jr.ty,{positions:oi,uvs:li}=ze,ai=ze.color,ui=ze.attributeOffset,fi=ui+ze.attributeSize;for(let pi=ui;pi<fi;pi++){const mi=pi*2,Ti=oi[mi],yi=oi[mi+1];Gr[Kr++]=ei*Ti+ri*yi+si,Gr[Kr++]=ii*yi+ti*Ti+ni,Gr[Kr++]=li[mi],Gr[Kr++]=li[mi+1],Yr[Kr++]=ai,Yr[Kr++]=Qr}}packQuadAttributes(ze,Gr,Yr,Kr,Zr){const Qr=ze.texture,Jr=ze.transform,ei=Jr.a,ti=Jr.b,ri=Jr.c,ii=Jr.d,si=Jr.tx,ni=Jr.ty,oi=ze.bounds,li=oi.maxX,ai=oi.minX,ui=oi.maxY,fi=oi.minY,pi=Qr.uvs,mi=ze.color,Ti=Zr<<16|ze.roundPixels&65535;Gr[Kr+0]=ei*ai+ri*fi+si,Gr[Kr+1]=ii*fi+ti*ai+ni,Gr[Kr+2]=pi.x0,Gr[Kr+3]=pi.y0,Yr[Kr+4]=mi,Yr[Kr+5]=Ti,Gr[Kr+6]=ei*li+ri*fi+si,Gr[Kr+7]=ii*fi+ti*li+ni,Gr[Kr+8]=pi.x1,Gr[Kr+9]=pi.y1,Yr[Kr+10]=mi,Yr[Kr+11]=Ti,Gr[Kr+12]=ei*li+ri*ui+si,Gr[Kr+13]=ii*ui+ti*li+ni,Gr[Kr+14]=pi.x2,Gr[Kr+15]=pi.y2,Yr[Kr+16]=mi,Yr[Kr+17]=Ti,Gr[Kr+18]=ei*ai+ri*ui+si,Gr[Kr+19]=ii*ui+ti*ai+ni,Gr[Kr+20]=pi.x3,Gr[Kr+21]=pi.y3,Yr[Kr+22]=mi,Yr[Kr+23]=Ti}};_DefaultBatcher.extension={type:[ExtensionType.Batcher],name:"default"};let DefaultBatcher=_DefaultBatcher;function buildUvs(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr=null){let ei=0;Gr*=ze,Kr*=Zr;const ti=Jr.a,ri=Jr.b,ii=Jr.c,si=Jr.d,ni=Jr.tx,oi=Jr.ty;for(;ei<Qr;){const li=Wr[Gr],ai=Wr[Gr+1];Yr[Kr]=ti*li+ii*ai+ni,Yr[Kr+1]=ri*li+si*ai+oi,Kr+=Zr,Gr+=ze,ei++}}function buildSimpleUvs(Wr,ze,Gr,Yr){let Kr=0;for(ze*=Gr;Kr<Yr;)Wr[ze]=0,Wr[ze+1]=0,ze+=Gr,Kr++}function transformVertices(Wr,ze,Gr,Yr,Kr){const Zr=ze.a,Qr=ze.b,Jr=ze.c,ei=ze.d,ti=ze.tx,ri=ze.ty;Gr||(Gr=0),Yr||(Yr=2),Kr||(Kr=Wr.length/Yr-Gr);let ii=Gr*Yr;for(let si=0;si<Kr;si++){const ni=Wr[ii],oi=Wr[ii+1];Wr[ii]=Zr*ni+Jr*oi+ti,Wr[ii+1]=Qr*ni+ei*oi+ri,ii+=Yr}}const identityMatrix=new Matrix;class BatchableGraphics{constructor(){this.packAsQuad=!1,this.batcherName="default",this.topology="triangle-list",this.applyTransform=!0,this.roundPixels=0,this._batcher=null,this._batch=null}get uvs(){return this.geometryData.uvs}get positions(){return this.geometryData.vertices}get indices(){return this.geometryData.indices}get blendMode(){return this.applyTransform?this.renderable.groupBlendMode:"normal"}get color(){const ze=this.baseColor,Gr=ze>>16|ze&65280|(ze&255)<<16,Yr=this.renderable;return Yr?multiplyHexColors(Gr,Yr.groupColor)+(this.alpha*Yr.groupAlpha*255<<24):Gr+(this.alpha*255<<24)}get transform(){var ze;return((ze=this.renderable)==null?void 0:ze.groupTransform)||identityMatrix}copyTo(ze){ze.indexOffset=this.indexOffset,ze.indexSize=this.indexSize,ze.attributeOffset=this.attributeOffset,ze.attributeSize=this.attributeSize,ze.baseColor=this.baseColor,ze.alpha=this.alpha,ze.texture=this.texture,ze.geometryData=this.geometryData,ze.topology=this.topology}reset(){this.applyTransform=!0,this.renderable=null,this.topology="triangle-list"}}const buildCircle={extension:{type:ExtensionType.ShapeBuilder,name:"circle"},build(Wr,ze){let Gr,Yr,Kr,Zr,Qr,Jr;if(Wr.type==="circle"){const mi=Wr;Gr=mi.x,Yr=mi.y,Qr=Jr=mi.radius,Kr=Zr=0}else if(Wr.type==="ellipse"){const mi=Wr;Gr=mi.x,Yr=mi.y,Qr=mi.halfWidth,Jr=mi.halfHeight,Kr=Zr=0}else{const mi=Wr,Ti=mi.width/2,yi=mi.height/2;Gr=mi.x+Ti,Yr=mi.y+yi,Qr=Jr=Math.max(0,Math.min(mi.radius,Math.min(Ti,yi))),Kr=Ti-Qr,Zr=yi-Jr}if(!(Qr>=0&&Jr>=0&&Kr>=0&&Zr>=0))return ze;const ei=Math.ceil(2.3*Math.sqrt(Qr+Jr)),ti=ei*8+(Kr?4:0)+(Zr?4:0);if(ti===0)return ze;if(ei===0)return ze[0]=ze[6]=Gr+Kr,ze[1]=ze[3]=Yr+Zr,ze[2]=ze[4]=Gr-Kr,ze[5]=ze[7]=Yr-Zr,ze;let ri=0,ii=ei*4+(Kr?2:0)+2,si=ii,ni=ti,oi=Kr+Qr,li=Zr,ai=Gr+oi,ui=Gr-oi,fi=Yr+li;if(ze[ri++]=ai,ze[ri++]=fi,ze[--ii]=fi,ze[--ii]=ui,Zr){const mi=Yr-li;ze[si++]=ui,ze[si++]=mi,ze[--ni]=mi,ze[--ni]=ai}for(let mi=1;mi<ei;mi++){const Ti=Math.PI/2*(mi/ei),yi=Kr+Math.cos(Ti)*Qr,_i=Zr+Math.sin(Ti)*Jr,Ci=Gr+yi,Bi=Gr-yi,Pi=Yr+_i,Si=Yr-_i;ze[ri++]=Ci,ze[ri++]=Pi,ze[--ii]=Pi,ze[--ii]=Bi,ze[si++]=Bi,ze[si++]=Si,ze[--ni]=Si,ze[--ni]=Ci}oi=Kr,li=Zr+Jr,ai=Gr+oi,ui=Gr-oi,fi=Yr+li;const pi=Yr-li;return ze[ri++]=ai,ze[ri++]=fi,ze[--ni]=pi,ze[--ni]=ai,Kr&&(ze[ri++]=ui,ze[ri++]=fi,ze[--ni]=pi,ze[--ni]=ui),ze},triangulate(Wr,ze,Gr,Yr,Kr,Zr){if(Wr.length===0)return;let Qr=0,Jr=0;for(let ri=0;ri<Wr.length;ri+=2)Qr+=Wr[ri],Jr+=Wr[ri+1];Qr/=Wr.length/2,Jr/=Wr.length/2;let ei=Yr;ze[ei*Gr]=Qr,ze[ei*Gr+1]=Jr;const ti=ei++;for(let ri=0;ri<Wr.length;ri+=2)ze[ei*Gr]=Wr[ri],ze[ei*Gr+1]=Wr[ri+1],ri>0&&(Kr[Zr++]=ei,Kr[Zr++]=ti,Kr[Zr++]=ei-1),ei++;Kr[Zr++]=ti+1,Kr[Zr++]=ti,Kr[Zr++]=ei-1}},buildEllipse={...buildCircle,extension:{...buildCircle.extension,name:"ellipse"}},buildRoundedRectangle={...buildCircle,extension:{...buildCircle.extension,name:"roundedRectangle"}},closePointEps=1e-4,curveEps=1e-4;function getOrientationOfPoints(Wr){const ze=Wr.length;if(ze<6)return 1;let Gr=0;for(let Yr=0,Kr=Wr[ze-2],Zr=Wr[ze-1];Yr<ze;Yr+=2){const Qr=Wr[Yr],Jr=Wr[Yr+1];Gr+=(Qr-Kr)*(Jr+Zr),Kr=Qr,Zr=Jr}return Gr<0?-1:1}function square(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr){const ei=Wr-Gr*Kr,ti=ze-Yr*Kr,ri=Wr+Gr*Zr,ii=ze+Yr*Zr;let si,ni;Qr?(si=Yr,ni=-Gr):(si=-Yr,ni=Gr);const oi=ei+si,li=ti+ni,ai=ri+si,ui=ii+ni;return Jr.push(oi,li),Jr.push(ai,ui),2}function round(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr){const ei=Gr-Wr,ti=Yr-ze;let ri=Math.atan2(ei,ti),ii=Math.atan2(Kr-Wr,Zr-ze);Jr&&ri<ii?ri+=Math.PI*2:!Jr&&ri>ii&&(ii+=Math.PI*2);let si=ri;const ni=ii-ri,oi=Math.abs(ni),li=Math.sqrt(ei*ei+ti*ti),ai=(15*oi*Math.sqrt(li)/Math.PI>>0)+1,ui=ni/ai;if(si+=ui,Jr){Qr.push(Wr,ze),Qr.push(Gr,Yr);for(let fi=1,pi=si;fi<ai;fi++,pi+=ui)Qr.push(Wr,ze),Qr.push(Wr+Math.sin(pi)*li,ze+Math.cos(pi)*li);Qr.push(Wr,ze),Qr.push(Kr,Zr)}else{Qr.push(Gr,Yr),Qr.push(Wr,ze);for(let fi=1,pi=si;fi<ai;fi++,pi+=ui)Qr.push(Wr+Math.sin(pi)*li,ze+Math.cos(pi)*li),Qr.push(Wr,ze);Qr.push(Kr,Zr),Qr.push(Wr,ze)}return ai*2}function buildLine(Wr,ze,Gr,Yr,Kr,Zr){const Qr=closePointEps;if(Wr.length===0)return;const Jr=ze;let ei=Jr.alignment;if(ze.alignment!==.5){let gi=getOrientationOfPoints(Wr);ei=(ei-.5)*gi+.5}const ti=new Point$1(Wr[0],Wr[1]),ri=new Point$1(Wr[Wr.length-2],Wr[Wr.length-1]),ii=Yr,si=Math.abs(ti.x-ri.x)<Qr&&Math.abs(ti.y-ri.y)<Qr;if(ii){Wr=Wr.slice(),si&&(Wr.pop(),Wr.pop(),ri.set(Wr[Wr.length-2],Wr[Wr.length-1]));const gi=(ti.x+ri.x)*.5,xi=(ri.y+ti.y)*.5;Wr.unshift(gi,xi),Wr.push(gi,xi)}const ni=Kr,oi=Wr.length/2;let li=Wr.length;const ai=ni.length/2,ui=Jr.width/2,fi=ui*ui,pi=Jr.miterLimit*Jr.miterLimit;let mi=Wr[0],Ti=Wr[1],yi=Wr[2],_i=Wr[3],Ci=0,Bi=0,Pi=-(Ti-_i),Si=mi-yi,Mi=0,ki=0,Wi=Math.sqrt(Pi*Pi+Si*Si);Pi/=Wi,Si/=Wi,Pi*=ui,Si*=ui;const Li=ei,ci=(1-Li)*2,hi=Li*2;ii||(Jr.cap==="round"?li+=round(mi-Pi*(ci-hi)*.5,Ti-Si*(ci-hi)*.5,mi-Pi*ci,Ti-Si*ci,mi+Pi*hi,Ti+Si*hi,ni,!0)+2:Jr.cap==="square"&&(li+=square(mi,Ti,Pi,Si,ci,hi,!0,ni))),ni.push(mi-Pi*ci,Ti-Si*ci),ni.push(mi+Pi*hi,Ti+Si*hi);for(let gi=1;gi<oi-1;++gi){mi=Wr[(gi-1)*2],Ti=Wr[(gi-1)*2+1],yi=Wr[gi*2],_i=Wr[gi*2+1],Ci=Wr[(gi+1)*2],Bi=Wr[(gi+1)*2+1],Pi=-(Ti-_i),Si=mi-yi,Wi=Math.sqrt(Pi*Pi+Si*Si),Pi/=Wi,Si/=Wi,Pi*=ui,Si*=ui,Mi=-(_i-Bi),ki=yi-Ci,Wi=Math.sqrt(Mi*Mi+ki*ki),Mi/=Wi,ki/=Wi,Mi*=ui,ki*=ui;const xi=yi-mi,bi=Ti-_i,vi=yi-Ci,Ei=Bi-_i,Ri=xi*vi+bi*Ei,wi=bi*vi-Ei*xi,Di=wi<0;if(Math.abs(wi)<.001*Math.abs(Ri)){ni.push(yi-Pi*ci,_i-Si*ci),ni.push(yi+Pi*hi,_i+Si*hi),Ri>=0&&(Jr.join==="round"?li+=round(yi,_i,yi-Pi*ci,_i-Si*ci,yi-Mi*ci,_i-ki*ci,ni,!1)+4:li+=2,ni.push(yi-Mi*hi,_i-ki*hi),ni.push(yi+Mi*ci,_i+ki*ci));continue}const Ni=(-Pi+mi)*(-Si+_i)-(-Pi+yi)*(-Si+Ti),Fi=(-Mi+Ci)*(-ki+_i)-(-Mi+yi)*(-ki+Bi),Hi=(xi*Fi-vi*Ni)/wi,Oi=(Ei*Ni-bi*Fi)/wi,ji=(Hi-yi)*(Hi-yi)+(Oi-_i)*(Oi-_i),zi=yi+(Hi-yi)*ci,Vi=_i+(Oi-_i)*ci,$i=yi-(Hi-yi)*hi,Ii=_i-(Oi-_i)*hi,Ui=Math.min(xi*xi+bi*bi,vi*vi+Ei*Ei),Xi=Di?ci:hi,qi=Ui+Xi*Xi*fi;ji<=qi?Jr.join==="bevel"||ji/fi>pi?(Di?(ni.push(zi,Vi),ni.push(yi+Pi*hi,_i+Si*hi),ni.push(zi,Vi),ni.push(yi+Mi*hi,_i+ki*hi)):(ni.push(yi-Pi*ci,_i-Si*ci),ni.push($i,Ii),ni.push(yi-Mi*ci,_i-ki*ci),ni.push($i,Ii)),li+=2):Jr.join==="round"?Di?(ni.push(zi,Vi),ni.push(yi+Pi*hi,_i+Si*hi),li+=round(yi,_i,yi+Pi*hi,_i+Si*hi,yi+Mi*hi,_i+ki*hi,ni,!0)+4,ni.push(zi,Vi),ni.push(yi+Mi*hi,_i+ki*hi)):(ni.push(yi-Pi*ci,_i-Si*ci),ni.push($i,Ii),li+=round(yi,_i,yi-Pi*ci,_i-Si*ci,yi-Mi*ci,_i-ki*ci,ni,!1)+4,ni.push(yi-Mi*ci,_i-ki*ci),ni.push($i,Ii)):(ni.push(zi,Vi),ni.push($i,Ii)):(ni.push(yi-Pi*ci,_i-Si*ci),ni.push(yi+Pi*hi,_i+Si*hi),Jr.join==="round"?Di?li+=round(yi,_i,yi+Pi*hi,_i+Si*hi,yi+Mi*hi,_i+ki*hi,ni,!0)+2:li+=round(yi,_i,yi-Pi*ci,_i-Si*ci,yi-Mi*ci,_i-ki*ci,ni,!1)+2:Jr.join==="miter"&&ji/fi<=pi&&(Di?(ni.push($i,Ii),ni.push($i,Ii)):(ni.push(zi,Vi),ni.push(zi,Vi)),li+=2),ni.push(yi-Mi*ci,_i-ki*ci),ni.push(yi+Mi*hi,_i+ki*hi),li+=2)}mi=Wr[(oi-2)*2],Ti=Wr[(oi-2)*2+1],yi=Wr[(oi-1)*2],_i=Wr[(oi-1)*2+1],Pi=-(Ti-_i),Si=mi-yi,Wi=Math.sqrt(Pi*Pi+Si*Si),Pi/=Wi,Si/=Wi,Pi*=ui,Si*=ui,ni.push(yi-Pi*ci,_i-Si*ci),ni.push(yi+Pi*hi,_i+Si*hi),ii||(Jr.cap==="round"?li+=round(yi-Pi*(ci-hi)*.5,_i-Si*(ci-hi)*.5,yi-Pi*ci,_i-Si*ci,yi+Pi*hi,_i+Si*hi,ni,!1)+2:Jr.cap==="square"&&(li+=square(yi,_i,Pi,Si,ci,hi,!1,ni)));const di=curveEps*curveEps;for(let gi=ai;gi<li+ai-2;++gi)mi=ni[gi*2],Ti=ni[gi*2+1],yi=ni[(gi+1)*2],_i=ni[(gi+1)*2+1],Ci=ni[(gi+2)*2],Bi=ni[(gi+2)*2+1],!(Math.abs(mi*(_i-Bi)+yi*(Bi-Ti)+Ci*(Ti-_i))<di)&&Zr.push(gi,gi+1,gi+2)}function buildPixelLine(Wr,ze,Gr,Yr){const Kr=closePointEps;if(Wr.length===0)return;const Zr=Wr[0],Qr=Wr[1],Jr=Wr[Wr.length-2],ei=Wr[Wr.length-1],ti=ze||Math.abs(Zr-Jr)<Kr&&Math.abs(Qr-ei)<Kr,ri=Gr,ii=Wr.length/2,si=ri.length/2;for(let ni=0;ni<ii;ni++)ri.push(Wr[ni*2]),ri.push(Wr[ni*2+1]);for(let ni=0;ni<ii-1;ni++)Yr.push(si+ni,si+ni+1);ti&&Yr.push(si+ii-1,si)}function triangulateWithHoles(Wr,ze,Gr,Yr,Kr,Zr,Qr){const Jr=earcut(Wr,ze,2);if(!Jr)return;for(let ti=0;ti<Jr.length;ti+=3)Zr[Qr++]=Jr[ti]+Kr,Zr[Qr++]=Jr[ti+1]+Kr,Zr[Qr++]=Jr[ti+2]+Kr;let ei=Kr*Yr;for(let ti=0;ti<Wr.length;ti+=2)Gr[ei]=Wr[ti],Gr[ei+1]=Wr[ti+1],ei+=Yr}const emptyArray=[],buildPolygon={extension:{type:ExtensionType.ShapeBuilder,name:"polygon"},build(Wr,ze){for(let Gr=0;Gr<Wr.points.length;Gr++)ze[Gr]=Wr.points[Gr];return ze},triangulate(Wr,ze,Gr,Yr,Kr,Zr){triangulateWithHoles(Wr,emptyArray,ze,Gr,Yr,Kr,Zr)}},buildRectangle={extension:{type:ExtensionType.ShapeBuilder,name:"rectangle"},build(Wr,ze){const Gr=Wr,Yr=Gr.x,Kr=Gr.y,Zr=Gr.width,Qr=Gr.height;return Zr>=0&&Qr>=0&&(ze[0]=Yr,ze[1]=Kr,ze[2]=Yr+Zr,ze[3]=Kr,ze[4]=Yr+Zr,ze[5]=Kr+Qr,ze[6]=Yr,ze[7]=Kr+Qr),ze},triangulate(Wr,ze,Gr,Yr,Kr,Zr){let Qr=0;Yr*=Gr,ze[Yr+Qr]=Wr[0],ze[Yr+Qr+1]=Wr[1],Qr+=Gr,ze[Yr+Qr]=Wr[2],ze[Yr+Qr+1]=Wr[3],Qr+=Gr,ze[Yr+Qr]=Wr[6],ze[Yr+Qr+1]=Wr[7],Qr+=Gr,ze[Yr+Qr]=Wr[4],ze[Yr+Qr+1]=Wr[5],Qr+=Gr;const Jr=Yr/Gr;Kr[Zr++]=Jr,Kr[Zr++]=Jr+1,Kr[Zr++]=Jr+2,Kr[Zr++]=Jr+1,Kr[Zr++]=Jr+3,Kr[Zr++]=Jr+2}},buildTriangle={extension:{type:ExtensionType.ShapeBuilder,name:"triangle"},build(Wr,ze){return ze[0]=Wr.x,ze[1]=Wr.y,ze[2]=Wr.x2,ze[3]=Wr.y2,ze[4]=Wr.x3,ze[5]=Wr.y3,ze},triangulate(Wr,ze,Gr,Yr,Kr,Zr){let Qr=0;Yr*=Gr,ze[Yr+Qr]=Wr[0],ze[Yr+Qr+1]=Wr[1],Qr+=Gr,ze[Yr+Qr]=Wr[2],ze[Yr+Qr+1]=Wr[3],Qr+=Gr,ze[Yr+Qr]=Wr[4],ze[Yr+Qr+1]=Wr[5];const Jr=Yr/Gr;Kr[Zr++]=Jr,Kr[Zr++]=Jr+1,Kr[Zr++]=Jr+2}},tempTextureMatrix$1=new Matrix,tempRect$2=new Rectangle;function generateTextureMatrix(Wr,ze,Gr,Yr){const Kr=ze.matrix?Wr.copyFrom(ze.matrix).invert():Wr.identity();if(ze.textureSpace==="local"){const Zr=Gr.getBounds(tempRect$2);Kr.translate(-Zr.x,-Zr.y),Kr.scale(1/Zr.width,1/Zr.height)}else{Kr.translate(ze.texture.frame.x,ze.texture.frame.y),Kr.scale(1/ze.texture.source.width,1/ze.texture.source.height);const Zr=ze.texture.source.style;Zr.addressMode==="clamp-to-edge"&&(Zr.addressMode="repeat",Zr.update())}return Yr&&Kr.append(tempTextureMatrix$1.copyFrom(Yr).invert()),Kr}const shapeBuilders={};extensions.handleByMap(ExtensionType.ShapeBuilder,shapeBuilders);extensions.add(buildRectangle,buildPolygon,buildTriangle,buildCircle,buildEllipse,buildRoundedRectangle);const tempRect$1=new Rectangle,tempTextureMatrix=new Matrix;function buildContextBatches(Wr,ze){const{geometryData:Gr,batches:Yr}=ze;Yr.length=0,Gr.indices.length=0,Gr.vertices.length=0,Gr.uvs.length=0;for(let Kr=0;Kr<Wr.instructions.length;Kr++){const Zr=Wr.instructions[Kr];if(Zr.action==="texture")addTextureToGeometryData(Zr.data,Yr,Gr);else if(Zr.action==="fill"||Zr.action==="stroke"){const Qr=Zr.action==="stroke",Jr=Zr.data.path.shapePath,ei=Zr.data.style,ti=Zr.data.hole;Qr&&ti&&addShapePathToGeometryData(ti.shapePath,ei,!0,Yr,Gr),ti&&(Jr.shapePrimitives[Jr.shapePrimitives.length-1].holes=ti.shapePath.shapePrimitives),addShapePathToGeometryData(Jr,ei,Qr,Yr,Gr)}}}function addTextureToGeometryData(Wr,ze,Gr){const{vertices:Yr,uvs:Kr,indices:Zr}=Gr,Qr=Zr.length,Jr=Yr.length/2,ei=[],ti=shapeBuilders.rectangle,ri=tempRect$1,ii=Wr.image;ri.x=Wr.dx,ri.y=Wr.dy,ri.width=Wr.dw,ri.height=Wr.dh;const si=Wr.transform;ti.build(ri,ei),si&&transformVertices(ei,si),ti.triangulate(ei,Yr,2,Jr,Zr,Qr);const ni=ii.uvs;Kr.push(ni.x0,ni.y0,ni.x1,ni.y1,ni.x3,ni.y3,ni.x2,ni.y2);const oi=BigPool.get(BatchableGraphics);oi.indexOffset=Qr,oi.indexSize=Zr.length-Qr,oi.attributeOffset=Jr,oi.attributeSize=Yr.length/2-Jr,oi.baseColor=Wr.style,oi.alpha=Wr.alpha,oi.texture=ii,oi.geometryData=Gr,ze.push(oi)}function addShapePathToGeometryData(Wr,ze,Gr,Yr,Kr){const{vertices:Zr,uvs:Qr,indices:Jr}=Kr;Wr.shapePrimitives.forEach(({shape:ei,transform:ti,holes:ri})=>{const ii=Jr.length,si=Zr.length/2,ni=[],oi=shapeBuilders[ei.type];let li="triangle-list";if(oi.build(ei,ni),ti&&transformVertices(ni,ti),Gr){const pi=ei.closePath??!0,mi=ze;mi.pixelLine?(buildPixelLine(ni,pi,Zr,Jr),li="line-list"):buildLine(ni,mi,!1,pi,Zr,Jr)}else if(ri){const pi=[],mi=ni.slice();getHoleArrays(ri).forEach(yi=>{pi.push(mi.length/2),mi.push(...yi)}),triangulateWithHoles(mi,pi,Zr,2,si,Jr,ii)}else oi.triangulate(ni,Zr,2,si,Jr,ii);const ai=Qr.length/2,ui=ze.texture;if(ui!==Texture.WHITE){const pi=generateTextureMatrix(tempTextureMatrix,ze,ei,ti);buildUvs(Zr,2,si,Qr,ai,2,Zr.length/2-si,pi)}else buildSimpleUvs(Qr,ai,2,Zr.length/2-si);const fi=BigPool.get(BatchableGraphics);fi.indexOffset=ii,fi.indexSize=Jr.length-ii,fi.attributeOffset=si,fi.attributeSize=Zr.length/2-si,fi.baseColor=ze.color,fi.alpha=ze.alpha,fi.texture=ui,fi.geometryData=Kr,fi.topology=li,Yr.push(fi)})}function getHoleArrays(Wr){const ze=[];for(let Gr=0;Gr<Wr.length;Gr++){const Yr=Wr[Gr].shape,Kr=[];shapeBuilders[Yr.type].build(Yr,Kr),ze.push(Kr)}return ze}class GpuGraphicsContext{constructor(){this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}}class GraphicsContextRenderData{constructor(){this.batcher=new DefaultBatcher,this.instructions=new InstructionSet}init(){this.instructions.reset()}get geometry(){return deprecation(v8_3_4,"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."),this.batcher.geometry}}const _GraphicsContextSystem=class ps{constructor(ze){this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null),ze.renderableGC.addManagedHash(this,"_gpuContextHash"),ze.renderableGC.addManagedHash(this,"_graphicsDataContextHash")}init(ze){ps.defaultOptions.bezierSmoothness=(ze==null?void 0:ze.bezierSmoothness)??ps.defaultOptions.bezierSmoothness}getContextRenderData(ze){return this._graphicsDataContextHash[ze.uid]||this._initContextRenderData(ze)}updateGpuContext(ze){let Gr=this._gpuContextHash[ze.uid]||this._initContext(ze);if(ze.dirty){Gr?this._cleanGraphicsContextData(ze):Gr=this._initContext(ze),buildContextBatches(ze,Gr);const Yr=ze.batchMode;ze.customShader||Yr==="no-batch"?Gr.isBatchable=!1:Yr==="auto"&&(Gr.isBatchable=Gr.geometryData.vertices.length<400),ze.dirty=!1}return Gr}getGpuContext(ze){return this._gpuContextHash[ze.uid]||this._initContext(ze)}_initContextRenderData(ze){const Gr=BigPool.get(GraphicsContextRenderData),{batches:Yr,geometryData:Kr}=this._gpuContextHash[ze.uid],Zr=Kr.vertices.length,Qr=Kr.indices.length;for(let ri=0;ri<Yr.length;ri++)Yr[ri].applyTransform=!1;const Jr=Gr.batcher;Jr.ensureAttributeBuffer(Zr),Jr.ensureIndexBuffer(Qr),Jr.begin();for(let ri=0;ri<Yr.length;ri++){const ii=Yr[ri];Jr.add(ii)}Jr.finish(Gr.instructions);const ei=Jr.geometry;ei.indexBuffer.setDataWithSize(Jr.indexBuffer,Jr.indexSize,!0),ei.buffers[0].setDataWithSize(Jr.attributeBuffer.float32View,Jr.attributeSize,!0);const ti=Jr.batches;for(let ri=0;ri<ti.length;ri++){const ii=ti[ri];ii.bindGroup=getTextureBatchBindGroup(ii.textures.textures,ii.textures.count)}return this._graphicsDataContextHash[ze.uid]=Gr,Gr}_initContext(ze){const Gr=new GpuGraphicsContext;return Gr.context=ze,this._gpuContextHash[ze.uid]=Gr,ze.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[ze.uid]}onGraphicsContextDestroy(ze){this._cleanGraphicsContextData(ze),ze.off("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[ze.uid]=null}_cleanGraphicsContextData(ze){const Gr=this._gpuContextHash[ze.uid];Gr.isBatchable||this._graphicsDataContextHash[ze.uid]&&(BigPool.return(this.getContextRenderData(ze)),this._graphicsDataContextHash[ze.uid]=null),Gr.batches&&Gr.batches.forEach(Yr=>{BigPool.return(Yr)})}destroy(){for(const ze in this._gpuContextHash)this._gpuContextHash[ze]&&this.onGraphicsContextDestroy(this._gpuContextHash[ze].context)}};_GraphicsContextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"graphicsContext"};_GraphicsContextSystem.defaultOptions={bezierSmoothness:.5};let GraphicsContextSystem=_GraphicsContextSystem;const RECURSION_LIMIT$1=8,FLT_EPSILON$1=11920929e-14,PATH_DISTANCE_EPSILON$1=1;function buildAdaptiveBezier(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti){const ii=Math.min(.99,Math.max(0,ti??GraphicsContextSystem.defaultOptions.bezierSmoothness));let si=(PATH_DISTANCE_EPSILON$1-ii)/1;return si*=si,begin$1(ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,Wr,si),Wr}function begin$1(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti){recursive$1(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti,0),ei.push(Qr,Jr)}function recursive$1(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti,ri){if(ri>RECURSION_LIMIT$1)return;const ii=(Wr+Gr)/2,si=(ze+Yr)/2,ni=(Gr+Kr)/2,oi=(Yr+Zr)/2,li=(Kr+Qr)/2,ai=(Zr+Jr)/2,ui=(ii+ni)/2,fi=(si+oi)/2,pi=(ni+li)/2,mi=(oi+ai)/2,Ti=(ui+pi)/2,yi=(fi+mi)/2;if(ri>0){let _i=Qr-Wr,Ci=Jr-ze;const Bi=Math.abs((Gr-Qr)*Ci-(Yr-Jr)*_i),Pi=Math.abs((Kr-Qr)*Ci-(Zr-Jr)*_i);if(Bi>FLT_EPSILON$1&&Pi>FLT_EPSILON$1){if((Bi+Pi)*(Bi+Pi)<=ti*(_i*_i+Ci*Ci)){ei.push(Ti,yi);return}}else if(Bi>FLT_EPSILON$1){if(Bi*Bi<=ti*(_i*_i+Ci*Ci)){ei.push(Ti,yi);return}}else if(Pi>FLT_EPSILON$1){if(Pi*Pi<=ti*(_i*_i+Ci*Ci)){ei.push(Ti,yi);return}}else if(_i=Ti-(Wr+Qr)/2,Ci=yi-(ze+Jr)/2,_i*_i+Ci*Ci<=ti){ei.push(Ti,yi);return}}recursive$1(Wr,ze,ii,si,ui,fi,Ti,yi,ei,ti,ri+1),recursive$1(Ti,yi,pi,mi,li,ai,Qr,Jr,ei,ti,ri+1)}const RECURSION_LIMIT=8,FLT_EPSILON=11920929e-14,PATH_DISTANCE_EPSILON=1;function buildAdaptiveQuadratic(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr){const ti=Math.min(.99,Math.max(0,Jr??GraphicsContextSystem.defaultOptions.bezierSmoothness));let ri=(PATH_DISTANCE_EPSILON-ti)/1;return ri*=ri,begin(ze,Gr,Yr,Kr,Zr,Qr,Wr,ri),Wr}function begin(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr){recursive(Qr,Wr,ze,Gr,Yr,Kr,Zr,Jr,0),Qr.push(Kr,Zr)}function recursive(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr,ei){if(ei>RECURSION_LIMIT)return;const ti=(ze+Yr)/2,ri=(Gr+Kr)/2,ii=(Yr+Zr)/2,si=(Kr+Qr)/2,ni=(ti+ii)/2,oi=(ri+si)/2;let li=Zr-ze,ai=Qr-Gr;const ui=Math.abs((Yr-Zr)*ai-(Kr-Qr)*li);if(ui>FLT_EPSILON){if(ui*ui<=Jr*(li*li+ai*ai)){Wr.push(ni,oi);return}}else if(li=ni-(ze+Zr)/2,ai=oi-(Gr+Qr)/2,li*li+ai*ai<=Jr){Wr.push(ni,oi);return}recursive(Wr,ze,Gr,ti,ri,ni,oi,Jr,ei+1),recursive(Wr,ni,oi,ii,si,Zr,Qr,Jr,ei+1)}function buildArc(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr){let ei=Math.abs(Kr-Zr);(!Qr&&Kr>Zr||Qr&&Zr>Kr)&&(ei=2*Math.PI-ei),Jr||(Jr=Math.max(6,Math.floor(6*Math.pow(Yr,1/3)*(ei/Math.PI)))),Jr=Math.max(Jr,3);let ti=ei/Jr,ri=Kr;ti*=Qr?-1:1;for(let ii=0;ii<Jr+1;ii++){const si=Math.cos(ri),ni=Math.sin(ri),oi=ze+si*Yr,li=Gr+ni*Yr;Wr.push(oi,li),ri+=ti}}function buildArcTo(Wr,ze,Gr,Yr,Kr,Zr){const Qr=Wr[Wr.length-2],ei=Wr[Wr.length-1]-Gr,ti=Qr-ze,ri=Kr-Gr,ii=Yr-ze,si=Math.abs(ei*ii-ti*ri);if(si<1e-8||Zr===0){(Wr[Wr.length-2]!==ze||Wr[Wr.length-1]!==Gr)&&Wr.push(ze,Gr);return}const ni=ei*ei+ti*ti,oi=ri*ri+ii*ii,li=ei*ri+ti*ii,ai=Zr*Math.sqrt(ni)/si,ui=Zr*Math.sqrt(oi)/si,fi=ai*li/ni,pi=ui*li/oi,mi=ai*ii+ui*ti,Ti=ai*ri+ui*ei,yi=ti*(ui+fi),_i=ei*(ui+fi),Ci=ii*(ai+pi),Bi=ri*(ai+pi),Pi=Math.atan2(_i-Ti,yi-mi),Si=Math.atan2(Bi-Ti,Ci-mi);buildArc(Wr,mi+ze,Ti+Gr,Zr,Pi,Si,ti*ri>ii*ei)}const TAU=Math.PI*2,out={centerX:0,centerY:0,ang1:0,ang2:0},mapToEllipse=({x:Wr,y:ze},Gr,Yr,Kr,Zr,Qr,Jr,ei)=>{Wr*=Gr,ze*=Yr;const ti=Kr*Wr-Zr*ze,ri=Zr*Wr+Kr*ze;return ei.x=ti+Qr,ei.y=ri+Jr,ei};function approxUnitArc(Wr,ze){const Gr=ze===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(ze/4),Yr=ze===1.5707963267948966?.551915024494:Gr,Kr=Math.cos(Wr),Zr=Math.sin(Wr),Qr=Math.cos(Wr+ze),Jr=Math.sin(Wr+ze);return[{x:Kr-Zr*Yr,y:Zr+Kr*Yr},{x:Qr+Jr*Yr,y:Jr-Qr*Yr},{x:Qr,y:Jr}]}const vectorAngle=(Wr,ze,Gr,Yr)=>{const Kr=Wr*Yr-ze*Gr<0?-1:1;let Zr=Wr*Gr+ze*Yr;return Zr>1&&(Zr=1),Zr<-1&&(Zr=-1),Kr*Math.acos(Zr)},getArcCenter=(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti,ri,ii,si)=>{const ni=Math.pow(Kr,2),oi=Math.pow(Zr,2),li=Math.pow(ri,2),ai=Math.pow(ii,2);let ui=ni*oi-ni*ai-oi*li;ui<0&&(ui=0),ui/=ni*ai+oi*li,ui=Math.sqrt(ui)*(Qr===Jr?-1:1);const fi=ui*Kr/Zr*ii,pi=ui*-Zr/Kr*ri,mi=ti*fi-ei*pi+(Wr+Gr)/2,Ti=ei*fi+ti*pi+(ze+Yr)/2,yi=(ri-fi)/Kr,_i=(ii-pi)/Zr,Ci=(-ri-fi)/Kr,Bi=(-ii-pi)/Zr,Pi=vectorAngle(1,0,yi,_i);let Si=vectorAngle(yi,_i,Ci,Bi);Jr===0&&Si>0&&(Si-=TAU),Jr===1&&Si<0&&(Si+=TAU),si.centerX=mi,si.centerY=Ti,si.ang1=Pi,si.ang2=Si};function buildArcToSvg(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr=0,ei=0,ti=0){if(Zr===0||Qr===0)return;const ri=Math.sin(Jr*TAU/360),ii=Math.cos(Jr*TAU/360),si=ii*(ze-Yr)/2+ri*(Gr-Kr)/2,ni=-ri*(ze-Yr)/2+ii*(Gr-Kr)/2;if(si===0&&ni===0)return;Zr=Math.abs(Zr),Qr=Math.abs(Qr);const oi=Math.pow(si,2)/Math.pow(Zr,2)+Math.pow(ni,2)/Math.pow(Qr,2);oi>1&&(Zr*=Math.sqrt(oi),Qr*=Math.sqrt(oi)),getArcCenter(ze,Gr,Yr,Kr,Zr,Qr,ei,ti,ri,ii,si,ni,out);let{ang1:li,ang2:ai}=out;const{centerX:ui,centerY:fi}=out;let pi=Math.abs(ai)/(TAU/4);Math.abs(1-pi)<1e-7&&(pi=1);const mi=Math.max(Math.ceil(pi),1);ai/=mi;let Ti=Wr[Wr.length-2],yi=Wr[Wr.length-1];const _i={x:0,y:0};for(let Ci=0;Ci<mi;Ci++){const Bi=approxUnitArc(li,ai),{x:Pi,y:Si}=mapToEllipse(Bi[0],Zr,Qr,ii,ri,ui,fi,_i),{x:Mi,y:ki}=mapToEllipse(Bi[1],Zr,Qr,ii,ri,ui,fi,_i),{x:Wi,y:Li}=mapToEllipse(Bi[2],Zr,Qr,ii,ri,ui,fi,_i);buildAdaptiveBezier(Wr,Ti,yi,Pi,Si,Mi,ki,Wi,Li),Ti=Wi,yi=Li,li+=ai}}function roundedShapeArc(Wr,ze,Gr){const Yr=(Qr,Jr)=>{const ei=Jr.x-Qr.x,ti=Jr.y-Qr.y,ri=Math.sqrt(ei*ei+ti*ti),ii=ei/ri,si=ti/ri;return{len:ri,nx:ii,ny:si}},Kr=(Qr,Jr)=>{Qr===0?Wr.moveTo(Jr.x,Jr.y):Wr.lineTo(Jr.x,Jr.y)};let Zr=ze[ze.length-1];for(let Qr=0;Qr<ze.length;Qr++){const Jr=ze[Qr%ze.length],ei=Jr.radius??Gr;if(ei<=0){Kr(Qr,Jr),Zr=Jr;continue}const ti=ze[(Qr+1)%ze.length],ri=Yr(Jr,Zr),ii=Yr(Jr,ti);if(ri.len<1e-4||ii.len<1e-4){Kr(Qr,Jr),Zr=Jr;continue}let si=Math.asin(ri.nx*ii.ny-ri.ny*ii.nx),ni=1,oi=!1;ri.nx*ii.nx-ri.ny*-ii.ny<0?si<0?si=Math.PI+si:(si=Math.PI-si,ni=-1,oi=!0):si>0&&(ni=-1,oi=!0);const li=si/2;let ai,ui=Math.abs(Math.cos(li)*ei/Math.sin(li));ui>Math.min(ri.len/2,ii.len/2)?(ui=Math.min(ri.len/2,ii.len/2),ai=Math.abs(ui*Math.sin(li)/Math.cos(li))):ai=ei;const fi=Jr.x+ii.nx*ui+-ii.ny*ai*ni,pi=Jr.y+ii.ny*ui+ii.nx*ai*ni,mi=Math.atan2(ri.ny,ri.nx)+Math.PI/2*ni,Ti=Math.atan2(ii.ny,ii.nx)-Math.PI/2*ni;Qr===0&&Wr.moveTo(fi+Math.cos(mi)*ai,pi+Math.sin(mi)*ai),Wr.arc(fi,pi,ai,mi,Ti,oi),Zr=Jr}}function roundedShapeQuadraticCurve(Wr,ze,Gr,Yr){const Kr=(Jr,ei)=>Math.sqrt((Jr.x-ei.x)**2+(Jr.y-ei.y)**2),Zr=(Jr,ei,ti)=>({x:Jr.x+(ei.x-Jr.x)*ti,y:Jr.y+(ei.y-Jr.y)*ti}),Qr=ze.length;for(let Jr=0;Jr<Qr;Jr++){const ei=ze[(Jr+1)%Qr],ti=ei.radius??Gr;if(ti<=0){Jr===0?Wr.moveTo(ei.x,ei.y):Wr.lineTo(ei.x,ei.y);continue}const ri=ze[Jr],ii=ze[(Jr+2)%Qr],si=Kr(ri,ei);let ni;if(si<1e-4)ni=ei;else{const ai=Math.min(si/2,ti);ni=Zr(ei,ri,ai/si)}const oi=Kr(ii,ei);let li;if(oi<1e-4)li=ei;else{const ai=Math.min(oi/2,ti);li=Zr(ei,ii,ai/oi)}Jr===0?Wr.moveTo(ni.x,ni.y):Wr.lineTo(ni.x,ni.y),Wr.quadraticCurveTo(ei.x,ei.y,li.x,li.y,Yr)}}const tempRectangle=new Rectangle;class ShapePath{constructor(ze){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Bounds,this._graphicsPath2D=ze,this.signed=ze.checkForHoles}moveTo(ze,Gr){return this.startPoly(ze,Gr),this}lineTo(ze,Gr){this._ensurePoly();const Yr=this._currentPoly.points,Kr=Yr[Yr.length-2],Zr=Yr[Yr.length-1];return(Kr!==ze||Zr!==Gr)&&Yr.push(ze,Gr),this}arc(ze,Gr,Yr,Kr,Zr,Qr){this._ensurePoly(!1);const Jr=this._currentPoly.points;return buildArc(Jr,ze,Gr,Yr,Kr,Zr,Qr),this}arcTo(ze,Gr,Yr,Kr,Zr){this._ensurePoly();const Qr=this._currentPoly.points;return buildArcTo(Qr,ze,Gr,Yr,Kr,Zr),this}arcToSvg(ze,Gr,Yr,Kr,Zr,Qr,Jr){const ei=this._currentPoly.points;return buildArcToSvg(ei,this._currentPoly.lastX,this._currentPoly.lastY,Qr,Jr,ze,Gr,Yr,Kr,Zr),this}bezierCurveTo(ze,Gr,Yr,Kr,Zr,Qr,Jr){this._ensurePoly();const ei=this._currentPoly;return buildAdaptiveBezier(this._currentPoly.points,ei.lastX,ei.lastY,ze,Gr,Yr,Kr,Zr,Qr,Jr),this}quadraticCurveTo(ze,Gr,Yr,Kr,Zr){this._ensurePoly();const Qr=this._currentPoly;return buildAdaptiveQuadratic(this._currentPoly.points,Qr.lastX,Qr.lastY,ze,Gr,Yr,Kr,Zr),this}closePath(){return this.endPoly(!0),this}addPath(ze,Gr){this.endPoly(),Gr&&!Gr.isIdentity()&&(ze=ze.clone(!0),ze.transform(Gr));const Yr=this.shapePrimitives,Kr=Yr.length;for(let Zr=0;Zr<ze.instructions.length;Zr++){const Qr=ze.instructions[Zr];this[Qr.action](...Qr.data)}if(ze.checkForHoles&&Yr.length-Kr>1){let Zr=null;for(let Qr=Kr;Qr<Yr.length;Qr++){const Jr=Yr[Qr];if(Jr.shape.type==="polygon"){const ei=Jr.shape,ti=Zr==null?void 0:Zr.shape;ti&&ti.containsPolygon(ei)?(Zr.holes||(Zr.holes=[]),Zr.holes.push(Jr),Yr.copyWithin(Qr,Qr+1),Yr.length--,Qr--):Zr=Jr}}}return this}finish(ze=!1){this.endPoly(ze)}rect(ze,Gr,Yr,Kr,Zr){return this.drawShape(new Rectangle(ze,Gr,Yr,Kr),Zr),this}circle(ze,Gr,Yr,Kr){return this.drawShape(new Circle(ze,Gr,Yr),Kr),this}poly(ze,Gr,Yr){const Kr=new Polygon(ze);return Kr.closePath=Gr,this.drawShape(Kr,Yr),this}regularPoly(ze,Gr,Yr,Kr,Zr=0,Qr){Kr=Math.max(Kr|0,3);const Jr=-1*Math.PI/2+Zr,ei=Math.PI*2/Kr,ti=[];for(let ri=0;ri<Kr;ri++){const ii=Jr-ri*ei;ti.push(ze+Yr*Math.cos(ii),Gr+Yr*Math.sin(ii))}return this.poly(ti,!0,Qr),this}roundPoly(ze,Gr,Yr,Kr,Zr,Qr=0,Jr){if(Kr=Math.max(Kr|0,3),Zr<=0)return this.regularPoly(ze,Gr,Yr,Kr,Qr);const ei=Yr*Math.sin(Math.PI/Kr)-.001;Zr=Math.min(Zr,ei);const ti=-1*Math.PI/2+Qr,ri=Math.PI*2/Kr,ii=(Kr-2)*Math.PI/Kr/2;for(let si=0;si<Kr;si++){const ni=si*ri+ti,oi=ze+Yr*Math.cos(ni),li=Gr+Yr*Math.sin(ni),ai=ni+Math.PI+ii,ui=ni-Math.PI-ii,fi=oi+Zr*Math.cos(ai),pi=li+Zr*Math.sin(ai),mi=oi+Zr*Math.cos(ui),Ti=li+Zr*Math.sin(ui);si===0?this.moveTo(fi,pi):this.lineTo(fi,pi),this.quadraticCurveTo(oi,li,mi,Ti,Jr)}return this.closePath()}roundShape(ze,Gr,Yr=!1,Kr){return ze.length<3?this:(Yr?roundedShapeQuadraticCurve(this,ze,Gr,Kr):roundedShapeArc(this,ze,Gr),this.closePath())}filletRect(ze,Gr,Yr,Kr,Zr){if(Zr===0)return this.rect(ze,Gr,Yr,Kr);const Qr=Math.min(Yr,Kr)/2,Jr=Math.min(Qr,Math.max(-Qr,Zr)),ei=ze+Yr,ti=Gr+Kr,ri=Jr<0?-Jr:0,ii=Math.abs(Jr);return this.moveTo(ze,Gr+ii).arcTo(ze+ri,Gr+ri,ze+ii,Gr,ii).lineTo(ei-ii,Gr).arcTo(ei-ri,Gr+ri,ei,Gr+ii,ii).lineTo(ei,ti-ii).arcTo(ei-ri,ti-ri,ze+Yr-ii,ti,ii).lineTo(ze+ii,ti).arcTo(ze+ri,ti-ri,ze,ti-ii,ii).closePath()}chamferRect(ze,Gr,Yr,Kr,Zr,Qr){if(Zr<=0)return this.rect(ze,Gr,Yr,Kr);const Jr=Math.min(Zr,Math.min(Yr,Kr)/2),ei=ze+Yr,ti=Gr+Kr,ri=[ze+Jr,Gr,ei-Jr,Gr,ei,Gr+Jr,ei,ti-Jr,ei-Jr,ti,ze+Jr,ti,ze,ti-Jr,ze,Gr+Jr];for(let ii=ri.length-1;ii>=2;ii-=2)ri[ii]===ri[ii-2]&&ri[ii-1]===ri[ii-3]&&ri.splice(ii-1,2);return this.poly(ri,!0,Qr)}ellipse(ze,Gr,Yr,Kr,Zr){return this.drawShape(new Ellipse(ze,Gr,Yr,Kr),Zr),this}roundRect(ze,Gr,Yr,Kr,Zr,Qr){return this.drawShape(new RoundedRectangle(ze,Gr,Yr,Kr,Zr),Qr),this}drawShape(ze,Gr){return this.endPoly(),this.shapePrimitives.push({shape:ze,transform:Gr}),this}startPoly(ze,Gr){let Yr=this._currentPoly;return Yr&&this.endPoly(),Yr=new Polygon,Yr.points.push(ze,Gr),this._currentPoly=Yr,this}endPoly(ze=!1){const Gr=this._currentPoly;return Gr&&Gr.points.length>2&&(Gr.closePath=ze,this.shapePrimitives.push({shape:Gr})),this._currentPoly=null,this}_ensurePoly(ze=!0){if(!this._currentPoly&&(this._currentPoly=new Polygon,ze)){const Gr=this.shapePrimitives[this.shapePrimitives.length-1];if(Gr){let Yr=Gr.shape.x,Kr=Gr.shape.y;if(Gr.transform&&!Gr.transform.isIdentity()){const Zr=Gr.transform,Qr=Yr;Yr=Zr.a*Yr+Zr.c*Kr+Zr.tx,Kr=Zr.b*Qr+Zr.d*Kr+Zr.ty}this._currentPoly.points.push(Yr,Kr)}else this._currentPoly.points.push(0,0)}}buildPath(){const ze=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let Gr=0;Gr<ze.instructions.length;Gr++){const Yr=ze.instructions[Gr];this[Yr.action](...Yr.data)}this.finish()}get bounds(){const ze=this._bounds;ze.clear();const Gr=this.shapePrimitives;for(let Yr=0;Yr<Gr.length;Yr++){const Kr=Gr[Yr],Zr=Kr.shape.getBounds(tempRectangle);Kr.transform?ze.addRect(Zr,Kr.transform):ze.addRect(Zr)}return ze}}class GraphicsPath{constructor(ze,Gr=!1){this.instructions=[],this.uid=uid$1("graphicsPath"),this._dirty=!0,this.checkForHoles=Gr,typeof ze=="string"?parseSVGPath(ze,this):this.instructions=(ze==null?void 0:ze.slice())??[]}get shapePath(){return this._shapePath||(this._shapePath=new ShapePath(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(ze,Gr){return ze=ze.clone(),this.instructions.push({action:"addPath",data:[ze,Gr]}),this._dirty=!0,this}arc(...ze){return this.instructions.push({action:"arc",data:ze}),this._dirty=!0,this}arcTo(...ze){return this.instructions.push({action:"arcTo",data:ze}),this._dirty=!0,this}arcToSvg(...ze){return this.instructions.push({action:"arcToSvg",data:ze}),this._dirty=!0,this}bezierCurveTo(...ze){return this.instructions.push({action:"bezierCurveTo",data:ze}),this._dirty=!0,this}bezierCurveToShort(ze,Gr,Yr,Kr,Zr){const Qr=this.instructions[this.instructions.length-1],Jr=this.getLastPoint(Point$1.shared);let ei=0,ti=0;if(!Qr||Qr.action!=="bezierCurveTo")ei=Jr.x,ti=Jr.y;else{ei=Qr.data[2],ti=Qr.data[3];const ri=Jr.x,ii=Jr.y;ei=ri+(ri-ei),ti=ii+(ii-ti)}return this.instructions.push({action:"bezierCurveTo",data:[ei,ti,ze,Gr,Yr,Kr,Zr]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...ze){return this.instructions.push({action:"ellipse",data:ze}),this._dirty=!0,this}lineTo(...ze){return this.instructions.push({action:"lineTo",data:ze}),this._dirty=!0,this}moveTo(...ze){return this.instructions.push({action:"moveTo",data:ze}),this}quadraticCurveTo(...ze){return this.instructions.push({action:"quadraticCurveTo",data:ze}),this._dirty=!0,this}quadraticCurveToShort(ze,Gr,Yr){const Kr=this.instructions[this.instructions.length-1],Zr=this.getLastPoint(Point$1.shared);let Qr=0,Jr=0;if(!Kr||Kr.action!=="quadraticCurveTo")Qr=Zr.x,Jr=Zr.y;else{Qr=Kr.data[0],Jr=Kr.data[1];const ei=Zr.x,ti=Zr.y;Qr=ei+(ei-Qr),Jr=ti+(ti-Jr)}return this.instructions.push({action:"quadraticCurveTo",data:[Qr,Jr,ze,Gr,Yr]}),this._dirty=!0,this}rect(ze,Gr,Yr,Kr,Zr){return this.instructions.push({action:"rect",data:[ze,Gr,Yr,Kr,Zr]}),this._dirty=!0,this}circle(ze,Gr,Yr,Kr){return this.instructions.push({action:"circle",data:[ze,Gr,Yr,Kr]}),this._dirty=!0,this}roundRect(...ze){return this.instructions.push({action:"roundRect",data:ze}),this._dirty=!0,this}poly(...ze){return this.instructions.push({action:"poly",data:ze}),this._dirty=!0,this}regularPoly(...ze){return this.instructions.push({action:"regularPoly",data:ze}),this._dirty=!0,this}roundPoly(...ze){return this.instructions.push({action:"roundPoly",data:ze}),this._dirty=!0,this}roundShape(...ze){return this.instructions.push({action:"roundShape",data:ze}),this._dirty=!0,this}filletRect(...ze){return this.instructions.push({action:"filletRect",data:ze}),this._dirty=!0,this}chamferRect(...ze){return this.instructions.push({action:"chamferRect",data:ze}),this._dirty=!0,this}star(ze,Gr,Yr,Kr,Zr,Qr,Jr){Zr||(Zr=Kr/2);const ei=-1*Math.PI/2+Qr,ti=Yr*2,ri=Math.PI*2/ti,ii=[];for(let si=0;si<ti;si++){const ni=si%2?Zr:Kr,oi=si*ri+ei;ii.push(ze+ni*Math.cos(oi),Gr+ni*Math.sin(oi))}return this.poly(ii,!0,Jr),this}clone(ze=!1){const Gr=new GraphicsPath;if(Gr.checkForHoles=this.checkForHoles,!ze)Gr.instructions=this.instructions.slice();else for(let Yr=0;Yr<this.instructions.length;Yr++){const Kr=this.instructions[Yr];Gr.instructions.push({action:Kr.action,data:Kr.data.slice()})}return Gr}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(ze){if(ze.isIdentity())return this;const Gr=ze.a,Yr=ze.b,Kr=ze.c,Zr=ze.d,Qr=ze.tx,Jr=ze.ty;let ei=0,ti=0,ri=0,ii=0,si=0,ni=0,oi=0,li=0;for(let ai=0;ai<this.instructions.length;ai++){const ui=this.instructions[ai],fi=ui.data;switch(ui.action){case"moveTo":case"lineTo":ei=fi[0],ti=fi[1],fi[0]=Gr*ei+Kr*ti+Qr,fi[1]=Yr*ei+Zr*ti+Jr;break;case"bezierCurveTo":ri=fi[0],ii=fi[1],si=fi[2],ni=fi[3],ei=fi[4],ti=fi[5],fi[0]=Gr*ri+Kr*ii+Qr,fi[1]=Yr*ri+Zr*ii+Jr,fi[2]=Gr*si+Kr*ni+Qr,fi[3]=Yr*si+Zr*ni+Jr,fi[4]=Gr*ei+Kr*ti+Qr,fi[5]=Yr*ei+Zr*ti+Jr;break;case"quadraticCurveTo":ri=fi[0],ii=fi[1],ei=fi[2],ti=fi[3],fi[0]=Gr*ri+Kr*ii+Qr,fi[1]=Yr*ri+Zr*ii+Jr,fi[2]=Gr*ei+Kr*ti+Qr,fi[3]=Yr*ei+Zr*ti+Jr;break;case"arcToSvg":ei=fi[5],ti=fi[6],oi=fi[0],li=fi[1],fi[0]=Gr*oi+Kr*li,fi[1]=Yr*oi+Zr*li,fi[5]=Gr*ei+Kr*ti+Qr,fi[6]=Yr*ei+Zr*ti+Jr;break;case"circle":fi[4]=adjustTransform(fi[3],ze);break;case"rect":fi[4]=adjustTransform(fi[4],ze);break;case"ellipse":fi[8]=adjustTransform(fi[8],ze);break;case"roundRect":fi[5]=adjustTransform(fi[5],ze);break;case"addPath":fi[0].transform(ze);break;case"poly":fi[2]=adjustTransform(fi[2],ze);break;default:warn("unknown transform action",ui.action);break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(ze){let Gr=this.instructions.length-1,Yr=this.instructions[Gr];if(!Yr)return ze.x=0,ze.y=0,ze;for(;Yr.action==="closePath";){if(Gr--,Gr<0)return ze.x=0,ze.y=0,ze;Yr=this.instructions[Gr]}switch(Yr.action){case"moveTo":case"lineTo":ze.x=Yr.data[0],ze.y=Yr.data[1];break;case"quadraticCurveTo":ze.x=Yr.data[2],ze.y=Yr.data[3];break;case"bezierCurveTo":ze.x=Yr.data[4],ze.y=Yr.data[5];break;case"arc":case"arcToSvg":ze.x=Yr.data[5],ze.y=Yr.data[6];break;case"addPath":Yr.data[0].getLastPoint(ze);break}return ze}}function adjustTransform(Wr,ze){return Wr?Wr.prepend(ze):ze.clone()}function parseSVGFloatAttribute(Wr,ze,Gr){const Yr=Wr.getAttribute(ze);return Yr?Number(Yr):Gr}function parseSVGDefinitions(Wr,ze){const Gr=Wr.querySelectorAll("defs");for(let Yr=0;Yr<Gr.length;Yr++){const Kr=Gr[Yr];for(let Zr=0;Zr<Kr.children.length;Zr++){const Qr=Kr.children[Zr];switch(Qr.nodeName.toLowerCase()){case"lineargradient":ze.defs[Qr.id]=parseLinearGradient(Qr);break;case"radialgradient":ze.defs[Qr.id]=parseRadialGradient();break}}}}function parseLinearGradient(Wr){const ze=parseSVGFloatAttribute(Wr,"x1",0),Gr=parseSVGFloatAttribute(Wr,"y1",0),Yr=parseSVGFloatAttribute(Wr,"x2",1),Kr=parseSVGFloatAttribute(Wr,"y2",0),Zr=Wr.getAttribute("gradientUnits")||"objectBoundingBox",Qr=new FillGradient(ze,Gr,Yr,Kr,Zr==="objectBoundingBox"?"local":"global");for(let Jr=0;Jr<Wr.children.length;Jr++){const ei=Wr.children[Jr],ti=parseSVGFloatAttribute(ei,"offset",0),ri=Color.shared.setValue(ei.getAttribute("stop-color")).toNumber();Qr.addColorStop(ti,ri)}return Qr}function parseRadialGradient(Wr){return warn("[SVG Parser] Radial gradients are not yet supported"),new FillGradient(0,0,1,0)}function extractSvgUrlId(Wr){const ze=Wr.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);return ze?ze[1]:""}const styleAttributes={fill:{type:"paint",default:0},"fill-opacity":{type:"number",default:1},stroke:{type:"paint",default:0},"stroke-width":{type:"number",default:1},"stroke-opacity":{type:"number",default:1},"stroke-linecap":{type:"string",default:"butt"},"stroke-linejoin":{type:"string",default:"miter"},"stroke-miterlimit":{type:"number",default:10},"stroke-dasharray":{type:"string",default:"none"},"stroke-dashoffset":{type:"number",default:0},opacity:{type:"number",default:1}};function parseSVGStyle(Wr,ze){const Gr=Wr.getAttribute("style"),Yr={},Kr={},Zr={strokeStyle:Yr,fillStyle:Kr,useFill:!1,useStroke:!1};for(const Qr in styleAttributes){const Jr=Wr.getAttribute(Qr);Jr&&parseAttribute(ze,Zr,Qr,Jr.trim())}if(Gr){const Qr=Gr.split(";");for(let Jr=0;Jr<Qr.length;Jr++){const ei=Qr[Jr].trim(),[ti,ri]=ei.split(":");styleAttributes[ti]&&parseAttribute(ze,Zr,ti,ri.trim())}}return{strokeStyle:Zr.useStroke?Yr:null,fillStyle:Zr.useFill?Kr:null,useFill:Zr.useFill,useStroke:Zr.useStroke}}function parseAttribute(Wr,ze,Gr,Yr){switch(Gr){case"stroke":if(Yr!=="none"){if(Yr.startsWith("url(")){const Kr=extractSvgUrlId(Yr);ze.strokeStyle.fill=Wr.defs[Kr]}else ze.strokeStyle.color=Color.shared.setValue(Yr).toNumber();ze.useStroke=!0}break;case"stroke-width":ze.strokeStyle.width=Number(Yr);break;case"fill":if(Yr!=="none"){if(Yr.startsWith("url(")){const Kr=extractSvgUrlId(Yr);ze.fillStyle.fill=Wr.defs[Kr]}else ze.fillStyle.color=Color.shared.setValue(Yr).toNumber();ze.useFill=!0}break;case"fill-opacity":ze.fillStyle.alpha=Number(Yr);break;case"stroke-opacity":ze.strokeStyle.alpha=Number(Yr);break;case"opacity":ze.fillStyle.alpha=Number(Yr),ze.strokeStyle.alpha=Number(Yr);break}}function SVGParser(Wr,ze){if(typeof Wr=="string"){const Qr=document.createElement("div");Qr.innerHTML=Wr.trim(),Wr=Qr.querySelector("svg")}const Gr={context:ze,defs:{},path:new GraphicsPath};parseSVGDefinitions(Wr,Gr);const Yr=Wr.children,{fillStyle:Kr,strokeStyle:Zr}=parseSVGStyle(Wr,Gr);for(let Qr=0;Qr<Yr.length;Qr++){const Jr=Yr[Qr];Jr.nodeName.toLowerCase()!=="defs"&&renderChildren(Jr,Gr,Kr,Zr)}return ze}function renderChildren(Wr,ze,Gr,Yr){const Kr=Wr.children,{fillStyle:Zr,strokeStyle:Qr}=parseSVGStyle(Wr,ze);Zr&&Gr?Gr={...Gr,...Zr}:Zr&&(Gr=Zr),Qr&&Yr?Yr={...Yr,...Qr}:Qr&&(Yr=Qr);const Jr=!Gr&&!Yr;Jr&&(Gr={color:0});let ei,ti,ri,ii,si,ni,oi,li,ai,ui,fi,pi,mi,Ti,yi,_i,Ci;switch(Wr.nodeName.toLowerCase()){case"path":Ti=Wr.getAttribute("d"),Wr.getAttribute("fill-rule")==="evenodd"&&warn("SVG Evenodd fill rule not supported, your svg may render incorrectly"),yi=new GraphicsPath(Ti,!0),ze.context.path(yi),Gr&&ze.context.fill(Gr),Yr&&ze.context.stroke(Yr);break;case"circle":oi=parseSVGFloatAttribute(Wr,"cx",0),li=parseSVGFloatAttribute(Wr,"cy",0),ai=parseSVGFloatAttribute(Wr,"r",0),ze.context.ellipse(oi,li,ai,ai),Gr&&ze.context.fill(Gr),Yr&&ze.context.stroke(Yr);break;case"rect":ei=parseSVGFloatAttribute(Wr,"x",0),ti=parseSVGFloatAttribute(Wr,"y",0),_i=parseSVGFloatAttribute(Wr,"width",0),Ci=parseSVGFloatAttribute(Wr,"height",0),ui=parseSVGFloatAttribute(Wr,"rx",0),fi=parseSVGFloatAttribute(Wr,"ry",0),ui||fi?ze.context.roundRect(ei,ti,_i,Ci,ui||fi):ze.context.rect(ei,ti,_i,Ci),Gr&&ze.context.fill(Gr),Yr&&ze.context.stroke(Yr);break;case"ellipse":oi=parseSVGFloatAttribute(Wr,"cx",0),li=parseSVGFloatAttribute(Wr,"cy",0),ui=parseSVGFloatAttribute(Wr,"rx",0),fi=parseSVGFloatAttribute(Wr,"ry",0),ze.context.beginPath(),ze.context.ellipse(oi,li,ui,fi),Gr&&ze.context.fill(Gr),Yr&&ze.context.stroke(Yr);break;case"line":ri=parseSVGFloatAttribute(Wr,"x1",0),ii=parseSVGFloatAttribute(Wr,"y1",0),si=parseSVGFloatAttribute(Wr,"x2",0),ni=parseSVGFloatAttribute(Wr,"y2",0),ze.context.beginPath(),ze.context.moveTo(ri,ii),ze.context.lineTo(si,ni),Yr&&ze.context.stroke(Yr);break;case"polygon":mi=Wr.getAttribute("points"),pi=mi.match(/\d+/g).map(Bi=>parseInt(Bi,10)),ze.context.poly(pi,!0),Gr&&ze.context.fill(Gr),Yr&&ze.context.stroke(Yr);break;case"polyline":mi=Wr.getAttribute("points"),pi=mi.match(/\d+/g).map(Bi=>parseInt(Bi,10)),ze.context.poly(pi,!1),Yr&&ze.context.stroke(Yr);break;case"g":case"svg":break;default:{warn(`[SVG parser] <${Wr.nodeName}> elements unsupported`);break}}Jr&&(Gr=null);for(let Bi=0;Bi<Kr.length;Bi++)renderChildren(Kr[Bi],ze,Gr,Yr)}function isColorLike(Wr){return Color.isColorLike(Wr)}function isFillPattern(Wr){return Wr instanceof FillPattern}function isFillGradient(Wr){return Wr instanceof FillGradient}function isTexture(Wr){return Wr instanceof Texture}function handleColorLike(Wr,ze,Gr){const Yr=Color.shared.setValue(ze??0);return Wr.color=Yr.toNumber(),Wr.alpha=Yr.alpha===1?Gr.alpha:Yr.alpha,Wr.texture=Texture.WHITE,{...Gr,...Wr}}function handleTexture(Wr,ze,Gr){return Wr.texture=ze,{...Gr,...Wr}}function handleFillPattern(Wr,ze,Gr){return Wr.fill=ze,Wr.color=16777215,Wr.texture=ze.texture,Wr.matrix=ze.transform,{...Gr,...Wr}}function handleFillGradient(Wr,ze,Gr){return ze.buildGradient(),Wr.fill=ze,Wr.color=16777215,Wr.texture=ze.texture,Wr.matrix=ze.transform,Wr.textureSpace=ze.textureSpace,{...Gr,...Wr}}function handleFillObject(Wr,ze){const Gr={...ze,...Wr},Yr=Color.shared.setValue(Gr.color);return Gr.alpha*=Yr.alpha,Gr.color=Yr.toNumber(),Gr}function toFillStyle(Wr,ze){if(Wr==null)return null;const Gr={},Yr=Wr;return isColorLike(Wr)?handleColorLike(Gr,Wr,ze):isTexture(Wr)?handleTexture(Gr,Wr,ze):isFillPattern(Wr)?handleFillPattern(Gr,Wr,ze):isFillGradient(Wr)?handleFillGradient(Gr,Wr,ze):Yr.fill&&isFillPattern(Yr.fill)?handleFillPattern(Yr,Yr.fill,ze):Yr.fill&&isFillGradient(Yr.fill)?handleFillGradient(Yr,Yr.fill,ze):handleFillObject(Yr,ze)}function toStrokeStyle(Wr,ze){const{width:Gr,alignment:Yr,miterLimit:Kr,cap:Zr,join:Qr,pixelLine:Jr,...ei}=ze,ti=toFillStyle(Wr,ei);return ti?{width:Gr,alignment:Yr,miterLimit:Kr,cap:Zr,join:Qr,pixelLine:Jr,...ti}:null}const tmpPoint=new Point$1,tempMatrix$2=new Matrix,_GraphicsContext=class Ki extends EventEmitter{constructor(){super(...arguments),this.uid=uid$1("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new GraphicsPath,this._transform=new Matrix,this._fillStyle={...Ki.defaultFillStyle},this._strokeStyle={...Ki.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new Bounds,this._boundsDirty=!0}clone(){const ze=new Ki;return ze.batchMode=this.batchMode,ze.instructions=this.instructions.slice(),ze._activePath=this._activePath.clone(),ze._transform=this._transform.clone(),ze._fillStyle={...this._fillStyle},ze._strokeStyle={...this._strokeStyle},ze._stateStack=this._stateStack.slice(),ze._bounds=this._bounds.clone(),ze._boundsDirty=!0,ze}get fillStyle(){return this._fillStyle}set fillStyle(ze){this._fillStyle=toFillStyle(ze,Ki.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(ze){this._strokeStyle=toStrokeStyle(ze,Ki.defaultStrokeStyle)}setFillStyle(ze){return this._fillStyle=toFillStyle(ze,Ki.defaultFillStyle),this}setStrokeStyle(ze){return this._strokeStyle=toFillStyle(ze,Ki.defaultStrokeStyle),this}texture(ze,Gr,Yr,Kr,Zr,Qr){return this.instructions.push({action:"texture",data:{image:ze,dx:Yr||0,dy:Kr||0,dw:Zr||ze.frame.width,dh:Qr||ze.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:Gr?Color.shared.setValue(Gr).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new GraphicsPath,this}fill(ze,Gr){let Yr;const Kr=this.instructions[this.instructions.length-1];return this._tick===0&&Kr&&Kr.action==="stroke"?Yr=Kr.data.path:Yr=this._activePath.clone(),Yr?(ze!=null&&(Gr!==void 0&&typeof ze=="number"&&(deprecation(v8_0_0,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),ze={color:ze,alpha:Gr}),this._fillStyle=toFillStyle(ze,Ki.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:Yr}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:ze,y:Gr}=this._activePath.getLastPoint(Point$1.shared);this._activePath.clear(),this._activePath.moveTo(ze,Gr)}stroke(ze){let Gr;const Yr=this.instructions[this.instructions.length-1];return this._tick===0&&Yr&&Yr.action==="fill"?Gr=Yr.data.path:Gr=this._activePath.clone(),Gr?(ze!=null&&(this._strokeStyle=toStrokeStyle(ze,Ki.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:Gr}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let ze=0;ze<2;ze++){const Gr=this.instructions[this.instructions.length-1-ze],Yr=this._activePath.clone();if(Gr&&(Gr.action==="stroke"||Gr.action==="fill"))if(Gr.data.hole)Gr.data.hole.addPath(Yr);else{Gr.data.hole=Yr;break}}return this._initNextPathLocation(),this}arc(ze,Gr,Yr,Kr,Zr,Qr){this._tick++;const Jr=this._transform;return this._activePath.arc(Jr.a*ze+Jr.c*Gr+Jr.tx,Jr.b*ze+Jr.d*Gr+Jr.ty,Yr,Kr,Zr,Qr),this}arcTo(ze,Gr,Yr,Kr,Zr){this._tick++;const Qr=this._transform;return this._activePath.arcTo(Qr.a*ze+Qr.c*Gr+Qr.tx,Qr.b*ze+Qr.d*Gr+Qr.ty,Qr.a*Yr+Qr.c*Kr+Qr.tx,Qr.b*Yr+Qr.d*Kr+Qr.ty,Zr),this}arcToSvg(ze,Gr,Yr,Kr,Zr,Qr,Jr){this._tick++;const ei=this._transform;return this._activePath.arcToSvg(ze,Gr,Yr,Kr,Zr,ei.a*Qr+ei.c*Jr+ei.tx,ei.b*Qr+ei.d*Jr+ei.ty),this}bezierCurveTo(ze,Gr,Yr,Kr,Zr,Qr,Jr){this._tick++;const ei=this._transform;return this._activePath.bezierCurveTo(ei.a*ze+ei.c*Gr+ei.tx,ei.b*ze+ei.d*Gr+ei.ty,ei.a*Yr+ei.c*Kr+ei.tx,ei.b*Yr+ei.d*Kr+ei.ty,ei.a*Zr+ei.c*Qr+ei.tx,ei.b*Zr+ei.d*Qr+ei.ty,Jr),this}closePath(){var ze;return this._tick++,(ze=this._activePath)==null||ze.closePath(),this}ellipse(ze,Gr,Yr,Kr){return this._tick++,this._activePath.ellipse(ze,Gr,Yr,Kr,this._transform.clone()),this}circle(ze,Gr,Yr){return this._tick++,this._activePath.circle(ze,Gr,Yr,this._transform.clone()),this}path(ze){return this._tick++,this._activePath.addPath(ze,this._transform.clone()),this}lineTo(ze,Gr){this._tick++;const Yr=this._transform;return this._activePath.lineTo(Yr.a*ze+Yr.c*Gr+Yr.tx,Yr.b*ze+Yr.d*Gr+Yr.ty),this}moveTo(ze,Gr){this._tick++;const Yr=this._transform,Kr=this._activePath.instructions,Zr=Yr.a*ze+Yr.c*Gr+Yr.tx,Qr=Yr.b*ze+Yr.d*Gr+Yr.ty;return Kr.length===1&&Kr[0].action==="moveTo"?(Kr[0].data[0]=Zr,Kr[0].data[1]=Qr,this):(this._activePath.moveTo(Zr,Qr),this)}quadraticCurveTo(ze,Gr,Yr,Kr,Zr){this._tick++;const Qr=this._transform;return this._activePath.quadraticCurveTo(Qr.a*ze+Qr.c*Gr+Qr.tx,Qr.b*ze+Qr.d*Gr+Qr.ty,Qr.a*Yr+Qr.c*Kr+Qr.tx,Qr.b*Yr+Qr.d*Kr+Qr.ty,Zr),this}rect(ze,Gr,Yr,Kr){return this._tick++,this._activePath.rect(ze,Gr,Yr,Kr,this._transform.clone()),this}roundRect(ze,Gr,Yr,Kr,Zr){return this._tick++,this._activePath.roundRect(ze,Gr,Yr,Kr,Zr,this._transform.clone()),this}poly(ze,Gr){return this._tick++,this._activePath.poly(ze,Gr,this._transform.clone()),this}regularPoly(ze,Gr,Yr,Kr,Zr=0,Qr){return this._tick++,this._activePath.regularPoly(ze,Gr,Yr,Kr,Zr,Qr),this}roundPoly(ze,Gr,Yr,Kr,Zr,Qr){return this._tick++,this._activePath.roundPoly(ze,Gr,Yr,Kr,Zr,Qr),this}roundShape(ze,Gr,Yr,Kr){return this._tick++,this._activePath.roundShape(ze,Gr,Yr,Kr),this}filletRect(ze,Gr,Yr,Kr,Zr){return this._tick++,this._activePath.filletRect(ze,Gr,Yr,Kr,Zr),this}chamferRect(ze,Gr,Yr,Kr,Zr,Qr){return this._tick++,this._activePath.chamferRect(ze,Gr,Yr,Kr,Zr,Qr),this}star(ze,Gr,Yr,Kr,Zr=0,Qr=0){return this._tick++,this._activePath.star(ze,Gr,Yr,Kr,Zr,Qr,this._transform.clone()),this}svg(ze){return this._tick++,SVGParser(ze,this),this}restore(){const ze=this._stateStack.pop();return ze&&(this._transform=ze.transform,this._fillStyle=ze.fillStyle,this._strokeStyle=ze.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(ze){return this._transform.rotate(ze),this}scale(ze,Gr=ze){return this._transform.scale(ze,Gr),this}setTransform(ze,Gr,Yr,Kr,Zr,Qr){return ze instanceof Matrix?(this._transform.set(ze.a,ze.b,ze.c,ze.d,ze.tx,ze.ty),this):(this._transform.set(ze,Gr,Yr,Kr,Zr,Qr),this)}transform(ze,Gr,Yr,Kr,Zr,Qr){return ze instanceof Matrix?(this._transform.append(ze),this):(tempMatrix$2.set(ze,Gr,Yr,Kr,Zr,Qr),this._transform.append(tempMatrix$2),this)}translate(ze,Gr=ze){return this._transform.translate(ze,Gr),this}clear(){return this._activePath.clear(),this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const ze=this._bounds;ze.clear();for(let Gr=0;Gr<this.instructions.length;Gr++){const Yr=this.instructions[Gr],Kr=Yr.action;if(Kr==="fill"){const Zr=Yr.data;ze.addBounds(Zr.path.bounds)}else if(Kr==="texture"){const Zr=Yr.data;ze.addFrame(Zr.dx,Zr.dy,Zr.dx+Zr.dw,Zr.dy+Zr.dh,Zr.transform)}if(Kr==="stroke"){const Zr=Yr.data,Qr=Zr.style.alignment,Jr=Zr.style.width*(1-Qr),ei=Zr.path.bounds;ze.addFrame(ei.minX-Jr,ei.minY-Jr,ei.maxX+Jr,ei.maxY+Jr)}}return ze}containsPoint(ze){var Kr;if(!this.bounds.containsPoint(ze.x,ze.y))return!1;const Gr=this.instructions;let Yr=!1;for(let Zr=0;Zr<Gr.length;Zr++){const Qr=Gr[Zr],Jr=Qr.data,ei=Jr.path;if(!Qr.action||!ei)continue;const ti=Jr.style,ri=ei.shapePath.shapePrimitives;for(let ii=0;ii<ri.length;ii++){const si=ri[ii].shape;if(!ti||!si)continue;const ni=ri[ii].transform,oi=ni?ni.applyInverse(ze,tmpPoint):ze;if(Qr.action==="fill")Yr=si.contains(oi.x,oi.y);else{const ai=ti;Yr=si.strokeContains(oi.x,oi.y,ai.width,ai.alignment)}const li=Jr.hole;if(li){const ai=(Kr=li.shapePath)==null?void 0:Kr.shapePrimitives;if(ai)for(let ui=0;ui<ai.length;ui++)ai[ui].shape.contains(oi.x,oi.y)&&(Yr=!1)}if(Yr)return!0}}return Yr}destroy(ze=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof ze=="boolean"?ze:ze==null?void 0:ze.texture){const Yr=typeof ze=="boolean"?ze:ze==null?void 0:ze.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(Yr),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(Yr)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};_GraphicsContext.defaultFillStyle={color:16777215,alpha:1,texture:Texture.WHITE,matrix:null,fill:null,textureSpace:"local"};_GraphicsContext.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:Texture.WHITE,matrix:null,fill:null,textureSpace:"local",pixelLine:!1};let GraphicsContext=_GraphicsContext;const valuesToIterateForKeys=["align","breakWords","cssOverrides","fontVariant","fontWeight","leading","letterSpacing","lineHeight","padding","textBaseline","trim","whiteSpace","wordWrap","wordWrapWidth","fontFamily","fontStyle","fontSize"];function generateTextStyleKey(Wr){const ze=[];let Gr=0;for(let Yr=0;Yr<valuesToIterateForKeys.length;Yr++){const Kr=`_${valuesToIterateForKeys[Yr]}`;ze[Gr++]=Wr[Kr]}return Gr=addFillStyleKey(Wr._fill,ze,Gr),Gr=addStokeStyleKey(Wr._stroke,ze,Gr),Gr=addDropShadowKey(Wr.dropShadow,ze,Gr),ze.join("-")}function addFillStyleKey(Wr,ze,Gr){var Yr;return Wr&&(ze[Gr++]=Wr.color,ze[Gr++]=Wr.alpha,ze[Gr++]=(Yr=Wr.fill)==null?void 0:Yr.styleKey),Gr}function addStokeStyleKey(Wr,ze,Gr){return Wr&&(Gr=addFillStyleKey(Wr,ze,Gr),ze[Gr++]=Wr.width,ze[Gr++]=Wr.alignment,ze[Gr++]=Wr.cap,ze[Gr++]=Wr.join,ze[Gr++]=Wr.miterLimit),Gr}function addDropShadowKey(Wr,ze,Gr){return Wr&&(ze[Gr++]=Wr.alpha,ze[Gr++]=Wr.angle,ze[Gr++]=Wr.blur,ze[Gr++]=Wr.distance,ze[Gr++]=Color.shared.setValue(Wr.color).toNumber()),Gr}const _TextStyle=class es extends EventEmitter{constructor(ze={}){super(),convertV7Tov8Style(ze);const Gr={...es.defaultTextStyle,...ze};for(const Yr in Gr){const Kr=Yr;this[Kr]=Gr[Yr]}this.update()}get align(){return this._align}set align(ze){this._align=ze,this.update()}get breakWords(){return this._breakWords}set breakWords(ze){this._breakWords=ze,this.update()}get dropShadow(){return this._dropShadow}set dropShadow(ze){ze!==null&&typeof ze=="object"?this._dropShadow=this._createProxy({...es.defaultDropShadow,...ze}):this._dropShadow=ze?this._createProxy({...es.defaultDropShadow}):null,this.update()}get fontFamily(){return this._fontFamily}set fontFamily(ze){this._fontFamily=ze,this.update()}get fontSize(){return this._fontSize}set fontSize(ze){typeof ze=="string"?this._fontSize=parseInt(ze,10):this._fontSize=ze,this.update()}get fontStyle(){return this._fontStyle}set fontStyle(ze){this._fontStyle=ze.toLowerCase(),this.update()}get fontVariant(){return this._fontVariant}set fontVariant(ze){this._fontVariant=ze,this.update()}get fontWeight(){return this._fontWeight}set fontWeight(ze){this._fontWeight=ze,this.update()}get leading(){return this._leading}set leading(ze){this._leading=ze,this.update()}get letterSpacing(){return this._letterSpacing}set letterSpacing(ze){this._letterSpacing=ze,this.update()}get lineHeight(){return this._lineHeight}set lineHeight(ze){this._lineHeight=ze,this.update()}get padding(){return this._padding}set padding(ze){this._padding=ze,this.update()}get trim(){return this._trim}set trim(ze){this._trim=ze,this.update()}get textBaseline(){return this._textBaseline}set textBaseline(ze){this._textBaseline=ze,this.update()}get whiteSpace(){return this._whiteSpace}set whiteSpace(ze){this._whiteSpace=ze,this.update()}get wordWrap(){return this._wordWrap}set wordWrap(ze){this._wordWrap=ze,this.update()}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(ze){this._wordWrapWidth=ze,this.update()}get fill(){return this._originalFill}set fill(ze){ze!==this._originalFill&&(this._originalFill=ze,this._isFillStyle(ze)&&(this._originalFill=this._createProxy({...GraphicsContext.defaultFillStyle,...ze},()=>{this._fill=toFillStyle({...this._originalFill},GraphicsContext.defaultFillStyle)})),this._fill=toFillStyle(ze===0?"black":ze,GraphicsContext.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(ze){ze!==this._originalStroke&&(this._originalStroke=ze,this._isFillStyle(ze)&&(this._originalStroke=this._createProxy({...GraphicsContext.defaultStrokeStyle,...ze},()=>{this._stroke=toStrokeStyle({...this._originalStroke},GraphicsContext.defaultStrokeStyle)})),this._stroke=toStrokeStyle(ze,GraphicsContext.defaultStrokeStyle),this.update())}_generateKey(){return this._styleKey=generateTextStyleKey(this),this._styleKey}update(){this._styleKey=null,this.emit("update",this)}reset(){const ze=es.defaultTextStyle;for(const Gr in ze)this[Gr]=ze[Gr]}get styleKey(){return this._styleKey||this._generateKey()}clone(){return new es({align:this.align,breakWords:this.breakWords,dropShadow:this._dropShadow?{...this._dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth})}destroy(ze=!1){var Yr,Kr,Zr,Qr;if(this.removeAllListeners(),typeof ze=="boolean"?ze:ze==null?void 0:ze.texture){const Jr=typeof ze=="boolean"?ze:ze==null?void 0:ze.textureSource;(Yr=this._fill)!=null&&Yr.texture&&this._fill.texture.destroy(Jr),(Kr=this._originalFill)!=null&&Kr.texture&&this._originalFill.texture.destroy(Jr),(Zr=this._stroke)!=null&&Zr.texture&&this._stroke.texture.destroy(Jr),(Qr=this._originalStroke)!=null&&Qr.texture&&this._originalStroke.texture.destroy(Jr)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}_createProxy(ze,Gr){return new Proxy(ze,{set:(Yr,Kr,Zr)=>(Yr[Kr]=Zr,Gr==null||Gr(Kr,Zr),this.update(),!0)})}_isFillStyle(ze){return(ze??null)!==null&&!(Color.isColorLike(ze)||ze instanceof FillGradient||ze instanceof FillPattern)}};_TextStyle.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5};_TextStyle.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let TextStyle=_TextStyle;function convertV7Tov8Style(Wr){const ze=Wr;if(typeof ze.dropShadow=="boolean"&&ze.dropShadow){const Gr=TextStyle.defaultDropShadow;Wr.dropShadow={alpha:ze.dropShadowAlpha??Gr.alpha,angle:ze.dropShadowAngle??Gr.angle,blur:ze.dropShadowBlur??Gr.blur,color:ze.dropShadowColor??Gr.color,distance:ze.dropShadowDistance??Gr.distance}}if(ze.strokeThickness!==void 0){deprecation(v8_0_0,"strokeThickness is now a part of stroke");const Gr=ze.stroke;let Yr={};if(Color.isColorLike(Gr))Yr.color=Gr;else if(Gr instanceof FillGradient||Gr instanceof FillPattern)Yr.fill=Gr;else if(Object.hasOwnProperty.call(Gr,"color")||Object.hasOwnProperty.call(Gr,"fill"))Yr=Gr;else throw new Error("Invalid stroke value.");Wr.stroke={...Yr,width:ze.strokeThickness}}if(Array.isArray(ze.fillGradientStops)){deprecation(v8_0_0,"gradient fill is now a fill pattern: `new FillGradient(...)`");let Gr;Wr.fontSize==null?Wr.fontSize=TextStyle.defaultTextStyle.fontSize:typeof Wr.fontSize=="string"?Gr=parseInt(Wr.fontSize,10):Gr=Wr.fontSize;const Yr=new FillGradient({start:{x:0,y:0},end:{x:0,y:(Gr||0)*1.7}}),Kr=ze.fillGradientStops.map(Zr=>Color.shared.setValue(Zr).toNumber());Kr.forEach((Zr,Qr)=>{const Jr=Qr/(Kr.length-1);Yr.addColorStop(Jr,Zr)}),Wr.fill={fill:Yr}}}class CanvasPoolClass{constructor(ze){this._canvasPool=Object.create(null),this.canvasOptions=ze||{},this.enableFullScreen=!1}_createCanvasAndContext(ze,Gr){const Yr=DOMAdapter.get().createCanvas();Yr.width=ze,Yr.height=Gr;const Kr=Yr.getContext("2d");return{canvas:Yr,context:Kr}}getOptimalCanvasAndContext(ze,Gr,Yr=1){ze=Math.ceil(ze*Yr-1e-6),Gr=Math.ceil(Gr*Yr-1e-6),ze=nextPow2(ze),Gr=nextPow2(Gr);const Kr=(ze<<17)+(Gr<<1);this._canvasPool[Kr]||(this._canvasPool[Kr]=[]);let Zr=this._canvasPool[Kr].pop();return Zr||(Zr=this._createCanvasAndContext(ze,Gr)),Zr}returnCanvasAndContext(ze){const Gr=ze.canvas,{width:Yr,height:Kr}=Gr,Zr=(Yr<<17)+(Kr<<1);ze.context.clearRect(0,0,Yr,Kr),this._canvasPool[Zr].push(ze)}clear(){this._canvasPool={}}}const CanvasPool=new CanvasPoolClass,genericFontFamilies=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function fontStringFromTextStyle(Wr){const ze=typeof Wr.fontSize=="number"?`${Wr.fontSize}px`:Wr.fontSize;let Gr=Wr.fontFamily;Array.isArray(Wr.fontFamily)||(Gr=Wr.fontFamily.split(","));for(let Yr=Gr.length-1;Yr>=0;Yr--){let Kr=Gr[Yr].trim();!/([\"\'])[^\'\"]+\1/.test(Kr)&&!genericFontFamilies.includes(Kr)&&(Kr=`"${Kr}"`),Gr[Yr]=Kr}return`${Wr.fontStyle} ${Wr.fontVariant} ${Wr.fontWeight} ${ze} ${Gr.join(",")}`}const contextSettings={willReadFrequently:!0},_CanvasTextMetrics=class Ai{static get experimentalLetterSpacingSupported(){let ze=Ai._experimentalLetterSpacingSupported;if(ze!==void 0){const Gr=DOMAdapter.get().getCanvasRenderingContext2D().prototype;ze=Ai._experimentalLetterSpacingSupported="letterSpacing"in Gr||"textLetterSpacing"in Gr}return ze}constructor(ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti){this.text=ze,this.style=Gr,this.width=Yr,this.height=Kr,this.lines=Zr,this.lineWidths=Qr,this.lineHeight=Jr,this.maxLineWidth=ei,this.fontProperties=ti}static measureText(ze=" ",Gr,Yr=Ai._canvas,Kr=Gr.wordWrap){var fi;const Zr=`${ze}:${Gr.styleKey}`;if(Ai._measurementCache[Zr])return Ai._measurementCache[Zr];const Qr=fontStringFromTextStyle(Gr),Jr=Ai.measureFont(Qr);Jr.fontSize===0&&(Jr.fontSize=Gr.fontSize,Jr.ascent=Gr.fontSize);const ei=Ai.__context;ei.font=Qr;const ri=(Kr?Ai._wordWrap(ze,Gr,Yr):ze).split(/(?:\r\n|\r|\n)/),ii=new Array(ri.length);let si=0;for(let pi=0;pi<ri.length;pi++){const mi=Ai._measureText(ri[pi],Gr.letterSpacing,ei);ii[pi]=mi,si=Math.max(si,mi)}const ni=((fi=Gr._stroke)==null?void 0:fi.width)||0;let oi=si+ni;Gr.dropShadow&&(oi+=Gr.dropShadow.distance);const li=Gr.lineHeight||Jr.fontSize;let ai=Math.max(li,Jr.fontSize+ni)+(ri.length-1)*(li+Gr.leading);return Gr.dropShadow&&(ai+=Gr.dropShadow.distance),new Ai(ze,Gr,oi,ai,ri,ii,li+Gr.leading,si,Jr)}static _measureText(ze,Gr,Yr){let Kr=!1;Ai.experimentalLetterSpacingSupported&&(Ai.experimentalLetterSpacing?(Yr.letterSpacing=`${Gr}px`,Yr.textLetterSpacing=`${Gr}px`,Kr=!0):(Yr.letterSpacing="0px",Yr.textLetterSpacing="0px"));const Zr=Yr.measureText(ze);let Qr=Zr.width;const Jr=-Zr.actualBoundingBoxLeft;let ti=Zr.actualBoundingBoxRight-Jr;if(Qr>0)if(Kr)Qr-=Gr,ti-=Gr;else{const ri=(Ai.graphemeSegmenter(ze).length-1)*Gr;Qr+=ri,ti+=ri}return Math.max(Qr,ti)}static _wordWrap(ze,Gr,Yr=Ai._canvas){const Kr=Yr.getContext("2d",contextSettings);let Zr=0,Qr="",Jr="";const ei=Object.create(null),{letterSpacing:ti,whiteSpace:ri}=Gr,ii=Ai._collapseSpaces(ri),si=Ai._collapseNewlines(ri);let ni=!ii;const oi=Gr.wordWrapWidth+ti,li=Ai._tokenize(ze);for(let ai=0;ai<li.length;ai++){let ui=li[ai];if(Ai._isNewline(ui)){if(!si){Jr+=Ai._addLine(Qr),ni=!ii,Qr="",Zr=0;continue}ui=" "}if(ii){const pi=Ai.isBreakingSpace(ui),mi=Ai.isBreakingSpace(Qr[Qr.length-1]);if(pi&&mi)continue}const fi=Ai._getFromCache(ui,ti,ei,Kr);if(fi>oi)if(Qr!==""&&(Jr+=Ai._addLine(Qr),Qr="",Zr=0),Ai.canBreakWords(ui,Gr.breakWords)){const pi=Ai.wordWrapSplit(ui);for(let mi=0;mi<pi.length;mi++){let Ti=pi[mi],yi=Ti,_i=1;for(;pi[mi+_i];){const Bi=pi[mi+_i];if(!Ai.canBreakChars(yi,Bi,ui,mi,Gr.breakWords))Ti+=Bi;else break;yi=Bi,_i++}mi+=_i-1;const Ci=Ai._getFromCache(Ti,ti,ei,Kr);Ci+Zr>oi&&(Jr+=Ai._addLine(Qr),ni=!1,Qr="",Zr=0),Qr+=Ti,Zr+=Ci}}else{Qr.length>0&&(Jr+=Ai._addLine(Qr),Qr="",Zr=0);const pi=ai===li.length-1;Jr+=Ai._addLine(ui,!pi),ni=!1,Qr="",Zr=0}else fi+Zr>oi&&(ni=!1,Jr+=Ai._addLine(Qr),Qr="",Zr=0),(Qr.length>0||!Ai.isBreakingSpace(ui)||ni)&&(Qr+=ui,Zr+=fi)}return Jr+=Ai._addLine(Qr,!1),Jr}static _addLine(ze,Gr=!0){return ze=Ai._trimRight(ze),ze=Gr?`${ze}
`:ze,ze}static _getFromCache(ze,Gr,Yr,Kr){let Zr=Yr[ze];return typeof Zr!="number"&&(Zr=Ai._measureText(ze,Gr,Kr)+Gr,Yr[ze]=Zr),Zr}static _collapseSpaces(ze){return ze==="normal"||ze==="pre-line"}static _collapseNewlines(ze){return ze==="normal"}static _trimRight(ze){if(typeof ze!="string")return"";for(let Gr=ze.length-1;Gr>=0;Gr--){const Yr=ze[Gr];if(!Ai.isBreakingSpace(Yr))break;ze=ze.slice(0,-1)}return ze}static _isNewline(ze){return typeof ze!="string"?!1:Ai._newlines.includes(ze.charCodeAt(0))}static isBreakingSpace(ze,Gr){return typeof ze!="string"?!1:Ai._breakingSpaces.includes(ze.charCodeAt(0))}static _tokenize(ze){const Gr=[];let Yr="";if(typeof ze!="string")return Gr;for(let Kr=0;Kr<ze.length;Kr++){const Zr=ze[Kr],Qr=ze[Kr+1];if(Ai.isBreakingSpace(Zr,Qr)||Ai._isNewline(Zr)){Yr!==""&&(Gr.push(Yr),Yr=""),Gr.push(Zr);continue}Yr+=Zr}return Yr!==""&&Gr.push(Yr),Gr}static canBreakWords(ze,Gr){return Gr}static canBreakChars(ze,Gr,Yr,Kr,Zr){return!0}static wordWrapSplit(ze){return Ai.graphemeSegmenter(ze)}static measureFont(ze){if(Ai._fonts[ze])return Ai._fonts[ze];const Gr=Ai._context;Gr.font=ze;const Yr=Gr.measureText(Ai.METRICS_STRING+Ai.BASELINE_SYMBOL),Kr={ascent:Yr.actualBoundingBoxAscent,descent:Yr.actualBoundingBoxDescent,fontSize:Yr.actualBoundingBoxAscent+Yr.actualBoundingBoxDescent};return Ai._fonts[ze]=Kr,Kr}static clearMetrics(ze=""){ze?delete Ai._fonts[ze]:Ai._fonts={}}static get _canvas(){if(!Ai.__canvas){let ze;try{const Gr=new OffscreenCanvas(0,0),Yr=Gr.getContext("2d",contextSettings);if(Yr!=null&&Yr.measureText)return Ai.__canvas=Gr,Gr;ze=DOMAdapter.get().createCanvas()}catch{ze=DOMAdapter.get().createCanvas()}ze.width=ze.height=10,Ai.__canvas=ze}return Ai.__canvas}static get _context(){return Ai.__context||(Ai.__context=Ai._canvas.getContext("2d",contextSettings)),Ai.__context}};_CanvasTextMetrics.METRICS_STRING="|q";_CanvasTextMetrics.BASELINE_SYMBOL="M";_CanvasTextMetrics.BASELINE_MULTIPLIER=1.4;_CanvasTextMetrics.HEIGHT_MULTIPLIER=2;_CanvasTextMetrics.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const Wr=new Intl.Segmenter;return ze=>[...Wr.segment(ze)].map(Gr=>Gr.segment)}return Wr=>[...Wr]})();_CanvasTextMetrics.experimentalLetterSpacing=!1;_CanvasTextMetrics._fonts={};_CanvasTextMetrics._newlines=[10,13];_CanvasTextMetrics._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288];_CanvasTextMetrics._measurementCache={};let CanvasTextMetrics=_CanvasTextMetrics;const PRECISION=1e5;function getCanvasFillStyle(Wr,ze,Gr,Yr=0){if(Wr.texture===Texture.WHITE&&!Wr.fill)return Color.shared.setValue(Wr.color).setAlpha(Wr.alpha??1).toHexa();if(Wr.fill){if(Wr.fill instanceof FillPattern){const Kr=Wr.fill,Zr=ze.createPattern(Kr.texture.source.resource,"repeat"),Qr=Kr.transform.copyTo(Matrix.shared);return Qr.scale(Kr.texture.frame.width,Kr.texture.frame.height),Zr.setTransform(Qr),Zr}else if(Wr.fill instanceof FillGradient){const Kr=Wr.fill,Zr=Kr.type==="linear",Qr=Kr.textureSpace==="local";let Jr=1,ei=1;Qr&&Gr&&(Jr=Gr.width+Yr,ei=Gr.height+Yr);let ti,ri=!1;if(Zr){const{start:ii,end:si}=Kr;ti=ze.createLinearGradient(ii.x*Jr,ii.y*ei,si.x*Jr,si.y*ei),ri=Math.abs(si.x-ii.x)<Math.abs((si.y-ii.y)*.1)}else{const{center:ii,innerRadius:si,outerCenter:ni,outerRadius:oi}=Kr;ti=ze.createRadialGradient(ii.x*Jr,ii.y*ei,si*Jr,ni.x*Jr,ni.y*ei,oi*Jr)}if(ri&&Qr&&Gr){const ii=Gr.lineHeight/ei;for(let si=0;si<Gr.lines.length;si++){const ni=(si*Gr.lineHeight+Yr/2)/ei;Kr.colorStops.forEach(oi=>{const li=ni+oi.offset*ii;ti.addColorStop(Math.floor(li*PRECISION)/PRECISION,Color.shared.setValue(oi.color).toHex())})}}else Kr.colorStops.forEach(ii=>{ti.addColorStop(ii.offset,Color.shared.setValue(ii.color).toHex())});return ti}}else{const Kr=ze.createPattern(Wr.texture.source.resource,"repeat"),Zr=Wr.matrix.copyTo(Matrix.shared);return Zr.scale(Wr.texture.frame.width,Wr.texture.frame.height),Kr.setTransform(Zr),Kr}return warn("FillStyle not recognised",Wr),"red"}function resolveCharacters(Wr){if(Wr==="")return[];typeof Wr=="string"&&(Wr=[Wr]);const ze=[];for(let Gr=0,Yr=Wr.length;Gr<Yr;Gr++){const Kr=Wr[Gr];if(Array.isArray(Kr)){if(Kr.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${Kr.length}.`);if(Kr[0].length===0||Kr[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const Zr=Kr[0].charCodeAt(0),Qr=Kr[1].charCodeAt(0);if(Qr<Zr)throw new Error("[BitmapFont]: Invalid character range.");for(let Jr=Zr,ei=Qr;Jr<=ei;Jr++)ze.push(String.fromCharCode(Jr))}else ze.push(...Array.from(Kr))}if(ze.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return ze}const _DynamicBitmapFont=class Ms extends AbstractBitmapFont{constructor(ze){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const Gr={...Ms.defaultOptions,...ze};this._textureSize=Gr.textureSize,this._mipmap=Gr.mipmap;const Yr=Gr.style.clone();Gr.overrideFill&&(Yr._fill.color=16777215,Yr._fill.alpha=1,Yr._fill.texture=Texture.WHITE,Yr._fill.fill=null),this.applyFillAsTint=Gr.overrideFill;const Kr=Yr.fontSize;Yr.fontSize=this.baseMeasurementFontSize;const Zr=fontStringFromTextStyle(Yr);Gr.overrideSize?Yr._stroke&&(Yr._stroke.width*=this.baseRenderedFontSize/Kr):Yr.fontSize=this.baseRenderedFontSize=Kr,this._style=Yr,this._skipKerning=Gr.skipKerning??!1,this.resolution=Gr.resolution??1,this._padding=Gr.padding??4,this.fontMetrics=CanvasTextMetrics.measureFont(Zr),this.lineHeight=Yr.lineHeight||this.fontMetrics.fontSize||Yr.fontSize}ensureCharacters(ze){var ai,ui;const Gr=resolveCharacters(ze).filter(fi=>!this._currentChars.includes(fi)).filter((fi,pi,mi)=>mi.indexOf(fi)===pi);if(!Gr.length)return;this._currentChars=[...this._currentChars,...Gr];let Yr;this._currentPageIndex===-1?Yr=this._nextPage():Yr=this.pages[this._currentPageIndex];let{canvas:Kr,context:Zr}=Yr.canvasAndContext,Qr=Yr.texture.source;const Jr=this._style;let ei=this._currentX,ti=this._currentY;const ri=this.baseRenderedFontSize/this.baseMeasurementFontSize,ii=this._padding*ri;let si=0,ni=!1;const oi=Kr.width/this.resolution,li=Kr.height/this.resolution;for(let fi=0;fi<Gr.length;fi++){const pi=Gr[fi],mi=CanvasTextMetrics.measureText(pi,Jr,Kr,!1);mi.lineHeight=mi.height;const Ti=mi.width*ri,yi=Math.ceil((Jr.fontStyle==="italic"?2:1)*Ti),_i=mi.height*ri,Ci=yi+ii*2,Bi=_i+ii*2;if(ni=!1,pi!==`
`&&pi!=="\r"&&pi!=="	"&&pi!==" "&&(ni=!0,si=Math.ceil(Math.max(Bi,si))),ei+Ci>oi&&(ti+=si,si=Bi,ei=0,ti+si>li)){Qr.update();const Si=this._nextPage();Kr=Si.canvasAndContext.canvas,Zr=Si.canvasAndContext.context,Qr=Si.texture.source,ti=0}const Pi=Ti/ri-(((ai=Jr.dropShadow)==null?void 0:ai.distance)??0)-(((ui=Jr._stroke)==null?void 0:ui.width)??0);if(this.chars[pi]={id:pi.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:Pi,kerning:{}},ni){this._drawGlyph(Zr,mi,ei+ii,ti+ii,ri,Jr);const Si=Qr.width*ri,Mi=Qr.height*ri,ki=new Rectangle(ei/Si*Qr.width,ti/Mi*Qr.height,Ci/Si*Qr.width,Bi/Mi*Qr.height);this.chars[pi].texture=new Texture({source:Qr,frame:ki}),ei+=Math.ceil(Ci)}}Qr.update(),this._currentX=ei,this._currentY=ti,this._skipKerning&&this._applyKerning(Gr,Zr)}get pageTextures(){return deprecation(v8_0_0,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(ze,Gr){const Yr=this._measureCache;for(let Kr=0;Kr<ze.length;Kr++){const Zr=ze[Kr];for(let Qr=0;Qr<this._currentChars.length;Qr++){const Jr=this._currentChars[Qr];let ei=Yr[Zr];ei||(ei=Yr[Zr]=Gr.measureText(Zr).width);let ti=Yr[Jr];ti||(ti=Yr[Jr]=Gr.measureText(Jr).width);let ri=Gr.measureText(Zr+Jr).width,ii=ri-(ei+ti);ii&&(this.chars[Zr].kerning[Jr]=ii),ri=Gr.measureText(Zr+Jr).width,ii=ri-(ei+ti),ii&&(this.chars[Jr].kerning[Zr]=ii)}}}_nextPage(){this._currentPageIndex++;const ze=this.resolution,Gr=CanvasPool.getOptimalCanvasAndContext(this._textureSize,this._textureSize,ze);this._setupContext(Gr.context,this._style,ze);const Yr=ze*(this.baseRenderedFontSize/this.baseMeasurementFontSize),Kr=new Texture({source:new ImageSource({resource:Gr.canvas,resolution:Yr,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})}),Zr={canvasAndContext:Gr,texture:Kr};return this.pages[this._currentPageIndex]=Zr,Zr}_setupContext(ze,Gr,Yr){Gr.fontSize=this.baseRenderedFontSize,ze.scale(Yr,Yr),ze.font=fontStringFromTextStyle(Gr),Gr.fontSize=this.baseMeasurementFontSize,ze.textBaseline=Gr.textBaseline;const Kr=Gr._stroke,Zr=(Kr==null?void 0:Kr.width)??0;if(Kr&&(ze.lineWidth=Zr,ze.lineJoin=Kr.join,ze.miterLimit=Kr.miterLimit,ze.strokeStyle=getCanvasFillStyle(Kr,ze)),Gr._fill&&(ze.fillStyle=getCanvasFillStyle(Gr._fill,ze)),Gr.dropShadow){const Qr=Gr.dropShadow,Jr=Color.shared.setValue(Qr.color).toArray(),ei=Qr.blur*Yr,ti=Qr.distance*Yr;ze.shadowColor=`rgba(${Jr[0]*255},${Jr[1]*255},${Jr[2]*255},${Qr.alpha})`,ze.shadowBlur=ei,ze.shadowOffsetX=Math.cos(Qr.angle)*ti,ze.shadowOffsetY=Math.sin(Qr.angle)*ti}else ze.shadowColor="black",ze.shadowBlur=0,ze.shadowOffsetX=0,ze.shadowOffsetY=0}_drawGlyph(ze,Gr,Yr,Kr,Zr,Qr){const Jr=Gr.text,ei=Gr.fontProperties,ti=Qr._stroke,ri=((ti==null?void 0:ti.width)??0)*Zr,ii=Yr+ri/2,si=Kr-ri/2,ni=ei.descent*Zr,oi=Gr.lineHeight*Zr;Qr.stroke&&ri&&ze.strokeText(Jr,ii,si+oi-ni),Qr._fill&&ze.fillText(Jr,ii,si+oi-ni)}destroy(){super.destroy();for(let ze=0;ze<this.pages.length;ze++){const{canvasAndContext:Gr,texture:Yr}=this.pages[ze];CanvasPool.returnCanvasAndContext(Gr),Yr.destroy(!0)}this.pages=null}};_DynamicBitmapFont.defaultOptions={textureSize:512,style:new TextStyle,mipmap:!0};let DynamicBitmapFont=_DynamicBitmapFont;function getBitmapTextLayout(Wr,ze,Gr,Yr){const Kr={width:0,height:0,offsetY:0,scale:ze.fontSize/Gr.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};Kr.offsetY=Gr.baseLineOffset;let Zr=Kr.lines[0],Qr=null,Jr=!0;const ei={width:0,start:0,index:0,positions:[],chars:[]},ti=oi=>{const li=Zr.width;for(let ai=0;ai<ei.index;ai++){const ui=oi.positions[ai];Zr.chars.push(oi.chars[ai]),Zr.charPositions.push(ui+li)}Zr.width+=oi.width,Jr=!1,ei.width=0,ei.index=0,ei.chars.length=0},ri=()=>{let oi=Zr.chars.length-1;if(Yr){let li=Zr.chars[oi];for(;li===" ";)Zr.width-=Gr.chars[li].xAdvance,li=Zr.chars[--oi]}Kr.width=Math.max(Kr.width,Zr.width),Zr={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},Jr=!0,Kr.lines.push(Zr),Kr.height+=Gr.lineHeight},ii=Gr.baseMeasurementFontSize/ze.fontSize,si=ze.letterSpacing*ii,ni=ze.wordWrapWidth*ii;for(let oi=0;oi<Wr.length+1;oi++){let li;const ai=oi===Wr.length;ai||(li=Wr[oi]);const ui=Gr.chars[li]||Gr.chars[" "];if(/(?:\s)/.test(li)||li==="\r"||li===`
`||ai){if(!Jr&&ze.wordWrap&&Zr.width+ei.width-si>ni?(ri(),ti(ei),ai||Zr.charPositions.push(0)):(ei.start=Zr.width,ti(ei),ai||Zr.charPositions.push(0)),li==="\r"||li===`
`)Zr.width!==0&&ri();else if(!ai){const Ti=ui.xAdvance+(ui.kerning[Qr]||0)+si;Zr.width+=Ti,Zr.spaceWidth=Ti,Zr.spacesIndex.push(Zr.charPositions.length),Zr.chars.push(li)}}else{const mi=ui.kerning[Qr]||0,Ti=ui.xAdvance+mi+si;ei.positions[ei.index++]=ei.width+mi,ei.chars.push(li),ei.width+=Ti}Qr=li}return ri(),ze.align==="center"?alignCenter(Kr):ze.align==="right"?alignRight(Kr):ze.align==="justify"&&alignJustify(Kr),Kr}function alignCenter(Wr){for(let ze=0;ze<Wr.lines.length;ze++){const Gr=Wr.lines[ze],Yr=Wr.width/2-Gr.width/2;for(let Kr=0;Kr<Gr.charPositions.length;Kr++)Gr.charPositions[Kr]+=Yr}}function alignRight(Wr){for(let ze=0;ze<Wr.lines.length;ze++){const Gr=Wr.lines[ze],Yr=Wr.width-Gr.width;for(let Kr=0;Kr<Gr.charPositions.length;Kr++)Gr.charPositions[Kr]+=Yr}}function alignJustify(Wr){const ze=Wr.width;for(let Gr=0;Gr<Wr.lines.length;Gr++){const Yr=Wr.lines[Gr];let Kr=0,Zr=Yr.spacesIndex[Kr++],Qr=0;const Jr=Yr.spacesIndex.length,ti=(ze-Yr.width)/Jr;for(let ri=0;ri<Yr.charPositions.length;ri++)ri===Zr&&(Zr=Yr.spacesIndex[Kr++],Qr+=ti),Yr.charPositions[ri]+=Qr}}let fontCount=0;class BitmapFontManagerClass{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(ze,Gr){var Qr;let Yr=`${Gr.fontFamily}-bitmap`,Kr=!0;if(Gr._fill.fill&&!Gr._stroke)Yr+=Gr._fill.fill.styleKey,Kr=!1;else if(Gr._stroke||Gr.dropShadow){let Jr=Gr.styleKey;Jr=Jr.substring(0,Jr.lastIndexOf("-")),Yr=`${Jr}-bitmap`,Kr=!1}if(!Cache.has(Yr)){const Jr=new DynamicBitmapFont({style:Gr,overrideFill:Kr,overrideSize:!0,...this.defaultOptions});fontCount++,fontCount>50&&warn("BitmapText",`You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),Jr.once("destroy",()=>{fontCount--,Cache.remove(Yr)}),Cache.set(Yr,Jr)}const Zr=Cache.get(Yr);return(Qr=Zr.ensureCharacters)==null||Qr.call(Zr,ze),Zr}getLayout(ze,Gr,Yr=!0){const Kr=this.getFont(ze,Gr);return getBitmapTextLayout([...ze],Gr,Kr,Yr)}measureText(ze,Gr,Yr=!0){return this.getLayout(ze,Gr,Yr)}install(...ze){var ti,ri,ii,si;let Gr=ze[0];typeof Gr=="string"&&(Gr={name:Gr,style:ze[1],chars:(ti=ze[2])==null?void 0:ti.chars,resolution:(ri=ze[2])==null?void 0:ri.resolution,padding:(ii=ze[2])==null?void 0:ii.padding,skipKerning:(si=ze[2])==null?void 0:si.skipKerning},deprecation(v8_0_0,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const Yr=Gr==null?void 0:Gr.name;if(!Yr)throw new Error("[BitmapFontManager] Property `name` is required.");Gr={...this.defaultOptions,...Gr};const Kr=Gr.style,Zr=Kr instanceof TextStyle?Kr:new TextStyle(Kr),Qr=Zr._fill.fill!==null&&Zr._fill.fill!==void 0,Jr=new DynamicBitmapFont({style:Zr,overrideFill:Qr,skipKerning:Gr.skipKerning,padding:Gr.padding,resolution:Gr.resolution,overrideSize:!1}),ei=resolveCharacters(Gr.chars);return Jr.ensureCharacters(ei.join("")),Cache.set(`${Yr}-bitmap`,Jr),Jr.once("destroy",()=>Cache.remove(`${Yr}-bitmap`)),Jr}uninstall(ze){const Gr=`${ze}-bitmap`,Yr=Cache.get(Gr);Yr&&Yr.destroy()}}const BitmapFontManager=new BitmapFontManagerClass;class BitmapFont extends AbstractBitmapFont{constructor(ze,Gr){super();const{textures:Yr,data:Kr}=ze;Object.keys(Kr.pages).forEach(Zr=>{const Qr=Kr.pages[parseInt(Zr,10)],Jr=Yr[Qr.id];this.pages.push({texture:Jr})}),Object.keys(Kr.chars).forEach(Zr=>{const Qr=Kr.chars[Zr],{frame:Jr,source:ei}=Yr[Qr.page],ti=new Rectangle(Qr.x+Jr.x,Qr.y+Jr.y,Qr.width,Qr.height),ri=new Texture({source:ei,frame:ti});this.chars[Zr]={id:Zr.codePointAt(0),xOffset:Qr.xOffset,yOffset:Qr.yOffset,xAdvance:Qr.xAdvance,kerning:Qr.kerning??{},texture:ri}}),this.baseRenderedFontSize=Kr.fontSize,this.baseMeasurementFontSize=Kr.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:Kr.fontSize},this.baseLineOffset=Kr.baseLineOffset,this.lineHeight=Kr.lineHeight,this.fontFamily=Kr.fontFamily,this.distanceField=Kr.distanceField??{type:"none",range:0},this.url=Gr}destroy(){super.destroy();for(let ze=0;ze<this.pages.length;ze++){const{texture:Gr}=this.pages[ze];Gr.destroy(!0)}this.pages=null}static install(ze){BitmapFontManager.install(ze)}static uninstall(ze){BitmapFontManager.uninstall(ze)}}const bitmapFontTextParser={test(Wr){return typeof Wr=="string"&&Wr.startsWith("info face=")},parse(Wr){const ze=Wr.match(/^[a-z]+\s+.+$/gm),Gr={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const ii in ze){const si=ze[ii].match(/^[a-z]+/gm)[0],ni=ze[ii].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),oi={};for(const li in ni){const ai=ni[li].split("="),ui=ai[0],fi=ai[1].replace(/"/gm,""),pi=parseFloat(fi),mi=isNaN(pi)?fi:pi;oi[ui]=mi}Gr[si].push(oi)}const Yr={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[Kr]=Gr.info,[Zr]=Gr.common,[Qr]=Gr.distanceField??[];Qr&&(Yr.distanceField={range:parseInt(Qr.distanceRange,10),type:Qr.fieldType}),Yr.fontSize=parseInt(Kr.size,10),Yr.fontFamily=Kr.face,Yr.lineHeight=parseInt(Zr.lineHeight,10);const Jr=Gr.page;for(let ii=0;ii<Jr.length;ii++)Yr.pages.push({id:parseInt(Jr[ii].id,10)||0,file:Jr[ii].file});const ei={};Yr.baseLineOffset=Yr.lineHeight-parseInt(Zr.base,10);const ti=Gr.char;for(let ii=0;ii<ti.length;ii++){const si=ti[ii],ni=parseInt(si.id,10);let oi=si.letter??si.char??String.fromCharCode(ni);oi==="space"&&(oi=" "),ei[ni]=oi,Yr.chars[oi]={id:ni,page:parseInt(si.page,10)||0,x:parseInt(si.x,10),y:parseInt(si.y,10),width:parseInt(si.width,10),height:parseInt(si.height,10),xOffset:parseInt(si.xoffset,10),yOffset:parseInt(si.yoffset,10),xAdvance:parseInt(si.xadvance,10),kerning:{}}}const ri=Gr.kerning||[];for(let ii=0;ii<ri.length;ii++){const si=parseInt(ri[ii].first,10),ni=parseInt(ri[ii].second,10),oi=parseInt(ri[ii].amount,10);Yr.chars[ei[ni]].kerning[ei[si]]=oi}return Yr}},bitmapFontXMLParser={test(Wr){const ze=Wr;return typeof ze!="string"&&"getElementsByTagName"in ze&&ze.getElementsByTagName("page").length&&ze.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(Wr){const ze={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},Gr=Wr.getElementsByTagName("info")[0],Yr=Wr.getElementsByTagName("common")[0],Kr=Wr.getElementsByTagName("distanceField")[0];Kr&&(ze.distanceField={type:Kr.getAttribute("fieldType"),range:parseInt(Kr.getAttribute("distanceRange"),10)});const Zr=Wr.getElementsByTagName("page"),Qr=Wr.getElementsByTagName("char"),Jr=Wr.getElementsByTagName("kerning");ze.fontSize=parseInt(Gr.getAttribute("size"),10),ze.fontFamily=Gr.getAttribute("face"),ze.lineHeight=parseInt(Yr.getAttribute("lineHeight"),10);for(let ti=0;ti<Zr.length;ti++)ze.pages.push({id:parseInt(Zr[ti].getAttribute("id"),10)||0,file:Zr[ti].getAttribute("file")});const ei={};ze.baseLineOffset=ze.lineHeight-parseInt(Yr.getAttribute("base"),10);for(let ti=0;ti<Qr.length;ti++){const ri=Qr[ti],ii=parseInt(ri.getAttribute("id"),10);let si=ri.getAttribute("letter")??ri.getAttribute("char")??String.fromCharCode(ii);si==="space"&&(si=" "),ei[ii]=si,ze.chars[si]={id:ii,page:parseInt(ri.getAttribute("page"),10)||0,x:parseInt(ri.getAttribute("x"),10),y:parseInt(ri.getAttribute("y"),10),width:parseInt(ri.getAttribute("width"),10),height:parseInt(ri.getAttribute("height"),10),xOffset:parseInt(ri.getAttribute("xoffset"),10),yOffset:parseInt(ri.getAttribute("yoffset"),10),xAdvance:parseInt(ri.getAttribute("xadvance"),10),kerning:{}}}for(let ti=0;ti<Jr.length;ti++){const ri=parseInt(Jr[ti].getAttribute("first"),10),ii=parseInt(Jr[ti].getAttribute("second"),10),si=parseInt(Jr[ti].getAttribute("amount"),10);ze.chars[ei[ii]].kerning[ei[ri]]=si}return ze}},bitmapFontXMLStringParser={test(Wr){return typeof Wr=="string"&&Wr.includes("<font>")?bitmapFontXMLParser.test(DOMAdapter.get().parseXML(Wr)):!1},parse(Wr){return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(Wr))}},validExtensions=[".xml",".fnt"],bitmapFontCachePlugin={extension:{type:ExtensionType.CacheParser,name:"cacheBitmapFont"},test:Wr=>Wr instanceof BitmapFont,getCacheableAssets(Wr,ze){const Gr={};return Wr.forEach(Yr=>{Gr[Yr]=ze,Gr[`${Yr}-bitmap`]=ze}),Gr[`${ze.fontFamily}-bitmap`]=ze,Gr}},loadBitmapFont={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Normal},name:"loadBitmapFont",test(Wr){return validExtensions.includes(path.extname(Wr).toLowerCase())},async testParse(Wr){return bitmapFontTextParser.test(Wr)||bitmapFontXMLStringParser.test(Wr)},async parse(Wr,ze,Gr){const Yr=bitmapFontTextParser.test(Wr)?bitmapFontTextParser.parse(Wr):bitmapFontXMLStringParser.parse(Wr),{src:Kr}=ze,{pages:Zr}=Yr,Qr=[],Jr=Yr.distanceField?{scaleMode:"linear",alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:!1,resolution:1}:{};for(let ii=0;ii<Zr.length;++ii){const si=Zr[ii].file;let ni=path.join(path.dirname(Kr),si);ni=copySearchParams(ni,Kr),Qr.push({src:ni,data:Jr})}const ei=await Gr.load(Qr),ti=Qr.map(ii=>ei[ii.src]);return new BitmapFont({data:Yr,textures:ti},Kr)},async load(Wr,ze){return await(await DOMAdapter.get().fetch(Wr)).text()},async unload(Wr,ze,Gr){await Promise.all(Wr.pages.map(Yr=>Gr.unload(Yr.texture.source._sourceOrigin))),Wr.destroy()}};class BackgroundLoader{constructor(ze,Gr=!1){this._loader=ze,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=Gr}add(ze){ze.forEach(Gr=>{this._assetList.push(Gr)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const ze=[],Gr=Math.min(this._assetList.length,this._maxConcurrent);for(let Yr=0;Yr<Gr;Yr++)ze.push(this._assetList.pop());await this._loader.load(ze),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(ze){this._isActive!==ze&&(this._isActive=ze,ze&&!this._isLoading&&this._next())}}const cacheTextureArray={extension:{type:ExtensionType.CacheParser,name:"cacheTextureArray"},test:Wr=>Array.isArray(Wr)&&Wr.every(ze=>ze instanceof Texture),getCacheableAssets:(Wr,ze)=>{const Gr={};return Wr.forEach(Yr=>{ze.forEach((Kr,Zr)=>{Gr[Yr+(Zr===0?"":Zr+1)]=Kr})}),Gr}};async function testImageFormat(Wr){if("Image"in globalThis)return new Promise(ze=>{const Gr=new Image;Gr.onload=()=>{ze(!0)},Gr.onerror=()=>{ze(!1)},Gr.src=Wr});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const ze=await(await fetch(Wr)).blob();await createImageBitmap(ze)}catch{return!1}return!0}return!1}const detectAvif={extension:{type:ExtensionType.DetectionParser,priority:1},test:async()=>testImageFormat("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async Wr=>[...Wr,"avif"],remove:async Wr=>Wr.filter(ze=>ze!=="avif")},imageFormats=["png","jpg","jpeg"],detectDefaults={extension:{type:ExtensionType.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async Wr=>[...Wr,...imageFormats],remove:async Wr=>Wr.filter(ze=>!imageFormats.includes(ze))},inWorker="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function testVideoFormat(Wr){return inWorker?!1:document.createElement("video").canPlayType(Wr)!==""}const detectMp4={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testVideoFormat("video/mp4"),add:async Wr=>[...Wr,"mp4","m4v"],remove:async Wr=>Wr.filter(ze=>ze!=="mp4"&&ze!=="m4v")},detectOgv={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testVideoFormat("video/ogg"),add:async Wr=>[...Wr,"ogv"],remove:async Wr=>Wr.filter(ze=>ze!=="ogv")},detectWebm={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testVideoFormat("video/webm"),add:async Wr=>[...Wr,"webm"],remove:async Wr=>Wr.filter(ze=>ze!=="webm")},detectWebp={extension:{type:ExtensionType.DetectionParser,priority:0},test:async()=>testImageFormat("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async Wr=>[...Wr,"webp"],remove:async Wr=>Wr.filter(ze=>ze!=="webp")};class Loader{constructor(){this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(ze,Gr,Yr)=>(this._parsersValidated=!1,ze[Gr]=Yr,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(ze,Gr){const Yr={promise:null,parser:null};return Yr.promise=(async()=>{var Qr,Jr;let Kr=null,Zr=null;if(Gr.loadParser&&(Zr=this._parserHash[Gr.loadParser],Zr||warn(`[Assets] specified load parser "${Gr.loadParser}" not found while loading ${ze}`)),!Zr){for(let ei=0;ei<this.parsers.length;ei++){const ti=this.parsers[ei];if(ti.load&&((Qr=ti.test)!=null&&Qr.call(ti,ze,Gr,this))){Zr=ti;break}}if(!Zr)return warn(`[Assets] ${ze} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}Kr=await Zr.load(ze,Gr,this),Yr.parser=Zr;for(let ei=0;ei<this.parsers.length;ei++){const ti=this.parsers[ei];ti.parse&&ti.parse&&await((Jr=ti.testParse)==null?void 0:Jr.call(ti,Kr,Gr,this))&&(Kr=await ti.parse(Kr,Gr,this)||Kr,Yr.parser=ti)}return Kr})(),Yr}async load(ze,Gr){this._parsersValidated||this._validateParsers();let Yr=0;const Kr={},Zr=isSingleItem(ze),Qr=convertToList(ze,ti=>({alias:[ti],src:ti,data:{}})),Jr=Qr.length,ei=Qr.map(async ti=>{const ri=path.toAbsolute(ti.src);if(!Kr[ti.src])try{this.promiseCache[ri]||(this.promiseCache[ri]=this._getLoadPromiseAndParser(ri,ti)),Kr[ti.src]=await this.promiseCache[ri].promise,Gr&&Gr(++Yr/Jr)}catch(ii){throw delete this.promiseCache[ri],delete Kr[ti.src],new Error(`[Loader.load] Failed to load ${ri}.
${ii}`)}});return await Promise.all(ei),Zr?Kr[Qr[0].src]:Kr}async unload(ze){const Yr=convertToList(ze,Kr=>({alias:[Kr],src:Kr})).map(async Kr=>{var Jr,ei;const Zr=path.toAbsolute(Kr.src),Qr=this.promiseCache[Zr];if(Qr){const ti=await Qr.promise;delete this.promiseCache[Zr],await((ei=(Jr=Qr.parser)==null?void 0:Jr.unload)==null?void 0:ei.call(Jr,ti,Kr,this))}});await Promise.all(Yr)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(ze=>ze.name).reduce((ze,Gr)=>(Gr.name?ze[Gr.name]&&warn(`[Assets] loadParser name conflict "${Gr.name}"`):warn("[Assets] loadParser should have a name"),{...ze,[Gr.name]:Gr}),{})}}function checkDataUrl(Wr,ze){if(Array.isArray(ze)){for(const Gr of ze)if(Wr.startsWith(`data:${Gr}`))return!0;return!1}return Wr.startsWith(`data:${ze}`)}function checkExtension(Wr,ze){const Gr=Wr.split("?")[0],Yr=path.extname(Gr).toLowerCase();return Array.isArray(ze)?ze.includes(Yr):Yr===ze}const validJSONExtension=".json",validJSONMIME="application/json",loadJson={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low},name:"loadJson",test(Wr){return checkDataUrl(Wr,validJSONMIME)||checkExtension(Wr,validJSONExtension)},async load(Wr){return await(await DOMAdapter.get().fetch(Wr)).json()}},validTXTExtension=".txt",validTXTMIME="text/plain",loadTxt={name:"loadTxt",extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low,name:"loadTxt"},test(Wr){return checkDataUrl(Wr,validTXTMIME)||checkExtension(Wr,validTXTExtension)},async load(Wr){return await(await DOMAdapter.get().fetch(Wr)).text()}},validWeights=["normal","bold","100","200","300","400","500","600","700","800","900"],validFontExtensions=[".ttf",".otf",".woff",".woff2"],validFontMIMEs=["font/ttf","font/otf","font/woff","font/woff2"],CSS_IDENT_TOKEN_REGEX=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function getFontFamilyName(Wr){const ze=path.extname(Wr),Kr=path.basename(Wr,ze).replace(/(-|_)/g," ").toLowerCase().split(" ").map(Jr=>Jr.charAt(0).toUpperCase()+Jr.slice(1));let Zr=Kr.length>0;for(const Jr of Kr)if(!Jr.match(CSS_IDENT_TOKEN_REGEX)){Zr=!1;break}let Qr=Kr.join(" ");return Zr||(Qr=`"${Qr.replace(/[\\"]/g,"\\$&")}"`),Qr}const validURICharactersRegex=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function encodeURIWhenNeeded(Wr){return validURICharactersRegex.test(Wr)?Wr:encodeURI(Wr)}const loadWebFont={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low},name:"loadWebFont",test(Wr){return checkDataUrl(Wr,validFontMIMEs)||checkExtension(Wr,validFontExtensions)},async load(Wr,ze){var Yr,Kr,Zr;const Gr=DOMAdapter.get().getFontFaceSet();if(Gr){const Qr=[],Jr=((Yr=ze.data)==null?void 0:Yr.family)??getFontFamilyName(Wr),ei=((Zr=(Kr=ze.data)==null?void 0:Kr.weights)==null?void 0:Zr.filter(ri=>validWeights.includes(ri)))??["normal"],ti=ze.data??{};for(let ri=0;ri<ei.length;ri++){const ii=ei[ri],si=new FontFace(Jr,`url(${encodeURIWhenNeeded(Wr)})`,{...ti,weight:ii});await si.load(),Gr.add(si),Qr.push(si)}return Cache.set(`${Jr}-and-url`,{url:Wr,fontFaces:Qr}),Qr.length===1?Qr[0]:Qr}return warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(Wr){(Array.isArray(Wr)?Wr:[Wr]).forEach(ze=>{Cache.remove(`${ze.family}-and-url`),DOMAdapter.get().getFontFaceSet().delete(ze)})}};function getResolutionOfUrl(Wr,ze=1){var Yr;const Gr=(Yr=Resolver.RETINA_PREFIX)==null?void 0:Yr.exec(Wr);return Gr?parseFloat(Gr[1]):ze}function createTexture(Wr,ze,Gr){Wr.label=Gr,Wr._sourceOrigin=Gr;const Yr=new Texture({source:Wr,label:Gr}),Kr=()=>{delete ze.promiseCache[Gr],Cache.has(Gr)&&Cache.remove(Gr)};return Yr.source.once("destroy",()=>{ze.promiseCache[Gr]&&(warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."),Kr())}),Yr.once("destroy",()=>{Wr.destroyed||(warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),Kr())}),Yr}const validSVGExtension=".svg",validSVGMIME="image/svg+xml",loadSvg={extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.Low,name:"loadSVG"},name:"loadSVG",config:{crossOrigin:"anonymous",parseAsGraphicsContext:!1},test(Wr){return checkDataUrl(Wr,validSVGMIME)||checkExtension(Wr,validSVGExtension)},async load(Wr,ze,Gr){var Yr;return((Yr=ze.data)==null?void 0:Yr.parseAsGraphicsContext)??this.config.parseAsGraphicsContext?loadAsGraphics(Wr):loadAsTexture(Wr,ze,Gr,this.config.crossOrigin)},unload(Wr){Wr.destroy(!0)}};async function loadAsTexture(Wr,ze,Gr,Yr){var ai,ui,fi;const Zr=await(await DOMAdapter.get().fetch(Wr)).blob(),Qr=URL.createObjectURL(Zr),Jr=new Image;Jr.src=Qr,Jr.crossOrigin=Yr,await Jr.decode(),URL.revokeObjectURL(Qr);const ei=document.createElement("canvas"),ti=ei.getContext("2d"),ri=((ai=ze.data)==null?void 0:ai.resolution)||getResolutionOfUrl(Wr),ii=((ui=ze.data)==null?void 0:ui.width)??Jr.width,si=((fi=ze.data)==null?void 0:fi.height)??Jr.height;ei.width=ii*ri,ei.height=si*ri,ti.drawImage(Jr,0,0,ii*ri,si*ri);const{parseAsGraphicsContext:ni,...oi}=ze.data??{},li=new ImageSource({resource:ei,alphaMode:"premultiply-alpha-on-upload",resolution:ri,...oi});return createTexture(li,Gr,Wr)}async function loadAsGraphics(Wr){const Gr=await(await DOMAdapter.get().fetch(Wr)).text(),Yr=new GraphicsContext;return Yr.svg(Gr),Yr}const WORKER_CODE$1=`(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;let WORKER_URL$1=null,WorkerInstance$1=class{constructor(){WORKER_URL$1||(WORKER_URL$1=URL.createObjectURL(new Blob([WORKER_CODE$1],{type:"application/javascript"}))),this.worker=new Worker(WORKER_URL$1)}};WorkerInstance$1.revokeObjectURL=function(){WORKER_URL$1&&(URL.revokeObjectURL(WORKER_URL$1),WORKER_URL$1=null)};const WORKER_CODE=`(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;let WORKER_URL=null;class WorkerInstance{constructor(){WORKER_URL||(WORKER_URL=URL.createObjectURL(new Blob([WORKER_CODE],{type:"application/javascript"}))),this.worker=new Worker(WORKER_URL)}}WorkerInstance.revokeObjectURL=function(){WORKER_URL&&(URL.revokeObjectURL(WORKER_URL),WORKER_URL=null)};let UUID=0,MAX_WORKERS;class WorkerManagerClass{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(ze=>{const{worker:Gr}=new WorkerInstance$1;Gr.addEventListener("message",Yr=>{Gr.terminate(),WorkerInstance$1.revokeObjectURL(),ze(Yr.data)})}),this._isImageBitmapSupported)}loadImageBitmap(ze,Gr){var Yr;return this._run("loadImageBitmap",[ze,(Yr=Gr==null?void 0:Gr.data)==null?void 0:Yr.alphaMode])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){MAX_WORKERS===void 0&&(MAX_WORKERS=navigator.hardwareConcurrency||4);let ze=this._workerPool.pop();return!ze&&this._createdWorkers<MAX_WORKERS&&(this._createdWorkers++,ze=new WorkerInstance().worker,ze.addEventListener("message",Gr=>{this._complete(Gr.data),this._returnWorker(Gr.target),this._next()})),ze}_returnWorker(ze){this._workerPool.push(ze)}_complete(ze){ze.error!==void 0?this._resolveHash[ze.uuid].reject(ze.error):this._resolveHash[ze.uuid].resolve(ze.data),this._resolveHash[ze.uuid]=null}async _run(ze,Gr){await this._initWorkers();const Yr=new Promise((Kr,Zr)=>{this._queue.push({id:ze,arguments:Gr,resolve:Kr,reject:Zr})});return this._next(),Yr}_next(){if(!this._queue.length)return;const ze=this._getWorker();if(!ze)return;const Gr=this._queue.pop(),Yr=Gr.id;this._resolveHash[UUID]={resolve:Gr.resolve,reject:Gr.reject},ze.postMessage({data:Gr.arguments,uuid:UUID++,id:Yr})}}const WorkerManager=new WorkerManagerClass,validImageExtensions=[".jpeg",".jpg",".png",".webp",".avif"],validImageMIMEs=["image/jpeg","image/png","image/webp","image/avif"];async function loadImageBitmap(Wr,ze){var Kr;const Gr=await DOMAdapter.get().fetch(Wr);if(!Gr.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${Wr}: ${Gr.status} ${Gr.statusText}`);const Yr=await Gr.blob();return((Kr=ze==null?void 0:ze.data)==null?void 0:Kr.alphaMode)==="premultiplied-alpha"?createImageBitmap(Yr,{premultiplyAlpha:"none"}):createImageBitmap(Yr)}const loadTextures$1={name:"loadTextures",extension:{type:ExtensionType.LoadParser,priority:LoaderParserPriority.High,name:"loadTextures"},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(Wr){return checkDataUrl(Wr,validImageMIMEs)||checkExtension(Wr,validImageExtensions)},async load(Wr,ze,Gr){var Zr;let Yr=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await WorkerManager.isImageBitmapSupported()?Yr=await WorkerManager.loadImageBitmap(Wr,ze):Yr=await loadImageBitmap(Wr,ze):Yr=await new Promise((Qr,Jr)=>{Yr=new Image,Yr.crossOrigin=this.config.crossOrigin,Yr.src=Wr,Yr.complete?Qr(Yr):(Yr.onload=()=>{Qr(Yr)},Yr.onerror=Jr)});const Kr=new ImageSource({resource:Yr,alphaMode:"premultiply-alpha-on-upload",resolution:((Zr=ze.data)==null?void 0:Zr.resolution)||getResolutionOfUrl(Wr),...ze.data});return createTexture(Kr,Gr,Wr)},unload(Wr){Wr.destroy(!0)}},validVideoExtensions=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"],validVideoMIMEs=validVideoExtensions.map(Wr=>`video/${Wr.substring(1)}`);function crossOrigin(Wr,ze,Gr){Gr===void 0&&!ze.startsWith("data:")?Wr.crossOrigin=determineCrossOrigin(ze):Gr!==!1&&(Wr.crossOrigin=typeof Gr=="string"?Gr:"anonymous")}function preloadVideo(Wr){return new Promise((ze,Gr)=>{Wr.addEventListener("canplaythrough",Yr),Wr.addEventListener("error",Kr),Wr.load();function Yr(){Zr(),ze()}function Kr(Qr){Zr(),Gr(Qr)}function Zr(){Wr.removeEventListener("canplaythrough",Yr),Wr.removeEventListener("error",Kr)}})}function determineCrossOrigin(Wr,ze=globalThis.location){if(Wr.startsWith("data:"))return"";ze||(ze=globalThis.location);const Gr=new URL(Wr,document.baseURI);return Gr.hostname!==ze.hostname||Gr.port!==ze.port||Gr.protocol!==ze.protocol?"anonymous":""}const loadVideoTextures={name:"loadVideo",extension:{type:ExtensionType.LoadParser,name:"loadVideo"},test(Wr){const ze=checkDataUrl(Wr,validVideoMIMEs),Gr=checkExtension(Wr,validVideoExtensions);return ze||Gr},async load(Wr,ze,Gr){var ei,ti;const Yr={...VideoSource.defaultOptions,resolution:((ei=ze.data)==null?void 0:ei.resolution)||getResolutionOfUrl(Wr),alphaMode:((ti=ze.data)==null?void 0:ti.alphaMode)||await detectVideoAlphaMode(),...ze.data},Kr=document.createElement("video"),Zr={preload:Yr.autoLoad!==!1?"auto":void 0,"webkit-playsinline":Yr.playsinline!==!1?"":void 0,playsinline:Yr.playsinline!==!1?"":void 0,muted:Yr.muted===!0?"":void 0,loop:Yr.loop===!0?"":void 0,autoplay:Yr.autoPlay!==!1?"":void 0};Object.keys(Zr).forEach(ri=>{const ii=Zr[ri];ii!==void 0&&Kr.setAttribute(ri,ii)}),Yr.muted===!0&&(Kr.muted=!0),crossOrigin(Kr,Wr,Yr.crossorigin);const Qr=document.createElement("source");let Jr;if(Wr.startsWith("data:"))Jr=Wr.slice(5,Wr.indexOf(";"));else if(!Wr.startsWith("blob:")){const ri=Wr.split("?")[0].slice(Wr.lastIndexOf(".")+1).toLowerCase();Jr=VideoSource.MIME_TYPES[ri]||`video/${ri}`}return Qr.src=Wr,Jr&&(Qr.type=Jr),new Promise(ri=>{const ii=async()=>{const si=new VideoSource({...Yr,resource:Kr});Kr.removeEventListener("canplay",ii),ze.data.preload&&await preloadVideo(Kr),ri(createTexture(si,Gr,Wr))};Kr.addEventListener("canplay",ii),Kr.appendChild(Qr)})},unload(Wr){Wr.destroy(!0)}},resolveTextureUrl={extension:{type:ExtensionType.ResolveParser,name:"resolveTexture"},test:loadTextures$1.test,parse:Wr=>{var ze;return{resolution:parseFloat(((ze=Resolver.RETINA_PREFIX.exec(Wr))==null?void 0:ze[1])??"1"),format:Wr.split(".").pop(),src:Wr}}},resolveJsonUrl={extension:{type:ExtensionType.ResolveParser,priority:-2,name:"resolveJson"},test:Wr=>Resolver.RETINA_PREFIX.test(Wr)&&Wr.endsWith(".json"),parse:resolveTextureUrl.parse};class AssetsClass{constructor(){this._detections=[],this._initialized=!1,this.resolver=new Resolver,this.loader=new Loader,this.cache=Cache,this._backgroundLoader=new BackgroundLoader(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(ze={}){var Zr,Qr;if(this._initialized){warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");return}if(this._initialized=!0,ze.defaultSearchParams&&this.resolver.setDefaultSearchParams(ze.defaultSearchParams),ze.basePath&&(this.resolver.basePath=ze.basePath),ze.bundleIdentifier&&this.resolver.setBundleIdentifier(ze.bundleIdentifier),ze.manifest){let Jr=ze.manifest;typeof Jr=="string"&&(Jr=await this.load(Jr)),this.resolver.addManifest(Jr)}const Gr=((Zr=ze.texturePreference)==null?void 0:Zr.resolution)??1,Yr=typeof Gr=="number"?[Gr]:Gr,Kr=await this._detectFormats({preferredFormats:(Qr=ze.texturePreference)==null?void 0:Qr.format,skipDetections:ze.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:Kr,resolution:Yr}}),ze.preferences&&this.setPreferences(ze.preferences)}add(ze){this.resolver.add(ze)}async load(ze,Gr){this._initialized||await this.init();const Yr=isSingleItem(ze),Kr=convertToList(ze).map(Jr=>{if(typeof Jr!="string"){const ei=this.resolver.getAlias(Jr);return ei.some(ti=>!this.resolver.hasKey(ti))&&this.add(Jr),Array.isArray(ei)?ei[0]:ei}return this.resolver.hasKey(Jr)||this.add({alias:Jr,src:Jr}),Jr}),Zr=this.resolver.resolve(Kr),Qr=await this._mapLoadToResolve(Zr,Gr);return Yr?Qr[Kr[0]]:Qr}addBundle(ze,Gr){this.resolver.addBundle(ze,Gr)}async loadBundle(ze,Gr){this._initialized||await this.init();let Yr=!1;typeof ze=="string"&&(Yr=!0,ze=[ze]);const Kr=this.resolver.resolveBundle(ze),Zr={},Qr=Object.keys(Kr);let Jr=0,ei=0;const ti=()=>{Gr==null||Gr(++Jr/ei)},ri=Qr.map(ii=>{const si=Kr[ii];return ei+=Object.keys(si).length,this._mapLoadToResolve(si,ti).then(ni=>{Zr[ii]=ni})});return await Promise.all(ri),Yr?Zr[ze[0]]:Zr}async backgroundLoad(ze){this._initialized||await this.init(),typeof ze=="string"&&(ze=[ze]);const Gr=this.resolver.resolve(ze);this._backgroundLoader.add(Object.values(Gr))}async backgroundLoadBundle(ze){this._initialized||await this.init(),typeof ze=="string"&&(ze=[ze]);const Gr=this.resolver.resolveBundle(ze);Object.values(Gr).forEach(Yr=>{this._backgroundLoader.add(Object.values(Yr))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(ze){if(typeof ze=="string")return Cache.get(ze);const Gr={};for(let Yr=0;Yr<ze.length;Yr++)Gr[Yr]=Cache.get(ze[Yr]);return Gr}async _mapLoadToResolve(ze,Gr){const Yr=[...new Set(Object.values(ze))];this._backgroundLoader.active=!1;const Kr=await this.loader.load(Yr,Gr);this._backgroundLoader.active=!0;const Zr={};return Yr.forEach(Qr=>{const Jr=Kr[Qr.src],ei=[Qr.src];Qr.alias&&ei.push(...Qr.alias),ei.forEach(ti=>{Zr[ti]=Jr}),Cache.set(ei,Jr)}),Zr}async unload(ze){this._initialized||await this.init();const Gr=convertToList(ze).map(Kr=>typeof Kr!="string"?Kr.src:Kr),Yr=this.resolver.resolve(Gr);await this._unloadFromResolved(Yr)}async unloadBundle(ze){this._initialized||await this.init(),ze=convertToList(ze);const Gr=this.resolver.resolveBundle(ze),Yr=Object.keys(Gr).map(Kr=>this._unloadFromResolved(Gr[Kr]));await Promise.all(Yr)}async _unloadFromResolved(ze){const Gr=Object.values(ze);Gr.forEach(Yr=>{Cache.remove(Yr.src)}),await this.loader.unload(Gr)}async _detectFormats(ze){let Gr=[];ze.preferredFormats&&(Gr=Array.isArray(ze.preferredFormats)?ze.preferredFormats:[ze.preferredFormats]);for(const Yr of ze.detections)ze.skipDetections||await Yr.test()?Gr=await Yr.add(Gr):ze.skipDetections||(Gr=await Yr.remove(Gr));return Gr=Gr.filter((Yr,Kr)=>Gr.indexOf(Yr)===Kr),Gr}get detections(){return this._detections}setPreferences(ze){this.loader.parsers.forEach(Gr=>{Gr.config&&Object.keys(Gr.config).filter(Yr=>Yr in ze).forEach(Yr=>{Gr.config[Yr]=ze[Yr]})})}}const Assets=new AssetsClass;extensions.handleByList(ExtensionType.LoadParser,Assets.loader.parsers).handleByList(ExtensionType.ResolveParser,Assets.resolver.parsers).handleByList(ExtensionType.CacheParser,Assets.cache.parsers).handleByList(ExtensionType.DetectionParser,Assets.detections);extensions.add(cacheTextureArray,detectDefaults,detectAvif,detectWebp,detectMp4,detectOgv,detectWebm,loadJson,loadTxt,loadWebFont,loadSvg,loadTextures$1,loadVideoTextures,loadBitmapFont,bitmapFontCachePlugin,resolveTextureUrl,resolveJsonUrl);const assetKeyMap={loader:ExtensionType.LoadParser,resolver:ExtensionType.ResolveParser,cache:ExtensionType.CacheParser,detection:ExtensionType.DetectionParser};extensions.handle(ExtensionType.Asset,Wr=>{const ze=Wr.ref;Object.entries(assetKeyMap).filter(([Gr])=>!!ze[Gr]).forEach(([Gr,Yr])=>extensions.add(Object.assign(ze[Gr],{extension:ze[Gr].extension??Yr})))},Wr=>{const ze=Wr.ref;Object.keys(assetKeyMap).filter(Gr=>!!ze[Gr]).forEach(Gr=>extensions.remove(ze[Gr]))});class DOMPipe{constructor(ze){this._destroyRenderableBound=this.destroyRenderable.bind(this),this._attachedDomElements=[],this._renderer=ze,this._renderer.runners.postrender.add(this),this._domElement=document.createElement("div"),this._domElement.style.position="absolute",this._domElement.style.top="0",this._domElement.style.left="0",this._domElement.style.pointerEvents="none",this._domElement.style.zIndex="1000"}addRenderable(ze,Gr){this._attachedDomElements.includes(ze)||(this._attachedDomElements.push(ze),ze.on("destroyed",this._destroyRenderableBound))}updateRenderable(ze){}validateRenderable(ze){return!0}destroyRenderable(ze){const Gr=this._attachedDomElements.indexOf(ze);Gr!==-1&&this._attachedDomElements.splice(Gr,1),ze.off("destroyed",this._destroyRenderableBound)}postrender(){var Yr;const ze=this._attachedDomElements;if(ze.length===0){this._domElement.remove();return}const Gr=this._renderer.view.canvas;this._domElement.parentNode!==Gr.parentNode&&((Yr=Gr.parentNode)==null||Yr.appendChild(this._domElement)),this._domElement.style.transform=`translate(${Gr.offsetLeft}px, ${Gr.offsetTop}px)`;for(let Kr=0;Kr<ze.length;Kr++){const Zr=ze[Kr],Qr=Zr.element;if(!Zr.parent||Zr.globalDisplayStatus<7)Qr.remove(),ze.splice(Kr,1),Kr--;else{this._domElement.contains(Qr)||(Qr.style.position="absolute",Qr.style.pointerEvents="auto",this._domElement.appendChild(Qr));const Jr=Zr.worldTransform,ei=Zr._anchor,ti=Zr.width*ei.x,ri=Zr.height*ei.y;Qr.style.transformOrigin=`${ti}px ${ri}px`,Qr.style.transform=`matrix(${Jr.a}, ${Jr.b}, ${Jr.c}, ${Jr.d}, ${Jr.tx-ti}, ${Jr.ty-ri})`,Qr.style.opacity=Zr.groupAlpha.toString()}}}destroy(){this._renderer.runners.postrender.remove(this);for(let ze=0;ze<this._attachedDomElements.length;ze++){const Gr=this._attachedDomElements[ze];Gr.off("destroyed",this._destroyRenderableBound),Gr.element.remove()}this._attachedDomElements.length=0,this._domElement.remove(),this._renderer=null}}DOMPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"dom"};class EventsTickerClass{constructor(){this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}init(ze){this.removeTickerListener(),this.events=ze,this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}get pauseUpdate(){return this._pauseUpdate}set pauseUpdate(ze){this._pauseUpdate=ze}addTickerListener(){this._tickerAdded||!this.domElement||(Ticker.system.add(this._tickerUpdate,this,UPDATE_PRIORITY.INTERACTION),this._tickerAdded=!0)}removeTickerListener(){this._tickerAdded&&(Ticker.system.remove(this._tickerUpdate,this),this._tickerAdded=!1)}pointerMoved(){this._didMove=!0}_update(){if(!this.domElement||this._pauseUpdate)return;if(this._didMove){this._didMove=!1;return}const ze=this.events._rootPointerEvent;this.events.supportsTouchEvents&&ze.pointerType==="touch"||globalThis.document.dispatchEvent(new PointerEvent("pointermove",{clientX:ze.clientX,clientY:ze.clientY,pointerType:ze.pointerType,pointerId:ze.pointerId}))}_tickerUpdate(ze){this._deltaTime+=ze.deltaTime,!(this._deltaTime<this.interactionFrequency)&&(this._deltaTime=0,this._update())}}const EventsTicker=new EventsTickerClass;class FederatedMouseEvent extends FederatedEvent{constructor(){super(...arguments),this.client=new Point$1,this.movement=new Point$1,this.offset=new Point$1,this.global=new Point$1,this.screen=new Point$1}get clientX(){return this.client.x}get clientY(){return this.client.y}get x(){return this.clientX}get y(){return this.clientY}get movementX(){return this.movement.x}get movementY(){return this.movement.y}get offsetX(){return this.offset.x}get offsetY(){return this.offset.y}get globalX(){return this.global.x}get globalY(){return this.global.y}get screenX(){return this.screen.x}get screenY(){return this.screen.y}getLocalPosition(ze,Gr,Yr){return ze.worldTransform.applyInverse(Yr||this.global,Gr)}getModifierState(ze){return"getModifierState"in this.nativeEvent&&this.nativeEvent.getModifierState(ze)}initMouseEvent(ze,Gr,Yr,Kr,Zr,Qr,Jr,ei,ti,ri,ii,si,ni,oi,li){throw new Error("Method not implemented.")}}class FederatedPointerEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.width=0,this.height=0,this.isPrimary=!1}getCoalescedEvents(){return this.type==="pointermove"||this.type==="mousemove"||this.type==="touchmove"?[this]:[]}getPredictedEvents(){throw new Error("getPredictedEvents is not supported!")}}class FederatedWheelEvent extends FederatedMouseEvent{constructor(){super(...arguments),this.DOM_DELTA_PIXEL=0,this.DOM_DELTA_LINE=1,this.DOM_DELTA_PAGE=2}}FederatedWheelEvent.DOM_DELTA_PIXEL=0;FederatedWheelEvent.DOM_DELTA_LINE=1;FederatedWheelEvent.DOM_DELTA_PAGE=2;const PROPAGATION_LIMIT=2048,tempHitLocation=new Point$1,tempLocalMapping=new Point$1;class EventBoundary{constructor(ze){this.dispatch=new EventEmitter,this.moveOnAll=!1,this.enableGlobalMoveEvents=!0,this.mappingState={trackingData:{}},this.eventPool=new Map,this._allInteractiveElements=[],this._hitElements=[],this._isPointerMoveEvent=!1,this.rootTarget=ze,this.hitPruneFn=this.hitPruneFn.bind(this),this.hitTestFn=this.hitTestFn.bind(this),this.mapPointerDown=this.mapPointerDown.bind(this),this.mapPointerMove=this.mapPointerMove.bind(this),this.mapPointerOut=this.mapPointerOut.bind(this),this.mapPointerOver=this.mapPointerOver.bind(this),this.mapPointerUp=this.mapPointerUp.bind(this),this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this),this.mapWheel=this.mapWheel.bind(this),this.mappingTable={},this.addEventMapping("pointerdown",this.mapPointerDown),this.addEventMapping("pointermove",this.mapPointerMove),this.addEventMapping("pointerout",this.mapPointerOut),this.addEventMapping("pointerleave",this.mapPointerOut),this.addEventMapping("pointerover",this.mapPointerOver),this.addEventMapping("pointerup",this.mapPointerUp),this.addEventMapping("pointerupoutside",this.mapPointerUpOutside),this.addEventMapping("wheel",this.mapWheel)}addEventMapping(ze,Gr){this.mappingTable[ze]||(this.mappingTable[ze]=[]),this.mappingTable[ze].push({fn:Gr,priority:0}),this.mappingTable[ze].sort((Yr,Kr)=>Yr.priority-Kr.priority)}dispatchEvent(ze,Gr){ze.propagationStopped=!1,ze.propagationImmediatelyStopped=!1,this.propagate(ze,Gr),this.dispatch.emit(Gr||ze.type,ze)}mapEvent(ze){if(!this.rootTarget)return;const Gr=this.mappingTable[ze.type];if(Gr)for(let Yr=0,Kr=Gr.length;Yr<Kr;Yr++)Gr[Yr].fn(ze);else warn(`[EventBoundary]: Event mapping not defined for ${ze.type}`)}hitTest(ze,Gr){EventsTicker.pauseUpdate=!0;const Kr=this._isPointerMoveEvent&&this.enableGlobalMoveEvents?"hitTestMoveRecursive":"hitTestRecursive",Zr=this[Kr](this.rootTarget,this.rootTarget.eventMode,tempHitLocation.set(ze,Gr),this.hitTestFn,this.hitPruneFn);return Zr&&Zr[0]}propagate(ze,Gr){if(!ze.target)return;const Yr=ze.composedPath();ze.eventPhase=ze.CAPTURING_PHASE;for(let Kr=0,Zr=Yr.length-1;Kr<Zr;Kr++)if(ze.currentTarget=Yr[Kr],this.notifyTarget(ze,Gr),ze.propagationStopped||ze.propagationImmediatelyStopped)return;if(ze.eventPhase=ze.AT_TARGET,ze.currentTarget=ze.target,this.notifyTarget(ze,Gr),!(ze.propagationStopped||ze.propagationImmediatelyStopped)){ze.eventPhase=ze.BUBBLING_PHASE;for(let Kr=Yr.length-2;Kr>=0;Kr--)if(ze.currentTarget=Yr[Kr],this.notifyTarget(ze,Gr),ze.propagationStopped||ze.propagationImmediatelyStopped)return}}all(ze,Gr,Yr=this._allInteractiveElements){if(Yr.length===0)return;ze.eventPhase=ze.BUBBLING_PHASE;const Kr=Array.isArray(Gr)?Gr:[Gr];for(let Zr=Yr.length-1;Zr>=0;Zr--)Kr.forEach(Qr=>{ze.currentTarget=Yr[Zr],this.notifyTarget(ze,Qr)})}propagationPath(ze){const Gr=[ze];for(let Yr=0;Yr<PROPAGATION_LIMIT&&ze!==this.rootTarget&&ze.parent;Yr++){if(!ze.parent)throw new Error("Cannot find propagation path to disconnected target");Gr.push(ze.parent),ze=ze.parent}return Gr.reverse(),Gr}hitTestMoveRecursive(ze,Gr,Yr,Kr,Zr,Qr=!1){let Jr=!1;if(this._interactivePrune(ze))return null;if((ze.eventMode==="dynamic"||Gr==="dynamic")&&(EventsTicker.pauseUpdate=!1),ze.interactiveChildren&&ze.children){const ri=ze.children;for(let ii=ri.length-1;ii>=0;ii--){const si=ri[ii],ni=this.hitTestMoveRecursive(si,this._isInteractive(Gr)?Gr:si.eventMode,Yr,Kr,Zr,Qr||Zr(ze,Yr));if(ni){if(ni.length>0&&!ni[ni.length-1].parent)continue;const oi=ze.isInteractive();(ni.length>0||oi)&&(oi&&this._allInteractiveElements.push(ze),ni.push(ze)),this._hitElements.length===0&&(this._hitElements=ni),Jr=!0}}}const ei=this._isInteractive(Gr),ti=ze.isInteractive();return ti&&ti&&this._allInteractiveElements.push(ze),Qr||this._hitElements.length>0?null:Jr?this._hitElements:ei&&!Zr(ze,Yr)&&Kr(ze,Yr)?ti?[ze]:[]:null}hitTestRecursive(ze,Gr,Yr,Kr,Zr){if(this._interactivePrune(ze)||Zr(ze,Yr))return null;if((ze.eventMode==="dynamic"||Gr==="dynamic")&&(EventsTicker.pauseUpdate=!1),ze.interactiveChildren&&ze.children){const ei=ze.children,ti=Yr;for(let ri=ei.length-1;ri>=0;ri--){const ii=ei[ri],si=this.hitTestRecursive(ii,this._isInteractive(Gr)?Gr:ii.eventMode,ti,Kr,Zr);if(si){if(si.length>0&&!si[si.length-1].parent)continue;const ni=ze.isInteractive();return(si.length>0||ni)&&si.push(ze),si}}}const Qr=this._isInteractive(Gr),Jr=ze.isInteractive();return Qr&&Kr(ze,Yr)?Jr?[ze]:[]:null}_isInteractive(ze){return ze==="static"||ze==="dynamic"}_interactivePrune(ze){return!ze||!ze.visible||!ze.renderable||!ze.measurable||ze.eventMode==="none"||ze.eventMode==="passive"&&!ze.interactiveChildren}hitPruneFn(ze,Gr){if(ze.hitArea&&(ze.worldTransform.applyInverse(Gr,tempLocalMapping),!ze.hitArea.contains(tempLocalMapping.x,tempLocalMapping.y)))return!0;if(ze.effects&&ze.effects.length)for(let Yr=0;Yr<ze.effects.length;Yr++){const Kr=ze.effects[Yr];if(Kr.containsPoint&&!Kr.containsPoint(Gr,this.hitTestFn))return!0}return!1}hitTestFn(ze,Gr){return ze.hitArea?!0:ze!=null&&ze.containsPoint?(ze.worldTransform.applyInverse(Gr,tempLocalMapping),ze.containsPoint(tempLocalMapping)):!1}notifyTarget(ze,Gr){var Zr,Qr;if(!ze.currentTarget.isInteractive())return;Gr??(Gr=ze.type);const Yr=`on${Gr}`;(Qr=(Zr=ze.currentTarget)[Yr])==null||Qr.call(Zr,ze);const Kr=ze.eventPhase===ze.CAPTURING_PHASE||ze.eventPhase===ze.AT_TARGET?`${Gr}capture`:Gr;this._notifyListeners(ze,Kr),ze.eventPhase===ze.AT_TARGET&&this._notifyListeners(ze,Gr)}mapPointerDown(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.createPointerEvent(ze);if(this.dispatchEvent(Gr,"pointerdown"),Gr.pointerType==="touch")this.dispatchEvent(Gr,"touchstart");else if(Gr.pointerType==="mouse"||Gr.pointerType==="pen"){const Kr=Gr.button===2;this.dispatchEvent(Gr,Kr?"rightdown":"mousedown")}const Yr=this.trackingData(ze.pointerId);Yr.pressTargetsByButton[ze.button]=Gr.composedPath(),this.freeEvent(Gr)}mapPointerMove(ze){var ei,ti;if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}this._allInteractiveElements.length=0,this._hitElements.length=0,this._isPointerMoveEvent=!0;const Gr=this.createPointerEvent(ze);this._isPointerMoveEvent=!1;const Yr=Gr.pointerType==="mouse"||Gr.pointerType==="pen",Kr=this.trackingData(ze.pointerId),Zr=this.findMountedTarget(Kr.overTargets);if(((ei=Kr.overTargets)==null?void 0:ei.length)>0&&Zr!==Gr.target){const ri=ze.type==="mousemove"?"mouseout":"pointerout",ii=this.createPointerEvent(ze,ri,Zr);if(this.dispatchEvent(ii,"pointerout"),Yr&&this.dispatchEvent(ii,"mouseout"),!Gr.composedPath().includes(Zr)){const si=this.createPointerEvent(ze,"pointerleave",Zr);for(si.eventPhase=si.AT_TARGET;si.target&&!Gr.composedPath().includes(si.target);)si.currentTarget=si.target,this.notifyTarget(si),Yr&&this.notifyTarget(si,"mouseleave"),si.target=si.target.parent;this.freeEvent(si)}this.freeEvent(ii)}if(Zr!==Gr.target){const ri=ze.type==="mousemove"?"mouseover":"pointerover",ii=this.clonePointerEvent(Gr,ri);this.dispatchEvent(ii,"pointerover"),Yr&&this.dispatchEvent(ii,"mouseover");let si=Zr==null?void 0:Zr.parent;for(;si&&si!==this.rootTarget.parent&&si!==Gr.target;)si=si.parent;if(!si||si===this.rootTarget.parent){const oi=this.clonePointerEvent(Gr,"pointerenter");for(oi.eventPhase=oi.AT_TARGET;oi.target&&oi.target!==Zr&&oi.target!==this.rootTarget.parent;)oi.currentTarget=oi.target,this.notifyTarget(oi),Yr&&this.notifyTarget(oi,"mouseenter"),oi.target=oi.target.parent;this.freeEvent(oi)}this.freeEvent(ii)}const Qr=[],Jr=this.enableGlobalMoveEvents??!0;this.moveOnAll?Qr.push("pointermove"):this.dispatchEvent(Gr,"pointermove"),Jr&&Qr.push("globalpointermove"),Gr.pointerType==="touch"&&(this.moveOnAll?Qr.splice(1,0,"touchmove"):this.dispatchEvent(Gr,"touchmove"),Jr&&Qr.push("globaltouchmove")),Yr&&(this.moveOnAll?Qr.splice(1,0,"mousemove"):this.dispatchEvent(Gr,"mousemove"),Jr&&Qr.push("globalmousemove"),this.cursor=(ti=Gr.target)==null?void 0:ti.cursor),Qr.length>0&&this.all(Gr,Qr),this._allInteractiveElements.length=0,this._hitElements.length=0,Kr.overTargets=Gr.composedPath(),this.freeEvent(Gr)}mapPointerOver(ze){var Qr;if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.trackingData(ze.pointerId),Yr=this.createPointerEvent(ze),Kr=Yr.pointerType==="mouse"||Yr.pointerType==="pen";this.dispatchEvent(Yr,"pointerover"),Kr&&this.dispatchEvent(Yr,"mouseover"),Yr.pointerType==="mouse"&&(this.cursor=(Qr=Yr.target)==null?void 0:Qr.cursor);const Zr=this.clonePointerEvent(Yr,"pointerenter");for(Zr.eventPhase=Zr.AT_TARGET;Zr.target&&Zr.target!==this.rootTarget.parent;)Zr.currentTarget=Zr.target,this.notifyTarget(Zr),Kr&&this.notifyTarget(Zr,"mouseenter"),Zr.target=Zr.target.parent;Gr.overTargets=Yr.composedPath(),this.freeEvent(Yr),this.freeEvent(Zr)}mapPointerOut(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.trackingData(ze.pointerId);if(Gr.overTargets){const Yr=ze.pointerType==="mouse"||ze.pointerType==="pen",Kr=this.findMountedTarget(Gr.overTargets),Zr=this.createPointerEvent(ze,"pointerout",Kr);this.dispatchEvent(Zr),Yr&&this.dispatchEvent(Zr,"mouseout");const Qr=this.createPointerEvent(ze,"pointerleave",Kr);for(Qr.eventPhase=Qr.AT_TARGET;Qr.target&&Qr.target!==this.rootTarget.parent;)Qr.currentTarget=Qr.target,this.notifyTarget(Qr),Yr&&this.notifyTarget(Qr,"mouseleave"),Qr.target=Qr.target.parent;Gr.overTargets=null,this.freeEvent(Zr),this.freeEvent(Qr)}this.cursor=null}mapPointerUp(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=performance.now(),Yr=this.createPointerEvent(ze);if(this.dispatchEvent(Yr,"pointerup"),Yr.pointerType==="touch")this.dispatchEvent(Yr,"touchend");else if(Yr.pointerType==="mouse"||Yr.pointerType==="pen"){const Jr=Yr.button===2;this.dispatchEvent(Yr,Jr?"rightup":"mouseup")}const Kr=this.trackingData(ze.pointerId),Zr=this.findMountedTarget(Kr.pressTargetsByButton[ze.button]);let Qr=Zr;if(Zr&&!Yr.composedPath().includes(Zr)){let Jr=Zr;for(;Jr&&!Yr.composedPath().includes(Jr);){if(Yr.currentTarget=Jr,this.notifyTarget(Yr,"pointerupoutside"),Yr.pointerType==="touch")this.notifyTarget(Yr,"touchendoutside");else if(Yr.pointerType==="mouse"||Yr.pointerType==="pen"){const ei=Yr.button===2;this.notifyTarget(Yr,ei?"rightupoutside":"mouseupoutside")}Jr=Jr.parent}delete Kr.pressTargetsByButton[ze.button],Qr=Jr}if(Qr){const Jr=this.clonePointerEvent(Yr,"click");Jr.target=Qr,Jr.path=null,Kr.clicksByButton[ze.button]||(Kr.clicksByButton[ze.button]={clickCount:0,target:Jr.target,timeStamp:Gr});const ei=Kr.clicksByButton[ze.button];if(ei.target===Jr.target&&Gr-ei.timeStamp<200?++ei.clickCount:ei.clickCount=1,ei.target=Jr.target,ei.timeStamp=Gr,Jr.detail=ei.clickCount,Jr.pointerType==="mouse"){const ti=Jr.button===2;this.dispatchEvent(Jr,ti?"rightclick":"click")}else Jr.pointerType==="touch"&&this.dispatchEvent(Jr,"tap");this.dispatchEvent(Jr,"pointertap"),this.freeEvent(Jr)}this.freeEvent(Yr)}mapPointerUpOutside(ze){if(!(ze instanceof FederatedPointerEvent)){warn("EventBoundary cannot map a non-pointer event as a pointer event");return}const Gr=this.trackingData(ze.pointerId),Yr=this.findMountedTarget(Gr.pressTargetsByButton[ze.button]),Kr=this.createPointerEvent(ze);if(Yr){let Zr=Yr;for(;Zr;)Kr.currentTarget=Zr,this.notifyTarget(Kr,"pointerupoutside"),Kr.pointerType==="touch"?this.notifyTarget(Kr,"touchendoutside"):(Kr.pointerType==="mouse"||Kr.pointerType==="pen")&&this.notifyTarget(Kr,Kr.button===2?"rightupoutside":"mouseupoutside"),Zr=Zr.parent;delete Gr.pressTargetsByButton[ze.button]}this.freeEvent(Kr)}mapWheel(ze){if(!(ze instanceof FederatedWheelEvent)){warn("EventBoundary cannot map a non-wheel event as a wheel event");return}const Gr=this.createWheelEvent(ze);this.dispatchEvent(Gr),this.freeEvent(Gr)}findMountedTarget(ze){if(!ze)return null;let Gr=ze[0];for(let Yr=1;Yr<ze.length&&ze[Yr].parent===Gr;Yr++)Gr=ze[Yr];return Gr}createPointerEvent(ze,Gr,Yr){const Kr=this.allocateEvent(FederatedPointerEvent);return this.copyPointerData(ze,Kr),this.copyMouseData(ze,Kr),this.copyData(ze,Kr),Kr.nativeEvent=ze.nativeEvent,Kr.originalEvent=ze,Kr.target=Yr??this.hitTest(Kr.global.x,Kr.global.y)??this._hitElements[0],typeof Gr=="string"&&(Kr.type=Gr),Kr}createWheelEvent(ze){const Gr=this.allocateEvent(FederatedWheelEvent);return this.copyWheelData(ze,Gr),this.copyMouseData(ze,Gr),this.copyData(ze,Gr),Gr.nativeEvent=ze.nativeEvent,Gr.originalEvent=ze,Gr.target=this.hitTest(Gr.global.x,Gr.global.y),Gr}clonePointerEvent(ze,Gr){const Yr=this.allocateEvent(FederatedPointerEvent);return Yr.nativeEvent=ze.nativeEvent,Yr.originalEvent=ze.originalEvent,this.copyPointerData(ze,Yr),this.copyMouseData(ze,Yr),this.copyData(ze,Yr),Yr.target=ze.target,Yr.path=ze.composedPath().slice(),Yr.type=Gr??Yr.type,Yr}copyWheelData(ze,Gr){Gr.deltaMode=ze.deltaMode,Gr.deltaX=ze.deltaX,Gr.deltaY=ze.deltaY,Gr.deltaZ=ze.deltaZ}copyPointerData(ze,Gr){ze instanceof FederatedPointerEvent&&Gr instanceof FederatedPointerEvent&&(Gr.pointerId=ze.pointerId,Gr.width=ze.width,Gr.height=ze.height,Gr.isPrimary=ze.isPrimary,Gr.pointerType=ze.pointerType,Gr.pressure=ze.pressure,Gr.tangentialPressure=ze.tangentialPressure,Gr.tiltX=ze.tiltX,Gr.tiltY=ze.tiltY,Gr.twist=ze.twist)}copyMouseData(ze,Gr){ze instanceof FederatedMouseEvent&&Gr instanceof FederatedMouseEvent&&(Gr.altKey=ze.altKey,Gr.button=ze.button,Gr.buttons=ze.buttons,Gr.client.copyFrom(ze.client),Gr.ctrlKey=ze.ctrlKey,Gr.metaKey=ze.metaKey,Gr.movement.copyFrom(ze.movement),Gr.screen.copyFrom(ze.screen),Gr.shiftKey=ze.shiftKey,Gr.global.copyFrom(ze.global))}copyData(ze,Gr){Gr.isTrusted=ze.isTrusted,Gr.srcElement=ze.srcElement,Gr.timeStamp=performance.now(),Gr.type=ze.type,Gr.detail=ze.detail,Gr.view=ze.view,Gr.which=ze.which,Gr.layer.copyFrom(ze.layer),Gr.page.copyFrom(ze.page)}trackingData(ze){return this.mappingState.trackingData[ze]||(this.mappingState.trackingData[ze]={pressTargetsByButton:{},clicksByButton:{},overTarget:null}),this.mappingState.trackingData[ze]}allocateEvent(ze){this.eventPool.has(ze)||this.eventPool.set(ze,[]);const Gr=this.eventPool.get(ze).pop()||new ze(this);return Gr.eventPhase=Gr.NONE,Gr.currentTarget=null,Gr.defaultPrevented=!1,Gr.path=null,Gr.target=null,Gr}freeEvent(ze){if(ze.manager!==this)throw new Error("It is illegal to free an event not managed by this EventBoundary!");const Gr=ze.constructor;this.eventPool.has(Gr)||this.eventPool.set(Gr,[]),this.eventPool.get(Gr).push(ze)}_notifyListeners(ze,Gr){const Yr=ze.currentTarget._events[Gr];if(Yr)if("fn"in Yr)Yr.once&&ze.currentTarget.removeListener(Gr,Yr.fn,void 0,!0),Yr.fn.call(Yr.context,ze);else for(let Kr=0,Zr=Yr.length;Kr<Zr&&!ze.propagationImmediatelyStopped;Kr++)Yr[Kr].once&&ze.currentTarget.removeListener(Gr,Yr[Kr].fn,void 0,!0),Yr[Kr].fn.call(Yr[Kr].context,ze)}}const MOUSE_POINTER_ID=1,TOUCH_TO_POINTER={touchstart:"pointerdown",touchend:"pointerup",touchendoutside:"pointerupoutside",touchmove:"pointermove",touchcancel:"pointercancel"},_EventSystem=class ms{constructor(ze){this.supportsTouchEvents="ontouchstart"in globalThis,this.supportsPointerEvents=!!globalThis.PointerEvent,this.domElement=null,this.resolution=1,this.renderer=ze,this.rootBoundary=new EventBoundary(null),EventsTicker.init(this),this.autoPreventDefault=!0,this._eventsAdded=!1,this._rootPointerEvent=new FederatedPointerEvent(null),this._rootWheelEvent=new FederatedWheelEvent(null),this.cursorStyles={default:"inherit",pointer:"pointer"},this.features=new Proxy({...ms.defaultEventFeatures},{set:(Gr,Yr,Kr)=>(Yr==="globalMove"&&(this.rootBoundary.enableGlobalMoveEvents=Kr),Gr[Yr]=Kr,!0)}),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onPointerOverOut=this._onPointerOverOut.bind(this),this.onWheel=this.onWheel.bind(this)}static get defaultEventMode(){return this._defaultEventMode}init(ze){const{canvas:Gr,resolution:Yr}=this.renderer;this.setTargetElement(Gr),this.resolution=Yr,ms._defaultEventMode=ze.eventMode??"passive",Object.assign(this.features,ze.eventFeatures??{}),this.rootBoundary.enableGlobalMoveEvents=this.features.globalMove}resolutionChange(ze){this.resolution=ze}destroy(){this.setTargetElement(null),this.renderer=null,this._currentCursor=null}setCursor(ze){ze||(ze="default");let Gr=!0;if(globalThis.OffscreenCanvas&&this.domElement instanceof OffscreenCanvas&&(Gr=!1),this._currentCursor===ze)return;this._currentCursor=ze;const Yr=this.cursorStyles[ze];if(Yr)switch(typeof Yr){case"string":Gr&&(this.domElement.style.cursor=Yr);break;case"function":Yr(ze);break;case"object":Gr&&Object.assign(this.domElement.style,Yr);break}else Gr&&typeof ze=="string"&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,ze)&&(this.domElement.style.cursor=ze)}get pointer(){return this._rootPointerEvent}_onPointerDown(ze){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const Gr=this._normalizeToPointerData(ze);this.autoPreventDefault&&Gr[0].isNormalized&&(ze.cancelable||!("cancelable"in ze))&&ze.preventDefault();for(let Yr=0,Kr=Gr.length;Yr<Kr;Yr++){const Zr=Gr[Yr],Qr=this._bootstrapEvent(this._rootPointerEvent,Zr);this.rootBoundary.mapEvent(Qr)}this.setCursor(this.rootBoundary.cursor)}_onPointerMove(ze){if(!this.features.move)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,EventsTicker.pointerMoved();const Gr=this._normalizeToPointerData(ze);for(let Yr=0,Kr=Gr.length;Yr<Kr;Yr++){const Zr=this._bootstrapEvent(this._rootPointerEvent,Gr[Yr]);this.rootBoundary.mapEvent(Zr)}this.setCursor(this.rootBoundary.cursor)}_onPointerUp(ze){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;let Gr=ze.target;ze.composedPath&&ze.composedPath().length>0&&(Gr=ze.composedPath()[0]);const Yr=Gr!==this.domElement?"outside":"",Kr=this._normalizeToPointerData(ze);for(let Zr=0,Qr=Kr.length;Zr<Qr;Zr++){const Jr=this._bootstrapEvent(this._rootPointerEvent,Kr[Zr]);Jr.type+=Yr,this.rootBoundary.mapEvent(Jr)}this.setCursor(this.rootBoundary.cursor)}_onPointerOverOut(ze){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const Gr=this._normalizeToPointerData(ze);for(let Yr=0,Kr=Gr.length;Yr<Kr;Yr++){const Zr=this._bootstrapEvent(this._rootPointerEvent,Gr[Yr]);this.rootBoundary.mapEvent(Zr)}this.setCursor(this.rootBoundary.cursor)}onWheel(ze){if(!this.features.wheel)return;const Gr=this.normalizeWheelEvent(ze);this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,this.rootBoundary.mapEvent(Gr)}setTargetElement(ze){this._removeEvents(),this.domElement=ze,EventsTicker.domElement=ze,this._addEvents()}_addEvents(){if(this._eventsAdded||!this.domElement)return;EventsTicker.addTickerListener();const ze=this.domElement.style;ze&&(globalThis.navigator.msPointerEnabled?(ze.msContentZooming="none",ze.msTouchAction="none"):this.supportsPointerEvents&&(ze.touchAction="none")),this.supportsPointerEvents?(globalThis.document.addEventListener("pointermove",this._onPointerMove,!0),this.domElement.addEventListener("pointerdown",this._onPointerDown,!0),this.domElement.addEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.addEventListener("pointerover",this._onPointerOverOut,!0),globalThis.addEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.addEventListener("mousemove",this._onPointerMove,!0),this.domElement.addEventListener("mousedown",this._onPointerDown,!0),this.domElement.addEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.addEventListener("mouseover",this._onPointerOverOut,!0),globalThis.addEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.addEventListener("touchstart",this._onPointerDown,!0),this.domElement.addEventListener("touchend",this._onPointerUp,!0),this.domElement.addEventListener("touchmove",this._onPointerMove,!0))),this.domElement.addEventListener("wheel",this.onWheel,{passive:!0,capture:!0}),this._eventsAdded=!0}_removeEvents(){if(!this._eventsAdded||!this.domElement)return;EventsTicker.removeTickerListener();const ze=this.domElement.style;ze&&(globalThis.navigator.msPointerEnabled?(ze.msContentZooming="",ze.msTouchAction=""):this.supportsPointerEvents&&(ze.touchAction="")),this.supportsPointerEvents?(globalThis.document.removeEventListener("pointermove",this._onPointerMove,!0),this.domElement.removeEventListener("pointerdown",this._onPointerDown,!0),this.domElement.removeEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.removeEventListener("pointerover",this._onPointerOverOut,!0),globalThis.removeEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.removeEventListener("mousemove",this._onPointerMove,!0),this.domElement.removeEventListener("mousedown",this._onPointerDown,!0),this.domElement.removeEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.removeEventListener("mouseover",this._onPointerOverOut,!0),globalThis.removeEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.removeEventListener("touchstart",this._onPointerDown,!0),this.domElement.removeEventListener("touchend",this._onPointerUp,!0),this.domElement.removeEventListener("touchmove",this._onPointerMove,!0))),this.domElement.removeEventListener("wheel",this.onWheel,!0),this.domElement=null,this._eventsAdded=!1}mapPositionToPoint(ze,Gr,Yr){const Kr=this.domElement.isConnected?this.domElement.getBoundingClientRect():{width:this.domElement.width,height:this.domElement.height,left:0,top:0},Zr=1/this.resolution;ze.x=(Gr-Kr.left)*(this.domElement.width/Kr.width)*Zr,ze.y=(Yr-Kr.top)*(this.domElement.height/Kr.height)*Zr}_normalizeToPointerData(ze){const Gr=[];if(this.supportsTouchEvents&&ze instanceof TouchEvent)for(let Yr=0,Kr=ze.changedTouches.length;Yr<Kr;Yr++){const Zr=ze.changedTouches[Yr];typeof Zr.button>"u"&&(Zr.button=0),typeof Zr.buttons>"u"&&(Zr.buttons=1),typeof Zr.isPrimary>"u"&&(Zr.isPrimary=ze.touches.length===1&&ze.type==="touchstart"),typeof Zr.width>"u"&&(Zr.width=Zr.radiusX||1),typeof Zr.height>"u"&&(Zr.height=Zr.radiusY||1),typeof Zr.tiltX>"u"&&(Zr.tiltX=0),typeof Zr.tiltY>"u"&&(Zr.tiltY=0),typeof Zr.pointerType>"u"&&(Zr.pointerType="touch"),typeof Zr.pointerId>"u"&&(Zr.pointerId=Zr.identifier||0),typeof Zr.pressure>"u"&&(Zr.pressure=Zr.force||.5),typeof Zr.twist>"u"&&(Zr.twist=0),typeof Zr.tangentialPressure>"u"&&(Zr.tangentialPressure=0),typeof Zr.layerX>"u"&&(Zr.layerX=Zr.offsetX=Zr.clientX),typeof Zr.layerY>"u"&&(Zr.layerY=Zr.offsetY=Zr.clientY),Zr.isNormalized=!0,Zr.type=ze.type,Gr.push(Zr)}else if(!globalThis.MouseEvent||ze instanceof MouseEvent&&(!this.supportsPointerEvents||!(ze instanceof globalThis.PointerEvent))){const Yr=ze;typeof Yr.isPrimary>"u"&&(Yr.isPrimary=!0),typeof Yr.width>"u"&&(Yr.width=1),typeof Yr.height>"u"&&(Yr.height=1),typeof Yr.tiltX>"u"&&(Yr.tiltX=0),typeof Yr.tiltY>"u"&&(Yr.tiltY=0),typeof Yr.pointerType>"u"&&(Yr.pointerType="mouse"),typeof Yr.pointerId>"u"&&(Yr.pointerId=MOUSE_POINTER_ID),typeof Yr.pressure>"u"&&(Yr.pressure=.5),typeof Yr.twist>"u"&&(Yr.twist=0),typeof Yr.tangentialPressure>"u"&&(Yr.tangentialPressure=0),Yr.isNormalized=!0,Gr.push(Yr)}else Gr.push(ze);return Gr}normalizeWheelEvent(ze){const Gr=this._rootWheelEvent;return this._transferMouseData(Gr,ze),Gr.deltaX=ze.deltaX,Gr.deltaY=ze.deltaY,Gr.deltaZ=ze.deltaZ,Gr.deltaMode=ze.deltaMode,this.mapPositionToPoint(Gr.screen,ze.clientX,ze.clientY),Gr.global.copyFrom(Gr.screen),Gr.offset.copyFrom(Gr.screen),Gr.nativeEvent=ze,Gr.type=ze.type,Gr}_bootstrapEvent(ze,Gr){return ze.originalEvent=null,ze.nativeEvent=Gr,ze.pointerId=Gr.pointerId,ze.width=Gr.width,ze.height=Gr.height,ze.isPrimary=Gr.isPrimary,ze.pointerType=Gr.pointerType,ze.pressure=Gr.pressure,ze.tangentialPressure=Gr.tangentialPressure,ze.tiltX=Gr.tiltX,ze.tiltY=Gr.tiltY,ze.twist=Gr.twist,this._transferMouseData(ze,Gr),this.mapPositionToPoint(ze.screen,Gr.clientX,Gr.clientY),ze.global.copyFrom(ze.screen),ze.offset.copyFrom(ze.screen),ze.isTrusted=Gr.isTrusted,ze.type==="pointerleave"&&(ze.type="pointerout"),ze.type.startsWith("mouse")&&(ze.type=ze.type.replace("mouse","pointer")),ze.type.startsWith("touch")&&(ze.type=TOUCH_TO_POINTER[ze.type]||ze.type),ze}_transferMouseData(ze,Gr){ze.isTrusted=Gr.isTrusted,ze.srcElement=Gr.srcElement,ze.timeStamp=performance.now(),ze.type=Gr.type,ze.altKey=Gr.altKey,ze.button=Gr.button,ze.buttons=Gr.buttons,ze.client.x=Gr.clientX,ze.client.y=Gr.clientY,ze.ctrlKey=Gr.ctrlKey,ze.metaKey=Gr.metaKey,ze.movement.x=Gr.movementX,ze.movement.y=Gr.movementY,ze.page.x=Gr.pageX,ze.page.y=Gr.pageY,ze.relatedTarget=null,ze.shiftKey=Gr.shiftKey}};_EventSystem.extension={name:"events",type:[ExtensionType.WebGLSystem,ExtensionType.CanvasSystem,ExtensionType.WebGPUSystem],priority:-1};_EventSystem.defaultEventFeatures={move:!0,globalMove:!0,click:!0,wheel:!0};let EventSystem=_EventSystem;const FederatedContainer={onclick:null,onmousedown:null,onmouseenter:null,onmouseleave:null,onmousemove:null,onglobalmousemove:null,onmouseout:null,onmouseover:null,onmouseup:null,onmouseupoutside:null,onpointercancel:null,onpointerdown:null,onpointerenter:null,onpointerleave:null,onpointermove:null,onglobalpointermove:null,onpointerout:null,onpointerover:null,onpointertap:null,onpointerup:null,onpointerupoutside:null,onrightclick:null,onrightdown:null,onrightup:null,onrightupoutside:null,ontap:null,ontouchcancel:null,ontouchend:null,ontouchendoutside:null,ontouchmove:null,onglobaltouchmove:null,ontouchstart:null,onwheel:null,get interactive(){return this.eventMode==="dynamic"||this.eventMode==="static"},set interactive(Wr){this.eventMode=Wr?"static":"passive"},_internalEventMode:void 0,get eventMode(){return this._internalEventMode??EventSystem.defaultEventMode},set eventMode(Wr){this._internalEventMode=Wr},isInteractive(){return this.eventMode==="static"||this.eventMode==="dynamic"},interactiveChildren:!0,hitArea:null,addEventListener(Wr,ze,Gr){const Yr=typeof Gr=="boolean"&&Gr||typeof Gr=="object"&&Gr.capture,Kr=typeof Gr=="object"?Gr.signal:void 0,Zr=typeof Gr=="object"?Gr.once===!0:!1,Qr=typeof ze=="function"?void 0:ze;Wr=Yr?`${Wr}capture`:Wr;const Jr=typeof ze=="function"?ze:ze.handleEvent,ei=this;Kr&&Kr.addEventListener("abort",()=>{ei.off(Wr,Jr,Qr)}),Zr?ei.once(Wr,Jr,Qr):ei.on(Wr,Jr,Qr)},removeEventListener(Wr,ze,Gr){const Yr=typeof Gr=="boolean"&&Gr||typeof Gr=="object"&&Gr.capture,Kr=typeof ze=="function"?void 0:ze;Wr=Yr?`${Wr}capture`:Wr,ze=typeof ze=="function"?ze:ze.handleEvent,this.off(Wr,ze,Kr)},dispatchEvent(Wr){if(!(Wr instanceof FederatedEvent))throw new Error("Container cannot propagate events outside of the Federated Events API");return Wr.defaultPrevented=!1,Wr.path=null,Wr.target=this,Wr.manager.dispatchEvent(Wr),!Wr.defaultPrevented}};var vertex$2=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,fragment$2=`
in vec2 vTextureCoord;
in vec4 vColor;

out vec4 finalColor;

uniform float uColorMatrix[20];
uniform float uAlpha;

uniform sampler2D uTexture;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture(uTexture, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * 0.2);
    float diff = (randomValue - 0.5) *  0.5;

    if (uAlpha == 0.0) {
        finalColor = color;
        return;
    }

    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    vec4 result;

    result.r = (uColorMatrix[0] * color.r);
        result.r += (uColorMatrix[1] * color.g);
        result.r += (uColorMatrix[2] * color.b);
        result.r += (uColorMatrix[3] * color.a);
        result.r += uColorMatrix[4];

    result.g = (uColorMatrix[5] * color.r);
        result.g += (uColorMatrix[6] * color.g);
        result.g += (uColorMatrix[7] * color.b);
        result.g += (uColorMatrix[8] * color.a);
        result.g += uColorMatrix[9];

    result.b = (uColorMatrix[10] * color.r);
       result.b += (uColorMatrix[11] * color.g);
       result.b += (uColorMatrix[12] * color.b);
       result.b += (uColorMatrix[13] * color.a);
       result.b += uColorMatrix[14];

    result.a = (uColorMatrix[15] * color.r);
       result.a += (uColorMatrix[16] * color.g);
       result.a += (uColorMatrix[17] * color.b);
       result.a += (uColorMatrix[18] * color.a);
       result.a += uColorMatrix[19];

    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    finalColor = vec4(rgb, result.a);
}
`,source$1=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct ColorMatrixUniforms {
  uColorMatrix:array<vec4<f32>, 5>,
  uAlpha:f32,
};


@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;
@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
  };
  
fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
  );
}


@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {


  var c = textureSample(uTexture, uSampler, uv);
  
  if (colorMatrixUniforms.uAlpha == 0.0) {
    return c;
  }

 
    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.r /= c.a;
      c.g /= c.a;
      c.b /= c.a;
    }

    var cm = colorMatrixUniforms.uColorMatrix;


    var result = vec4<f32>(0.);

    result.r = (cm[0][0] * c.r);
    result.r += (cm[0][1] * c.g);
    result.r += (cm[0][2] * c.b);
    result.r += (cm[0][3] * c.a);
    result.r += cm[1][0];

    result.g = (cm[1][1] * c.r);
    result.g += (cm[1][2] * c.g);
    result.g += (cm[1][3] * c.b);
    result.g += (cm[2][0] * c.a);
    result.g += cm[2][1];

    result.b = (cm[2][2] * c.r);
    result.b += (cm[2][3] * c.g);
    result.b += (cm[3][0] * c.b);
    result.b += (cm[3][1] * c.a);
    result.b += cm[3][2];

    result.a = (cm[3][3] * c.r);
    result.a += (cm[4][0] * c.g);
    result.a += (cm[4][1] * c.b);
    result.a += (cm[4][2] * c.a);
    result.a += cm[4][3];

    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);

    rgb.r *= result.a;
    rgb.g *= result.a;
    rgb.b *= result.a;

    return vec4(rgb, result.a);
}`;class ColorMatrixFilter extends Filter{constructor(ze={}){const Gr=new UniformGroup({uColorMatrix:{value:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],type:"f32",size:20},uAlpha:{value:1,type:"f32"}}),Yr=GpuProgram.from({vertex:{source:source$1,entryPoint:"mainVertex"},fragment:{source:source$1,entryPoint:"mainFragment"}}),Kr=GlProgram.from({vertex:vertex$2,fragment:fragment$2,name:"color-matrix-filter"});super({...ze,gpuProgram:Yr,glProgram:Kr,resources:{colorMatrixUniforms:Gr}}),this.alpha=1}_loadMatrix(ze,Gr=!1){let Yr=ze;Gr&&(this._multiply(Yr,this.matrix,ze),Yr=this._colorMatrix(Yr)),this.resources.colorMatrixUniforms.uniforms.uColorMatrix=Yr,this.resources.colorMatrixUniforms.update()}_multiply(ze,Gr,Yr){return ze[0]=Gr[0]*Yr[0]+Gr[1]*Yr[5]+Gr[2]*Yr[10]+Gr[3]*Yr[15],ze[1]=Gr[0]*Yr[1]+Gr[1]*Yr[6]+Gr[2]*Yr[11]+Gr[3]*Yr[16],ze[2]=Gr[0]*Yr[2]+Gr[1]*Yr[7]+Gr[2]*Yr[12]+Gr[3]*Yr[17],ze[3]=Gr[0]*Yr[3]+Gr[1]*Yr[8]+Gr[2]*Yr[13]+Gr[3]*Yr[18],ze[4]=Gr[0]*Yr[4]+Gr[1]*Yr[9]+Gr[2]*Yr[14]+Gr[3]*Yr[19]+Gr[4],ze[5]=Gr[5]*Yr[0]+Gr[6]*Yr[5]+Gr[7]*Yr[10]+Gr[8]*Yr[15],ze[6]=Gr[5]*Yr[1]+Gr[6]*Yr[6]+Gr[7]*Yr[11]+Gr[8]*Yr[16],ze[7]=Gr[5]*Yr[2]+Gr[6]*Yr[7]+Gr[7]*Yr[12]+Gr[8]*Yr[17],ze[8]=Gr[5]*Yr[3]+Gr[6]*Yr[8]+Gr[7]*Yr[13]+Gr[8]*Yr[18],ze[9]=Gr[5]*Yr[4]+Gr[6]*Yr[9]+Gr[7]*Yr[14]+Gr[8]*Yr[19]+Gr[9],ze[10]=Gr[10]*Yr[0]+Gr[11]*Yr[5]+Gr[12]*Yr[10]+Gr[13]*Yr[15],ze[11]=Gr[10]*Yr[1]+Gr[11]*Yr[6]+Gr[12]*Yr[11]+Gr[13]*Yr[16],ze[12]=Gr[10]*Yr[2]+Gr[11]*Yr[7]+Gr[12]*Yr[12]+Gr[13]*Yr[17],ze[13]=Gr[10]*Yr[3]+Gr[11]*Yr[8]+Gr[12]*Yr[13]+Gr[13]*Yr[18],ze[14]=Gr[10]*Yr[4]+Gr[11]*Yr[9]+Gr[12]*Yr[14]+Gr[13]*Yr[19]+Gr[14],ze[15]=Gr[15]*Yr[0]+Gr[16]*Yr[5]+Gr[17]*Yr[10]+Gr[18]*Yr[15],ze[16]=Gr[15]*Yr[1]+Gr[16]*Yr[6]+Gr[17]*Yr[11]+Gr[18]*Yr[16],ze[17]=Gr[15]*Yr[2]+Gr[16]*Yr[7]+Gr[17]*Yr[12]+Gr[18]*Yr[17],ze[18]=Gr[15]*Yr[3]+Gr[16]*Yr[8]+Gr[17]*Yr[13]+Gr[18]*Yr[18],ze[19]=Gr[15]*Yr[4]+Gr[16]*Yr[9]+Gr[17]*Yr[14]+Gr[18]*Yr[19]+Gr[19],ze}_colorMatrix(ze){const Gr=new Float32Array(ze);return Gr[4]/=255,Gr[9]/=255,Gr[14]/=255,Gr[19]/=255,Gr}brightness(ze,Gr){const Yr=[ze,0,0,0,0,0,ze,0,0,0,0,0,ze,0,0,0,0,0,1,0];this._loadMatrix(Yr,Gr)}tint(ze,Gr){const[Yr,Kr,Zr]=Color.shared.setValue(ze).toArray(),Qr=[Yr,0,0,0,0,0,Kr,0,0,0,0,0,Zr,0,0,0,0,0,1,0];this._loadMatrix(Qr,Gr)}greyscale(ze,Gr){const Yr=[ze,ze,ze,0,0,ze,ze,ze,0,0,ze,ze,ze,0,0,0,0,0,1,0];this._loadMatrix(Yr,Gr)}grayscale(ze,Gr){this.greyscale(ze,Gr)}blackAndWhite(ze){const Gr=[.3,.6,.1,0,0,.3,.6,.1,0,0,.3,.6,.1,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}hue(ze,Gr){ze=(ze||0)/180*Math.PI;const Yr=Math.cos(ze),Kr=Math.sin(ze),Zr=Math.sqrt,Qr=1/3,Jr=Zr(Qr),ei=Yr+(1-Yr)*Qr,ti=Qr*(1-Yr)-Jr*Kr,ri=Qr*(1-Yr)+Jr*Kr,ii=Qr*(1-Yr)+Jr*Kr,si=Yr+Qr*(1-Yr),ni=Qr*(1-Yr)-Jr*Kr,oi=Qr*(1-Yr)-Jr*Kr,li=Qr*(1-Yr)+Jr*Kr,ai=Yr+Qr*(1-Yr),ui=[ei,ti,ri,0,0,ii,si,ni,0,0,oi,li,ai,0,0,0,0,0,1,0];this._loadMatrix(ui,Gr)}contrast(ze,Gr){const Yr=(ze||0)+1,Kr=-.5*(Yr-1),Zr=[Yr,0,0,0,Kr,0,Yr,0,0,Kr,0,0,Yr,0,Kr,0,0,0,1,0];this._loadMatrix(Zr,Gr)}saturate(ze=0,Gr){const Yr=ze*2/3+1,Kr=(Yr-1)*-.5,Zr=[Yr,Kr,Kr,0,0,Kr,Yr,Kr,0,0,Kr,Kr,Yr,0,0,0,0,0,1,0];this._loadMatrix(Zr,Gr)}desaturate(){this.saturate(-1)}negative(ze){const Gr=[-1,0,0,1,0,0,-1,0,1,0,0,0,-1,1,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}sepia(ze){const Gr=[.393,.7689999,.18899999,0,0,.349,.6859999,.16799999,0,0,.272,.5339999,.13099999,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}technicolor(ze){const Gr=[1.9125277891456083,-.8545344976951645,-.09155508482755585,0,11.793603434377337,-.3087833385928097,1.7658908555458428,-.10601743074722245,0,-70.35205161461398,-.231103377548616,-.7501899197440212,1.847597816108189,0,30.950940869491138,0,0,0,1,0];this._loadMatrix(Gr,ze)}polaroid(ze){const Gr=[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}toBGR(ze){const Gr=[0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}kodachrome(ze){const Gr=[1.1285582396593525,-.3967382283601348,-.03992559172921793,0,63.72958762196502,-.16404339962244616,1.0835251566291304,-.05498805115633132,0,24.732407896706203,-.16786010706155763,-.5603416277695248,1.6014850761964943,0,35.62982807460946,0,0,0,1,0];this._loadMatrix(Gr,ze)}browni(ze){const Gr=[.5997023498159715,.34553243048391263,-.2708298674538042,0,47.43192855600873,-.037703249837783157,.8609577587992641,.15059552388459913,0,-36.96841498319127,.24113635128153335,-.07441037908422492,.44972182064877153,0,-7.562075277591283,0,0,0,1,0];this._loadMatrix(Gr,ze)}vintage(ze){const Gr=[.6279345635605994,.3202183420819367,-.03965408211312453,0,9.651285835294123,.02578397704808868,.6441188644374771,.03259127616149294,0,7.462829176470591,.0466055556782719,-.0851232987247891,.5241648018700465,0,5.159190588235296,0,0,0,1,0];this._loadMatrix(Gr,ze)}colorTone(ze,Gr,Yr,Kr,Zr){ze||(ze=.2),Gr||(Gr=.15),Yr||(Yr=16770432),Kr||(Kr=3375104);const Qr=Color.shared,[Jr,ei,ti]=Qr.setValue(Yr).toArray(),[ri,ii,si]=Qr.setValue(Kr).toArray(),ni=[.3,.59,.11,0,0,Jr,ei,ti,ze,0,ri,ii,si,Gr,0,Jr-ri,ei-ii,ti-si,0,0];this._loadMatrix(ni,Zr)}night(ze,Gr){ze||(ze=.1);const Yr=[ze*-2,-ze,0,0,0,-ze,0,ze,0,0,0,ze,ze*2,0,0,0,0,0,1,0];this._loadMatrix(Yr,Gr)}predator(ze,Gr){const Yr=[11.224130630493164*ze,-4.794486999511719*ze,-2.8746118545532227*ze,0*ze,.40342438220977783*ze,-3.6330697536468506*ze,9.193157196044922*ze,-2.951810836791992*ze,0*ze,-1.316135048866272*ze,-3.2184197902679443*ze,-4.2375030517578125*ze,7.476448059082031*ze,0*ze,.8044459223747253*ze,0,0,0,1,0];this._loadMatrix(Yr,Gr)}lsd(ze){const Gr=[2,-.4,.5,0,0,-.5,2,-.4,0,0,-.4,-.5,3,0,0,0,0,0,1,0];this._loadMatrix(Gr,ze)}reset(){const ze=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0];this._loadMatrix(ze,!1)}get matrix(){return this.resources.colorMatrixUniforms.uniforms.uColorMatrix}set matrix(ze){this.resources.colorMatrixUniforms.uniforms.uColorMatrix=ze}get alpha(){return this.resources.colorMatrixUniforms.uniforms.uAlpha}set alpha(ze){this.resources.colorMatrixUniforms.uniforms.uAlpha=ze}}class FilterPipe{constructor(ze){this._renderer=ze}push(ze,Gr,Yr){this._renderer.renderPipes.batch.break(Yr),Yr.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:Gr,filterEffect:ze})}pop(ze,Gr,Yr){this._renderer.renderPipes.batch.break(Yr),Yr.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(ze){ze.action==="pushFilter"?this._renderer.filter.push(ze):ze.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}FilterPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"filter"};function getGlobalRenderableBounds(Wr,ze){ze.clear();const Gr=ze.matrix;for(let Yr=0;Yr<Wr.length;Yr++){const Kr=Wr[Yr];Kr.globalDisplayStatus<7||(ze.matrix=Kr.worldTransform,ze.addBounds(Kr.bounds))}return ze.matrix=Gr,ze}const quadGeometry=new Geometry({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class FilterSystem{constructor(ze){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new UniformGroup({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new BindGroup({}),this.renderer=ze}get activeBackTexture(){var ze;return(ze=this._activeFilterData)==null?void 0:ze.backTexture}push(ze){var ni;const Gr=this.renderer,Yr=ze.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const Kr=this._filterStack[this._filterStackIndex];if(this._filterStackIndex++,Yr.length===0){Kr.skip=!0;return}const Zr=Kr.bounds;if(ze.renderables?getGlobalRenderableBounds(ze.renderables,Zr):ze.filterEffect.filterArea?(Zr.clear(),Zr.addRect(ze.filterEffect.filterArea),Zr.applyMatrix(ze.container.worldTransform)):ze.container.getFastGlobalBounds(!0,Zr),ze.container){const li=(ze.container.renderGroup||ze.container.parentRenderGroup).cacheToLocalTransform;li&&Zr.applyMatrix(li)}const Qr=Gr.renderTarget.renderTarget.colorTexture.source;let Jr=1/0,ei=0,ti=!0,ri=!1,ii=!1,si=!0;for(let oi=0;oi<Yr.length;oi++){const li=Yr[oi];if(Jr=Math.min(Jr,li.resolution==="inherit"?Qr._resolution:li.resolution),ei+=li.padding,li.antialias==="off"?ti=!1:li.antialias==="inherit"&&ti&&(ti=Qr.antialias),li.clipToViewport||(si=!1),!!!(li.compatibleRenderers&Gr.type)){ii=!1;break}if(li.blendRequired&&!(((ni=Gr.backBuffer)==null?void 0:ni.useBackBuffer)??!0)){warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),ii=!1;break}ii=li.enabled||ii,ri||(ri=li.blendRequired)}if(!ii){Kr.skip=!0;return}if(si){const oi=Gr.renderTarget.rootViewPort,li=Gr.renderTarget.renderTarget.resolution;Zr.fitBounds(0,oi.width/li,0,oi.height/li)}if(Zr.scale(Jr).ceil().scale(1/Jr).pad(ei|0),!Zr.isPositive){Kr.skip=!0;return}Kr.skip=!1,Kr.bounds=Zr,Kr.blendRequired=ri,Kr.container=ze.container,Kr.filterEffect=ze.filterEffect,Kr.previousRenderSurface=Gr.renderTarget.renderSurface,Kr.inputTexture=TexturePool.getOptimalTexture(Zr.width,Zr.height,Jr,ti),Gr.renderTarget.bind(Kr.inputTexture,!0),Gr.globalUniforms.push({offset:Zr})}pop(){const ze=this.renderer;this._filterStackIndex--;const Gr=this._filterStack[this._filterStackIndex];if(Gr.skip)return;this._activeFilterData=Gr;const Yr=Gr.inputTexture,Kr=Gr.bounds;let Zr=Texture.EMPTY;if(ze.renderTarget.finishRenderPass(),Gr.blendRequired){const Jr=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null,ei=ze.renderTarget.getRenderTarget(Gr.previousRenderSurface);Zr=this.getBackTexture(ei,Kr,Jr)}Gr.backTexture=Zr;const Qr=Gr.filterEffect.filters;if(this._globalFilterBindGroup.setResource(Yr.source.style,2),this._globalFilterBindGroup.setResource(Zr.source,3),ze.globalUniforms.pop(),Qr.length===1)Qr[0].apply(this,Yr,Gr.previousRenderSurface,!1),TexturePool.returnTexture(Yr);else{let Jr=Gr.inputTexture,ei=TexturePool.getOptimalTexture(Kr.width,Kr.height,Jr.source._resolution,!1),ti=0;for(ti=0;ti<Qr.length-1;++ti){Qr[ti].apply(this,Jr,ei,!0);const ii=Jr;Jr=ei,ei=ii}Qr[ti].apply(this,Jr,Gr.previousRenderSurface,!1),TexturePool.returnTexture(Jr),TexturePool.returnTexture(ei)}Gr.blendRequired&&TexturePool.returnTexture(Zr)}getBackTexture(ze,Gr,Yr){const Kr=ze.colorTexture.source._resolution,Zr=TexturePool.getOptimalTexture(Gr.width,Gr.height,Kr,!1);let Qr=Gr.minX,Jr=Gr.minY;Yr&&(Qr-=Yr.minX,Jr-=Yr.minY),Qr=Math.floor(Qr*Kr),Jr=Math.floor(Jr*Kr);const ei=Math.ceil(Gr.width*Kr),ti=Math.ceil(Gr.height*Kr);return this.renderer.renderTarget.copyToTexture(ze,Zr,{x:Qr,y:Jr},{width:ei,height:ti},{x:0,y:0}),Zr}applyFilter(ze,Gr,Yr,Kr){const Zr=this.renderer,Qr=this._filterStack[this._filterStackIndex],Jr=Qr.bounds,ei=Point$1.shared,ri=Qr.previousRenderSurface===Yr;let ii=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,si=this._filterStackIndex-1;for(;si>0&&this._filterStack[si].skip;)--si;si>0&&(ii=this._filterStack[si].inputTexture.source._resolution);const ni=this._filterGlobalUniforms,oi=ni.uniforms,li=oi.uOutputFrame,ai=oi.uInputSize,ui=oi.uInputPixel,fi=oi.uInputClamp,pi=oi.uGlobalFrame,mi=oi.uOutputTexture;if(ri){let _i=this._filterStackIndex;for(;_i>0;){_i--;const Ci=this._filterStack[this._filterStackIndex-1];if(!Ci.skip){ei.x=Ci.bounds.minX,ei.y=Ci.bounds.minY;break}}li[0]=Jr.minX-ei.x,li[1]=Jr.minY-ei.y}else li[0]=0,li[1]=0;li[2]=Gr.frame.width,li[3]=Gr.frame.height,ai[0]=Gr.source.width,ai[1]=Gr.source.height,ai[2]=1/ai[0],ai[3]=1/ai[1],ui[0]=Gr.source.pixelWidth,ui[1]=Gr.source.pixelHeight,ui[2]=1/ui[0],ui[3]=1/ui[1],fi[0]=.5*ui[2],fi[1]=.5*ui[3],fi[2]=Gr.frame.width*ai[2]-.5*ui[2],fi[3]=Gr.frame.height*ai[3]-.5*ui[3];const Ti=this.renderer.renderTarget.rootRenderTarget.colorTexture;pi[0]=ei.x*ii,pi[1]=ei.y*ii,pi[2]=Ti.source.width*ii,pi[3]=Ti.source.height*ii;const yi=this.renderer.renderTarget.getRenderTarget(Yr);if(Zr.renderTarget.bind(Yr,!!Kr),Yr instanceof Texture?(mi[0]=Yr.frame.width,mi[1]=Yr.frame.height):(mi[0]=yi.width,mi[1]=yi.height),mi[2]=yi.isRoot?-1:1,ni.update(),Zr.renderPipes.uniformBatch){const _i=Zr.renderPipes.uniformBatch.getUboResource(ni);this._globalFilterBindGroup.setResource(_i,0)}else this._globalFilterBindGroup.setResource(ni,0);this._globalFilterBindGroup.setResource(Gr.source,1),this._globalFilterBindGroup.setResource(Gr.source.style,2),ze.groups[0]=this._globalFilterBindGroup,Zr.encoder.draw({geometry:quadGeometry,shader:ze,state:ze._state,topology:"triangle-list"}),Zr.type===RendererType.WEBGL&&Zr.renderTarget.finishRenderPass()}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Bounds,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(ze,Gr){const Yr=this._activeFilterData,Kr=ze.set(Yr.inputTexture._source.width,0,0,Yr.inputTexture._source.height,Yr.bounds.minX,Yr.bounds.minY),Zr=Gr.worldTransform.copyTo(Matrix.shared),Qr=Gr.renderGroup||Gr.parentRenderGroup;return Qr&&Qr.cacheToLocalTransform&&Zr.prepend(Qr.cacheToLocalTransform),Zr.invert(),Kr.prepend(Zr),Kr.scale(1/Gr.texture.frame.width,1/Gr.texture.frame.height),Kr.translate(Gr.anchor.x,Gr.anchor.y),Kr}}FilterSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"filter"};var fragment$1=`in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,vertex$1=`in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,source=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;class MaskFilter extends Filter{constructor(ze){const{sprite:Gr,...Yr}=ze,Kr=new TextureMatrix(Gr.texture),Zr=new UniformGroup({uFilterMatrix:{value:new Matrix,type:"mat3x3<f32>"},uMaskClamp:{value:Kr.uClampFrame,type:"vec4<f32>"},uAlpha:{value:1,type:"f32"},uInverse:{value:ze.inverse?1:0,type:"f32"}}),Qr=GpuProgram.from({vertex:{source,entryPoint:"mainVertex"},fragment:{source,entryPoint:"mainFragment"}}),Jr=GlProgram.from({vertex:vertex$1,fragment:fragment$1,name:"mask-filter"});super({...Yr,gpuProgram:Qr,glProgram:Jr,resources:{filterUniforms:Zr,uMaskTexture:Gr.texture.source}}),this.sprite=Gr,this._textureMatrix=Kr}set inverse(ze){this.resources.filterUniforms.uniforms.uInverse=ze?1:0}get inverse(){return this.resources.filterUniforms.uniforms.uInverse===1}apply(ze,Gr,Yr,Kr){this._textureMatrix.texture=this.sprite.texture,ze.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.uMaskTexture=this.sprite.texture.source,ze.applyFilter(this,Gr,Yr,Kr)}}class Graphics extends ViewContainer{constructor(ze){ze instanceof GraphicsContext&&(ze={context:ze});const{context:Gr,roundPixels:Yr,...Kr}=ze||{};super({label:"Graphics",...Kr}),this.renderPipeId="graphics",Gr?this._context=Gr:this._context=this._ownedContext=new GraphicsContext,this._context.on("update",this.onViewUpdate,this),this.allowChildren=!1,this.roundPixels=Yr??!1}set context(ze){ze!==this._context&&(this._context.off("update",this.onViewUpdate,this),this._context=ze,this._context.on("update",this.onViewUpdate,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}updateBounds(){}containsPoint(ze){return this._context.containsPoint(ze)}destroy(ze){this._ownedContext&&!ze?this._ownedContext.destroy(ze):(ze===!0||(ze==null?void 0:ze.context)===!0)&&this._context.destroy(ze),this._ownedContext=null,this._context=null,super.destroy(ze)}_callContextMethod(ze,Gr){return this.context[ze](...Gr),this}setFillStyle(...ze){return this._callContextMethod("setFillStyle",ze)}setStrokeStyle(...ze){return this._callContextMethod("setStrokeStyle",ze)}fill(...ze){return this._callContextMethod("fill",ze)}stroke(...ze){return this._callContextMethod("stroke",ze)}texture(...ze){return this._callContextMethod("texture",ze)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...ze){return this._callContextMethod("arc",ze)}arcTo(...ze){return this._callContextMethod("arcTo",ze)}arcToSvg(...ze){return this._callContextMethod("arcToSvg",ze)}bezierCurveTo(...ze){return this._callContextMethod("bezierCurveTo",ze)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...ze){return this._callContextMethod("ellipse",ze)}circle(...ze){return this._callContextMethod("circle",ze)}path(...ze){return this._callContextMethod("path",ze)}lineTo(...ze){return this._callContextMethod("lineTo",ze)}moveTo(...ze){return this._callContextMethod("moveTo",ze)}quadraticCurveTo(...ze){return this._callContextMethod("quadraticCurveTo",ze)}rect(...ze){return this._callContextMethod("rect",ze)}roundRect(...ze){return this._callContextMethod("roundRect",ze)}poly(...ze){return this._callContextMethod("poly",ze)}regularPoly(...ze){return this._callContextMethod("regularPoly",ze)}roundPoly(...ze){return this._callContextMethod("roundPoly",ze)}roundShape(...ze){return this._callContextMethod("roundShape",ze)}filletRect(...ze){return this._callContextMethod("filletRect",ze)}chamferRect(...ze){return this._callContextMethod("chamferRect",ze)}star(...ze){return this._callContextMethod("star",ze)}svg(...ze){return this._callContextMethod("svg",ze)}restore(...ze){return this._callContextMethod("restore",ze)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...ze){return this._callContextMethod("rotate",ze)}scaleTransform(...ze){return this._callContextMethod("scale",ze)}setTransform(...ze){return this._callContextMethod("setTransform",ze)}transform(...ze){return this._callContextMethod("transform",ze)}translateTransform(...ze){return this._callContextMethod("translate",ze)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(ze){this._context.fillStyle=ze}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(ze){this._context.strokeStyle=ze}clone(ze=!1){return ze?new Graphics(this._context.clone()):(this._ownedContext=null,new Graphics(this._context))}lineStyle(ze,Gr,Yr){deprecation(v8_0_0,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const Kr={};return ze&&(Kr.width=ze),Gr&&(Kr.color=Gr),Yr&&(Kr.alpha=Yr),this.context.strokeStyle=Kr,this}beginFill(ze,Gr){deprecation(v8_0_0,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const Yr={};return ze!==void 0&&(Yr.color=ze),Gr!==void 0&&(Yr.alpha=Gr),this.context.fillStyle=Yr,this}endFill(){deprecation(v8_0_0,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const ze=this.context.strokeStyle;return(ze.width!==GraphicsContext.defaultStrokeStyle.width||ze.color!==GraphicsContext.defaultStrokeStyle.color||ze.alpha!==GraphicsContext.defaultStrokeStyle.alpha)&&this.context.stroke(),this}drawCircle(...ze){return deprecation(v8_0_0,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",ze)}drawEllipse(...ze){return deprecation(v8_0_0,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",ze)}drawPolygon(...ze){return deprecation(v8_0_0,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",ze)}drawRect(...ze){return deprecation(v8_0_0,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",ze)}drawRoundedRect(...ze){return deprecation(v8_0_0,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",ze)}drawStar(...ze){return deprecation(v8_0_0,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",ze)}}const _MeshGeometry=class Bs extends Geometry{constructor(...ze){let Gr=ze[0]??{};Gr instanceof Float32Array&&(deprecation(v8_0_0,"use new MeshGeometry({ positions, uvs, indices }) instead"),Gr={positions:Gr,uvs:ze[1],indices:ze[2]}),Gr={...Bs.defaultOptions,...Gr};const Yr=Gr.positions||new Float32Array([0,0,1,0,1,1,0,1]);let Kr=Gr.uvs;Kr||(Gr.positions?Kr=new Float32Array(Yr.length):Kr=new Float32Array([0,0,1,0,1,1,0,1]));const Zr=Gr.indices||new Uint32Array([0,1,2,0,2,3]),Qr=Gr.shrinkBuffersToFit,Jr=new Buffer({data:Yr,label:"attribute-mesh-positions",shrinkToFit:Qr,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ei=new Buffer({data:Kr,label:"attribute-mesh-uvs",shrinkToFit:Qr,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),ti=new Buffer({data:Zr,label:"index-mesh-buffer",shrinkToFit:Qr,usage:BufferUsage.INDEX|BufferUsage.COPY_DST});super({attributes:{aPosition:{buffer:Jr,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:ei,format:"float32x2",stride:2*4,offset:0}},indexBuffer:ti,topology:Gr.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(ze){this.attributes.aPosition.buffer.data=ze}get uvs(){return this.attributes.aUV.buffer.data}set uvs(ze){this.attributes.aUV.buffer.data=ze}get indices(){return this.indexBuffer.data}set indices(ze){this.indexBuffer.data=ze}};_MeshGeometry.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let MeshGeometry=_MeshGeometry;class Transform{constructor({matrix:ze,observer:Gr}={}){this.dirty=!0,this._matrix=ze??new Matrix,this.observer=Gr,this.position=new ObservablePoint(this,0,0),this.scale=new ObservablePoint(this,1,1),this.pivot=new ObservablePoint(this,0,0),this.skew=new ObservablePoint(this,0,0),this._rotation=0,this._cx=1,this._sx=0,this._cy=0,this._sy=1}get matrix(){const ze=this._matrix;return this.dirty&&(ze.a=this._cx*this.scale.x,ze.b=this._sx*this.scale.x,ze.c=this._cy*this.scale.y,ze.d=this._sy*this.scale.y,ze.tx=this.position.x-(this.pivot.x*ze.a+this.pivot.y*ze.c),ze.ty=this.position.y-(this.pivot.x*ze.b+this.pivot.y*ze.d),this.dirty=!1),ze}_onUpdate(ze){var Gr;this.dirty=!0,ze===this.skew&&this.updateSkew(),(Gr=this.observer)==null||Gr._onUpdate(this)}updateSkew(){this._cx=Math.cos(this._rotation+this.skew.y),this._sx=Math.sin(this._rotation+this.skew.y),this._cy=-Math.sin(this._rotation-this.skew.x),this._sy=Math.cos(this._rotation-this.skew.x),this.dirty=!0}toString(){return`[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`}setFromMatrix(ze){ze.decompose(this),this.dirty=!0}get rotation(){return this._rotation}set rotation(ze){this._rotation!==ze&&(this._rotation=ze,this._onUpdate(this.skew))}}const _TilingSprite=class as extends ViewContainer{constructor(...ze){let Gr=ze[0]||{};Gr instanceof Texture&&(Gr={texture:Gr}),ze.length>1&&(deprecation(v8_0_0,"use new TilingSprite({ texture, width:100, height:100 }) instead"),Gr.width=ze[1],Gr.height=ze[2]),Gr={...as.defaultOptions,...Gr};const{texture:Yr,anchor:Kr,tilePosition:Zr,tileScale:Qr,tileRotation:Jr,width:ei,height:ti,applyAnchorToTexture:ri,roundPixels:ii,...si}=Gr??{};super({label:"TilingSprite",...si}),this.renderPipeId="tilingSprite",this.batched=!0,this.allowChildren=!1,this._anchor=new ObservablePoint({_onUpdate:()=>{this.onViewUpdate()}}),this.applyAnchorToTexture=ri,this.texture=Yr,this._width=ei??Yr.width,this._height=ti??Yr.height,this._tileTransform=new Transform({observer:{_onUpdate:()=>this.onViewUpdate()}}),Kr&&(this.anchor=Kr),this.tilePosition=Zr,this.tileScale=Qr,this.tileRotation=Jr,this.roundPixels=ii??!1}static from(ze,Gr={}){return typeof ze=="string"?new as({texture:Cache.get(ze),...Gr}):new as({texture:ze,...Gr})}get uvRespectAnchor(){return warn("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),this.applyAnchorToTexture}set uvRespectAnchor(ze){warn("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"),this.applyAnchorToTexture=ze}get clampMargin(){return this._texture.textureMatrix.clampMargin}set clampMargin(ze){this._texture.textureMatrix.clampMargin=ze}get anchor(){return this._anchor}set anchor(ze){typeof ze=="number"?this._anchor.set(ze):this._anchor.copyFrom(ze)}get tilePosition(){return this._tileTransform.position}set tilePosition(ze){this._tileTransform.position.copyFrom(ze)}get tileScale(){return this._tileTransform.scale}set tileScale(ze){typeof ze=="number"?this._tileTransform.scale.set(ze):this._tileTransform.scale.copyFrom(ze)}set tileRotation(ze){this._tileTransform.rotation=ze}get tileRotation(){return this._tileTransform.rotation}get tileTransform(){return this._tileTransform}set texture(ze){ze||(ze=Texture.EMPTY);const Gr=this._texture;Gr!==ze&&(Gr&&Gr.dynamic&&Gr.off("update",this.onViewUpdate,this),ze.dynamic&&ze.on("update",this.onViewUpdate,this),this._texture=ze,this.onViewUpdate())}get texture(){return this._texture}set width(ze){this._width=ze,this.onViewUpdate()}get width(){return this._width}set height(ze){this._height=ze,this.onViewUpdate()}get height(){return this._height}setSize(ze,Gr){typeof ze=="object"&&(Gr=ze.height??ze.width,ze=ze.width),this._width=ze,this._height=Gr??ze,this.onViewUpdate()}getSize(ze){return ze||(ze={}),ze.width=this._width,ze.height=this._height,ze}updateBounds(){const ze=this._bounds,Gr=this._anchor,Yr=this._width,Kr=this._height;ze.minX=-Gr._x*Yr,ze.maxX=ze.minX+Yr,ze.minY=-Gr._y*Kr,ze.maxY=ze.minY+Kr}containsPoint(ze){const Gr=this._width,Yr=this._height,Kr=-Gr*this._anchor._x;let Zr=0;return ze.x>=Kr&&ze.x<=Kr+Gr&&(Zr=-Yr*this._anchor._y,ze.y>=Zr&&ze.y<=Zr+Yr)}destroy(ze=!1){if(super.destroy(ze),this._anchor=null,this._tileTransform=null,this._bounds=null,typeof ze=="boolean"?ze:ze==null?void 0:ze.texture){const Yr=typeof ze=="boolean"?ze:ze==null?void 0:ze.textureSource;this._texture.destroy(Yr)}this._texture=null}};_TilingSprite.defaultOptions={texture:Texture.EMPTY,anchor:{x:0,y:0},tilePosition:{x:0,y:0},tileScale:{x:1,y:1},tileRotation:0,applyAnchorToTexture:!1};let TilingSprite=_TilingSprite;class AbstractText extends ViewContainer{constructor(ze,Gr){const{text:Yr,resolution:Kr,style:Zr,anchor:Qr,width:Jr,height:ei,roundPixels:ti,...ri}=ze;super({...ri}),this.batched=!0,this._resolution=null,this._autoResolution=!0,this._didTextUpdate=!0,this._styleClass=Gr,this.text=Yr??"",this.style=Zr,this.resolution=Kr??null,this.allowChildren=!1,this._anchor=new ObservablePoint({_onUpdate:()=>{this.onViewUpdate()}}),Qr&&(this.anchor=Qr),this.roundPixels=ti??!1,Jr!==void 0&&(this.width=Jr),ei!==void 0&&(this.height=ei)}get anchor(){return this._anchor}set anchor(ze){typeof ze=="number"?this._anchor.set(ze):this._anchor.copyFrom(ze)}set text(ze){ze=ze.toString(),this._text!==ze&&(this._text=ze,this.onViewUpdate())}get text(){return this._text}set resolution(ze){this._autoResolution=ze===null,this._resolution=ze,this.onViewUpdate()}get resolution(){return this._resolution}get style(){return this._style}set style(ze){var Gr;ze||(ze={}),(Gr=this._style)==null||Gr.off("update",this.onViewUpdate,this),ze instanceof this._styleClass?this._style=ze:this._style=new this._styleClass(ze),this._style.on("update",this.onViewUpdate,this),this.onViewUpdate()}get width(){return Math.abs(this.scale.x)*this.bounds.width}set width(ze){this._setWidth(ze,this.bounds.width)}get height(){return Math.abs(this.scale.y)*this.bounds.height}set height(ze){this._setHeight(ze,this.bounds.height)}getSize(ze){return ze||(ze={}),ze.width=Math.abs(this.scale.x)*this.bounds.width,ze.height=Math.abs(this.scale.y)*this.bounds.height,ze}setSize(ze,Gr){typeof ze=="object"?(Gr=ze.height??ze.width,ze=ze.width):Gr??(Gr=ze),ze!==void 0&&this._setWidth(ze,this.bounds.width),Gr!==void 0&&this._setHeight(Gr,this.bounds.height)}containsPoint(ze){const Gr=this.bounds.width,Yr=this.bounds.height,Kr=-Gr*this.anchor.x;let Zr=0;return ze.x>=Kr&&ze.x<=Kr+Gr&&(Zr=-Yr*this.anchor.y,ze.y>=Zr&&ze.y<=Zr+Yr)}onViewUpdate(){this.didViewUpdate||(this._didTextUpdate=!0),super.onViewUpdate()}_getKey(){return`${this.text}:${this._style.styleKey}:${this._resolution}`}destroy(ze=!1){super.destroy(ze),this.owner=null,this._bounds=null,this._anchor=null,(typeof ze=="boolean"?ze:ze!=null&&ze.style)&&this._style.destroy(ze),this._style=null,this._text=null}}function ensureTextOptions(Wr,ze){let Gr=Wr[0]??{};return(typeof Gr=="string"||Wr[1])&&(deprecation(v8_0_0,`use new ${ze}({ text: "hi!", style }) instead`),Gr={text:Gr,style:Wr[1]}),Gr}class Text extends AbstractText{constructor(...ze){const Gr=ensureTextOptions(ze,"Text");super(Gr,TextStyle),this.renderPipeId="text"}updateBounds(){const ze=this._bounds,Gr=this._anchor,Yr=CanvasTextMetrics.measureText(this._text,this._style),{width:Kr,height:Zr}=Yr;ze.minX=-Gr._x*Kr,ze.maxX=ze.minX+Kr,ze.minY=-Gr._y*Zr,ze.maxY=ze.minY+Zr}}function textStyleToCSS(Wr){const ze=Wr._stroke,Gr=Wr._fill,Kr=[`div { ${[`color: ${Color.shared.setValue(Gr.color).toHex()}`,`font-size: ${Wr.fontSize}px`,`font-family: ${Wr.fontFamily}`,`font-weight: ${Wr.fontWeight}`,`font-style: ${Wr.fontStyle}`,`font-variant: ${Wr.fontVariant}`,`letter-spacing: ${Wr.letterSpacing}px`,`text-align: ${Wr.align}`,`padding: ${Wr.padding}px`,`white-space: ${Wr.whiteSpace==="pre"&&Wr.wordWrap?"pre-wrap":Wr.whiteSpace}`,...Wr.lineHeight?[`line-height: ${Wr.lineHeight}px`]:[],...Wr.wordWrap?[`word-wrap: ${Wr.breakWords?"break-all":"break-word"}`,`max-width: ${Wr.wordWrapWidth}px`]:[],...ze?[strokeToCSS(ze)]:[],...Wr.dropShadow?[dropShadowToCSS(Wr.dropShadow)]:[],...Wr.cssOverrides].join(";")} }`];return tagStyleToCSS(Wr.tagStyles,Kr),Kr.join(" ")}function dropShadowToCSS(Wr){const ze=Color.shared.setValue(Wr.color).setAlpha(Wr.alpha).toHexa(),Gr=Math.round(Math.cos(Wr.angle)*Wr.distance),Yr=Math.round(Math.sin(Wr.angle)*Wr.distance),Kr=`${Gr}px ${Yr}px`;return Wr.blur>0?`text-shadow: ${Kr} ${Wr.blur}px ${ze}`:`text-shadow: ${Kr} ${ze}`}function strokeToCSS(Wr){return[`-webkit-text-stroke-width: ${Wr.width}px`,`-webkit-text-stroke-color: ${Color.shared.setValue(Wr.color).toHex()}`,`text-stroke-width: ${Wr.width}px`,`text-stroke-color: ${Color.shared.setValue(Wr.color).toHex()}`,"paint-order: stroke"].join(";")}const templates={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},transform={fill:Wr=>`color: ${Color.shared.setValue(Wr).toHex()}`,breakWords:Wr=>`word-wrap: ${Wr?"break-all":"break-word"}`,stroke:strokeToCSS,dropShadow:dropShadowToCSS};function tagStyleToCSS(Wr,ze){for(const Gr in Wr){const Yr=Wr[Gr],Kr=[];for(const Zr in Yr)transform[Zr]?Kr.push(transform[Zr](Yr[Zr])):templates[Zr]&&Kr.push(templates[Zr].replace("{{VALUE}}",Yr[Zr]));ze.push(`${Gr} { ${Kr.join(";")} }`)}}class HTMLTextStyle extends TextStyle{constructor(ze={}){super(ze),this._cssOverrides=[],this.cssOverrides??(this.cssOverrides=ze.cssOverrides),this.tagStyles=ze.tagStyles??{}}set cssOverrides(ze){this._cssOverrides=ze instanceof Array?ze:[ze],this.update()}get cssOverrides(){return this._cssOverrides}_generateKey(){return this._styleKey=generateTextStyleKey(this)+this._cssOverrides.join("-"),this._styleKey}update(){this._cssStyle=null,super.update()}clone(){return new HTMLTextStyle({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow?{...this.dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides})}get cssStyle(){return this._cssStyle||(this._cssStyle=textStyleToCSS(this)),this._cssStyle}addOverride(...ze){const Gr=ze.filter(Yr=>!this.cssOverrides.includes(Yr));Gr.length>0&&(this.cssOverrides.push(...Gr),this.update())}removeOverride(...ze){const Gr=ze.filter(Yr=>this.cssOverrides.includes(Yr));Gr.length>0&&(this.cssOverrides=this.cssOverrides.filter(Yr=>!Gr.includes(Yr)),this.update())}set fill(ze){typeof ze!="string"&&typeof ze!="number"&&warn("[HTMLTextStyle] only color fill is not supported by HTMLText"),super.fill=ze}set stroke(ze){ze&&typeof ze!="string"&&typeof ze!="number"&&warn("[HTMLTextStyle] only color stroke is not supported by HTMLText"),super.stroke=ze}}const nssvg="http://www.w3.org/2000/svg",nsxhtml="http://www.w3.org/1999/xhtml";class HTMLTextRenderData{constructor(){this.svgRoot=document.createElementNS(nssvg,"svg"),this.foreignObject=document.createElementNS(nssvg,"foreignObject"),this.domElement=document.createElementNS(nsxhtml,"div"),this.styleElement=document.createElementNS(nsxhtml,"style"),this.image=new Image;const{foreignObject:ze,svgRoot:Gr,styleElement:Yr,domElement:Kr}=this;ze.setAttribute("width","10000"),ze.setAttribute("height","10000"),ze.style.overflow="hidden",Gr.appendChild(ze),ze.appendChild(Yr),ze.appendChild(Kr)}}let tempHTMLTextRenderData;function measureHtmlText(Wr,ze,Gr,Yr){Yr||(Yr=tempHTMLTextRenderData||(tempHTMLTextRenderData=new HTMLTextRenderData));const{domElement:Kr,styleElement:Zr,svgRoot:Qr}=Yr;Kr.innerHTML=`<style>${ze.cssStyle};</style><div style='padding:0'>${Wr}</div>`,Kr.setAttribute("style","transform-origin: top left; display: inline-block"),Gr&&(Zr.textContent=Gr),document.body.appendChild(Qr);const Jr=Kr.getBoundingClientRect();Qr.remove();const ei=ze.padding*2;return{width:Jr.width-ei,height:Jr.height-ei}}class GlBatchAdaptor{constructor(){this._tempState=State.for2d(),this._didUploadHash={}}init(ze){ze.renderer.runners.contextChange.add(this)}contextChange(){this._didUploadHash={}}start(ze,Gr,Yr){const Kr=ze.renderer,Zr=this._didUploadHash[Yr.uid];Kr.shader.bind(Yr,Zr),Zr||(this._didUploadHash[Yr.uid]=!0),Kr.shader.updateUniformGroup(Kr.globalUniforms.uniformGroup),Kr.geometry.bind(Gr,Yr.glProgram)}execute(ze,Gr){const Yr=ze.renderer;this._tempState.blendMode=Gr.blendMode,Yr.state.set(this._tempState);const Kr=Gr.textures.textures;for(let Zr=0;Zr<Gr.textures.count;Zr++)Yr.texture.bind(Kr[Zr],Zr);Yr.geometry.draw(Gr.topology,Gr.size,Gr.start)}}GlBatchAdaptor.extension={type:[ExtensionType.WebGLPipesAdaptor],name:"batch"};const tempState=State.for2d();class GpuBatchAdaptor{start(ze,Gr,Yr){const Kr=ze.renderer,Zr=Kr.encoder,Qr=Yr.gpuProgram;this._shader=Yr,this._geometry=Gr,Zr.setGeometry(Gr,Qr),tempState.blendMode="normal",Kr.pipeline.getPipeline(Gr,Qr,tempState);const Jr=Kr.globalUniforms.bindGroup;Zr.resetBindGroup(1),Zr.setBindGroup(0,Jr,Qr)}execute(ze,Gr){const Yr=this._shader.gpuProgram,Kr=ze.renderer,Zr=Kr.encoder;if(!Gr.bindGroup){const ei=Gr.textures;Gr.bindGroup=getTextureBatchBindGroup(ei.textures,ei.count)}tempState.blendMode=Gr.blendMode;const Qr=Kr.bindGroup.getBindGroup(Gr.bindGroup,Yr,1),Jr=Kr.pipeline.getPipeline(this._geometry,Yr,tempState,Gr.topology);Gr.bindGroup._touch(Kr.textureGC.count),Zr.setPipeline(Jr),Zr.renderPassEncoder.setBindGroup(1,Qr),Zr.renderPassEncoder.drawIndexed(Gr.size,1,Gr.start)}}GpuBatchAdaptor.extension={type:[ExtensionType.WebGPUPipesAdaptor],name:"batch"};const _BatcherPipe=class Rs{constructor(ze,Gr){var Yr,Kr;this.state=State.for2d(),this._batchersByInstructionSet=Object.create(null),this._activeBatches=Object.create(null),this.renderer=ze,this._adaptor=Gr,(Kr=(Yr=this._adaptor).init)==null||Kr.call(Yr,this)}static getBatcher(ze){return new this._availableBatchers[ze]}buildStart(ze){let Gr=this._batchersByInstructionSet[ze.uid];Gr||(Gr=this._batchersByInstructionSet[ze.uid]=Object.create(null),Gr.default||(Gr.default=new DefaultBatcher)),this._activeBatches=Gr,this._activeBatch=this._activeBatches.default;for(const Yr in this._activeBatches)this._activeBatches[Yr].begin()}addToBatch(ze,Gr){if(this._activeBatch.name!==ze.batcherName){this._activeBatch.break(Gr);let Yr=this._activeBatches[ze.batcherName];Yr||(Yr=this._activeBatches[ze.batcherName]=Rs.getBatcher(ze.batcherName),Yr.begin()),this._activeBatch=Yr}this._activeBatch.add(ze)}break(ze){this._activeBatch.break(ze)}buildEnd(ze){this._activeBatch.break(ze);const Gr=this._activeBatches;for(const Yr in Gr){const Kr=Gr[Yr],Zr=Kr.geometry;Zr.indexBuffer.setDataWithSize(Kr.indexBuffer,Kr.indexSize,!0),Zr.buffers[0].setDataWithSize(Kr.attributeBuffer.float32View,Kr.attributeSize,!1)}}upload(ze){const Gr=this._batchersByInstructionSet[ze.uid];for(const Yr in Gr){const Kr=Gr[Yr],Zr=Kr.geometry;Kr.dirty&&(Kr.dirty=!1,Zr.buffers[0].update(Kr.attributeSize*4))}}execute(ze){if(ze.action==="startBatch"){const Gr=ze.batcher,Yr=Gr.geometry,Kr=Gr.shader;this._adaptor.start(this,Yr,Kr)}this._adaptor.execute(this,ze)}destroy(){this.state=null,this.renderer=null,this._adaptor=null;for(const ze in this._activeBatches)this._activeBatches[ze].destroy();this._activeBatches=null}};_BatcherPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"batch"};_BatcherPipe._availableBatchers=Object.create(null);let BatcherPipe=_BatcherPipe;extensions.handleByMap(ExtensionType.Batcher,BatcherPipe._availableBatchers);extensions.add(DefaultBatcher);const localUniformBit={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}},localUniformBitGroup2={...localUniformBit,vertex:{...localUniformBit.vertex,header:localUniformBit.vertex.header.replace("group(1)","group(2)")}},localUniformBitGl={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}},textureBit={name:"texture-bit",vertex:{header:`

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,main:`
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `,main:`
            outColor = textureSample(uTexture, uSampler, vUV);
        `}},textureBitGl={name:"texture-bit",vertex:{header:`
            uniform mat3 uTextureMatrix;
        `,main:`
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
        uniform sampler2D uTexture;

         
        `,main:`
            outColor = texture(uTexture, vUV);
        `}},tempBounds$2=new Bounds;class AlphaMaskEffect extends FilterEffect{constructor(){super(),this.filters=[new MaskFilter({sprite:new Sprite(Texture.EMPTY),inverse:!1,resolution:"inherit",antialias:"inherit"})]}get sprite(){return this.filters[0].sprite}set sprite(ze){this.filters[0].sprite=ze}get inverse(){return this.filters[0].inverse}set inverse(ze){this.filters[0].inverse=ze}}class AlphaMaskPipe{constructor(ze){this._activeMaskStage=[],this._renderer=ze}push(ze,Gr,Yr){const Kr=this._renderer;if(Kr.renderPipes.batch.break(Yr),Yr.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1,maskedContainer:Gr}),ze.inverse=Gr._maskOptions.inverse,ze.renderMaskToTexture){const Zr=ze.mask;Zr.includeInBuild=!0,Zr.collectRenderables(Yr,Kr,null),Zr.includeInBuild=!1}Kr.renderPipes.batch.break(Yr),Yr.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask:ze,maskedContainer:Gr,inverse:Gr._maskOptions.inverse,canBundle:!1})}pop(ze,Gr,Yr){this._renderer.renderPipes.batch.break(Yr),Yr.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1})}execute(ze){const Gr=this._renderer,Yr=ze.mask.renderMaskToTexture;if(ze.action==="pushMaskBegin"){const Kr=BigPool.get(AlphaMaskEffect);if(Kr.inverse=ze.inverse,Yr){ze.mask.mask.measurable=!0;const Zr=getGlobalBounds(ze.mask.mask,!0,tempBounds$2);ze.mask.mask.measurable=!1,Zr.ceil();const Qr=Gr.renderTarget.renderTarget.colorTexture.source,Jr=TexturePool.getOptimalTexture(Zr.width,Zr.height,Qr._resolution,Qr.antialias);Gr.renderTarget.push(Jr,!0),Gr.globalUniforms.push({offset:Zr,worldColor:4294967295});const ei=Kr.sprite;ei.texture=Jr,ei.worldTransform.tx=Zr.minX,ei.worldTransform.ty=Zr.minY,this._activeMaskStage.push({filterEffect:Kr,maskedContainer:ze.maskedContainer,filterTexture:Jr})}else Kr.sprite=ze.mask.mask,this._activeMaskStage.push({filterEffect:Kr,maskedContainer:ze.maskedContainer})}else if(ze.action==="pushMaskEnd"){const Kr=this._activeMaskStage[this._activeMaskStage.length-1];Yr&&(Gr.type===RendererType.WEBGL&&Gr.renderTarget.finishRenderPass(),Gr.renderTarget.pop(),Gr.globalUniforms.pop()),Gr.filter.push({renderPipeId:"filter",action:"pushFilter",container:Kr.maskedContainer,filterEffect:Kr.filterEffect,canBundle:!1})}else if(ze.action==="popMaskEnd"){Gr.filter.pop();const Kr=this._activeMaskStage.pop();Yr&&TexturePool.returnTexture(Kr.filterTexture),BigPool.return(Kr.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}AlphaMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"alphaMask"};class ColorMaskPipe{constructor(ze){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=ze}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(ze,Gr,Yr){this._renderer.renderPipes.batch.break(Yr);const Zr=this._colorStack;Zr[this._colorStackIndex]=Zr[this._colorStackIndex-1]&ze.mask;const Qr=this._colorStack[this._colorStackIndex];Qr!==this._currentColor&&(this._currentColor=Qr,Yr.add({renderPipeId:"colorMask",colorMask:Qr,canBundle:!1})),this._colorStackIndex++}pop(ze,Gr,Yr){this._renderer.renderPipes.batch.break(Yr);const Zr=this._colorStack;this._colorStackIndex--;const Qr=Zr[this._colorStackIndex-1];Qr!==this._currentColor&&(this._currentColor=Qr,Yr.add({renderPipeId:"colorMask",colorMask:Qr,canBundle:!1}))}execute(ze){this._renderer.colorMask.setMask(ze.colorMask)}destroy(){this._colorStack=null}}ColorMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"colorMask"};class StencilMaskPipe{constructor(ze){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=ze}push(ze,Gr,Yr){var Kr;const Zr=ze,Qr=this._renderer;Qr.renderPipes.batch.break(Yr),Qr.renderPipes.blendMode.setBlendMode(Zr.mask,"none",Yr),Yr.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1});const Jr=Zr.mask;Jr.includeInBuild=!0,this._maskHash.has(Zr)||this._maskHash.set(Zr,{instructionsStart:0,instructionsLength:0});const ei=this._maskHash.get(Zr);ei.instructionsStart=Yr.instructionSize,Jr.collectRenderables(Yr,Qr,null),Jr.includeInBuild=!1,Qr.renderPipes.batch.break(Yr),Yr.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask:ze,inverse:Gr._maskOptions.inverse,canBundle:!1});const ti=Yr.instructionSize-ei.instructionsStart-1;ei.instructionsLength=ti;const ri=Qr.renderTarget.renderTarget.uid;(Kr=this._maskStackHash)[ri]??(Kr[ri]=0)}pop(ze,Gr,Yr){const Kr=ze,Zr=this._renderer;Zr.renderPipes.batch.break(Yr),Zr.renderPipes.blendMode.setBlendMode(Kr.mask,"none",Yr),Yr.add({renderPipeId:"stencilMask",action:"popMaskBegin",inverse:Gr._maskOptions.inverse,canBundle:!1});const Qr=this._maskHash.get(ze);for(let Jr=0;Jr<Qr.instructionsLength;Jr++)Yr.instructions[Yr.instructionSize++]=Yr.instructions[Qr.instructionsStart++];Yr.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(ze){var Gr;const Yr=this._renderer,Kr=Yr.renderTarget.renderTarget.uid;let Zr=(Gr=this._maskStackHash)[Kr]??(Gr[Kr]=0);ze.action==="pushMaskBegin"?(Yr.renderTarget.ensureDepthStencil(),Yr.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD,Zr),Zr++,Yr.colorMask.setMask(0)):ze.action==="pushMaskEnd"?(ze.inverse?Yr.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE,Zr):Yr.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,Zr),Yr.colorMask.setMask(15)):ze.action==="popMaskBegin"?(Yr.colorMask.setMask(0),Zr!==0?Yr.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE,Zr):(Yr.renderTarget.clear(null,CLEAR.STENCIL),Yr.stencil.setStencilMode(STENCIL_MODES.DISABLED,Zr)),Zr--):ze.action==="popMaskEnd"&&(ze.inverse?Yr.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE,Zr):Yr.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE,Zr),Yr.colorMask.setMask(15)),this._maskStackHash[Kr]=Zr}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}StencilMaskPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"stencilMask"};var BUFFER_TYPE=(Wr=>(Wr[Wr.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",Wr[Wr.ARRAY_BUFFER=34962]="ARRAY_BUFFER",Wr[Wr.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",Wr))(BUFFER_TYPE||{});class GlBuffer{constructor(ze,Gr){this._lastBindBaseLocation=-1,this._lastBindCallId=-1,this.buffer=ze||null,this.updateID=-1,this.byteLength=-1,this.type=Gr}}class GlBufferSystem{constructor(ze){this._gpuBuffers=Object.create(null),this._boundBufferBases=Object.create(null),this._minBaseLocation=0,this._nextBindBaseIndex=this._minBaseLocation,this._bindCallId=0,this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuBuffers")}destroy(){this._renderer=null,this._gl=null,this._gpuBuffers=null,this._boundBufferBases=null}contextChange(){const ze=this._gl=this._renderer.gl;this._gpuBuffers=Object.create(null),this._maxBindings=ze.MAX_UNIFORM_BUFFER_BINDINGS?ze.getParameter(ze.MAX_UNIFORM_BUFFER_BINDINGS):0}getGlBuffer(ze){return this._gpuBuffers[ze.uid]||this.createGLBuffer(ze)}bind(ze){const{_gl:Gr}=this,Yr=this.getGlBuffer(ze);Gr.bindBuffer(Yr.type,Yr.buffer)}bindBufferBase(ze,Gr){const{_gl:Yr}=this;this._boundBufferBases[Gr]!==ze&&(this._boundBufferBases[Gr]=ze,ze._lastBindBaseLocation=Gr,Yr.bindBufferBase(Yr.UNIFORM_BUFFER,Gr,ze.buffer))}nextBindBase(ze){this._bindCallId++,this._minBaseLocation=0,ze&&(this._boundBufferBases[0]=null,this._minBaseLocation=1,this._nextBindBaseIndex<1&&(this._nextBindBaseIndex=1))}freeLocationForBufferBase(ze){let Gr=this.getLastBindBaseLocation(ze);if(Gr>=this._minBaseLocation)return ze._lastBindCallId=this._bindCallId,Gr;let Yr=0,Kr=this._nextBindBaseIndex;for(;Yr<2;){Kr>=this._maxBindings&&(Kr=this._minBaseLocation,Yr++);const Zr=this._boundBufferBases[Kr];if(Zr&&Zr._lastBindCallId===this._bindCallId){Kr++;continue}break}return Gr=Kr,this._nextBindBaseIndex=Kr+1,Yr>=2?-1:(ze._lastBindCallId=this._bindCallId,this._boundBufferBases[Gr]=null,Gr)}getLastBindBaseLocation(ze){const Gr=ze._lastBindBaseLocation;return this._boundBufferBases[Gr]===ze?Gr:-1}bindBufferRange(ze,Gr,Yr,Kr){const{_gl:Zr}=this;Yr||(Yr=0),Gr||(Gr=0),this._boundBufferBases[Gr]=null,Zr.bindBufferRange(Zr.UNIFORM_BUFFER,Gr||0,ze.buffer,Yr*256,Kr||256)}updateBuffer(ze){const{_gl:Gr}=this,Yr=this.getGlBuffer(ze);if(ze._updateID===Yr.updateID)return Yr;Yr.updateID=ze._updateID,Gr.bindBuffer(Yr.type,Yr.buffer);const Kr=ze.data,Zr=ze.descriptor.usage&BufferUsage.STATIC?Gr.STATIC_DRAW:Gr.DYNAMIC_DRAW;return Kr?Yr.byteLength>=Kr.byteLength?Gr.bufferSubData(Yr.type,0,Kr,0,ze._updateSize/Kr.BYTES_PER_ELEMENT):(Yr.byteLength=Kr.byteLength,Gr.bufferData(Yr.type,Kr,Zr)):(Yr.byteLength=ze.descriptor.size,Gr.bufferData(Yr.type,Yr.byteLength,Zr)),Yr}destroyAll(){const ze=this._gl;for(const Gr in this._gpuBuffers)ze.deleteBuffer(this._gpuBuffers[Gr].buffer);this._gpuBuffers=Object.create(null)}onBufferDestroy(ze,Gr){const Yr=this._gpuBuffers[ze.uid],Kr=this._gl;Gr||Kr.deleteBuffer(Yr.buffer),this._gpuBuffers[ze.uid]=null}createGLBuffer(ze){const{_gl:Gr}=this;let Yr=BUFFER_TYPE.ARRAY_BUFFER;ze.descriptor.usage&BufferUsage.INDEX?Yr=BUFFER_TYPE.ELEMENT_ARRAY_BUFFER:ze.descriptor.usage&BufferUsage.UNIFORM&&(Yr=BUFFER_TYPE.UNIFORM_BUFFER);const Kr=new GlBuffer(Gr.createBuffer(),Yr);return this._gpuBuffers[ze.uid]=Kr,ze.on("destroy",this.onBufferDestroy,this),Kr}resetState(){this._boundBufferBases=Object.create(null)}}GlBufferSystem.extension={type:[ExtensionType.WebGLSystem],name:"buffer"};const _GlContextSystem=class Is{constructor(ze){this.supports={uint32Indices:!0,uniformBufferObject:!0,vertexArrayObject:!0,srgbTextures:!0,nonPowOf2wrapping:!0,msaa:!0,nonPowOf2mipmaps:!0},this._renderer=ze,this.extensions=Object.create(null),this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}contextChange(ze){this.gl=ze,this._renderer.gl=ze}init(ze){ze={...Is.defaultOptions,...ze};let Gr=this.multiView=ze.multiView;if(ze.context&&Gr&&(warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."),Gr=!1),Gr?this.canvas=DOMAdapter.get().createCanvas(this._renderer.canvas.width,this._renderer.canvas.height):this.canvas=this._renderer.view.canvas,ze.context)this.initFromContext(ze.context);else{const Yr=this._renderer.background.alpha<1,Kr=ze.premultipliedAlpha??!0,Zr=ze.antialias&&!this._renderer.backBuffer.useBackBuffer;this.createContext(ze.preferWebGLVersion,{alpha:Yr,premultipliedAlpha:Kr,antialias:Zr,stencil:!0,preserveDrawingBuffer:ze.preserveDrawingBuffer,powerPreference:ze.powerPreference??"default"})}}ensureCanvasSize(ze){if(!this.multiView){ze!==this.canvas&&warn("multiView is disabled, but targetCanvas is not the main canvas");return}const{canvas:Gr}=this;(Gr.width<ze.width||Gr.height<ze.height)&&(Gr.width=Math.max(ze.width,ze.width),Gr.height=Math.max(ze.height,ze.height))}initFromContext(ze){this.gl=ze,this.webGLVersion=ze instanceof DOMAdapter.get().getWebGLRenderingContext()?1:2,this.getExtensions(),this.validateContext(ze),this._renderer.runners.contextChange.emit(ze);const Gr=this._renderer.view.canvas;Gr.addEventListener("webglcontextlost",this.handleContextLost,!1),Gr.addEventListener("webglcontextrestored",this.handleContextRestored,!1)}createContext(ze,Gr){let Yr;const Kr=this.canvas;if(ze===2&&(Yr=Kr.getContext("webgl2",Gr)),!Yr&&(Yr=Kr.getContext("webgl",Gr),!Yr))throw new Error("This browser does not support WebGL. Try using the canvas renderer");this.gl=Yr,this.initFromContext(this.gl)}getExtensions(){const{gl:ze}=this,Gr={anisotropicFiltering:ze.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:ze.getExtension("OES_texture_float_linear"),s3tc:ze.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:ze.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:ze.getExtension("WEBGL_compressed_texture_etc"),etc1:ze.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:ze.getExtension("WEBGL_compressed_texture_pvrtc")||ze.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:ze.getExtension("WEBGL_compressed_texture_atc"),astc:ze.getExtension("WEBGL_compressed_texture_astc"),bptc:ze.getExtension("EXT_texture_compression_bptc"),rgtc:ze.getExtension("EXT_texture_compression_rgtc"),loseContext:ze.getExtension("WEBGL_lose_context")};if(this.webGLVersion===1)this.extensions={...Gr,drawBuffers:ze.getExtension("WEBGL_draw_buffers"),depthTexture:ze.getExtension("WEBGL_depth_texture"),vertexArrayObject:ze.getExtension("OES_vertex_array_object")||ze.getExtension("MOZ_OES_vertex_array_object")||ze.getExtension("WEBKIT_OES_vertex_array_object"),uint32ElementIndex:ze.getExtension("OES_element_index_uint"),floatTexture:ze.getExtension("OES_texture_float"),floatTextureLinear:ze.getExtension("OES_texture_float_linear"),textureHalfFloat:ze.getExtension("OES_texture_half_float"),textureHalfFloatLinear:ze.getExtension("OES_texture_half_float_linear"),vertexAttribDivisorANGLE:ze.getExtension("ANGLE_instanced_arrays"),srgb:ze.getExtension("EXT_sRGB")};else{this.extensions={...Gr,colorBufferFloat:ze.getExtension("EXT_color_buffer_float")};const Yr=ze.getExtension("WEBGL_provoking_vertex");Yr&&Yr.provokingVertexWEBGL(Yr.FIRST_VERTEX_CONVENTION_WEBGL)}}handleContextLost(ze){ze.preventDefault(),this._contextLossForced&&(this._contextLossForced=!1,setTimeout(()=>{var Gr;this.gl.isContextLost()&&((Gr=this.extensions.loseContext)==null||Gr.restoreContext())},0))}handleContextRestored(){this.getExtensions(),this._renderer.runners.contextChange.emit(this.gl)}destroy(){var Gr;const ze=this._renderer.view.canvas;this._renderer=null,ze.removeEventListener("webglcontextlost",this.handleContextLost),ze.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),(Gr=this.extensions.loseContext)==null||Gr.loseContext()}forceContextLoss(){var ze;(ze=this.extensions.loseContext)==null||ze.loseContext(),this._contextLossForced=!0}validateContext(ze){const Gr=ze.getContextAttributes();Gr&&!Gr.stencil&&warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");const Yr=this.supports,Kr=this.webGLVersion===2,Zr=this.extensions;Yr.uint32Indices=Kr||!!Zr.uint32ElementIndex,Yr.uniformBufferObject=Kr,Yr.vertexArrayObject=Kr||!!Zr.vertexArrayObject,Yr.srgbTextures=Kr||!!Zr.srgb,Yr.nonPowOf2wrapping=Kr,Yr.nonPowOf2mipmaps=Kr,Yr.msaa=Kr,Yr.uint32Indices||warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly")}};_GlContextSystem.extension={type:[ExtensionType.WebGLSystem],name:"context"};_GlContextSystem.defaultOptions={context:null,premultipliedAlpha:!0,preserveDrawingBuffer:!1,powerPreference:void 0,preferWebGLVersion:2,multiView:!1};let GlContextSystem=_GlContextSystem;function ensureAttributes(Wr,ze){for(const Gr in Wr.attributes){const Yr=Wr.attributes[Gr],Kr=ze[Gr];Kr?(Yr.format??(Yr.format=Kr.format),Yr.offset??(Yr.offset=Kr.offset),Yr.instance??(Yr.instance=Kr.instance)):warn(`Attribute ${Gr} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}ensureStartAndStride(Wr)}function ensureStartAndStride(Wr){const{buffers:ze,attributes:Gr}=Wr,Yr={},Kr={};for(const Zr in ze){const Qr=ze[Zr];Yr[Qr.uid]=0,Kr[Qr.uid]=0}for(const Zr in Gr){const Qr=Gr[Zr];Yr[Qr.buffer.uid]+=getAttributeInfoFromFormat(Qr.format).stride}for(const Zr in Gr){const Qr=Gr[Zr];Qr.stride??(Qr.stride=Yr[Qr.buffer.uid]),Qr.start??(Qr.start=Kr[Qr.buffer.uid]),Kr[Qr.buffer.uid]+=getAttributeInfoFromFormat(Qr.format).stride}}var GL_FORMATS=(Wr=>(Wr[Wr.RGBA=6408]="RGBA",Wr[Wr.RGB=6407]="RGB",Wr[Wr.RG=33319]="RG",Wr[Wr.RED=6403]="RED",Wr[Wr.RGBA_INTEGER=36249]="RGBA_INTEGER",Wr[Wr.RGB_INTEGER=36248]="RGB_INTEGER",Wr[Wr.RG_INTEGER=33320]="RG_INTEGER",Wr[Wr.RED_INTEGER=36244]="RED_INTEGER",Wr[Wr.ALPHA=6406]="ALPHA",Wr[Wr.LUMINANCE=6409]="LUMINANCE",Wr[Wr.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",Wr[Wr.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",Wr[Wr.DEPTH_STENCIL=34041]="DEPTH_STENCIL",Wr))(GL_FORMATS||{}),GL_TARGETS=(Wr=>(Wr[Wr.TEXTURE_2D=3553]="TEXTURE_2D",Wr[Wr.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",Wr[Wr.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",Wr[Wr.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",Wr[Wr.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",Wr[Wr.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",Wr[Wr.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",Wr[Wr.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",Wr[Wr.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",Wr))(GL_TARGETS||{}),GL_TYPES=(Wr=>(Wr[Wr.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",Wr[Wr.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",Wr[Wr.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",Wr[Wr.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",Wr[Wr.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",Wr[Wr.UNSIGNED_INT=5125]="UNSIGNED_INT",Wr[Wr.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",Wr[Wr.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",Wr[Wr.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",Wr[Wr.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",Wr[Wr.BYTE=5120]="BYTE",Wr[Wr.SHORT=5122]="SHORT",Wr[Wr.INT=5124]="INT",Wr[Wr.FLOAT=5126]="FLOAT",Wr[Wr.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",Wr[Wr.HALF_FLOAT=36193]="HALF_FLOAT",Wr))(GL_TYPES||{});const infoMap={uint8x2:GL_TYPES.UNSIGNED_BYTE,uint8x4:GL_TYPES.UNSIGNED_BYTE,sint8x2:GL_TYPES.BYTE,sint8x4:GL_TYPES.BYTE,unorm8x2:GL_TYPES.UNSIGNED_BYTE,unorm8x4:GL_TYPES.UNSIGNED_BYTE,snorm8x2:GL_TYPES.BYTE,snorm8x4:GL_TYPES.BYTE,uint16x2:GL_TYPES.UNSIGNED_SHORT,uint16x4:GL_TYPES.UNSIGNED_SHORT,sint16x2:GL_TYPES.SHORT,sint16x4:GL_TYPES.SHORT,unorm16x2:GL_TYPES.UNSIGNED_SHORT,unorm16x4:GL_TYPES.UNSIGNED_SHORT,snorm16x2:GL_TYPES.SHORT,snorm16x4:GL_TYPES.SHORT,float16x2:GL_TYPES.HALF_FLOAT,float16x4:GL_TYPES.HALF_FLOAT,float32:GL_TYPES.FLOAT,float32x2:GL_TYPES.FLOAT,float32x3:GL_TYPES.FLOAT,float32x4:GL_TYPES.FLOAT,uint32:GL_TYPES.UNSIGNED_INT,uint32x2:GL_TYPES.UNSIGNED_INT,uint32x3:GL_TYPES.UNSIGNED_INT,uint32x4:GL_TYPES.UNSIGNED_INT,sint32:GL_TYPES.INT,sint32x2:GL_TYPES.INT,sint32x3:GL_TYPES.INT,sint32x4:GL_TYPES.INT};function getGlTypeFromFormat(Wr){return infoMap[Wr]??infoMap.float32}const topologyToGlMap={"point-list":0,"line-list":1,"line-strip":3,"triangle-list":4,"triangle-strip":5};class GlGeometrySystem{constructor(ze){this._geometryVaoHash=Object.create(null),this._renderer=ze,this._activeGeometry=null,this._activeVao=null,this.hasVao=!0,this.hasInstance=!0,this._renderer.renderableGC.addManagedHash(this,"_geometryVaoHash")}contextChange(){const ze=this.gl=this._renderer.gl;if(!this._renderer.context.supports.vertexArrayObject)throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");const Gr=this._renderer.context.extensions.vertexArrayObject;Gr&&(ze.createVertexArray=()=>Gr.createVertexArrayOES(),ze.bindVertexArray=Kr=>Gr.bindVertexArrayOES(Kr),ze.deleteVertexArray=Kr=>Gr.deleteVertexArrayOES(Kr));const Yr=this._renderer.context.extensions.vertexAttribDivisorANGLE;Yr&&(ze.drawArraysInstanced=(Kr,Zr,Qr,Jr)=>{Yr.drawArraysInstancedANGLE(Kr,Zr,Qr,Jr)},ze.drawElementsInstanced=(Kr,Zr,Qr,Jr,ei)=>{Yr.drawElementsInstancedANGLE(Kr,Zr,Qr,Jr,ei)},ze.vertexAttribDivisor=(Kr,Zr)=>Yr.vertexAttribDivisorANGLE(Kr,Zr)),this._activeGeometry=null,this._activeVao=null,this._geometryVaoHash=Object.create(null)}bind(ze,Gr){const Yr=this.gl;this._activeGeometry=ze;const Kr=this.getVao(ze,Gr);this._activeVao!==Kr&&(this._activeVao=Kr,Yr.bindVertexArray(Kr)),this.updateBuffers()}resetState(){this.unbind()}updateBuffers(){const ze=this._activeGeometry,Gr=this._renderer.buffer;for(let Yr=0;Yr<ze.buffers.length;Yr++){const Kr=ze.buffers[Yr];Gr.updateBuffer(Kr)}}checkCompatibility(ze,Gr){const Yr=ze.attributes,Kr=Gr._attributeData;for(const Zr in Kr)if(!Yr[Zr])throw new Error(`shader and geometry incompatible, geometry missing the "${Zr}" attribute`)}getSignature(ze,Gr){const Yr=ze.attributes,Kr=Gr._attributeData,Zr=["g",ze.uid];for(const Qr in Yr)Kr[Qr]&&Zr.push(Qr,Kr[Qr].location);return Zr.join("-")}getVao(ze,Gr){var Yr;return((Yr=this._geometryVaoHash[ze.uid])==null?void 0:Yr[Gr._key])||this.initGeometryVao(ze,Gr)}initGeometryVao(ze,Gr,Yr=!0){const Kr=this._renderer.gl,Zr=this._renderer.buffer;this._renderer.shader._getProgramData(Gr),this.checkCompatibility(ze,Gr);const Qr=this.getSignature(ze,Gr);this._geometryVaoHash[ze.uid]||(this._geometryVaoHash[ze.uid]=Object.create(null),ze.on("destroy",this.onGeometryDestroy,this));const Jr=this._geometryVaoHash[ze.uid];let ei=Jr[Qr];if(ei)return Jr[Gr._key]=ei,ei;ensureAttributes(ze,Gr._attributeData);const ti=ze.buffers;ei=Kr.createVertexArray(),Kr.bindVertexArray(ei);for(let ri=0;ri<ti.length;ri++){const ii=ti[ri];Zr.bind(ii)}return this.activateVao(ze,Gr),Jr[Gr._key]=ei,Jr[Qr]=ei,Kr.bindVertexArray(null),ei}onGeometryDestroy(ze,Gr){const Yr=this._geometryVaoHash[ze.uid],Kr=this.gl;if(Yr){if(Gr)for(const Zr in Yr)this._activeVao!==Yr[Zr]&&this.unbind(),Kr.deleteVertexArray(Yr[Zr]);this._geometryVaoHash[ze.uid]=null}}destroyAll(ze=!1){const Gr=this.gl;for(const Yr in this._geometryVaoHash){if(ze)for(const Kr in this._geometryVaoHash[Yr]){const Zr=this._geometryVaoHash[Yr];this._activeVao!==Zr&&this.unbind(),Gr.deleteVertexArray(Zr[Kr])}this._geometryVaoHash[Yr]=null}}activateVao(ze,Gr){var Jr;const Yr=this._renderer.gl,Kr=this._renderer.buffer,Zr=ze.attributes;ze.indexBuffer&&Kr.bind(ze.indexBuffer);let Qr=null;for(const ei in Zr){const ti=Zr[ei],ri=ti.buffer,ii=Kr.getGlBuffer(ri),si=Gr._attributeData[ei];if(si){Qr!==ii&&(Kr.bind(ri),Qr=ii);const ni=si.location;Yr.enableVertexAttribArray(ni);const oi=getAttributeInfoFromFormat(ti.format),li=getGlTypeFromFormat(ti.format);if(((Jr=si.format)==null?void 0:Jr.substring(1,4))==="int"?Yr.vertexAttribIPointer(ni,oi.size,li,ti.stride,ti.offset):Yr.vertexAttribPointer(ni,oi.size,li,oi.normalised,ti.stride,ti.offset),ti.instance)if(this.hasInstance){const ai=ti.divisor??1;Yr.vertexAttribDivisor(ni,ai)}else throw new Error("geometry error, GPU Instancing is not supported on this device")}}}draw(ze,Gr,Yr,Kr){const{gl:Zr}=this._renderer,Qr=this._activeGeometry,Jr=topologyToGlMap[ze||Qr.topology];if(Kr??(Kr=Qr.instanceCount),Qr.indexBuffer){const ei=Qr.indexBuffer.data.BYTES_PER_ELEMENT,ti=ei===2?Zr.UNSIGNED_SHORT:Zr.UNSIGNED_INT;Kr>1?Zr.drawElementsInstanced(Jr,Gr||Qr.indexBuffer.data.length,ti,(Yr||0)*ei,Kr):Zr.drawElements(Jr,Gr||Qr.indexBuffer.data.length,ti,(Yr||0)*ei)}else Kr>1?Zr.drawArraysInstanced(Jr,Yr||0,Gr||Qr.getSize(),Kr):Zr.drawArrays(Jr,Yr||0,Gr||Qr.getSize());return this}unbind(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null}destroy(){this._renderer=null,this.gl=null,this._activeVao=null,this._activeGeometry=null}}GlGeometrySystem.extension={type:[ExtensionType.WebGLSystem],name:"geometry"};const bigTriangleGeometry=new Geometry({attributes:{aPosition:[-1,-1,3,-1,-1,3]}}),_GlBackBufferSystem=class Gs{constructor(ze){this.useBackBuffer=!1,this._useBackBufferThisRender=!1,this._renderer=ze}init(ze={}){const{useBackBuffer:Gr,antialias:Yr}={...Gs.defaultOptions,...ze};this.useBackBuffer=Gr,this._antialias=Yr,this._renderer.context.supports.msaa||(warn("antialiasing, is not supported on when using the back buffer"),this._antialias=!1),this._state=State.for2d();const Kr=new GlProgram({vertex:`
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,fragment:`
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,name:"big-triangle"});this._bigTriangleShader=new Shader({glProgram:Kr,resources:{uTexture:Texture.WHITE.source}})}renderStart(ze){const Gr=this._renderer.renderTarget.getRenderTarget(ze.target);if(this._useBackBufferThisRender=this.useBackBuffer&&!!Gr.isRoot,this._useBackBufferThisRender){const Yr=this._renderer.renderTarget.getRenderTarget(ze.target);this._targetTexture=Yr.colorTexture,ze.target=this._getBackBufferTexture(Yr.colorTexture)}}renderEnd(){this._presentBackBuffer()}_presentBackBuffer(){const ze=this._renderer;ze.renderTarget.finishRenderPass(),this._useBackBufferThisRender&&(ze.renderTarget.bind(this._targetTexture,!1),this._bigTriangleShader.resources.uTexture=this._backBufferTexture.source,ze.encoder.draw({geometry:bigTriangleGeometry,shader:this._bigTriangleShader,state:this._state}))}_getBackBufferTexture(ze){return this._backBufferTexture=this._backBufferTexture||new Texture({source:new TextureSource({width:ze.width,height:ze.height,resolution:ze._resolution,antialias:this._antialias})}),this._backBufferTexture.source.resize(ze.width,ze.height,ze._resolution),this._backBufferTexture}destroy(){this._backBufferTexture&&(this._backBufferTexture.destroy(),this._backBufferTexture=null)}};_GlBackBufferSystem.extension={type:[ExtensionType.WebGLSystem],name:"backBuffer",priority:1};_GlBackBufferSystem.defaultOptions={useBackBuffer:!1};let GlBackBufferSystem=_GlBackBufferSystem;class GlColorMaskSystem{constructor(ze){this._colorMaskCache=15,this._renderer=ze}setMask(ze){this._colorMaskCache!==ze&&(this._colorMaskCache=ze,this._renderer.gl.colorMask(!!(ze&8),!!(ze&4),!!(ze&2),!!(ze&1)))}}GlColorMaskSystem.extension={type:[ExtensionType.WebGLSystem],name:"colorMask"};class GlEncoderSystem{constructor(ze){this.commandFinished=Promise.resolve(),this._renderer=ze}setGeometry(ze,Gr){this._renderer.geometry.bind(ze,Gr.glProgram)}finishRenderPass(){}draw(ze){const Gr=this._renderer,{geometry:Yr,shader:Kr,state:Zr,skipSync:Qr,topology:Jr,size:ei,start:ti,instanceCount:ri}=ze;Gr.shader.bind(Kr,Qr),Gr.geometry.bind(Yr,Gr.shader._activeProgram),Zr&&Gr.state.set(Zr),Gr.geometry.draw(Jr,ei,ti,ri??Yr.instanceCount)}destroy(){this._renderer=null}}GlEncoderSystem.extension={type:[ExtensionType.WebGLSystem],name:"encoder"};class GlRenderTarget{constructor(){this.width=-1,this.height=-1,this.msaa=!1,this.msaaRenderBuffer=[]}}const GpuStencilModesToPixi=[];GpuStencilModesToPixi[STENCIL_MODES.NONE]=void 0;GpuStencilModesToPixi[STENCIL_MODES.DISABLED]={stencilWriteMask:0,stencilReadMask:0};GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}};GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}};GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}};GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"replace"},stencilBack:{compare:"not-equal",passOp:"replace"}};class GlStencilSystem{constructor(ze){this._stencilCache={enabled:!1,stencilReference:0,stencilMode:STENCIL_MODES.NONE},this._renderTargetStencilState=Object.create(null),ze.renderTarget.onRenderTargetChange.add(this)}contextChange(ze){this._gl=ze,this._comparisonFuncMapping={always:ze.ALWAYS,never:ze.NEVER,equal:ze.EQUAL,"not-equal":ze.NOTEQUAL,less:ze.LESS,"less-equal":ze.LEQUAL,greater:ze.GREATER,"greater-equal":ze.GEQUAL},this._stencilOpsMapping={keep:ze.KEEP,zero:ze.ZERO,replace:ze.REPLACE,invert:ze.INVERT,"increment-clamp":ze.INCR,"decrement-clamp":ze.DECR,"increment-wrap":ze.INCR_WRAP,"decrement-wrap":ze.DECR_WRAP},this.resetState()}onRenderTargetChange(ze){if(this._activeRenderTarget===ze)return;this._activeRenderTarget=ze;let Gr=this._renderTargetStencilState[ze.uid];Gr||(Gr=this._renderTargetStencilState[ze.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this.setStencilMode(Gr.stencilMode,Gr.stencilReference)}resetState(){this._stencilCache.enabled=!1,this._stencilCache.stencilMode=STENCIL_MODES.NONE,this._stencilCache.stencilReference=0}setStencilMode(ze,Gr){const Yr=this._renderTargetStencilState[this._activeRenderTarget.uid],Kr=this._gl,Zr=GpuStencilModesToPixi[ze],Qr=this._stencilCache;if(Yr.stencilMode=ze,Yr.stencilReference=Gr,ze===STENCIL_MODES.DISABLED){this._stencilCache.enabled&&(this._stencilCache.enabled=!1,Kr.disable(Kr.STENCIL_TEST));return}this._stencilCache.enabled||(this._stencilCache.enabled=!0,Kr.enable(Kr.STENCIL_TEST)),(ze!==Qr.stencilMode||Qr.stencilReference!==Gr)&&(Qr.stencilMode=ze,Qr.stencilReference=Gr,Kr.stencilFunc(this._comparisonFuncMapping[Zr.stencilBack.compare],Gr,255),Kr.stencilOp(Kr.KEEP,Kr.KEEP,this._stencilOpsMapping[Zr.stencilBack.passOp]))}}GlStencilSystem.extension={type:[ExtensionType.WebGLSystem],name:"stencil"};class UboSystem{constructor(ze){this._syncFunctionHash=Object.create(null),this._adaptor=ze,this._systemCheck()}_systemCheck(){if(!unsafeEvalSupported())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(ze){const Gr=this.getUniformGroupData(ze);ze.buffer||(ze.buffer=new Buffer({data:new Float32Array(Gr.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}))}getUniformGroupData(ze){return this._syncFunctionHash[ze._signature]||this._initUniformGroup(ze)}_initUniformGroup(ze){const Gr=ze._signature;let Yr=this._syncFunctionHash[Gr];if(!Yr){const Kr=Object.keys(ze.uniformStructures).map(Jr=>ze.uniformStructures[Jr]),Zr=this._adaptor.createUboElements(Kr),Qr=this._generateUboSync(Zr.uboElements);Yr=this._syncFunctionHash[Gr]={layout:Zr,syncFunction:Qr}}return this._syncFunctionHash[Gr]}_generateUboSync(ze){return this._adaptor.generateUboSync(ze)}syncUniformGroup(ze,Gr,Yr){const Kr=this.getUniformGroupData(ze);ze.buffer||(ze.buffer=new Buffer({data:new Float32Array(Kr.layout.size/4),usage:BufferUsage.UNIFORM|BufferUsage.COPY_DST}));let Zr=null;return Gr||(Gr=ze.buffer.data,Zr=ze.buffer.dataInt32),Yr||(Yr=0),Kr.syncFunction(ze.uniforms,Gr,Zr,Yr),!0}updateUniformGroup(ze){if(ze.isStatic&&!ze._dirtyId)return!1;ze._dirtyId=0;const Gr=this.syncUniformGroup(ze);return ze.buffer.update(),Gr}destroy(){this._syncFunctionHash=null}}const WGSL_TO_STD40_SIZE={f32:4,i32:4,"vec2<f32>":8,"vec3<f32>":12,"vec4<f32>":16,"vec2<i32>":8,"vec3<i32>":12,"vec4<i32>":16,"mat2x2<f32>":16*2,"mat3x3<f32>":16*3,"mat4x4<f32>":16*4};function createUboElementsSTD40(Wr){const ze=Wr.map(Zr=>({data:Zr,offset:0,size:0})),Gr=16;let Yr=0,Kr=0;for(let Zr=0;Zr<ze.length;Zr++){const Qr=ze[Zr];if(Yr=WGSL_TO_STD40_SIZE[Qr.data.type],!Yr)throw new Error(`Unknown type ${Qr.data.type}`);Qr.data.size>1&&(Yr=Math.max(Yr,Gr)*Qr.data.size);const Jr=Yr===12?16:Yr;Qr.size=Yr;const ei=Kr%Gr;ei>0&&Gr-ei<Jr?Kr+=(Gr-ei)%16:Kr+=(Yr-ei%Yr)%Yr,Qr.offset=Kr,Kr+=Yr}return Kr=Math.ceil(Kr/16)*16,{uboElements:ze,size:Kr}}const uniformParsers=[{type:"mat3x3<f32>",test:Wr=>Wr.value.a!==void 0,ubo:`
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,uniform:`
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `},{type:"vec4<f32>",test:Wr=>Wr.type==="vec4<f32>"&&Wr.size===1&&Wr.value.width!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `},{type:"vec2<f32>",test:Wr=>Wr.type==="vec2<f32>"&&Wr.size===1&&Wr.value.x!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `},{type:"vec4<f32>",test:Wr=>Wr.type==="vec4<f32>"&&Wr.size===1&&Wr.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `},{type:"vec3<f32>",test:Wr=>Wr.type==="vec3<f32>"&&Wr.size===1&&Wr.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `}];function createUboSyncFunction(Wr,ze,Gr,Yr){const Kr=[`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];let Zr=0;for(let Jr=0;Jr<Wr.length;Jr++){const ei=Wr[Jr],ti=ei.data.name;let ri=!1,ii=0;for(let si=0;si<uniformParsers.length;si++)if(uniformParsers[si].test(ei.data)){ii=ei.offset/4,Kr.push(`name = "${ti}";`,`offset += ${ii-Zr};`,uniformParsers[si][ze]||uniformParsers[si].ubo),ri=!0;break}if(!ri)if(ei.data.size>1)ii=ei.offset/4,Kr.push(Gr(ei,ii-Zr));else{const si=Yr[ei.data.type];ii=ei.offset/4,Kr.push(`
                    v = uv.${ti};
                    offset += ${ii-Zr};
                    ${si};
                `)}Zr=ii}const Qr=Kr.join(`
`);return new Function("uv","data","dataInt32","offset",Qr)}function loopMatrix(Wr,ze){return`
        for (let i = 0; i < ${Wr*ze}; i++) {
            data[offset + (((i / ${Wr})|0) * 4) + (i % ${Wr})] = v[i];
        }
    `}const uboSyncFunctionsSTD40={f32:`
        data[offset] = v;`,i32:`
        dataInt32[offset] = v;`,"vec2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];`,"vec3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,"vec4<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,"vec2<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,"vec3<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,"vec4<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,"mat3x3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,"mat4x4<f32>":`
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,"mat3x2<f32>":loopMatrix(3,2),"mat4x2<f32>":loopMatrix(4,2),"mat2x3<f32>":loopMatrix(2,3),"mat4x3<f32>":loopMatrix(4,3),"mat2x4<f32>":loopMatrix(2,4),"mat3x4<f32>":loopMatrix(3,4)},uboSyncFunctionsWGSL={...uboSyncFunctionsSTD40,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `};function generateArraySyncSTD40(Wr,ze){const Gr=Math.max(WGSL_TO_STD40_SIZE[Wr.data.type]/16,1),Yr=Wr.data.value.length/Wr.data.size,Kr=(4-Yr%4)%4,Zr=Wr.data.type.indexOf("i32")>=0?"dataInt32":"data";return`
        v = uv.${Wr.data.name};
        offset += ${ze};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${Wr.data.size*Gr}; i++)
        {
            for(var j = 0; j < ${Yr}; j++)
            {
                ${Zr}[arrayOffset++] = v[t++];
            }
            ${Kr!==0?`arrayOffset += ${Kr};`:""}
        }
    `}function createUboSyncFunctionSTD40(Wr){return createUboSyncFunction(Wr,"uboStd40",generateArraySyncSTD40,uboSyncFunctionsSTD40)}class GlUboSystem extends UboSystem{constructor(){super({createUboElements:createUboElementsSTD40,generateUboSync:createUboSyncFunctionSTD40})}}GlUboSystem.extension={type:[ExtensionType.WebGLSystem],name:"ubo"};class GlRenderTargetAdaptor{constructor(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new Rectangle}init(ze,Gr){this._renderer=ze,this._renderTargetSystem=Gr,ze.runners.contextChange.add(this)}contextChange(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new Rectangle}copyToTexture(ze,Gr,Yr,Kr,Zr){const Qr=this._renderTargetSystem,Jr=this._renderer,ei=Qr.getGpuRenderTarget(ze),ti=Jr.gl;return this.finishRenderPass(ze),ti.bindFramebuffer(ti.FRAMEBUFFER,ei.resolveTargetFramebuffer),Jr.texture.bind(Gr,0),ti.copyTexSubImage2D(ti.TEXTURE_2D,0,Zr.x,Zr.y,Yr.x,Yr.y,Kr.width,Kr.height),Gr}startRenderPass(ze,Gr=!0,Yr,Kr){const Zr=this._renderTargetSystem,Qr=ze.colorTexture,Jr=Zr.getGpuRenderTarget(ze);let ei=Kr.y;ze.isRoot&&(ei=Qr.pixelHeight-Kr.height),ze.colorTextures.forEach(ii=>{this._renderer.texture.unbind(ii)});const ti=this._renderer.gl;ti.bindFramebuffer(ti.FRAMEBUFFER,Jr.framebuffer);const ri=this._viewPortCache;(ri.x!==Kr.x||ri.y!==ei||ri.width!==Kr.width||ri.height!==Kr.height)&&(ri.x=Kr.x,ri.y=ei,ri.width=Kr.width,ri.height=Kr.height,ti.viewport(Kr.x,ei,Kr.width,Kr.height)),!Jr.depthStencilRenderBuffer&&(ze.stencil||ze.depth)&&this._initStencil(Jr),this.clear(ze,Gr,Yr)}finishRenderPass(ze){const Yr=this._renderTargetSystem.getGpuRenderTarget(ze);if(!Yr.msaa)return;const Kr=this._renderer.gl;Kr.bindFramebuffer(Kr.FRAMEBUFFER,Yr.resolveTargetFramebuffer),Kr.bindFramebuffer(Kr.READ_FRAMEBUFFER,Yr.framebuffer),Kr.blitFramebuffer(0,0,Yr.width,Yr.height,0,0,Yr.width,Yr.height,Kr.COLOR_BUFFER_BIT,Kr.NEAREST),Kr.bindFramebuffer(Kr.FRAMEBUFFER,Yr.framebuffer)}initGpuRenderTarget(ze){const Yr=this._renderer.gl,Kr=new GlRenderTarget,Zr=ze.colorTexture;return CanvasSource.test(Zr.resource)?(this._renderer.context.ensureCanvasSize(ze.colorTexture.resource),Kr.framebuffer=null,Kr):(this._initColor(ze,Kr),Yr.bindFramebuffer(Yr.FRAMEBUFFER,null),Kr)}destroyGpuRenderTarget(ze){const Gr=this._renderer.gl;ze.framebuffer&&(Gr.deleteFramebuffer(ze.framebuffer),ze.framebuffer=null),ze.resolveTargetFramebuffer&&(Gr.deleteFramebuffer(ze.resolveTargetFramebuffer),ze.resolveTargetFramebuffer=null),ze.depthStencilRenderBuffer&&(Gr.deleteRenderbuffer(ze.depthStencilRenderBuffer),ze.depthStencilRenderBuffer=null),ze.msaaRenderBuffer.forEach(Yr=>{Gr.deleteRenderbuffer(Yr)}),ze.msaaRenderBuffer=null}clear(ze,Gr,Yr){if(!Gr)return;const Kr=this._renderTargetSystem;typeof Gr=="boolean"&&(Gr=Gr?CLEAR.ALL:CLEAR.NONE);const Zr=this._renderer.gl;if(Gr&CLEAR.COLOR){Yr??(Yr=Kr.defaultClearColor);const Qr=this._clearColorCache,Jr=Yr;(Qr[0]!==Jr[0]||Qr[1]!==Jr[1]||Qr[2]!==Jr[2]||Qr[3]!==Jr[3])&&(Qr[0]=Jr[0],Qr[1]=Jr[1],Qr[2]=Jr[2],Qr[3]=Jr[3],Zr.clearColor(Jr[0],Jr[1],Jr[2],Jr[3]))}Zr.clear(Gr)}resizeGpuRenderTarget(ze){if(ze.isRoot)return;const Yr=this._renderTargetSystem.getGpuRenderTarget(ze);this._resizeColor(ze,Yr),(ze.stencil||ze.depth)&&this._resizeStencil(Yr)}_initColor(ze,Gr){const Yr=this._renderer,Kr=Yr.gl,Zr=Kr.createFramebuffer();if(Gr.resolveTargetFramebuffer=Zr,Kr.bindFramebuffer(Kr.FRAMEBUFFER,Zr),Gr.width=ze.colorTexture.source.pixelWidth,Gr.height=ze.colorTexture.source.pixelHeight,ze.colorTextures.forEach((Qr,Jr)=>{const ei=Qr.source;ei.antialias&&(Yr.context.supports.msaa?Gr.msaa=!0:warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1")),Yr.texture.bindSource(ei,0);const ri=Yr.texture.getGlSource(ei).texture;Kr.framebufferTexture2D(Kr.FRAMEBUFFER,Kr.COLOR_ATTACHMENT0+Jr,3553,ri,0)}),Gr.msaa){const Qr=Kr.createFramebuffer();Gr.framebuffer=Qr,Kr.bindFramebuffer(Kr.FRAMEBUFFER,Qr),ze.colorTextures.forEach((Jr,ei)=>{const ti=Kr.createRenderbuffer();Gr.msaaRenderBuffer[ei]=ti})}else Gr.framebuffer=Zr;this._resizeColor(ze,Gr)}_resizeColor(ze,Gr){const Yr=ze.colorTexture.source;if(Gr.width=Yr.pixelWidth,Gr.height=Yr.pixelHeight,ze.colorTextures.forEach((Kr,Zr)=>{Zr!==0&&Kr.source.resize(Yr.width,Yr.height,Yr._resolution)}),Gr.msaa){const Kr=this._renderer,Zr=Kr.gl,Qr=Gr.framebuffer;Zr.bindFramebuffer(Zr.FRAMEBUFFER,Qr),ze.colorTextures.forEach((Jr,ei)=>{const ti=Jr.source;Kr.texture.bindSource(ti,0);const ii=Kr.texture.getGlSource(ti).internalFormat,si=Gr.msaaRenderBuffer[ei];Zr.bindRenderbuffer(Zr.RENDERBUFFER,si),Zr.renderbufferStorageMultisample(Zr.RENDERBUFFER,4,ii,ti.pixelWidth,ti.pixelHeight),Zr.framebufferRenderbuffer(Zr.FRAMEBUFFER,Zr.COLOR_ATTACHMENT0+ei,Zr.RENDERBUFFER,si)})}}_initStencil(ze){if(ze.framebuffer===null)return;const Gr=this._renderer.gl,Yr=Gr.createRenderbuffer();ze.depthStencilRenderBuffer=Yr,Gr.bindRenderbuffer(Gr.RENDERBUFFER,Yr),Gr.framebufferRenderbuffer(Gr.FRAMEBUFFER,Gr.DEPTH_STENCIL_ATTACHMENT,Gr.RENDERBUFFER,Yr),this._resizeStencil(ze)}_resizeStencil(ze){const Gr=this._renderer.gl;Gr.bindRenderbuffer(Gr.RENDERBUFFER,ze.depthStencilRenderBuffer),ze.msaa?Gr.renderbufferStorageMultisample(Gr.RENDERBUFFER,4,Gr.DEPTH24_STENCIL8,ze.width,ze.height):Gr.renderbufferStorage(Gr.RENDERBUFFER,this._renderer.context.webGLVersion===2?Gr.DEPTH24_STENCIL8:Gr.DEPTH_STENCIL,ze.width,ze.height)}prerender(ze){const Gr=ze.colorTexture.resource;this._renderer.context.multiView&&CanvasSource.test(Gr)&&this._renderer.context.ensureCanvasSize(Gr)}postrender(ze){if(this._renderer.context.multiView&&CanvasSource.test(ze.colorTexture.resource)){const Gr=this._renderer.context.canvas,Yr=ze.colorTexture;Yr.context2D.drawImage(Gr,0,Yr.pixelHeight-Gr.height)}}}function calculateProjection(Wr,ze,Gr,Yr,Kr,Zr){const Qr=Zr?1:-1;return Wr.identity(),Wr.a=1/Yr*2,Wr.d=Qr*(1/Kr*2),Wr.tx=-1-ze*Wr.a,Wr.ty=-Qr-Gr*Wr.d,Wr}const canvasCache=new Map;function getCanvasTexture(Wr,ze){if(!canvasCache.has(Wr)){const Gr=new Texture({source:new CanvasSource({resource:Wr,...ze})}),Yr=()=>{canvasCache.get(Wr)===Gr&&canvasCache.delete(Wr)};Gr.once("destroy",Yr),Gr.source.once("destroy",Yr),canvasCache.set(Wr,Gr)}return canvasCache.get(Wr)}function isRenderingToScreen(Wr){const ze=Wr.colorTexture.source.resource;return globalThis.HTMLCanvasElement&&ze instanceof HTMLCanvasElement&&document.body.contains(ze)}const _RenderTarget=class ks{constructor(ze={}){if(this.uid=uid$1("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),this._managedColorTextures=!1,ze={...ks.defaultOptions,...ze},this.stencil=ze.stencil,this.depth=ze.depth,this.isRoot=ze.isRoot,typeof ze.colorTextures=="number"){this._managedColorTextures=!0;for(let Gr=0;Gr<ze.colorTextures;Gr++)this.colorTextures.push(new TextureSource({width:ze.width,height:ze.height,resolution:ze.resolution,antialias:ze.antialias}))}else{this.colorTextures=[...ze.colorTextures.map(Yr=>Yr.source)];const Gr=this.colorTexture.source;this.resize(Gr.width,Gr.height,Gr._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),(ze.depthStencilTexture||this.stencil)&&(ze.depthStencilTexture instanceof Texture||ze.depthStencilTexture instanceof TextureSource?this.depthStencilTexture=ze.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const ze=this._size;return ze[0]=this.pixelWidth,ze[1]=this.pixelHeight,ze}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(ze){this.resize(ze.width,ze.height,ze._resolution,!0)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new TextureSource({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:!1,antialias:!1,mipLevelCount:1}))}resize(ze,Gr,Yr=this.resolution,Kr=!1){this.dirtyId++,this.colorTextures.forEach((Zr,Qr)=>{Kr&&Qr===0||Zr.source.resize(ze,Gr,Yr)}),this.depthStencilTexture&&this.depthStencilTexture.source.resize(ze,Gr,Yr)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this._managedColorTextures&&this.colorTextures.forEach(ze=>{ze.destroy()}),this.depthStencilTexture&&(this.depthStencilTexture.destroy(),delete this.depthStencilTexture)}};_RenderTarget.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:!1,depth:!1,antialias:!1,isRoot:!1};let RenderTarget=_RenderTarget;class RenderTargetSystem{constructor(ze){this.rootViewPort=new Rectangle,this.viewport=new Rectangle,this.onRenderTargetChange=new SystemRunner("onRenderTargetChange"),this.projectionMatrix=new Matrix,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=ze,ze.renderableGC.addManagedHash(this,"_gpuRenderTargetHash")}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target:ze,clear:Gr,clearColor:Yr,frame:Kr}){var Zr,Qr;this._renderTargetStack.length=0,this.push(ze,Gr,Yr,Kr),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=isRenderingToScreen(this.rootRenderTarget),(Qr=(Zr=this.adaptor).prerender)==null||Qr.call(Zr,this.rootRenderTarget)}postrender(){var ze,Gr;(Gr=(ze=this.adaptor).postrender)==null||Gr.call(ze,this.rootRenderTarget)}bind(ze,Gr=!0,Yr,Kr){const Zr=this.getRenderTarget(ze),Qr=this.renderTarget!==Zr;this.renderTarget=Zr,this.renderSurface=ze;const Jr=this.getGpuRenderTarget(Zr);(Zr.pixelWidth!==Jr.width||Zr.pixelHeight!==Jr.height)&&(this.adaptor.resizeGpuRenderTarget(Zr),Jr.width=Zr.pixelWidth,Jr.height=Zr.pixelHeight);const ei=Zr.colorTexture,ti=this.viewport,ri=ei.pixelWidth,ii=ei.pixelHeight;if(!Kr&&ze instanceof Texture&&(Kr=ze.frame),Kr){const si=ei._resolution;ti.x=Kr.x*si+.5|0,ti.y=Kr.y*si+.5|0,ti.width=Kr.width*si+.5|0,ti.height=Kr.height*si+.5|0}else ti.x=0,ti.y=0,ti.width=ri,ti.height=ii;return calculateProjection(this.projectionMatrix,0,0,ti.width/ei.resolution,ti.height/ei.resolution,!Zr.isRoot),this.adaptor.startRenderPass(Zr,Gr,Yr,ti),Qr&&this.onRenderTargetChange.emit(Zr),Zr}clear(ze,Gr=CLEAR.ALL,Yr){Gr&&(ze&&(ze=this.getRenderTarget(ze)),this.adaptor.clear(ze||this.renderTarget,Gr,Yr,this.viewport))}contextChange(){this._gpuRenderTargetHash=Object.create(null)}push(ze,Gr=CLEAR.ALL,Yr,Kr){const Zr=this.bind(ze,Gr,Yr,Kr);return this._renderTargetStack.push({renderTarget:Zr,frame:Kr}),Zr}pop(){this._renderTargetStack.pop();const ze=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(ze.renderTarget,!1,null,ze.frame)}getRenderTarget(ze){return ze.isTexture&&(ze=ze.source),this._renderSurfaceToRenderTargetHash.get(ze)??this._initRenderTarget(ze)}copyToTexture(ze,Gr,Yr,Kr,Zr){Yr.x<0&&(Kr.width+=Yr.x,Zr.x-=Yr.x,Yr.x=0),Yr.y<0&&(Kr.height+=Yr.y,Zr.y-=Yr.y,Yr.y=0);const{pixelWidth:Qr,pixelHeight:Jr}=ze;return Kr.width=Math.min(Kr.width,Qr-Yr.x),Kr.height=Math.min(Kr.height,Jr-Yr.y),this.adaptor.copyToTexture(ze,Gr,Yr,Kr,Zr)}ensureDepthStencil(){this.renderTarget.stencil||(this.renderTarget.stencil=!0,this.adaptor.startRenderPass(this.renderTarget,!1,null,this.viewport))}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach((ze,Gr)=>{ze!==Gr&&ze.destroy()}),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(ze){let Gr=null;return CanvasSource.test(ze)&&(ze=getCanvasTexture(ze).source),ze instanceof RenderTarget?Gr=ze:ze instanceof TextureSource&&(Gr=new RenderTarget({colorTextures:[ze]}),CanvasSource.test(ze.source.resource)&&(Gr.isRoot=!0),ze.once("destroy",()=>{Gr.destroy(),this._renderSurfaceToRenderTargetHash.delete(ze);const Yr=this._gpuRenderTargetHash[Gr.uid];Yr&&(this._gpuRenderTargetHash[Gr.uid]=null,this.adaptor.destroyGpuRenderTarget(Yr))})),this._renderSurfaceToRenderTargetHash.set(ze,Gr),Gr}getGpuRenderTarget(ze){return this._gpuRenderTargetHash[ze.uid]||(this._gpuRenderTargetHash[ze.uid]=this.adaptor.initGpuRenderTarget(ze))}resetState(){this.renderTarget=null,this.renderSurface=null}}class GlRenderTargetSystem extends RenderTargetSystem{constructor(ze){super(ze),this.adaptor=new GlRenderTargetAdaptor,this.adaptor.init(ze,this)}}GlRenderTargetSystem.extension={type:[ExtensionType.WebGLSystem],name:"renderTarget"};class BufferResource extends EventEmitter{constructor({buffer:ze,offset:Gr,size:Yr}){super(),this.uid=uid$1("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=uid$1("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=ze,this.offset=Gr|0,this.size=Yr,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=uid$1("resource"),this.emit("change",this)}destroy(ze=!1){this.destroyed=!0,ze&&this.buffer.destroy(),this.emit("change",this),this.buffer=null}}function generateShaderSyncCode(Wr,ze){const Gr=[],Yr=[`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];let Kr=!1,Zr=0;const Qr=ze._getProgramData(Wr.glProgram);for(const ei in Wr.groups){const ti=Wr.groups[ei];Gr.push(`
            resources = g[${ei}].resources;
        `);for(const ri in ti.resources){const ii=ti.resources[ri];if(ii instanceof UniformGroup)if(ii.ubo){const si=Wr._uniformBindMap[ei][Number(ri)];Gr.push(`
                        sS.bindUniformBlock(
                            resources[${ri}],
                            '${si}',
                            ${Wr.glProgram._uniformBlockData[si].index}
                        );
                    `)}else Gr.push(`
                        ugS.updateUniformGroup(resources[${ri}], p, sD);
                    `);else if(ii instanceof BufferResource){const si=Wr._uniformBindMap[ei][Number(ri)];Gr.push(`
                    sS.bindUniformBlock(
                        resources[${ri}],
                        '${si}',
                        ${Wr.glProgram._uniformBlockData[si].index}
                    );
                `)}else if(ii instanceof TextureSource){const si=Wr._uniformBindMap[ei][ri],ni=Qr.uniformData[si];ni&&(Kr||(Kr=!0,Yr.push(`
                        var tS = r.texture;
                        `)),ze._gl.uniform1i(ni.location,Zr),Gr.push(`
                        tS.bind(resources[${ri}], ${Zr});
                    `),Zr++)}}}const Jr=[...Yr,...Gr].join(`
`);return new Function("r","s","sD",Jr)}class GlProgramData{constructor(ze,Gr){this.program=ze,this.uniformData=Gr,this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBlockBindings={}}destroy(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBlockBindings=null,this.program=null}}function compileShader(Wr,ze,Gr){const Yr=Wr.createShader(ze);return Wr.shaderSource(Yr,Gr),Wr.compileShader(Yr),Yr}function booleanArray(Wr){const ze=new Array(Wr);for(let Gr=0;Gr<ze.length;Gr++)ze[Gr]=!1;return ze}function defaultValue(Wr,ze){switch(Wr){case"float":return 0;case"vec2":return new Float32Array(2*ze);case"vec3":return new Float32Array(3*ze);case"vec4":return new Float32Array(4*ze);case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"ivec2":return new Int32Array(2*ze);case"ivec3":return new Int32Array(3*ze);case"ivec4":return new Int32Array(4*ze);case"uvec2":return new Uint32Array(2*ze);case"uvec3":return new Uint32Array(3*ze);case"uvec4":return new Uint32Array(4*ze);case"bool":return!1;case"bvec2":return booleanArray(2*ze);case"bvec3":return booleanArray(3*ze);case"bvec4":return booleanArray(4*ze);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}let GL_TABLE=null;const GL_TO_GLSL_TYPES={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"},GLSL_TO_VERTEX_TYPES={float:"float32",vec2:"float32x2",vec3:"float32x3",vec4:"float32x4",int:"sint32",ivec2:"sint32x2",ivec3:"sint32x3",ivec4:"sint32x4",uint:"uint32",uvec2:"uint32x2",uvec3:"uint32x3",uvec4:"uint32x4",bool:"uint32",bvec2:"uint32x2",bvec3:"uint32x3",bvec4:"uint32x4"};function mapType(Wr,ze){if(!GL_TABLE){const Gr=Object.keys(GL_TO_GLSL_TYPES);GL_TABLE={};for(let Yr=0;Yr<Gr.length;++Yr){const Kr=Gr[Yr];GL_TABLE[Wr[Kr]]=GL_TO_GLSL_TYPES[Kr]}}return GL_TABLE[ze]}function mapGlToVertexFormat(Wr,ze){const Gr=mapType(Wr,ze);return GLSL_TO_VERTEX_TYPES[Gr]||"float32"}function extractAttributesFromGlProgram(Wr,ze,Gr=!1){const Yr={},Kr=ze.getProgramParameter(Wr,ze.ACTIVE_ATTRIBUTES);for(let Qr=0;Qr<Kr;Qr++){const Jr=ze.getActiveAttrib(Wr,Qr);if(Jr.name.startsWith("gl_"))continue;const ei=mapGlToVertexFormat(ze,Jr.type);Yr[Jr.name]={location:0,format:ei,stride:getAttributeInfoFromFormat(ei).stride,offset:0,instance:!1,start:0}}const Zr=Object.keys(Yr);if(Gr){Zr.sort((Qr,Jr)=>Qr>Jr?1:-1);for(let Qr=0;Qr<Zr.length;Qr++)Yr[Zr[Qr]].location=Qr,ze.bindAttribLocation(Wr,Qr,Zr[Qr]);ze.linkProgram(Wr)}else for(let Qr=0;Qr<Zr.length;Qr++)Yr[Zr[Qr]].location=ze.getAttribLocation(Wr,Zr[Qr]);return Yr}function getUboData(Wr,ze){if(!ze.ACTIVE_UNIFORM_BLOCKS)return{};const Gr={},Yr=ze.getProgramParameter(Wr,ze.ACTIVE_UNIFORM_BLOCKS);for(let Kr=0;Kr<Yr;Kr++){const Zr=ze.getActiveUniformBlockName(Wr,Kr),Qr=ze.getUniformBlockIndex(Wr,Zr),Jr=ze.getActiveUniformBlockParameter(Wr,Kr,ze.UNIFORM_BLOCK_DATA_SIZE);Gr[Zr]={name:Zr,index:Qr,size:Jr}}return Gr}function getUniformData(Wr,ze){const Gr={},Yr=ze.getProgramParameter(Wr,ze.ACTIVE_UNIFORMS);for(let Kr=0;Kr<Yr;Kr++){const Zr=ze.getActiveUniform(Wr,Kr),Qr=Zr.name.replace(/\[.*?\]$/,""),Jr=!!Zr.name.match(/\[.*?\]$/),ei=mapType(ze,Zr.type);Gr[Qr]={name:Qr,index:Kr,type:ei,size:Zr.size,isArray:Jr,value:defaultValue(ei,Zr.size)}}return Gr}function logPrettyShaderError(Wr,ze){const Gr=Wr.getShaderSource(ze).split(`
`).map((ti,ri)=>`${ri}: ${ti}`),Yr=Wr.getShaderInfoLog(ze),Kr=Yr.split(`
`),Zr={},Qr=Kr.map(ti=>parseFloat(ti.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1"))).filter(ti=>ti&&!Zr[ti]?(Zr[ti]=!0,!0):!1),Jr=[""];Qr.forEach(ti=>{Gr[ti-1]=`%c${Gr[ti-1]}%c`,Jr.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")});const ei=Gr.join(`
`);Jr[0]=ei,console.error(Yr),console.groupCollapsed("click to view full shader code"),console.warn(...Jr),console.groupEnd()}function logProgramError(Wr,ze,Gr,Yr){Wr.getProgramParameter(ze,Wr.LINK_STATUS)||(Wr.getShaderParameter(Gr,Wr.COMPILE_STATUS)||logPrettyShaderError(Wr,Gr),Wr.getShaderParameter(Yr,Wr.COMPILE_STATUS)||logPrettyShaderError(Wr,Yr),console.error("PixiJS Error: Could not initialize shader."),Wr.getProgramInfoLog(ze)!==""&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",Wr.getProgramInfoLog(ze)))}function generateProgram(Wr,ze){const Gr=compileShader(Wr,Wr.VERTEX_SHADER,ze.vertex),Yr=compileShader(Wr,Wr.FRAGMENT_SHADER,ze.fragment),Kr=Wr.createProgram();Wr.attachShader(Kr,Gr),Wr.attachShader(Kr,Yr);const Zr=ze.transformFeedbackVaryings;Zr&&(typeof Wr.transformFeedbackVaryings!="function"?warn("TransformFeedback is not supported but TransformFeedbackVaryings are given."):Wr.transformFeedbackVaryings(Kr,Zr.names,Zr.bufferMode==="separate"?Wr.SEPARATE_ATTRIBS:Wr.INTERLEAVED_ATTRIBS)),Wr.linkProgram(Kr),Wr.getProgramParameter(Kr,Wr.LINK_STATUS)||logProgramError(Wr,Kr,Gr,Yr),ze._attributeData=extractAttributesFromGlProgram(Kr,Wr,!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(ze.vertex)),ze._uniformData=getUniformData(Kr,Wr),ze._uniformBlockData=getUboData(Kr,Wr),Wr.deleteShader(Gr),Wr.deleteShader(Yr);const Qr={};for(const ei in ze._uniformData){const ti=ze._uniformData[ei];Qr[ei]={location:Wr.getUniformLocation(Kr,ei),value:defaultValue(ti.type,ti.size)}}return new GlProgramData(Kr,Qr)}const defaultSyncData={textureCount:0,blockIndex:0};class GlShaderSystem{constructor(ze){this._activeProgram=null,this._programDataHash=Object.create(null),this._shaderSyncFunctions=Object.create(null),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_programDataHash")}contextChange(ze){this._gl=ze,this._programDataHash=Object.create(null),this._shaderSyncFunctions=Object.create(null),this._activeProgram=null,this.maxTextures=getMaxTexturesPerBatch()}bind(ze,Gr){if(this._setProgram(ze.glProgram),Gr)return;defaultSyncData.textureCount=0,defaultSyncData.blockIndex=0;let Yr=this._shaderSyncFunctions[ze.glProgram._key];Yr||(Yr=this._shaderSyncFunctions[ze.glProgram._key]=this._generateShaderSync(ze,this)),this._renderer.buffer.nextBindBase(!!ze.glProgram.transformFeedbackVaryings),Yr(this._renderer,ze,defaultSyncData)}updateUniformGroup(ze){this._renderer.uniformGroup.updateUniformGroup(ze,this._activeProgram,defaultSyncData)}bindUniformBlock(ze,Gr,Yr=0){const Kr=this._renderer.buffer,Zr=this._getProgramData(this._activeProgram),Qr=ze._bufferResource;Qr||this._renderer.ubo.updateUniformGroup(ze);const Jr=ze.buffer,ei=Kr.updateBuffer(Jr),ti=Kr.freeLocationForBufferBase(ei);if(Qr){const{offset:ii,size:si}=ze;ii===0&&si===Jr.data.byteLength?Kr.bindBufferBase(ei,ti):Kr.bindBufferRange(ei,ti,ii)}else Kr.getLastBindBaseLocation(ei)!==ti&&Kr.bindBufferBase(ei,ti);const ri=this._activeProgram._uniformBlockData[Gr].index;Zr.uniformBlockBindings[Yr]!==ti&&(Zr.uniformBlockBindings[Yr]=ti,this._renderer.gl.uniformBlockBinding(Zr.program,ri,ti))}_setProgram(ze){if(this._activeProgram===ze)return;this._activeProgram=ze;const Gr=this._getProgramData(ze);this._gl.useProgram(Gr.program)}_getProgramData(ze){return this._programDataHash[ze._key]||this._createProgramData(ze)}_createProgramData(ze){const Gr=ze._key;return this._programDataHash[Gr]=generateProgram(this._gl,ze),this._programDataHash[Gr]}destroy(){for(const ze of Object.keys(this._programDataHash))this._programDataHash[ze].destroy(),this._programDataHash[ze]=null;this._programDataHash=null}_generateShaderSync(ze,Gr){return generateShaderSyncCode(ze,Gr)}resetState(){this._activeProgram=null}}GlShaderSystem.extension={type:[ExtensionType.WebGLSystem],name:"shader"};const UNIFORM_TO_SINGLE_SETTERS={f32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,"vec2<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,"vec3<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,"vec4<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,i32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,"vec2<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,"vec3<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,"vec4<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,u32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,"vec2<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,"vec3<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,"vec4<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,bool:`if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,"vec2<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,"vec3<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,"vec4<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,"mat2x2<f32>":"gl.uniformMatrix2fv(location, false, v);","mat3x3<f32>":"gl.uniformMatrix3fv(location, false, v);","mat4x4<f32>":"gl.uniformMatrix4fv(location, false, v);"},UNIFORM_TO_ARRAY_SETTERS={f32:"gl.uniform1fv(location, v);","vec2<f32>":"gl.uniform2fv(location, v);","vec3<f32>":"gl.uniform3fv(location, v);","vec4<f32>":"gl.uniform4fv(location, v);","mat2x2<f32>":"gl.uniformMatrix2fv(location, false, v);","mat3x3<f32>":"gl.uniformMatrix3fv(location, false, v);","mat4x4<f32>":"gl.uniformMatrix4fv(location, false, v);",i32:"gl.uniform1iv(location, v);","vec2<i32>":"gl.uniform2iv(location, v);","vec3<i32>":"gl.uniform3iv(location, v);","vec4<i32>":"gl.uniform4iv(location, v);",u32:"gl.uniform1iv(location, v);","vec2<u32>":"gl.uniform2iv(location, v);","vec3<u32>":"gl.uniform3iv(location, v);","vec4<u32>":"gl.uniform4iv(location, v);",bool:"gl.uniform1iv(location, v);","vec2<bool>":"gl.uniform2iv(location, v);","vec3<bool>":"gl.uniform3iv(location, v);","vec4<bool>":"gl.uniform4iv(location, v);"};function generateUniformsSync(Wr,ze){const Gr=[`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];for(const Yr in Wr.uniforms){if(!ze[Yr]){Wr.uniforms[Yr]instanceof UniformGroup?Wr.uniforms[Yr].ubo?Gr.push(`
                        renderer.shader.bindUniformBlock(uv.${Yr}, "${Yr}");
                    `):Gr.push(`
                        renderer.shader.updateUniformGroup(uv.${Yr});
                    `):Wr.uniforms[Yr]instanceof BufferResource&&Gr.push(`
                        renderer.shader.bindBufferResource(uv.${Yr}, "${Yr}");
                    `);continue}const Kr=Wr.uniformStructures[Yr];let Zr=!1;for(let Qr=0;Qr<uniformParsers.length;Qr++){const Jr=uniformParsers[Qr];if(Kr.type===Jr.type&&Jr.test(Kr)){Gr.push(`name = "${Yr}";`,uniformParsers[Qr].uniform),Zr=!0;break}}if(!Zr){const Jr=(Kr.size===1?UNIFORM_TO_SINGLE_SETTERS:UNIFORM_TO_ARRAY_SETTERS)[Kr.type].replace("location",`ud["${Yr}"].location`);Gr.push(`
            cu = ud["${Yr}"];
            cv = cu.value;
            v = uv["${Yr}"];
            ${Jr};`)}}return new Function("ud","uv","renderer","syncData",Gr.join(`
`))}class GlUniformGroupSystem{constructor(ze){this._cache={},this._uniformGroupSyncHash={},this._renderer=ze,this.gl=null,this._cache={}}contextChange(ze){this.gl=ze}updateUniformGroup(ze,Gr,Yr){const Kr=this._renderer.shader._getProgramData(Gr);(!ze.isStatic||ze._dirtyId!==Kr.uniformDirtyGroups[ze.uid])&&(Kr.uniformDirtyGroups[ze.uid]=ze._dirtyId,this._getUniformSyncFunction(ze,Gr)(Kr.uniformData,ze.uniforms,this._renderer,Yr))}_getUniformSyncFunction(ze,Gr){var Yr;return((Yr=this._uniformGroupSyncHash[ze._signature])==null?void 0:Yr[Gr._key])||this._createUniformSyncFunction(ze,Gr)}_createUniformSyncFunction(ze,Gr){const Yr=this._uniformGroupSyncHash[ze._signature]||(this._uniformGroupSyncHash[ze._signature]={}),Kr=this._getSignature(ze,Gr._uniformData,"u");return this._cache[Kr]||(this._cache[Kr]=this._generateUniformsSync(ze,Gr._uniformData)),Yr[Gr._key]=this._cache[Kr],Yr[Gr._key]}_generateUniformsSync(ze,Gr){return generateUniformsSync(ze,Gr)}_getSignature(ze,Gr,Yr){const Kr=ze.uniforms,Zr=[`${Yr}-`];for(const Qr in Kr)Zr.push(Qr),Gr[Qr]&&Zr.push(Gr[Qr].type);return Zr.join("-")}destroy(){this._renderer=null,this._cache=null}}GlUniformGroupSystem.extension={type:[ExtensionType.WebGLSystem],name:"uniformGroup"};function mapWebGLBlendModesToPixi(Wr){const ze={};if(ze.normal=[Wr.ONE,Wr.ONE_MINUS_SRC_ALPHA],ze.add=[Wr.ONE,Wr.ONE],ze.multiply=[Wr.DST_COLOR,Wr.ONE_MINUS_SRC_ALPHA,Wr.ONE,Wr.ONE_MINUS_SRC_ALPHA],ze.screen=[Wr.ONE,Wr.ONE_MINUS_SRC_COLOR,Wr.ONE,Wr.ONE_MINUS_SRC_ALPHA],ze.none=[0,0],ze["normal-npm"]=[Wr.SRC_ALPHA,Wr.ONE_MINUS_SRC_ALPHA,Wr.ONE,Wr.ONE_MINUS_SRC_ALPHA],ze["add-npm"]=[Wr.SRC_ALPHA,Wr.ONE,Wr.ONE,Wr.ONE],ze["screen-npm"]=[Wr.SRC_ALPHA,Wr.ONE_MINUS_SRC_COLOR,Wr.ONE,Wr.ONE_MINUS_SRC_ALPHA],ze.erase=[Wr.ZERO,Wr.ONE_MINUS_SRC_ALPHA],!(Wr instanceof DOMAdapter.get().getWebGLRenderingContext()))ze.min=[Wr.ONE,Wr.ONE,Wr.ONE,Wr.ONE,Wr.MIN,Wr.MIN],ze.max=[Wr.ONE,Wr.ONE,Wr.ONE,Wr.ONE,Wr.MAX,Wr.MAX];else{const Yr=Wr.getExtension("EXT_blend_minmax");Yr&&(ze.min=[Wr.ONE,Wr.ONE,Wr.ONE,Wr.ONE,Yr.MIN_EXT,Yr.MIN_EXT],ze.max=[Wr.ONE,Wr.ONE,Wr.ONE,Wr.ONE,Yr.MAX_EXT,Yr.MAX_EXT])}return ze}const BLEND=0,OFFSET=1,CULLING=2,DEPTH_TEST=3,WINDING=4,DEPTH_MASK=5,_GlStateSystem=class gs{constructor(ze){this._invertFrontFace=!1,this.gl=null,this.stateId=0,this.polygonOffset=0,this.blendMode="none",this._blendEq=!1,this.map=[],this.map[BLEND]=this.setBlend,this.map[OFFSET]=this.setOffset,this.map[CULLING]=this.setCullFace,this.map[DEPTH_TEST]=this.setDepthTest,this.map[WINDING]=this.setFrontFace,this.map[DEPTH_MASK]=this.setDepthMask,this.checks=[],this.defaultState=State.for2d(),ze.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(ze){this._invertFrontFace=!ze.isRoot,this._cullFace?this.setFrontFace(this._frontFace):this._frontFaceDirty=!0}contextChange(ze){this.gl=ze,this.blendModesMap=mapWebGLBlendModesToPixi(ze),this.resetState()}set(ze){if(ze||(ze=this.defaultState),this.stateId!==ze.data){let Gr=this.stateId^ze.data,Yr=0;for(;Gr;)Gr&1&&this.map[Yr].call(this,!!(ze.data&1<<Yr)),Gr>>=1,Yr++;this.stateId=ze.data}for(let Gr=0;Gr<this.checks.length;Gr++)this.checks[Gr](this,ze)}forceState(ze){ze||(ze=this.defaultState);for(let Gr=0;Gr<this.map.length;Gr++)this.map[Gr].call(this,!!(ze.data&1<<Gr));for(let Gr=0;Gr<this.checks.length;Gr++)this.checks[Gr](this,ze);this.stateId=ze.data}setBlend(ze){this._updateCheck(gs._checkBlendMode,ze),this.gl[ze?"enable":"disable"](this.gl.BLEND)}setOffset(ze){this._updateCheck(gs._checkPolygonOffset,ze),this.gl[ze?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}setDepthTest(ze){this.gl[ze?"enable":"disable"](this.gl.DEPTH_TEST)}setDepthMask(ze){this.gl.depthMask(ze)}setCullFace(ze){this._cullFace=ze,this.gl[ze?"enable":"disable"](this.gl.CULL_FACE),this._cullFace&&this._frontFaceDirty&&this.setFrontFace(this._frontFace)}setFrontFace(ze){this._frontFace=ze,this._frontFaceDirty=!1;const Gr=this._invertFrontFace?!ze:ze;this._glFrontFace!==Gr&&(this._glFrontFace=Gr,this.gl.frontFace(this.gl[Gr?"CW":"CCW"]))}setBlendMode(ze){if(this.blendModesMap[ze]||(ze="normal"),ze===this.blendMode)return;this.blendMode=ze;const Gr=this.blendModesMap[ze],Yr=this.gl;Gr.length===2?Yr.blendFunc(Gr[0],Gr[1]):Yr.blendFuncSeparate(Gr[0],Gr[1],Gr[2],Gr[3]),Gr.length===6?(this._blendEq=!0,Yr.blendEquationSeparate(Gr[4],Gr[5])):this._blendEq&&(this._blendEq=!1,Yr.blendEquationSeparate(Yr.FUNC_ADD,Yr.FUNC_ADD))}setPolygonOffset(ze,Gr){this.gl.polygonOffset(ze,Gr)}resetState(){this._glFrontFace=!1,this._frontFace=!1,this._cullFace=!1,this._frontFaceDirty=!1,this._invertFrontFace=!1,this.gl.frontFace(this.gl.CCW),this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode="",this.setBlendMode("normal")}_updateCheck(ze,Gr){const Yr=this.checks.indexOf(ze);Gr&&Yr===-1?this.checks.push(ze):!Gr&&Yr!==-1&&this.checks.splice(Yr,1)}static _checkBlendMode(ze,Gr){ze.setBlendMode(Gr.blendMode)}static _checkPolygonOffset(ze,Gr){ze.setPolygonOffset(1,Gr.polygonOffset)}destroy(){this.gl=null,this.checks.length=0}};_GlStateSystem.extension={type:[ExtensionType.WebGLSystem],name:"state"};let GlStateSystem=_GlStateSystem;class GlTexture{constructor(ze){this.target=GL_TARGETS.TEXTURE_2D,this.texture=ze,this.width=-1,this.height=-1,this.type=GL_TYPES.UNSIGNED_BYTE,this.internalFormat=GL_FORMATS.RGBA,this.format=GL_FORMATS.RGBA,this.samplerType=0}}const glUploadBufferImageResource={id:"buffer",upload(Wr,ze,Gr){ze.width===Wr.width||ze.height===Wr.height?Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,Wr.width,Wr.height,ze.format,ze.type,Wr.resource):Gr.texImage2D(ze.target,0,ze.internalFormat,Wr.width,Wr.height,0,ze.format,ze.type,Wr.resource),ze.width=Wr.width,ze.height=Wr.height}},compressedFormatMap={"bc1-rgba-unorm":!0,"bc1-rgba-unorm-srgb":!0,"bc2-rgba-unorm":!0,"bc2-rgba-unorm-srgb":!0,"bc3-rgba-unorm":!0,"bc3-rgba-unorm-srgb":!0,"bc4-r-unorm":!0,"bc4-r-snorm":!0,"bc5-rg-unorm":!0,"bc5-rg-snorm":!0,"bc6h-rgb-ufloat":!0,"bc6h-rgb-float":!0,"bc7-rgba-unorm":!0,"bc7-rgba-unorm-srgb":!0,"etc2-rgb8unorm":!0,"etc2-rgb8unorm-srgb":!0,"etc2-rgb8a1unorm":!0,"etc2-rgb8a1unorm-srgb":!0,"etc2-rgba8unorm":!0,"etc2-rgba8unorm-srgb":!0,"eac-r11unorm":!0,"eac-r11snorm":!0,"eac-rg11unorm":!0,"eac-rg11snorm":!0,"astc-4x4-unorm":!0,"astc-4x4-unorm-srgb":!0,"astc-5x4-unorm":!0,"astc-5x4-unorm-srgb":!0,"astc-5x5-unorm":!0,"astc-5x5-unorm-srgb":!0,"astc-6x5-unorm":!0,"astc-6x5-unorm-srgb":!0,"astc-6x6-unorm":!0,"astc-6x6-unorm-srgb":!0,"astc-8x5-unorm":!0,"astc-8x5-unorm-srgb":!0,"astc-8x6-unorm":!0,"astc-8x6-unorm-srgb":!0,"astc-8x8-unorm":!0,"astc-8x8-unorm-srgb":!0,"astc-10x5-unorm":!0,"astc-10x5-unorm-srgb":!0,"astc-10x6-unorm":!0,"astc-10x6-unorm-srgb":!0,"astc-10x8-unorm":!0,"astc-10x8-unorm-srgb":!0,"astc-10x10-unorm":!0,"astc-10x10-unorm-srgb":!0,"astc-12x10-unorm":!0,"astc-12x10-unorm-srgb":!0,"astc-12x12-unorm":!0,"astc-12x12-unorm-srgb":!0},glUploadCompressedTextureResource={id:"compressed",upload(Wr,ze,Gr){Gr.pixelStorei(Gr.UNPACK_ALIGNMENT,4);let Yr=Wr.pixelWidth,Kr=Wr.pixelHeight;const Zr=!!compressedFormatMap[Wr.format];for(let Qr=0;Qr<Wr.resource.length;Qr++){const Jr=Wr.resource[Qr];Zr?Gr.compressedTexImage2D(Gr.TEXTURE_2D,Qr,ze.internalFormat,Yr,Kr,0,Jr):Gr.texImage2D(Gr.TEXTURE_2D,Qr,ze.internalFormat,Yr,Kr,0,ze.format,ze.type,Jr),Yr=Math.max(Yr>>1,1),Kr=Math.max(Kr>>1,1)}}},glUploadImageResource={id:"image",upload(Wr,ze,Gr,Yr){const Kr=ze.width,Zr=ze.height,Qr=Wr.pixelWidth,Jr=Wr.pixelHeight,ei=Wr.resourceWidth,ti=Wr.resourceHeight;ei<Qr||ti<Jr?((Kr!==Qr||Zr!==Jr)&&Gr.texImage2D(ze.target,0,ze.internalFormat,Qr,Jr,0,ze.format,ze.type,null),Yr===2?Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,ei,ti,ze.format,ze.type,Wr.resource):Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,ze.format,ze.type,Wr.resource)):Kr===Qr&&Zr===Jr?Gr.texSubImage2D(Gr.TEXTURE_2D,0,0,0,ze.format,ze.type,Wr.resource):Yr===2?Gr.texImage2D(ze.target,0,ze.internalFormat,Qr,Jr,0,ze.format,ze.type,Wr.resource):Gr.texImage2D(ze.target,0,ze.internalFormat,ze.format,ze.type,Wr.resource),ze.width=Qr,ze.height=Jr}},glUploadVideoResource={id:"video",upload(Wr,ze,Gr,Yr){if(!Wr.isValid){Gr.texImage2D(ze.target,0,ze.internalFormat,1,1,0,ze.format,ze.type,null);return}glUploadImageResource.upload(Wr,ze,Gr,Yr)}},scaleModeToGlFilter={linear:9729,nearest:9728},mipmapScaleModeToGlFilter={linear:{linear:9987,nearest:9985},nearest:{linear:9986,nearest:9984}},wrapModeToGlAddress={"clamp-to-edge":33071,repeat:10497,"mirror-repeat":33648},compareModeToGlCompare={never:512,less:513,equal:514,"less-equal":515,greater:516,"not-equal":517,"greater-equal":518,always:519};function applyStyleParams(Wr,ze,Gr,Yr,Kr,Zr,Qr,Jr){const ei=Zr;if(!Jr||Wr.addressModeU!=="repeat"||Wr.addressModeV!=="repeat"||Wr.addressModeW!=="repeat"){const ti=wrapModeToGlAddress[Qr?"clamp-to-edge":Wr.addressModeU],ri=wrapModeToGlAddress[Qr?"clamp-to-edge":Wr.addressModeV],ii=wrapModeToGlAddress[Qr?"clamp-to-edge":Wr.addressModeW];ze[Kr](ei,ze.TEXTURE_WRAP_S,ti),ze[Kr](ei,ze.TEXTURE_WRAP_T,ri),ze.TEXTURE_WRAP_R&&ze[Kr](ei,ze.TEXTURE_WRAP_R,ii)}if((!Jr||Wr.magFilter!=="linear")&&ze[Kr](ei,ze.TEXTURE_MAG_FILTER,scaleModeToGlFilter[Wr.magFilter]),Gr){if(!Jr||Wr.mipmapFilter!=="linear"){const ti=mipmapScaleModeToGlFilter[Wr.minFilter][Wr.mipmapFilter];ze[Kr](ei,ze.TEXTURE_MIN_FILTER,ti)}}else ze[Kr](ei,ze.TEXTURE_MIN_FILTER,scaleModeToGlFilter[Wr.minFilter]);if(Yr&&Wr.maxAnisotropy>1){const ti=Math.min(Wr.maxAnisotropy,ze.getParameter(Yr.MAX_TEXTURE_MAX_ANISOTROPY_EXT));ze[Kr](ei,Yr.TEXTURE_MAX_ANISOTROPY_EXT,ti)}Wr.compare&&ze[Kr](ei,ze.TEXTURE_COMPARE_FUNC,compareModeToGlCompare[Wr.compare])}function mapFormatToGlFormat(Wr){return{r8unorm:Wr.RED,r8snorm:Wr.RED,r8uint:Wr.RED,r8sint:Wr.RED,r16uint:Wr.RED,r16sint:Wr.RED,r16float:Wr.RED,rg8unorm:Wr.RG,rg8snorm:Wr.RG,rg8uint:Wr.RG,rg8sint:Wr.RG,r32uint:Wr.RED,r32sint:Wr.RED,r32float:Wr.RED,rg16uint:Wr.RG,rg16sint:Wr.RG,rg16float:Wr.RG,rgba8unorm:Wr.RGBA,"rgba8unorm-srgb":Wr.RGBA,rgba8snorm:Wr.RGBA,rgba8uint:Wr.RGBA,rgba8sint:Wr.RGBA,bgra8unorm:Wr.RGBA,"bgra8unorm-srgb":Wr.RGBA,rgb9e5ufloat:Wr.RGB,rgb10a2unorm:Wr.RGBA,rg11b10ufloat:Wr.RGB,rg32uint:Wr.RG,rg32sint:Wr.RG,rg32float:Wr.RG,rgba16uint:Wr.RGBA,rgba16sint:Wr.RGBA,rgba16float:Wr.RGBA,rgba32uint:Wr.RGBA,rgba32sint:Wr.RGBA,rgba32float:Wr.RGBA,stencil8:Wr.STENCIL_INDEX8,depth16unorm:Wr.DEPTH_COMPONENT,depth24plus:Wr.DEPTH_COMPONENT,"depth24plus-stencil8":Wr.DEPTH_STENCIL,depth32float:Wr.DEPTH_COMPONENT,"depth32float-stencil8":Wr.DEPTH_STENCIL}}function mapFormatToGlInternalFormat(Wr,ze){let Gr={},Yr=Wr.RGBA;return Wr instanceof DOMAdapter.get().getWebGLRenderingContext()?ze.srgb&&(Gr={"rgba8unorm-srgb":ze.srgb.SRGB8_ALPHA8_EXT,"bgra8unorm-srgb":ze.srgb.SRGB8_ALPHA8_EXT}):(Gr={"rgba8unorm-srgb":Wr.SRGB8_ALPHA8,"bgra8unorm-srgb":Wr.SRGB8_ALPHA8},Yr=Wr.RGBA8),{r8unorm:Wr.R8,r8snorm:Wr.R8_SNORM,r8uint:Wr.R8UI,r8sint:Wr.R8I,r16uint:Wr.R16UI,r16sint:Wr.R16I,r16float:Wr.R16F,rg8unorm:Wr.RG8,rg8snorm:Wr.RG8_SNORM,rg8uint:Wr.RG8UI,rg8sint:Wr.RG8I,r32uint:Wr.R32UI,r32sint:Wr.R32I,r32float:Wr.R32F,rg16uint:Wr.RG16UI,rg16sint:Wr.RG16I,rg16float:Wr.RG16F,rgba8unorm:Wr.RGBA,...Gr,rgba8snorm:Wr.RGBA8_SNORM,rgba8uint:Wr.RGBA8UI,rgba8sint:Wr.RGBA8I,bgra8unorm:Yr,rgb9e5ufloat:Wr.RGB9_E5,rgb10a2unorm:Wr.RGB10_A2,rg11b10ufloat:Wr.R11F_G11F_B10F,rg32uint:Wr.RG32UI,rg32sint:Wr.RG32I,rg32float:Wr.RG32F,rgba16uint:Wr.RGBA16UI,rgba16sint:Wr.RGBA16I,rgba16float:Wr.RGBA16F,rgba32uint:Wr.RGBA32UI,rgba32sint:Wr.RGBA32I,rgba32float:Wr.RGBA32F,stencil8:Wr.STENCIL_INDEX8,depth16unorm:Wr.DEPTH_COMPONENT16,depth24plus:Wr.DEPTH_COMPONENT24,"depth24plus-stencil8":Wr.DEPTH24_STENCIL8,depth32float:Wr.DEPTH_COMPONENT32F,"depth32float-stencil8":Wr.DEPTH32F_STENCIL8,...ze.s3tc?{"bc1-rgba-unorm":ze.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,"bc2-rgba-unorm":ze.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,"bc3-rgba-unorm":ze.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT}:{},...ze.s3tc_sRGB?{"bc1-rgba-unorm-srgb":ze.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,"bc2-rgba-unorm-srgb":ze.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,"bc3-rgba-unorm-srgb":ze.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}:{},...ze.rgtc?{"bc4-r-unorm":ze.rgtc.COMPRESSED_RED_RGTC1_EXT,"bc4-r-snorm":ze.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,"bc5-rg-unorm":ze.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,"bc5-rg-snorm":ze.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}:{},...ze.bptc?{"bc6h-rgb-float":ze.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,"bc6h-rgb-ufloat":ze.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,"bc7-rgba-unorm":ze.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,"bc7-rgba-unorm-srgb":ze.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT}:{},...ze.etc?{"etc2-rgb8unorm":ze.etc.COMPRESSED_RGB8_ETC2,"etc2-rgb8unorm-srgb":ze.etc.COMPRESSED_SRGB8_ETC2,"etc2-rgb8a1unorm":ze.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgb8a1unorm-srgb":ze.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgba8unorm":ze.etc.COMPRESSED_RGBA8_ETC2_EAC,"etc2-rgba8unorm-srgb":ze.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,"eac-r11unorm":ze.etc.COMPRESSED_R11_EAC,"eac-rg11unorm":ze.etc.COMPRESSED_SIGNED_RG11_EAC}:{},...ze.astc?{"astc-4x4-unorm":ze.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,"astc-4x4-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,"astc-5x4-unorm":ze.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,"astc-5x4-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,"astc-5x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,"astc-5x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,"astc-6x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,"astc-6x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,"astc-6x6-unorm":ze.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,"astc-6x6-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,"astc-8x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,"astc-8x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,"astc-8x6-unorm":ze.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,"astc-8x6-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,"astc-8x8-unorm":ze.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,"astc-8x8-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,"astc-10x5-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,"astc-10x5-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,"astc-10x6-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,"astc-10x6-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,"astc-10x8-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,"astc-10x8-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,"astc-10x10-unorm":ze.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,"astc-10x10-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,"astc-12x10-unorm":ze.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,"astc-12x10-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,"astc-12x12-unorm":ze.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,"astc-12x12-unorm-srgb":ze.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR}:{}}}function mapFormatToGlType(Wr){return{r8unorm:Wr.UNSIGNED_BYTE,r8snorm:Wr.BYTE,r8uint:Wr.UNSIGNED_BYTE,r8sint:Wr.BYTE,r16uint:Wr.UNSIGNED_SHORT,r16sint:Wr.SHORT,r16float:Wr.HALF_FLOAT,rg8unorm:Wr.UNSIGNED_BYTE,rg8snorm:Wr.BYTE,rg8uint:Wr.UNSIGNED_BYTE,rg8sint:Wr.BYTE,r32uint:Wr.UNSIGNED_INT,r32sint:Wr.INT,r32float:Wr.FLOAT,rg16uint:Wr.UNSIGNED_SHORT,rg16sint:Wr.SHORT,rg16float:Wr.HALF_FLOAT,rgba8unorm:Wr.UNSIGNED_BYTE,"rgba8unorm-srgb":Wr.UNSIGNED_BYTE,rgba8snorm:Wr.BYTE,rgba8uint:Wr.UNSIGNED_BYTE,rgba8sint:Wr.BYTE,bgra8unorm:Wr.UNSIGNED_BYTE,"bgra8unorm-srgb":Wr.UNSIGNED_BYTE,rgb9e5ufloat:Wr.UNSIGNED_INT_5_9_9_9_REV,rgb10a2unorm:Wr.UNSIGNED_INT_2_10_10_10_REV,rg11b10ufloat:Wr.UNSIGNED_INT_10F_11F_11F_REV,rg32uint:Wr.UNSIGNED_INT,rg32sint:Wr.INT,rg32float:Wr.FLOAT,rgba16uint:Wr.UNSIGNED_SHORT,rgba16sint:Wr.SHORT,rgba16float:Wr.HALF_FLOAT,rgba32uint:Wr.UNSIGNED_INT,rgba32sint:Wr.INT,rgba32float:Wr.FLOAT,stencil8:Wr.UNSIGNED_BYTE,depth16unorm:Wr.UNSIGNED_SHORT,depth24plus:Wr.UNSIGNED_INT,"depth24plus-stencil8":Wr.UNSIGNED_INT_24_8,depth32float:Wr.FLOAT,"depth32float-stencil8":Wr.FLOAT_32_UNSIGNED_INT_24_8_REV}}const BYTES_PER_PIXEL=4;class GlTextureSystem{constructor(ze){this.managedTextures=[],this._glTextures=Object.create(null),this._glSamplers=Object.create(null),this._boundTextures=[],this._activeTextureLocation=-1,this._boundSamplers=Object.create(null),this._uploads={image:glUploadImageResource,buffer:glUploadBufferImageResource,video:glUploadVideoResource,compressed:glUploadCompressedTextureResource},this._premultiplyAlpha=!1,this._useSeparateSamplers=!1,this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_glTextures"),this._renderer.renderableGC.addManagedHash(this,"_glSamplers")}contextChange(ze){this._gl=ze,this._mapFormatToInternalFormat||(this._mapFormatToInternalFormat=mapFormatToGlInternalFormat(ze,this._renderer.context.extensions),this._mapFormatToType=mapFormatToGlType(ze),this._mapFormatToFormat=mapFormatToGlFormat(ze)),this._glTextures=Object.create(null),this._glSamplers=Object.create(null),this._boundSamplers=Object.create(null),this._premultiplyAlpha=!1;for(let Gr=0;Gr<16;Gr++)this.bind(Texture.EMPTY,Gr)}initSource(ze){this.bind(ze)}bind(ze,Gr=0){const Yr=ze.source;ze?(this.bindSource(Yr,Gr),this._useSeparateSamplers&&this._bindSampler(Yr.style,Gr)):(this.bindSource(null,Gr),this._useSeparateSamplers&&this._bindSampler(null,Gr))}bindSource(ze,Gr=0){const Yr=this._gl;if(ze._touched=this._renderer.textureGC.count,this._boundTextures[Gr]!==ze){this._boundTextures[Gr]=ze,this._activateLocation(Gr),ze||(ze=Texture.EMPTY.source);const Kr=this.getGlSource(ze);Yr.bindTexture(Kr.target,Kr.texture)}}_bindSampler(ze,Gr=0){const Yr=this._gl;if(!ze){this._boundSamplers[Gr]=null,Yr.bindSampler(Gr,null);return}const Kr=this._getGlSampler(ze);this._boundSamplers[Gr]!==Kr&&(this._boundSamplers[Gr]=Kr,Yr.bindSampler(Gr,Kr))}unbind(ze){const Gr=ze.source,Yr=this._boundTextures,Kr=this._gl;for(let Zr=0;Zr<Yr.length;Zr++)if(Yr[Zr]===Gr){this._activateLocation(Zr);const Qr=this.getGlSource(Gr);Kr.bindTexture(Qr.target,null),Yr[Zr]=null}}_activateLocation(ze){this._activeTextureLocation!==ze&&(this._activeTextureLocation=ze,this._gl.activeTexture(this._gl.TEXTURE0+ze))}_initSource(ze){const Gr=this._gl,Yr=new GlTexture(Gr.createTexture());if(Yr.type=this._mapFormatToType[ze.format],Yr.internalFormat=this._mapFormatToInternalFormat[ze.format],Yr.format=this._mapFormatToFormat[ze.format],ze.autoGenerateMipmaps&&(this._renderer.context.supports.nonPowOf2mipmaps||ze.isPowerOfTwo)){const Kr=Math.max(ze.width,ze.height);ze.mipLevelCount=Math.floor(Math.log2(Kr))+1}return this._glTextures[ze.uid]=Yr,this.managedTextures.includes(ze)||(ze.on("update",this.onSourceUpdate,this),ze.on("resize",this.onSourceUpdate,this),ze.on("styleChange",this.onStyleChange,this),ze.on("destroy",this.onSourceDestroy,this),ze.on("unload",this.onSourceUnload,this),ze.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(ze)),this.onSourceUpdate(ze),this.updateStyle(ze,!1),Yr}onStyleChange(ze){this.updateStyle(ze,!1)}updateStyle(ze,Gr){const Yr=this._gl,Kr=this.getGlSource(ze);Yr.bindTexture(Yr.TEXTURE_2D,Kr.texture),this._boundTextures[this._activeTextureLocation]=ze,applyStyleParams(ze.style,Yr,ze.mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"texParameteri",Yr.TEXTURE_2D,!this._renderer.context.supports.nonPowOf2wrapping&&!ze.isPowerOfTwo,Gr)}onSourceUnload(ze){const Gr=this._glTextures[ze.uid];Gr&&(this.unbind(ze),this._glTextures[ze.uid]=null,this._gl.deleteTexture(Gr.texture))}onSourceUpdate(ze){const Gr=this._gl,Yr=this.getGlSource(ze);Gr.bindTexture(Gr.TEXTURE_2D,Yr.texture),this._boundTextures[this._activeTextureLocation]=ze;const Kr=ze.alphaMode==="premultiply-alpha-on-upload";this._premultiplyAlpha!==Kr&&(this._premultiplyAlpha=Kr,Gr.pixelStorei(Gr.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Kr)),this._uploads[ze.uploadMethodId]?this._uploads[ze.uploadMethodId].upload(ze,Yr,Gr,this._renderer.context.webGLVersion):Gr.texImage2D(Gr.TEXTURE_2D,0,Gr.RGBA,ze.pixelWidth,ze.pixelHeight,0,Gr.RGBA,Gr.UNSIGNED_BYTE,null),ze.autoGenerateMipmaps&&ze.mipLevelCount>1&&this.onUpdateMipmaps(ze,!1)}onUpdateMipmaps(ze,Gr=!0){Gr&&this.bindSource(ze,0);const Yr=this.getGlSource(ze);this._gl.generateMipmap(Yr.target)}onSourceDestroy(ze){ze.off("destroy",this.onSourceDestroy,this),ze.off("update",this.onSourceUpdate,this),ze.off("resize",this.onSourceUpdate,this),ze.off("unload",this.onSourceUnload,this),ze.off("styleChange",this.onStyleChange,this),ze.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(ze),1),this.onSourceUnload(ze)}_initSampler(ze){const Gr=this._gl,Yr=this._gl.createSampler();return this._glSamplers[ze._resourceId]=Yr,applyStyleParams(ze,Gr,this._boundTextures[this._activeTextureLocation].mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"samplerParameteri",Yr,!1,!0),this._glSamplers[ze._resourceId]}_getGlSampler(ze){return this._glSamplers[ze._resourceId]||this._initSampler(ze)}getGlSource(ze){return this._glTextures[ze.uid]||this._initSource(ze)}generateCanvas(ze){const{pixels:Gr,width:Yr,height:Kr}=this.getPixels(ze),Zr=DOMAdapter.get().createCanvas();Zr.width=Yr,Zr.height=Kr;const Qr=Zr.getContext("2d");if(Qr){const Jr=Qr.createImageData(Yr,Kr);Jr.data.set(Gr),Qr.putImageData(Jr,0,0)}return Zr}getPixels(ze){const Gr=ze.source.resolution,Yr=ze.frame,Kr=Math.max(Math.round(Yr.width*Gr),1),Zr=Math.max(Math.round(Yr.height*Gr),1),Qr=new Uint8Array(BYTES_PER_PIXEL*Kr*Zr),Jr=this._renderer,ei=Jr.renderTarget.getRenderTarget(ze),ti=Jr.renderTarget.getGpuRenderTarget(ei),ri=Jr.gl;return ri.bindFramebuffer(ri.FRAMEBUFFER,ti.resolveTargetFramebuffer),ri.readPixels(Math.round(Yr.x*Gr),Math.round(Yr.y*Gr),Kr,Zr,ri.RGBA,ri.UNSIGNED_BYTE,Qr),{pixels:new Uint8ClampedArray(Qr.buffer),width:Kr,height:Zr}}destroy(){this.managedTextures.slice().forEach(ze=>this.onSourceDestroy(ze)),this.managedTextures=null,this._renderer=null}resetState(){this._activeTextureLocation=-1,this._boundTextures.fill(Texture.EMPTY.source),this._boundSamplers=Object.create(null);const ze=this._gl;this._premultiplyAlpha=!1,ze.pixelStorei(ze.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this._premultiplyAlpha)}}GlTextureSystem.extension={type:[ExtensionType.WebGLSystem],name:"texture"};class GlGraphicsAdaptor{init(){const ze=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uRound:{value:0,type:"f32"}}),Gr=getMaxTexturesPerBatch(),Yr=compileHighShaderGlProgram({name:"graphics",bits:[colorBitGl,generateTextureBatchBitGl(Gr),localUniformBitGl,roundPixelsBitGl]});this.shader=new Shader({glProgram:Yr,resources:{localUniforms:ze,batchSamplers:getBatchSamplersUniformGroup(Gr)}})}execute(ze,Gr){const Yr=Gr.context,Kr=Yr.customShader||this.shader,Zr=ze.renderer,Qr=Zr.graphicsContext,{batcher:Jr,instructions:ei}=Qr.getContextRenderData(Yr);Kr.groups[0]=Zr.globalUniforms.bindGroup,Zr.state.set(ze.state),Zr.shader.bind(Kr),Zr.geometry.bind(Jr.geometry,Kr.glProgram);const ti=ei.instructions;for(let ri=0;ri<ei.instructionSize;ri++){const ii=ti[ri];if(ii.size){for(let si=0;si<ii.textures.count;si++)Zr.texture.bind(ii.textures.textures[si],si);Zr.geometry.draw(ii.topology,ii.size,ii.start)}}}destroy(){this.shader.destroy(!0),this.shader=null}}GlGraphicsAdaptor.extension={type:[ExtensionType.WebGLPipesAdaptor],name:"graphics"};class GlMeshAdaptor{init(){const ze=compileHighShaderGlProgram({name:"mesh",bits:[localUniformBitGl,textureBitGl,roundPixelsBitGl]});this._shader=new Shader({glProgram:ze,resources:{uTexture:Texture.EMPTY.source,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new Matrix}}}})}execute(ze,Gr){const Yr=ze.renderer;let Kr=Gr._shader;if(Kr){if(!Kr.glProgram){warn("Mesh shader has no glProgram",Gr.shader);return}}else{Kr=this._shader;const Zr=Gr.texture,Qr=Zr.source;Kr.resources.uTexture=Qr,Kr.resources.uSampler=Qr.style,Kr.resources.textureUniforms.uniforms.uTextureMatrix=Zr.textureMatrix.mapCoord}Kr.groups[100]=Yr.globalUniforms.bindGroup,Kr.groups[101]=ze.localUniformsBindGroup,Yr.encoder.draw({geometry:Gr._geometry,shader:Kr,state:Gr.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GlMeshAdaptor.extension={type:[ExtensionType.WebGLPipesAdaptor],name:"mesh"};class CustomRenderPipe{constructor(ze){this._renderer=ze}updateRenderable(){}destroyRenderable(){}validateRenderable(){return!1}addRenderable(ze,Gr){this._renderer.renderPipes.batch.break(Gr),Gr.add(ze)}execute(ze){ze.isRenderable&&ze.render(this._renderer)}destroy(){this._renderer=null}}CustomRenderPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"customRender"};class BatchableSprite{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}}function executeInstructions(Wr,ze){const Gr=Wr.instructionSet,Yr=Gr.instructions;for(let Kr=0;Kr<Gr.instructionSize;Kr++){const Zr=Yr[Kr];ze[Zr.renderPipeId].execute(Zr)}}const tempMatrix$1=new Matrix;class RenderGroupPipe{constructor(ze){this._renderer=ze}addRenderGroup(ze,Gr){ze.isCachedAsTexture?this._addRenderableCacheAsTexture(ze,Gr):this._addRenderableDirect(ze,Gr)}execute(ze){ze.isRenderable&&(ze.isCachedAsTexture?this._executeCacheAsTexture(ze):this._executeDirect(ze))}destroy(){this._renderer=null}_addRenderableDirect(ze,Gr){this._renderer.renderPipes.batch.break(Gr),ze._batchableRenderGroup&&(BigPool.return(ze._batchableRenderGroup),ze._batchableRenderGroup=null),Gr.add(ze)}_addRenderableCacheAsTexture(ze,Gr){const Yr=ze._batchableRenderGroup??(ze._batchableRenderGroup=BigPool.get(BatchableSprite));Yr.renderable=ze.root,Yr.transform=ze.root.relativeGroupTransform,Yr.texture=ze.texture,Yr.bounds=ze._textureBounds,Gr.add(ze),this._renderer.renderPipes.batch.addToBatch(Yr,Gr)}_executeCacheAsTexture(ze){if(ze.textureNeedsUpdate){ze.textureNeedsUpdate=!1;const Gr=tempMatrix$1.identity().translate(-ze._textureBounds.x,-ze._textureBounds.y);this._renderer.renderTarget.push(ze.texture,!0,null,ze.texture.frame),this._renderer.globalUniforms.push({worldTransformMatrix:Gr,worldColor:4294967295}),executeInstructions(ze,this._renderer.renderPipes),this._renderer.renderTarget.finishRenderPass(),this._renderer.renderTarget.pop(),this._renderer.globalUniforms.pop()}ze._batchableRenderGroup._batcher.updateElement(ze._batchableRenderGroup),ze._batchableRenderGroup._batcher.geometry.buffers[0].update()}_executeDirect(ze){this._renderer.globalUniforms.push({worldTransformMatrix:ze.inverseParentTextureTransform,worldColor:ze.worldColorAlpha}),executeInstructions(ze,this._renderer.renderPipes),this._renderer.globalUniforms.pop()}}RenderGroupPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"renderGroup"};function clearList(Wr,ze){ze||(ze=0);for(let Gr=ze;Gr<Wr.length&&Wr[Gr];Gr++)Wr[Gr]=null}const tempContainer=new Container,UPDATE_BLEND_COLOR_VISIBLE=UPDATE_VISIBLE|UPDATE_COLOR|UPDATE_BLEND;function updateRenderGroupTransforms(Wr,ze=!1){updateRenderGroupTransform(Wr);const Gr=Wr.childrenToUpdate,Yr=Wr.updateTick++;for(const Kr in Gr){const Zr=Number(Kr),Qr=Gr[Kr],Jr=Qr.list,ei=Qr.index;for(let ti=0;ti<ei;ti++){const ri=Jr[ti];ri.parentRenderGroup===Wr&&ri.relativeRenderGroupDepth===Zr&&updateTransformAndChildren(ri,Yr,0)}clearList(Jr,ei),Qr.index=0}if(ze)for(let Kr=0;Kr<Wr.renderGroupChildren.length;Kr++)updateRenderGroupTransforms(Wr.renderGroupChildren[Kr],ze)}function updateRenderGroupTransform(Wr){const ze=Wr.root;let Gr;if(Wr.renderGroupParent){const Yr=Wr.renderGroupParent;Wr.worldTransform.appendFrom(ze.relativeGroupTransform,Yr.worldTransform),Wr.worldColor=multiplyColors(ze.groupColor,Yr.worldColor),Gr=ze.groupAlpha*Yr.worldAlpha}else Wr.worldTransform.copyFrom(ze.localTransform),Wr.worldColor=ze.localColor,Gr=ze.localAlpha;Gr=Gr<0?0:Gr>1?1:Gr,Wr.worldAlpha=Gr,Wr.worldColorAlpha=Wr.worldColor+((Gr*255|0)<<24)}function updateTransformAndChildren(Wr,ze,Gr){if(ze===Wr.updateTick)return;Wr.updateTick=ze,Wr.didChange=!1;const Yr=Wr.localTransform;Wr.updateLocalTransform();const Kr=Wr.parent;if(Kr&&!Kr.renderGroup?(Gr|=Wr._updateFlags,Wr.relativeGroupTransform.appendFrom(Yr,Kr.relativeGroupTransform),Gr&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(Wr,Kr,Gr)):(Gr=Wr._updateFlags,Wr.relativeGroupTransform.copyFrom(Yr),Gr&UPDATE_BLEND_COLOR_VISIBLE&&updateColorBlendVisibility(Wr,tempContainer,Gr)),!Wr.renderGroup){const Zr=Wr.children,Qr=Zr.length;for(let ti=0;ti<Qr;ti++)updateTransformAndChildren(Zr[ti],ze,Gr);const Jr=Wr.parentRenderGroup,ei=Wr;ei.renderPipeId&&!Jr.structureDidChange&&Jr.updateRenderable(ei)}}function updateColorBlendVisibility(Wr,ze,Gr){if(Gr&UPDATE_COLOR){Wr.groupColor=multiplyColors(Wr.localColor,ze.groupColor);let Yr=Wr.localAlpha*ze.groupAlpha;Yr=Yr<0?0:Yr>1?1:Yr,Wr.groupAlpha=Yr,Wr.groupColorAlpha=Wr.groupColor+((Yr*255|0)<<24)}Gr&UPDATE_BLEND&&(Wr.groupBlendMode=Wr.localBlendMode==="inherit"?ze.groupBlendMode:Wr.localBlendMode),Gr&UPDATE_VISIBLE&&(Wr.globalDisplayStatus=Wr.localDisplayStatus&ze.globalDisplayStatus),Wr._updateFlags=0}function validateRenderables(Wr,ze){const{list:Gr,index:Yr}=Wr.childrenRenderablesToUpdate;let Kr=!1;for(let Zr=0;Zr<Yr;Zr++){const Qr=Gr[Zr];if(Kr=ze[Qr.renderPipeId].validateRenderable(Qr),Kr)break}return Wr.structureDidChange=Kr,Kr}const tempMatrix=new Matrix;class RenderGroupSystem{constructor(ze){this._renderer=ze}render({container:ze,transform:Gr}){const Yr=ze.parent,Kr=ze.renderGroup.renderGroupParent;ze.parent=null,ze.renderGroup.renderGroupParent=null;const Zr=this._renderer;let Qr=tempMatrix;Gr&&(Qr=Qr.copyFrom(ze.renderGroup.localTransform),ze.renderGroup.localTransform.copyFrom(Gr));const Jr=Zr.renderPipes;this._updateCachedRenderGroups(ze.renderGroup,null),this._updateRenderGroups(ze.renderGroup),Zr.globalUniforms.start({worldTransformMatrix:Gr?ze.renderGroup.localTransform:ze.renderGroup.worldTransform,worldColor:ze.renderGroup.worldColorAlpha}),executeInstructions(ze.renderGroup,Jr),Jr.uniformBatch&&Jr.uniformBatch.renderEnd(),Gr&&ze.renderGroup.localTransform.copyFrom(Qr),ze.parent=Yr,ze.renderGroup.renderGroupParent=Kr}destroy(){this._renderer=null}_updateCachedRenderGroups(ze,Gr){if(ze.isCachedAsTexture){if(!ze.updateCacheTexture)return;Gr=ze}ze._parentCacheAsTextureRenderGroup=Gr;for(let Yr=ze.renderGroupChildren.length-1;Yr>=0;Yr--)this._updateCachedRenderGroups(ze.renderGroupChildren[Yr],Gr);if(ze.invalidateMatrices(),ze.isCachedAsTexture){if(ze.textureNeedsUpdate){const Yr=ze.root.getLocalBounds();Yr.ceil();const Kr=ze.texture;ze.texture&&TexturePool.returnTexture(ze.texture);const Zr=this._renderer,Qr=ze.textureOptions.resolution||Zr.view.resolution,Jr=ze.textureOptions.antialias??Zr.view.antialias;ze.texture=TexturePool.getOptimalTexture(Yr.width,Yr.height,Qr,Jr),ze._textureBounds||(ze._textureBounds=new Bounds),ze._textureBounds.copyFrom(Yr),Kr!==ze.texture&&ze.renderGroupParent&&(ze.renderGroupParent.structureDidChange=!0)}}else ze.texture&&(TexturePool.returnTexture(ze.texture),ze.texture=null)}_updateRenderGroups(ze){const Gr=this._renderer,Yr=Gr.renderPipes;if(ze.runOnRender(Gr),ze.instructionSet.renderPipes=Yr,ze.structureDidChange?clearList(ze.childrenRenderablesToUpdate.list,0):validateRenderables(ze,Yr),updateRenderGroupTransforms(ze),ze.structureDidChange?(ze.structureDidChange=!1,this._buildInstructions(ze,Gr)):this._updateRenderables(ze),ze.childrenRenderablesToUpdate.index=0,Gr.renderPipes.batch.upload(ze.instructionSet),!(ze.isCachedAsTexture&&!ze.textureNeedsUpdate))for(let Kr=0;Kr<ze.renderGroupChildren.length;Kr++)this._updateRenderGroups(ze.renderGroupChildren[Kr])}_updateRenderables(ze){const{list:Gr,index:Yr}=ze.childrenRenderablesToUpdate;for(let Kr=0;Kr<Yr;Kr++){const Zr=Gr[Kr];Zr.didViewUpdate&&ze.updateRenderable(Zr)}clearList(Gr,Yr)}_buildInstructions(ze,Gr){const Yr=ze.root,Kr=ze.instructionSet;Kr.reset();const Zr=Gr.renderPipes?Gr:Gr.batch.renderer,Qr=Zr.renderPipes;Qr.batch.buildStart(Kr),Qr.blendMode.buildStart(),Qr.colorMask.buildStart(),Yr.sortableChildren&&Yr.sortChildren(),Yr.collectRenderablesWithEffects(Kr,Zr,null),Qr.batch.buildEnd(Kr),Qr.blendMode.buildEnd(Kr)}}RenderGroupSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"renderGroup"};class SpritePipe{constructor(ze){this._gpuSpriteHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuSpriteHash")}addRenderable(ze,Gr){const Yr=this._getGpuSprite(ze);ze.didViewUpdate&&this._updateBatchableSprite(ze,Yr),this._renderer.renderPipes.batch.addToBatch(Yr,Gr)}updateRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];ze.didViewUpdate&&this._updateBatchableSprite(ze,Gr),Gr._batcher.updateElement(Gr)}validateRenderable(ze){const Gr=this._getGpuSprite(ze);return!Gr._batcher.checkAndUpdateTexture(Gr,ze._texture)}destroyRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];BigPool.return(Gr),this._gpuSpriteHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(ze,Gr){Gr.bounds=ze.visualBounds,Gr.texture=ze._texture}_getGpuSprite(ze){return this._gpuSpriteHash[ze.uid]||this._initGPUSprite(ze)}_initGPUSprite(ze){const Gr=BigPool.get(BatchableSprite);return Gr.renderable=ze,Gr.transform=ze.groupTransform,Gr.texture=ze._texture,Gr.bounds=ze.visualBounds,Gr.roundPixels=this._renderer._roundPixels|ze._roundPixels,this._gpuSpriteHash[ze.uid]=Gr,ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuSpriteHash)BigPool.return(this._gpuSpriteHash[ze]);this._gpuSpriteHash=null,this._renderer=null}}SpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"sprite"};const _BackgroundSystem=class Fs{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new Color(0),this.color=this._backgroundColor,this.alpha=1}init(ze){ze={...Fs.defaultOptions,...ze},this.clearBeforeRender=ze.clearBeforeRender,this.color=ze.background||ze.backgroundColor||this._backgroundColor,this.alpha=ze.backgroundAlpha,this._backgroundColor.setAlpha(ze.backgroundAlpha)}get color(){return this._backgroundColor}set color(ze){this._backgroundColor.setValue(ze)}get alpha(){return this._backgroundColor.alpha}set alpha(ze){this._backgroundColor.setAlpha(ze)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};_BackgroundSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"background",priority:0};_BackgroundSystem.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};let BackgroundSystem=_BackgroundSystem;const BLEND_MODE_FILTERS={};extensions.handle(ExtensionType.BlendMode,Wr=>{if(!Wr.name)throw new Error("BlendMode extension must have a name property");BLEND_MODE_FILTERS[Wr.name]=Wr.ref},Wr=>{delete BLEND_MODE_FILTERS[Wr.name]});class BlendModePipe{constructor(ze){this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=ze,this._renderer.runners.prerender.add(this)}prerender(){this._activeBlendMode="normal",this._isAdvanced=!1}setBlendMode(ze,Gr,Yr){if(this._activeBlendMode===Gr){this._isAdvanced&&this._renderableList.push(ze);return}this._activeBlendMode=Gr,this._isAdvanced&&this._endAdvancedBlendMode(Yr),this._isAdvanced=!!BLEND_MODE_FILTERS[Gr],this._isAdvanced&&(this._beginAdvancedBlendMode(Yr),this._renderableList.push(ze))}_beginAdvancedBlendMode(ze){this._renderer.renderPipes.batch.break(ze);const Gr=this._activeBlendMode;if(!BLEND_MODE_FILTERS[Gr]){warn(`Unable to assign BlendMode: '${Gr}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);return}let Yr=this._filterHash[Gr];Yr||(Yr=this._filterHash[Gr]=new FilterEffect,Yr.filters=[new BLEND_MODE_FILTERS[Gr]]);const Kr={renderPipeId:"filter",action:"pushFilter",renderables:[],filterEffect:Yr,canBundle:!1};this._renderableList=Kr.renderables,ze.add(Kr)}_endAdvancedBlendMode(ze){this._renderableList=null,this._renderer.renderPipes.batch.break(ze),ze.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(ze){this._isAdvanced&&this._endAdvancedBlendMode(ze)}destroy(){this._renderer=null,this._renderableList=null;for(const ze in this._filterHash)this._filterHash[ze].destroy();this._filterHash=null}}BlendModePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"blendMode"};const imageTypes={png:"image/png",jpg:"image/jpeg",webp:"image/webp"},_ExtractSystem=class Us{constructor(ze){this._renderer=ze}_normalizeOptions(ze,Gr={}){return ze instanceof Container||ze instanceof Texture?{target:ze,...Gr}:{...Gr,...ze}}async image(ze){const Gr=new Image;return Gr.src=await this.base64(ze),Gr}async base64(ze){ze=this._normalizeOptions(ze,Us.defaultImageOptions);const{format:Gr,quality:Yr}=ze,Kr=this.canvas(ze);if(Kr.toBlob!==void 0)return new Promise((Zr,Qr)=>{Kr.toBlob(Jr=>{if(!Jr){Qr(new Error("ICanvas.toBlob failed!"));return}const ei=new FileReader;ei.onload=()=>Zr(ei.result),ei.onerror=Qr,ei.readAsDataURL(Jr)},imageTypes[Gr],Yr)});if(Kr.toDataURL!==void 0)return Kr.toDataURL(imageTypes[Gr],Yr);if(Kr.convertToBlob!==void 0){const Zr=await Kr.convertToBlob({type:imageTypes[Gr],quality:Yr});return new Promise((Qr,Jr)=>{const ei=new FileReader;ei.onload=()=>Qr(ei.result),ei.onerror=Jr,ei.readAsDataURL(Zr)})}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(ze){ze=this._normalizeOptions(ze);const Gr=ze.target,Yr=this._renderer;if(Gr instanceof Texture)return Yr.texture.generateCanvas(Gr);const Kr=Yr.textureGenerator.generateTexture(ze),Zr=Yr.texture.generateCanvas(Kr);return Kr.destroy(!0),Zr}pixels(ze){ze=this._normalizeOptions(ze);const Gr=ze.target,Yr=this._renderer,Kr=Gr instanceof Texture?Gr:Yr.textureGenerator.generateTexture(ze),Zr=Yr.texture.getPixels(Kr);return Gr instanceof Container&&Kr.destroy(!0),Zr}texture(ze){return ze=this._normalizeOptions(ze),ze.target instanceof Texture?ze.target:this._renderer.textureGenerator.generateTexture(ze)}download(ze){ze=this._normalizeOptions(ze);const Gr=this.canvas(ze),Yr=document.createElement("a");Yr.download=ze.filename??"image.png",Yr.href=Gr.toDataURL("image/png"),document.body.appendChild(Yr),Yr.click(),document.body.removeChild(Yr)}log(ze){const Gr=ze.width??200;ze=this._normalizeOptions(ze);const Yr=this.canvas(ze),Kr=Yr.toDataURL();console.log(`[Pixi Texture] ${Yr.width}px ${Yr.height}px`);const Zr=["font-size: 1px;",`padding: ${Gr}px 300px;`,`background: url(${Kr}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",Zr)}destroy(){this._renderer=null}};_ExtractSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"extract"};_ExtractSystem.defaultImageOptions={format:"png",quality:1};let ExtractSystem=_ExtractSystem;class RenderTexture extends Texture{static create(ze){return new RenderTexture({source:new TextureSource(ze)})}resize(ze,Gr,Yr){return this.source.resize(ze,Gr,Yr),this}}const tempRect=new Rectangle,tempBounds$1=new Bounds,noColor=[0,0,0,0];class GenerateTextureSystem{constructor(ze){this._renderer=ze}generateTexture(ze){var ti;ze instanceof Container&&(ze={target:ze,frame:void 0,textureSourceOptions:{},resolution:void 0});const Gr=ze.resolution||this._renderer.resolution,Yr=ze.antialias||this._renderer.view.antialias,Kr=ze.target;let Zr=ze.clearColor;Zr?Zr=Array.isArray(Zr)&&Zr.length===4?Zr:Color.shared.setValue(Zr).toArray():Zr=noColor;const Qr=((ti=ze.frame)==null?void 0:ti.copyTo(tempRect))||getLocalBounds(Kr,tempBounds$1).rectangle;Qr.width=Math.max(Qr.width,1/Gr)|0,Qr.height=Math.max(Qr.height,1/Gr)|0;const Jr=RenderTexture.create({...ze.textureSourceOptions,width:Qr.width,height:Qr.height,resolution:Gr,antialias:Yr}),ei=Matrix.shared.translate(-Qr.x,-Qr.y);return this._renderer.render({container:Kr,transform:ei,target:Jr,clearColor:Zr}),Jr.source.updateMipmaps(),Jr}destroy(){this._renderer=null}}GenerateTextureSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"textureGenerator"};function color32BitToUniform(Wr,ze,Gr){const Yr=(Wr>>24&255)/255;ze[Gr++]=(Wr&255)/255*Yr,ze[Gr++]=(Wr>>8&255)/255*Yr,ze[Gr++]=(Wr>>16&255)/255*Yr,ze[Gr++]=Yr}class GlobalUniformSystem{constructor(ze){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=ze}reset(){this._stackIndex=0;for(let ze=0;ze<this._activeUniforms.length;ze++)this._uniformsPool.push(this._activeUniforms[ze]);for(let ze=0;ze<this._activeBindGroups.length;ze++)this._bindGroupPool.push(this._activeBindGroups[ze]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(ze){this.reset(),this.push(ze)}bind({size:ze,projectionMatrix:Gr,worldTransformMatrix:Yr,worldColor:Kr,offset:Zr}){const Qr=this._renderer.renderTarget.renderTarget,Jr=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{worldTransformMatrix:new Matrix,worldColor:4294967295,offset:new Point$1},ei={projectionMatrix:Gr||this._renderer.renderTarget.projectionMatrix,resolution:ze||Qr.size,worldTransformMatrix:Yr||Jr.worldTransformMatrix,worldColor:Kr||Jr.worldColor,offset:Zr||Jr.offset,bindGroup:null},ti=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(ti);const ri=ti.uniforms;ri.uProjectionMatrix=ei.projectionMatrix,ri.uResolution=ei.resolution,ri.uWorldTransformMatrix.copyFrom(ei.worldTransformMatrix),ri.uWorldTransformMatrix.tx-=ei.offset.x,ri.uWorldTransformMatrix.ty-=ei.offset.y,color32BitToUniform(ei.worldColor,ri.uWorldColorAlpha,0),ti.update();let ii;this._renderer.renderPipes.uniformBatch?ii=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(ti,!1):(ii=this._bindGroupPool.pop()||new BindGroup,this._activeBindGroups.push(ii),ii.setResource(ti,0)),ei.bindGroup=ii,this._currentGlobalUniformData=ei}push(ze){this.bind(ze),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1],this._renderer.type===RendererType.WEBGL&&this._currentGlobalUniformData.bindGroup.resources[0].update()}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get globalUniformData(){return this._currentGlobalUniformData}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new UniformGroup({uProjectionMatrix:{value:new Matrix,type:"mat3x3<f32>"},uWorldTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uWorldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{isStatic:!0})}destroy(){this._renderer=null}}GlobalUniformSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"globalUniforms"};let uid=1;class SchedulerSystem{constructor(){this._tasks=[],this._offset=0}init(){Ticker.system.add(this._update,this)}repeat(ze,Gr,Yr=!0){const Kr=uid++;let Zr=0;return Yr&&(this._offset+=1e3,Zr=this._offset),this._tasks.push({func:ze,duration:Gr,start:performance.now(),offset:Zr,last:performance.now(),repeat:!0,id:Kr}),Kr}cancel(ze){for(let Gr=0;Gr<this._tasks.length;Gr++)if(this._tasks[Gr].id===ze){this._tasks.splice(Gr,1);return}}_update(){const ze=performance.now();for(let Gr=0;Gr<this._tasks.length;Gr++){const Yr=this._tasks[Gr];if(ze-Yr.offset-Yr.last>=Yr.duration){const Kr=ze-Yr.start;Yr.func(Kr),Yr.last=ze}}}destroy(){Ticker.system.remove(this._update,this),this._tasks.length=0}}SchedulerSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"scheduler",priority:0};let saidHello=!1;function sayHello(Wr){if(!saidHello){if(DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const ze=[`%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${Wr}) http://www.pixijs.com/

`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...ze)}else globalThis.console&&globalThis.console.log(`PixiJS ${VERSION} - ${Wr} - http://www.pixijs.com/`);saidHello=!0}}class HelloSystem{constructor(ze){this._renderer=ze}init(ze){if(ze.hello){let Gr=this._renderer.name;this._renderer.type===RendererType.WEBGL&&(Gr+=` ${this._renderer.context.webGLVersion}`),sayHello(Gr)}}}HelloSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"hello",priority:-2};HelloSystem.defaultOptions={hello:!1};function cleanHash(Wr){let ze=!1;for(const Yr in Wr)if(Wr[Yr]==null){ze=!0;break}if(!ze)return Wr;const Gr=Object.create(null);for(const Yr in Wr){const Kr=Wr[Yr];Kr&&(Gr[Yr]=Kr)}return Gr}function cleanArray(Wr){let ze=0;for(let Gr=0;Gr<Wr.length;Gr++)Wr[Gr]==null?ze++:Wr[Gr-ze]=Wr[Gr];return Wr.length-=ze,Wr}let renderableGCTick=0;const _RenderableGCSystem=class Os{constructor(ze){this._managedRenderables=[],this._managedHashes=[],this._managedArrays=[],this._renderer=ze}init(ze){ze={...Os.defaultOptions,...ze},this.maxUnusedTime=ze.renderableGCMaxUnusedTime,this._frequency=ze.renderableGCFrequency,this.enabled=ze.renderableGCActive}get enabled(){return!!this._handler}set enabled(ze){this.enabled!==ze&&(ze?(this._handler=this._renderer.scheduler.repeat(()=>this.run(),this._frequency,!1),this._hashHandler=this._renderer.scheduler.repeat(()=>{for(const Gr of this._managedHashes)Gr.context[Gr.hash]=cleanHash(Gr.context[Gr.hash])},this._frequency),this._arrayHandler=this._renderer.scheduler.repeat(()=>{for(const Gr of this._managedArrays)cleanArray(Gr.context[Gr.hash])},this._frequency)):(this._renderer.scheduler.cancel(this._handler),this._renderer.scheduler.cancel(this._hashHandler),this._renderer.scheduler.cancel(this._arrayHandler)))}addManagedHash(ze,Gr){this._managedHashes.push({context:ze,hash:Gr})}addManagedArray(ze,Gr){this._managedArrays.push({context:ze,hash:Gr})}prerender({container:ze}){this._now=performance.now(),ze.renderGroup.gcTick=renderableGCTick++,this._updateInstructionGCTick(ze.renderGroup,ze.renderGroup.gcTick)}addRenderable(ze){this.enabled&&(ze._lastUsed===-1&&(this._managedRenderables.push(ze),ze.once("destroyed",this._removeRenderable,this)),ze._lastUsed=this._now)}run(){var Zr;const ze=this._now,Gr=this._managedRenderables,Yr=this._renderer.renderPipes;let Kr=0;for(let Qr=0;Qr<Gr.length;Qr++){const Jr=Gr[Qr];if(Jr===null){Kr++;continue}const ei=Jr.renderGroup??Jr.parentRenderGroup,ti=((Zr=ei==null?void 0:ei.instructionSet)==null?void 0:Zr.gcTick)??-1;if(((ei==null?void 0:ei.gcTick)??0)===ti&&(Jr._lastUsed=ze),ze-Jr._lastUsed>this.maxUnusedTime){if(!Jr.destroyed){const ri=Yr;ei&&(ei.structureDidChange=!0),ri[Jr.renderPipeId].destroyRenderable(Jr)}Jr._lastUsed=-1,Kr++,Jr.off("destroyed",this._removeRenderable,this)}else Gr[Qr-Kr]=Jr}Gr.length-=Kr}destroy(){this.enabled=!1,this._renderer=null,this._managedRenderables.length=0,this._managedHashes.length=0,this._managedArrays.length=0}_removeRenderable(ze){const Gr=this._managedRenderables.indexOf(ze);Gr>=0&&(ze.off("destroyed",this._removeRenderable,this),this._managedRenderables[Gr]=null)}_updateInstructionGCTick(ze,Gr){ze.instructionSet.gcTick=Gr;for(const Yr of ze.renderGroupChildren)this._updateInstructionGCTick(Yr,Gr)}};_RenderableGCSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"renderableGC",priority:0};_RenderableGCSystem.defaultOptions={renderableGCActive:!0,renderableGCMaxUnusedTime:6e4,renderableGCFrequency:3e4};let RenderableGCSystem=_RenderableGCSystem;const _TextureGCSystem=class Ds{constructor(ze){this._renderer=ze,this.count=0,this.checkCount=0}init(ze){ze={...Ds.defaultOptions,...ze},this.checkCountMax=ze.textureGCCheckCountMax,this.maxIdle=ze.textureGCAMaxIdle??ze.textureGCMaxIdle,this.active=ze.textureGCActive}postrender(){this._renderer.renderingToScreen&&(this.count++,this.active&&(this.checkCount++,this.checkCount>this.checkCountMax&&(this.checkCount=0,this.run())))}run(){const ze=this._renderer.texture.managedTextures;for(let Gr=0;Gr<ze.length;Gr++){const Yr=ze[Gr];Yr.autoGarbageCollect&&Yr.resource&&Yr._touched>-1&&this.count-Yr._touched>this.maxIdle&&(Yr._touched=-1,Yr.unload())}}destroy(){this._renderer=null}};_TextureGCSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem],name:"textureGC"};_TextureGCSystem.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:null,textureGCMaxIdle:60*60,textureGCCheckCountMax:600};let TextureGCSystem=_TextureGCSystem;const _ViewSystem=class Ls{get autoDensity(){return this.texture.source.autoDensity}set autoDensity(ze){this.texture.source.autoDensity=ze}get resolution(){return this.texture.source._resolution}set resolution(ze){this.texture.source.resize(this.texture.source.width,this.texture.source.height,ze)}init(ze){ze={...Ls.defaultOptions,...ze},ze.view&&(deprecation(v8_0_0,"ViewSystem.view has been renamed to ViewSystem.canvas"),ze.canvas=ze.view),this.screen=new Rectangle(0,0,ze.width,ze.height),this.canvas=ze.canvas||DOMAdapter.get().createCanvas(),this.antialias=!!ze.antialias,this.texture=getCanvasTexture(this.canvas,ze),this.renderTarget=new RenderTarget({colorTextures:[this.texture],depth:!!ze.depth,isRoot:!0}),this.texture.source.transparent=ze.backgroundAlpha<1,this.resolution=ze.resolution}resize(ze,Gr,Yr){this.texture.source.resize(ze,Gr,Yr),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height}destroy(ze=!1){(typeof ze=="boolean"?ze:!!(ze!=null&&ze.removeView))&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas)}};_ViewSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"view",priority:0};_ViewSystem.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};let ViewSystem=_ViewSystem;const SharedSystems=[BackgroundSystem,GlobalUniformSystem,HelloSystem,ViewSystem,RenderGroupSystem,TextureGCSystem,GenerateTextureSystem,ExtractSystem,RendererInitHook,RenderableGCSystem,SchedulerSystem],SharedRenderPipes=[BlendModePipe,BatcherPipe,SpritePipe,RenderGroupPipe,AlphaMaskPipe,StencilMaskPipe,ColorMaskPipe,CustomRenderPipe],DefaultWebGLSystems=[...SharedSystems,GlUboSystem,GlBackBufferSystem,GlContextSystem,GlBufferSystem,GlTextureSystem,GlRenderTargetSystem,GlGeometrySystem,GlUniformGroupSystem,GlShaderSystem,GlEncoderSystem,GlStateSystem,GlStencilSystem,GlColorMaskSystem],DefaultWebGLPipes=[...SharedRenderPipes],DefaultWebGLAdapters=[GlBatchAdaptor,GlMeshAdaptor,GlGraphicsAdaptor],systems$1=[],renderPipes$1=[],renderPipeAdaptors$1=[];extensions.handleByNamedList(ExtensionType.WebGLSystem,systems$1);extensions.handleByNamedList(ExtensionType.WebGLPipes,renderPipes$1);extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor,renderPipeAdaptors$1);extensions.add(...DefaultWebGLSystems,...DefaultWebGLPipes,...DefaultWebGLAdapters);class WebGLRenderer extends AbstractRenderer{constructor(){const ze={name:"webgl",type:RendererType.WEBGL,systems:systems$1,renderPipes:renderPipes$1,renderPipeAdaptors:renderPipeAdaptors$1};super(ze)}}const WebGLRenderer$1=Object.freeze(Object.defineProperty({__proto__:null,WebGLRenderer},Symbol.toStringTag,{value:"Module"}));class BindGroupSystem{constructor(ze){this._hash=Object.create(null),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_hash")}contextChange(ze){this._gpu=ze}getBindGroup(ze,Gr,Yr){return ze._updateKey(),this._hash[ze._key]||this._createBindGroup(ze,Gr,Yr)}_createBindGroup(ze,Gr,Yr){const Kr=this._gpu.device,Zr=Gr.layout[Yr],Qr=[],Jr=this._renderer;for(const ri in Zr){const ii=ze.resources[ri]??ze.resources[Zr[ri]];let si;if(ii._resourceType==="uniformGroup"){const ni=ii;Jr.ubo.updateUniformGroup(ni);const oi=ni.buffer;si={buffer:Jr.buffer.getGPUBuffer(oi),offset:0,size:oi.descriptor.size}}else if(ii._resourceType==="buffer"){const ni=ii;si={buffer:Jr.buffer.getGPUBuffer(ni),offset:0,size:ni.descriptor.size}}else if(ii._resourceType==="bufferResource"){const ni=ii;si={buffer:Jr.buffer.getGPUBuffer(ni.buffer),offset:ni.offset,size:ni.size}}else if(ii._resourceType==="textureSampler"){const ni=ii;si=Jr.texture.getGpuSampler(ni)}else if(ii._resourceType==="textureSource"){const ni=ii;si=Jr.texture.getGpuSource(ni).createView({})}Qr.push({binding:Zr[ri],resource:si})}const ei=Jr.shader.getProgramData(Gr).bindGroups[Yr],ti=Kr.createBindGroup({layout:ei,entries:Qr});return this._hash[ze._key]=ti,ti}destroy(){for(const ze of Object.keys(this._hash))this._hash[ze]=null;this._hash=null,this._renderer=null}}BindGroupSystem.extension={type:[ExtensionType.WebGPUSystem],name:"bindGroup"};class GpuBufferSystem{constructor(ze){this._gpuBuffers=Object.create(null),this._managedBuffers=[],ze.renderableGC.addManagedHash(this,"_gpuBuffers")}contextChange(ze){this._gpu=ze}getGPUBuffer(ze){return this._gpuBuffers[ze.uid]||this.createGPUBuffer(ze)}updateBuffer(ze){const Gr=this._gpuBuffers[ze.uid]||this.createGPUBuffer(ze),Yr=ze.data;return ze._updateID&&Yr&&(ze._updateID=0,this._gpu.device.queue.writeBuffer(Gr,0,Yr.buffer,0,(ze._updateSize||Yr.byteLength)+3&-4)),Gr}destroyAll(){for(const ze in this._gpuBuffers)this._gpuBuffers[ze].destroy();this._gpuBuffers={}}createGPUBuffer(ze){this._gpuBuffers[ze.uid]||(ze.on("update",this.updateBuffer,this),ze.on("change",this.onBufferChange,this),ze.on("destroy",this.onBufferDestroy,this),this._managedBuffers.push(ze));const Gr=this._gpu.device.createBuffer(ze.descriptor);return ze._updateID=0,ze.data&&(fastCopy(ze.data.buffer,Gr.getMappedRange()),Gr.unmap()),this._gpuBuffers[ze.uid]=Gr,Gr}onBufferChange(ze){this._gpuBuffers[ze.uid].destroy(),ze._updateID=0,this._gpuBuffers[ze.uid]=this.createGPUBuffer(ze)}onBufferDestroy(ze){this._managedBuffers.splice(this._managedBuffers.indexOf(ze),1),this._destroyBuffer(ze)}destroy(){this._managedBuffers.forEach(ze=>this._destroyBuffer(ze)),this._managedBuffers=null,this._gpuBuffers=null}_destroyBuffer(ze){this._gpuBuffers[ze.uid].destroy(),ze.off("update",this.updateBuffer,this),ze.off("change",this.onBufferChange,this),ze.off("destroy",this.onBufferDestroy,this),this._gpuBuffers[ze.uid]=null}}GpuBufferSystem.extension={type:[ExtensionType.WebGPUSystem],name:"buffer"};class UboBatch{constructor({minUniformOffsetAlignment:ze}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=ze,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(ze){if(ze>this._minUniformOffsetAlignment/4)throw new Error(`UniformBufferBatch: array is too large: ${ze*4}`);const Gr=this.byteIndex;let Yr=Gr+ze*4;if(Yr=Math.ceil(Yr/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,Yr>this.data.length*4)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=Yr,Gr}addGroup(ze){const Gr=this.addEmptyGroup(ze.length);for(let Yr=0;Yr<ze.length;Yr++)this.data[Gr/4+Yr]=ze[Yr];return Gr}destroy(){this.data=null}}class GpuColorMaskSystem{constructor(ze){this._colorMaskCache=15,this._renderer=ze}setMask(ze){this._colorMaskCache!==ze&&(this._colorMaskCache=ze,this._renderer.pipeline.setColorMask(ze))}destroy(){this._renderer=null,this._colorMaskCache=null}}GpuColorMaskSystem.extension={type:[ExtensionType.WebGPUSystem],name:"colorMask"};class GpuDeviceSystem{constructor(ze){this._renderer=ze}async init(ze){return this._initPromise?this._initPromise:(this._initPromise=this._createDeviceAndAdaptor(ze).then(Gr=>{this.gpu=Gr,this._renderer.runners.contextChange.emit(this.gpu)}),this._initPromise)}contextChange(ze){this._renderer.gpu=ze}async _createDeviceAndAdaptor(ze){const Gr=await DOMAdapter.get().getNavigator().gpu.requestAdapter({powerPreference:ze.powerPreference,forceFallbackAdapter:ze.forceFallbackAdapter}),Yr=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(Zr=>Gr.features.has(Zr)),Kr=await Gr.requestDevice({requiredFeatures:Yr});return{adapter:Gr,device:Kr}}destroy(){this.gpu=null,this._renderer=null}}GpuDeviceSystem.extension={type:[ExtensionType.WebGPUSystem],name:"device"};GpuDeviceSystem.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class GpuEncoderSystem{constructor(ze){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=ze}renderStart(){this.commandFinished=new Promise(ze=>{this._resolveCommandFinished=ze}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(ze){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(ze.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(ze){this.renderPassEncoder.setViewport(ze.x,ze.y,ze.width,ze.height,0,1)}setPipelineFromGeometryProgramAndState(ze,Gr,Yr,Kr){const Zr=this._renderer.pipeline.getPipeline(ze,Gr,Yr,Kr);this.setPipeline(Zr)}setPipeline(ze){this._boundPipeline!==ze&&(this._boundPipeline=ze,this.renderPassEncoder.setPipeline(ze))}_setVertexBuffer(ze,Gr){this._boundVertexBuffer[ze]!==Gr&&(this._boundVertexBuffer[ze]=Gr,this.renderPassEncoder.setVertexBuffer(ze,this._renderer.buffer.updateBuffer(Gr)))}_setIndexBuffer(ze){if(this._boundIndexBuffer===ze)return;this._boundIndexBuffer=ze;const Gr=ze.data.BYTES_PER_ELEMENT===2?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(ze),Gr)}resetBindGroup(ze){this._boundBindGroup[ze]=null}setBindGroup(ze,Gr,Yr){if(this._boundBindGroup[ze]===Gr)return;this._boundBindGroup[ze]=Gr,Gr._touch(this._renderer.textureGC.count);const Kr=this._renderer.bindGroup.getBindGroup(Gr,Yr,ze);this.renderPassEncoder.setBindGroup(ze,Kr)}setGeometry(ze,Gr){const Yr=this._renderer.pipeline.getBufferNamesToBind(ze,Gr);for(const Kr in Yr)this._setVertexBuffer(Kr,ze.attributes[Yr[Kr]].buffer);ze.indexBuffer&&this._setIndexBuffer(ze.indexBuffer)}_setShaderBindGroups(ze,Gr){for(const Yr in ze.groups){const Kr=ze.groups[Yr];Gr||this._syncBindGroup(Kr),this.setBindGroup(Yr,Kr,ze.gpuProgram)}}_syncBindGroup(ze){for(const Gr in ze.resources){const Yr=ze.resources[Gr];Yr.isUniformGroup&&this._renderer.ubo.updateUniformGroup(Yr)}}draw(ze){const{geometry:Gr,shader:Yr,state:Kr,topology:Zr,size:Qr,start:Jr,instanceCount:ei,skipSync:ti}=ze;this.setPipelineFromGeometryProgramAndState(Gr,Yr.gpuProgram,Kr,Zr),this.setGeometry(Gr,Yr.gpuProgram),this._setShaderBindGroups(Yr,ti),Gr.indexBuffer?this.renderPassEncoder.drawIndexed(Qr||Gr.indexBuffer.data.length,ei??Gr.instanceCount,Jr||0):this.renderPassEncoder.draw(Qr||Gr.getSize(),ei??Gr.instanceCount,Jr||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){const ze=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(ze);const Gr=this._boundPipeline,Yr={...this._boundVertexBuffer},Kr=this._boundIndexBuffer,Zr={...this._boundBindGroup};this._clearCache();const Qr=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(Qr.x,Qr.y,Qr.width,Qr.height,0,1),this.setPipeline(Gr);for(const Jr in Yr)this._setVertexBuffer(Jr,Yr[Jr]);for(const Jr in Zr)this.setBindGroup(Jr,Zr[Jr],null);this._setIndexBuffer(Kr)}_clearCache(){for(let ze=0;ze<16;ze++)this._boundBindGroup[ze]=null,this._boundVertexBuffer[ze]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(ze){this._gpu=ze}}GpuEncoderSystem.extension={type:[ExtensionType.WebGPUSystem],name:"encoder",priority:1};class GpuStencilSystem{constructor(ze){this._renderTargetStencilState=Object.create(null),this._renderer=ze,ze.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(ze){let Gr=this._renderTargetStencilState[ze.uid];Gr||(Gr=this._renderTargetStencilState[ze.uid]={stencilMode:STENCIL_MODES.DISABLED,stencilReference:0}),this._activeRenderTarget=ze,this.setStencilMode(Gr.stencilMode,Gr.stencilReference)}setStencilMode(ze,Gr){const Yr=this._renderTargetStencilState[this._activeRenderTarget.uid];Yr.stencilMode=ze,Yr.stencilReference=Gr;const Kr=this._renderer;Kr.pipeline.setStencilMode(ze),Kr.encoder.renderPassEncoder.setStencilReference(Gr)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}GpuStencilSystem.extension={type:[ExtensionType.WebGPUSystem],name:"stencil"};const WGSL_ALIGN_SIZE_DATA={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function createUboElementsWGSL(Wr){const ze=Wr.map(Yr=>({data:Yr,offset:0,size:0}));let Gr=0;for(let Yr=0;Yr<ze.length;Yr++){const Kr=ze[Yr];let Zr=WGSL_ALIGN_SIZE_DATA[Kr.data.type].size;const Qr=WGSL_ALIGN_SIZE_DATA[Kr.data.type].align;if(!WGSL_ALIGN_SIZE_DATA[Kr.data.type])throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${Kr.data.type}`);Kr.data.size>1&&(Zr=Math.max(Zr,Qr)*Kr.data.size),Gr=Math.ceil(Gr/Qr)*Qr,Kr.size=Zr,Kr.offset=Gr,Gr+=Zr}return Gr=Math.ceil(Gr/16)*16,{uboElements:ze,size:Gr}}function generateArraySyncWGSL(Wr,ze){const{size:Gr,align:Yr}=WGSL_ALIGN_SIZE_DATA[Wr.data.type],Kr=(Yr-Gr)/4,Zr=Wr.data.type.indexOf("i32")>=0?"dataInt32":"data";return`
         v = uv.${Wr.data.name};
         ${ze!==0?`offset += ${ze};`:""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${Wr.data.size*(Gr/4)}; i++)
         {
             for(var j = 0; j < ${Gr/4}; j++)
             {
                 ${Zr}[arrayOffset++] = v[t++];
             }
             ${Kr!==0?`arrayOffset += ${Kr};`:""}
         }
     `}function createUboSyncFunctionWGSL(Wr){return createUboSyncFunction(Wr,"uboWgsl",generateArraySyncWGSL,uboSyncFunctionsWGSL)}class GpuUboSystem extends UboSystem{constructor(){super({createUboElements:createUboElementsWGSL,generateUboSync:createUboSyncFunctionWGSL})}}GpuUboSystem.extension={type:[ExtensionType.WebGPUSystem],name:"ubo"};const minUniformOffsetAlignment=128;class GpuUniformBatchPipe{constructor(ze){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_bindGroupHash"),this._batchBuffer=new UboBatch({minUniformOffsetAlignment});const Gr=256/minUniformOffsetAlignment;for(let Yr=0;Yr<Gr;Yr++){let Kr=BufferUsage.UNIFORM|BufferUsage.COPY_DST;Yr===0&&(Kr|=BufferUsage.COPY_SRC),this._buffers.push(new Buffer({data:this._batchBuffer.data,usage:Kr}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){for(const ze in this._bindGroupHash)this._bindGroupHash[ze]=null;this._batchBuffer.clear()}getUniformBindGroup(ze,Gr){if(!Gr&&this._bindGroupHash[ze.uid])return this._bindGroupHash[ze.uid];this._renderer.ubo.ensureUniformGroup(ze);const Yr=ze.buffer.data,Kr=this._batchBuffer.addEmptyGroup(Yr.length);return this._renderer.ubo.syncUniformGroup(ze,this._batchBuffer.data,Kr/4),this._bindGroupHash[ze.uid]=this._getBindGroup(Kr/minUniformOffsetAlignment),this._bindGroupHash[ze.uid]}getUboResource(ze){this._renderer.ubo.updateUniformGroup(ze);const Gr=ze.buffer.data,Yr=this._batchBuffer.addGroup(Gr);return this._getBufferResource(Yr/minUniformOffsetAlignment)}getArrayBindGroup(ze){const Gr=this._batchBuffer.addGroup(ze);return this._getBindGroup(Gr/minUniformOffsetAlignment)}getArrayBufferResource(ze){const Yr=this._batchBuffer.addGroup(ze)/minUniformOffsetAlignment;return this._getBufferResource(Yr)}_getBufferResource(ze){if(!this._bufferResources[ze]){const Gr=this._buffers[ze%2];this._bufferResources[ze]=new BufferResource({buffer:Gr,offset:(ze/2|0)*256,size:minUniformOffsetAlignment})}return this._bufferResources[ze]}_getBindGroup(ze){if(!this._bindGroups[ze]){const Gr=new BindGroup({0:this._getBufferResource(ze)});this._bindGroups[ze]=Gr}return this._bindGroups[ze]}_uploadBindGroups(){const ze=this._renderer.buffer,Gr=this._buffers[0];Gr.update(this._batchBuffer.byteIndex),ze.updateBuffer(Gr);const Yr=this._renderer.gpu.device.createCommandEncoder();for(let Kr=1;Kr<this._buffers.length;Kr++){const Zr=this._buffers[Kr];Yr.copyBufferToBuffer(ze.getGPUBuffer(Gr),minUniformOffsetAlignment,ze.getGPUBuffer(Zr),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([Yr.finish()])}destroy(){for(let ze=0;ze<this._bindGroups.length;ze++)this._bindGroups[ze].destroy();this._bindGroups=null,this._bindGroupHash=null;for(let ze=0;ze<this._buffers.length;ze++)this._buffers[ze].destroy();this._buffers=null;for(let ze=0;ze<this._bufferResources.length;ze++)this._bufferResources[ze].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._bindGroupHash=null,this._renderer=null}}GpuUniformBatchPipe.extension={type:[ExtensionType.WebGPUPipes],name:"uniformBatch"};const topologyStringToId={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function getGraphicsStateKey(Wr,ze,Gr,Yr,Kr){return Wr<<24|ze<<16|Gr<<10|Yr<<5|Kr}function getGlobalStateKey(Wr,ze,Gr,Yr){return Gr<<6|Wr<<3|Yr<<1|ze}class PipelineSystem{constructor(ze){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._bindingNamesCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._renderer=ze}contextChange(ze){this._gpu=ze,this.setStencilMode(STENCIL_MODES.DISABLED),this._updatePipeHash()}setMultisampleCount(ze){this._multisampleCount!==ze&&(this._multisampleCount=ze,this._updatePipeHash())}setRenderTarget(ze){this._multisampleCount=ze.msaaSamples,this._depthStencilAttachment=ze.descriptor.depthStencilAttachment?1:0,this._updatePipeHash()}setColorMask(ze){this._colorMask!==ze&&(this._colorMask=ze,this._updatePipeHash())}setStencilMode(ze){this._stencilMode!==ze&&(this._stencilMode=ze,this._stencilState=GpuStencilModesToPixi[ze],this._updatePipeHash())}setPipeline(ze,Gr,Yr,Kr){const Zr=this.getPipeline(ze,Gr,Yr);Kr.setPipeline(Zr)}getPipeline(ze,Gr,Yr,Kr){ze._layoutKey||(ensureAttributes(ze,Gr.attributeData),this._generateBufferKey(ze)),Kr||(Kr=ze.topology);const Zr=getGraphicsStateKey(ze._layoutKey,Gr._layoutKey,Yr.data,Yr._blendModeId,topologyStringToId[Kr]);return this._pipeCache[Zr]?this._pipeCache[Zr]:(this._pipeCache[Zr]=this._createPipeline(ze,Gr,Yr,Kr),this._pipeCache[Zr])}_createPipeline(ze,Gr,Yr,Kr){const Zr=this._gpu.device,Qr=this._createVertexBufferLayouts(ze,Gr),Jr=this._renderer.state.getColorTargets(Yr);Jr[0].writeMask=this._stencilMode===STENCIL_MODES.RENDERING_MASK_ADD?0:this._colorMask;const ei=this._renderer.shader.getProgramData(Gr).pipeline,ti={vertex:{module:this._getModule(Gr.vertex.source),entryPoint:Gr.vertex.entryPoint,buffers:Qr},fragment:{module:this._getModule(Gr.fragment.source),entryPoint:Gr.fragment.entryPoint,targets:Jr},primitive:{topology:Kr,cullMode:Yr.cullMode},layout:ei,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};return this._depthStencilAttachment&&(ti.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:Yr.depthTest,depthCompare:Yr.depthTest?"less":"always"}),Zr.createRenderPipeline(ti)}_getModule(ze){return this._moduleCache[ze]||this._createModule(ze)}_createModule(ze){const Gr=this._gpu.device;return this._moduleCache[ze]=Gr.createShaderModule({code:ze}),this._moduleCache[ze]}_generateBufferKey(ze){const Gr=[];let Yr=0;const Kr=Object.keys(ze.attributes).sort();for(let Qr=0;Qr<Kr.length;Qr++){const Jr=ze.attributes[Kr[Qr]];Gr[Yr++]=Jr.offset,Gr[Yr++]=Jr.format,Gr[Yr++]=Jr.stride,Gr[Yr++]=Jr.instance}const Zr=Gr.join("|");return ze._layoutKey=createIdFromString(Zr,"geometry"),ze._layoutKey}_generateAttributeLocationsKey(ze){const Gr=[];let Yr=0;const Kr=Object.keys(ze.attributeData).sort();for(let Qr=0;Qr<Kr.length;Qr++){const Jr=ze.attributeData[Kr[Qr]];Gr[Yr++]=Jr.location}const Zr=Gr.join("|");return ze._attributeLocationsKey=createIdFromString(Zr,"programAttributes"),ze._attributeLocationsKey}getBufferNamesToBind(ze,Gr){const Yr=ze._layoutKey<<16|Gr._attributeLocationsKey;if(this._bindingNamesCache[Yr])return this._bindingNamesCache[Yr];const Kr=this._createVertexBufferLayouts(ze,Gr),Zr=Object.create(null),Qr=Gr.attributeData;for(let Jr=0;Jr<Kr.length;Jr++){const ti=Object.values(Kr[Jr].attributes)[0].shaderLocation;for(const ri in Qr)if(Qr[ri].location===ti){Zr[Jr]=ri;break}}return this._bindingNamesCache[Yr]=Zr,Zr}_createVertexBufferLayouts(ze,Gr){Gr._attributeLocationsKey||this._generateAttributeLocationsKey(Gr);const Yr=ze._layoutKey<<16|Gr._attributeLocationsKey;if(this._bufferLayoutsCache[Yr])return this._bufferLayoutsCache[Yr];const Kr=[];return ze.buffers.forEach(Zr=>{const Qr={arrayStride:0,stepMode:"vertex",attributes:[]},Jr=Qr.attributes;for(const ei in Gr.attributeData){const ti=ze.attributes[ei];(ti.divisor??1)!==1&&warn(`Attribute ${ei} has an invalid divisor value of '${ti.divisor}'. WebGPU only supports a divisor value of 1`),ti.buffer===Zr&&(Qr.arrayStride=ti.stride,Qr.stepMode=ti.instance?"instance":"vertex",Jr.push({shaderLocation:Gr.attributeData[ei].location,offset:ti.offset,format:ti.format}))}Jr.length&&Kr.push(Qr)}),this._bufferLayoutsCache[Yr]=Kr,Kr}_updatePipeHash(){const ze=getGlobalStateKey(this._stencilMode,this._multisampleCount,this._colorMask,this._depthStencilAttachment);this._pipeStateCaches[ze]||(this._pipeStateCaches[ze]=Object.create(null)),this._pipeCache=this._pipeStateCaches[ze]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}PipelineSystem.extension={type:[ExtensionType.WebGPUSystem],name:"pipeline"};class GpuRenderTarget{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class GpuRenderTargetAdaptor{init(ze,Gr){this._renderer=ze,this._renderTargetSystem=Gr}copyToTexture(ze,Gr,Yr,Kr,Zr){const Qr=this._renderer,Jr=this._getGpuColorTexture(ze),ei=Qr.texture.getGpuSource(Gr.source);return Qr.encoder.commandEncoder.copyTextureToTexture({texture:Jr,origin:Yr},{texture:ei,origin:Zr},Kr),Gr}startRenderPass(ze,Gr=!0,Yr,Kr){const Qr=this._renderTargetSystem.getGpuRenderTarget(ze),Jr=this.getDescriptor(ze,Gr,Yr);Qr.descriptor=Jr,this._renderer.pipeline.setRenderTarget(Qr),this._renderer.encoder.beginRenderPass(Qr),this._renderer.encoder.setViewport(Kr)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(ze){const Gr=this._renderTargetSystem.getGpuRenderTarget(ze);return Gr.contexts[0]?Gr.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(ze.colorTextures[0].source)}getDescriptor(ze,Gr,Yr){typeof Gr=="boolean"&&(Gr=Gr?CLEAR.ALL:CLEAR.NONE);const Kr=this._renderTargetSystem,Zr=Kr.getGpuRenderTarget(ze),Qr=ze.colorTextures.map((ti,ri)=>{const ii=Zr.contexts[ri];let si,ni;ii?si=ii.getCurrentTexture().createView():si=this._renderer.texture.getGpuSource(ti).createView({mipLevelCount:1}),Zr.msaaTextures[ri]&&(ni=si,si=this._renderer.texture.getTextureView(Zr.msaaTextures[ri]));const oi=Gr&CLEAR.COLOR?"clear":"load";return Yr??(Yr=Kr.defaultClearColor),{view:si,resolveTarget:ni,clearValue:Yr,storeOp:"store",loadOp:oi}});let Jr;if((ze.stencil||ze.depth)&&!ze.depthStencilTexture&&(ze.ensureDepthStencilTexture(),ze.depthStencilTexture.source.sampleCount=Zr.msaa?4:1),ze.depthStencilTexture){const ti=Gr&CLEAR.STENCIL?"clear":"load",ri=Gr&CLEAR.DEPTH?"clear":"load";Jr={view:this._renderer.texture.getGpuSource(ze.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:ti,depthClearValue:1,depthLoadOp:ri,depthStoreOp:"store"}}return{colorAttachments:Qr,depthStencilAttachment:Jr}}clear(ze,Gr=!0,Yr,Kr){if(!Gr)return;const{gpu:Zr,encoder:Qr}=this._renderer,Jr=Zr.device;if(Qr.commandEncoder===null){const ti=Jr.createCommandEncoder(),ri=this.getDescriptor(ze,Gr,Yr),ii=ti.beginRenderPass(ri);ii.setViewport(Kr.x,Kr.y,Kr.width,Kr.height,0,1),ii.end();const si=ti.finish();Jr.queue.submit([si])}else this.startRenderPass(ze,Gr,Yr,Kr)}initGpuRenderTarget(ze){ze.isRoot=!0;const Gr=new GpuRenderTarget;return ze.colorTextures.forEach((Yr,Kr)=>{if(CanvasSource.test(Yr.resource)){const Zr=Yr.resource.getContext("webgpu"),Qr=Yr.transparent?"premultiplied":"opaque";try{Zr.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:Qr})}catch(Jr){console.error(Jr)}Gr.contexts[Kr]=Zr}if(Gr.msaa=Yr.source.antialias,Yr.source.antialias){const Zr=new TextureSource({width:0,height:0,sampleCount:4});Gr.msaaTextures[Kr]=Zr}}),Gr.msaa&&(Gr.msaaSamples=4,ze.depthStencilTexture&&(ze.depthStencilTexture.source.sampleCount=4)),Gr}destroyGpuRenderTarget(ze){ze.contexts.forEach(Gr=>{Gr.unconfigure()}),ze.msaaTextures.forEach(Gr=>{Gr.destroy()}),ze.msaaTextures.length=0,ze.contexts.length=0}ensureDepthStencilTexture(ze){const Gr=this._renderTargetSystem.getGpuRenderTarget(ze);ze.depthStencilTexture&&Gr.msaa&&(ze.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(ze){const Gr=this._renderTargetSystem.getGpuRenderTarget(ze);Gr.width=ze.width,Gr.height=ze.height,Gr.msaa&&ze.colorTextures.forEach((Yr,Kr)=>{const Zr=Gr.msaaTextures[Kr];Zr==null||Zr.resize(Yr.source.width,Yr.source.height,Yr.source._resolution)})}}class GpuRenderTargetSystem extends RenderTargetSystem{constructor(ze){super(ze),this.adaptor=new GpuRenderTargetAdaptor,this.adaptor.init(ze,this)}}GpuRenderTargetSystem.extension={type:[ExtensionType.WebGPUSystem],name:"renderTarget"};class GpuShaderSystem{constructor(){this._gpuProgramData=Object.create(null)}contextChange(ze){this._gpu=ze,this.maxTextures=ze.device.limits.maxSampledTexturesPerShaderStage}getProgramData(ze){return this._gpuProgramData[ze._layoutKey]||this._createGPUProgramData(ze)}_createGPUProgramData(ze){const Gr=this._gpu.device,Yr=ze.gpuLayout.map(Zr=>Gr.createBindGroupLayout({entries:Zr})),Kr={bindGroupLayouts:Yr};return this._gpuProgramData[ze._layoutKey]={bindGroups:Yr,pipeline:Gr.createPipelineLayout(Kr)},this._gpuProgramData[ze._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}}GpuShaderSystem.extension={type:[ExtensionType.WebGPUSystem],name:"shader"};const GpuBlendModesToPixi={};GpuBlendModesToPixi.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}};GpuBlendModesToPixi.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}};GpuBlendModesToPixi.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}};GpuBlendModesToPixi.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}};GpuBlendModesToPixi["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}};GpuBlendModesToPixi["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}};GpuBlendModesToPixi["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}};GpuBlendModesToPixi.min={alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}};GpuBlendModesToPixi.max={alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}};class GpuStateSystem{constructor(){this.defaultState=new State,this.defaultState.blend=!0}contextChange(ze){this.gpu=ze}getColorTargets(ze){return[{format:"bgra8unorm",writeMask:0,blend:GpuBlendModesToPixi[ze.blendMode]||GpuBlendModesToPixi.normal}]}destroy(){this.gpu=null}}GpuStateSystem.extension={type:[ExtensionType.WebGPUSystem],name:"state"};const gpuUploadBufferImageResource={type:"image",upload(Wr,ze,Gr){const Yr=Wr.resource,Kr=(Wr.pixelWidth|0)*(Wr.pixelHeight|0),Zr=Yr.byteLength/Kr;Gr.device.queue.writeTexture({texture:ze},Yr,{offset:0,rowsPerImage:Wr.pixelHeight,bytesPerRow:Wr.pixelHeight*Zr},{width:Wr.pixelWidth,height:Wr.pixelHeight,depthOrArrayLayers:1})}},blockDataMap={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},defaultBlockData={blockBytes:4,blockWidth:1,blockHeight:1},gpuUploadCompressedTextureResource={type:"compressed",upload(Wr,ze,Gr){let Yr=Wr.pixelWidth,Kr=Wr.pixelHeight;const Zr=blockDataMap[Wr.format]||defaultBlockData;for(let Qr=0;Qr<Wr.resource.length;Qr++){const Jr=Wr.resource[Qr],ei=Math.ceil(Yr/Zr.blockWidth)*Zr.blockBytes;Gr.device.queue.writeTexture({texture:ze,mipLevel:Qr},Jr,{offset:0,bytesPerRow:ei},{width:Math.ceil(Yr/Zr.blockWidth)*Zr.blockWidth,height:Math.ceil(Kr/Zr.blockHeight)*Zr.blockHeight,depthOrArrayLayers:1}),Yr=Math.max(Yr>>1,1),Kr=Math.max(Kr>>1,1)}}},gpuUploadImageResource={type:"image",upload(Wr,ze,Gr){const Yr=Wr.resource;if(!Yr)return;const Kr=Math.min(ze.width,Wr.resourceWidth||Wr.pixelWidth),Zr=Math.min(ze.height,Wr.resourceHeight||Wr.pixelHeight),Qr=Wr.alphaMode==="premultiply-alpha-on-upload";Gr.device.queue.copyExternalImageToTexture({source:Yr},{texture:ze,premultipliedAlpha:Qr},{width:Kr,height:Zr})}},gpuUploadVideoResource={type:"video",upload(Wr,ze,Gr){gpuUploadImageResource.upload(Wr,ze,Gr)}};class GpuMipmapGenerator{constructor(ze){this.device=ze,this.sampler=ze.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(ze){let Gr=this.pipelines[ze];return Gr||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})),Gr=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:ze}]}}),this.pipelines[ze]=Gr),Gr}generateMipmap(ze){const Gr=this._getMipmapPipeline(ze.format);if(ze.dimension==="3d"||ze.dimension==="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let Yr=ze;const Kr=ze.depthOrArrayLayers||1,Zr=ze.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!Zr){const ei={size:{width:Math.ceil(ze.width/2),height:Math.ceil(ze.height/2),depthOrArrayLayers:Kr},format:ze.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:ze.mipLevelCount-1};Yr=this.device.createTexture(ei)}const Qr=this.device.createCommandEncoder({}),Jr=Gr.getBindGroupLayout(0);for(let ei=0;ei<Kr;++ei){let ti=ze.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:ei,arrayLayerCount:1}),ri=Zr?1:0;for(let ii=1;ii<ze.mipLevelCount;++ii){const si=Yr.createView({baseMipLevel:ri++,mipLevelCount:1,dimension:"2d",baseArrayLayer:ei,arrayLayerCount:1}),ni=Qr.beginRenderPass({colorAttachments:[{view:si,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),oi=this.device.createBindGroup({layout:Jr,entries:[{binding:0,resource:this.sampler},{binding:1,resource:ti}]});ni.setPipeline(Gr),ni.setBindGroup(0,oi),ni.draw(3,1,0,0),ni.end(),ti=si}}if(!Zr){const ei={width:Math.ceil(ze.width/2),height:Math.ceil(ze.height/2),depthOrArrayLayers:Kr};for(let ti=1;ti<ze.mipLevelCount;++ti)Qr.copyTextureToTexture({texture:Yr,mipLevel:ti-1},{texture:ze,mipLevel:ti},ei),ei.width=Math.ceil(ei.width/2),ei.height=Math.ceil(ei.height/2)}return this.device.queue.submit([Qr.finish()]),Zr||Yr.destroy(),ze}}class GpuTextureSystem{constructor(ze){this.managedTextures=[],this._gpuSources=Object.create(null),this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._textureViewHash=Object.create(null),this._uploads={image:gpuUploadImageResource,buffer:gpuUploadBufferImageResource,video:gpuUploadVideoResource,compressed:gpuUploadCompressedTextureResource},this._renderer=ze,ze.renderableGC.addManagedHash(this,"_gpuSources"),ze.renderableGC.addManagedHash(this,"_gpuSamplers"),ze.renderableGC.addManagedHash(this,"_bindGroupHash"),ze.renderableGC.addManagedHash(this,"_textureViewHash")}contextChange(ze){this._gpu=ze}initSource(ze){if(ze.autoGenerateMipmaps){const ei=Math.max(ze.pixelWidth,ze.pixelHeight);ze.mipLevelCount=Math.floor(Math.log2(ei))+1}let Gr=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;ze.uploadMethodId!=="compressed"&&(Gr|=GPUTextureUsage.RENDER_ATTACHMENT,Gr|=GPUTextureUsage.COPY_SRC);const Yr=blockDataMap[ze.format]||{blockWidth:1,blockHeight:1},Kr=Math.ceil(ze.pixelWidth/Yr.blockWidth)*Yr.blockWidth,Zr=Math.ceil(ze.pixelHeight/Yr.blockHeight)*Yr.blockHeight,Qr={label:ze.label,size:{width:Kr,height:Zr},format:ze.format,sampleCount:ze.sampleCount,mipLevelCount:ze.mipLevelCount,dimension:ze.dimension,usage:Gr},Jr=this._gpu.device.createTexture(Qr);return this._gpuSources[ze.uid]=Jr,this.managedTextures.includes(ze)||(ze.on("update",this.onSourceUpdate,this),ze.on("resize",this.onSourceResize,this),ze.on("destroy",this.onSourceDestroy,this),ze.on("unload",this.onSourceUnload,this),ze.on("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.push(ze)),this.onSourceUpdate(ze),Jr}onSourceUpdate(ze){const Gr=this.getGpuSource(ze);Gr&&(this._uploads[ze.uploadMethodId]&&this._uploads[ze.uploadMethodId].upload(ze,Gr,this._gpu),ze.autoGenerateMipmaps&&ze.mipLevelCount>1&&this.onUpdateMipmaps(ze))}onSourceUnload(ze){const Gr=this._gpuSources[ze.uid];Gr&&(this._gpuSources[ze.uid]=null,Gr.destroy())}onUpdateMipmaps(ze){this._mipmapGenerator||(this._mipmapGenerator=new GpuMipmapGenerator(this._gpu.device));const Gr=this.getGpuSource(ze);this._mipmapGenerator.generateMipmap(Gr)}onSourceDestroy(ze){ze.off("update",this.onSourceUpdate,this),ze.off("unload",this.onSourceUnload,this),ze.off("destroy",this.onSourceDestroy,this),ze.off("resize",this.onSourceResize,this),ze.off("updateMipmaps",this.onUpdateMipmaps,this),this.managedTextures.splice(this.managedTextures.indexOf(ze),1),this.onSourceUnload(ze)}onSourceResize(ze){const Gr=this._gpuSources[ze.uid];Gr?(Gr.width!==ze.pixelWidth||Gr.height!==ze.pixelHeight)&&(this._textureViewHash[ze.uid]=null,this._bindGroupHash[ze.uid]=null,this.onSourceUnload(ze),this.initSource(ze)):this.initSource(ze)}_initSampler(ze){return this._gpuSamplers[ze._resourceId]=this._gpu.device.createSampler(ze),this._gpuSamplers[ze._resourceId]}getGpuSampler(ze){return this._gpuSamplers[ze._resourceId]||this._initSampler(ze)}getGpuSource(ze){return this._gpuSources[ze.uid]||this.initSource(ze)}getTextureBindGroup(ze){return this._bindGroupHash[ze.uid]??this._createTextureBindGroup(ze)}_createTextureBindGroup(ze){const Gr=ze.source;return this._bindGroupHash[ze.uid]=new BindGroup({0:Gr,1:Gr.style,2:new UniformGroup({uTextureMatrix:{type:"mat3x3<f32>",value:ze.textureMatrix.mapCoord}})}),this._bindGroupHash[ze.uid]}getTextureView(ze){const Gr=ze.source;return this._textureViewHash[Gr.uid]??this._createTextureView(Gr)}_createTextureView(ze){return this._textureViewHash[ze.uid]=this.getGpuSource(ze).createView(),this._textureViewHash[ze.uid]}generateCanvas(ze){const Gr=this._renderer,Yr=Gr.gpu.device.createCommandEncoder(),Kr=DOMAdapter.get().createCanvas();Kr.width=ze.source.pixelWidth,Kr.height=ze.source.pixelHeight;const Zr=Kr.getContext("webgpu");return Zr.configure({device:Gr.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),Yr.copyTextureToTexture({texture:Gr.texture.getGpuSource(ze.source),origin:{x:0,y:0}},{texture:Zr.getCurrentTexture()},{width:Kr.width,height:Kr.height}),Gr.gpu.device.queue.submit([Yr.finish()]),Kr}getPixels(ze){const Gr=this.generateCanvas(ze),Yr=CanvasPool.getOptimalCanvasAndContext(Gr.width,Gr.height),Kr=Yr.context;Kr.drawImage(Gr,0,0);const{width:Zr,height:Qr}=Gr,Jr=Kr.getImageData(0,0,Zr,Qr),ei=new Uint8ClampedArray(Jr.data.buffer);return CanvasPool.returnCanvasAndContext(Yr),{pixels:ei,width:Zr,height:Qr}}destroy(){this.managedTextures.slice().forEach(ze=>this.onSourceDestroy(ze)),this.managedTextures=null;for(const ze of Object.keys(this._bindGroupHash)){const Gr=Number(ze),Yr=this._bindGroupHash[Gr];Yr==null||Yr.destroy(),this._bindGroupHash[Gr]=null}this._gpu=null,this._mipmapGenerator=null,this._gpuSources=null,this._bindGroupHash=null,this._textureViewHash=null,this._gpuSamplers=null}}GpuTextureSystem.extension={type:[ExtensionType.WebGPUSystem],name:"texture"};class GpuGraphicsAdaptor{init(){const ze=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),Gr=compileHighShaderGpuProgram({name:"graphics",bits:[colorBit,generateTextureBatchBit(getMaxTexturesPerBatch()),localUniformBitGroup2,roundPixelsBit]});this.shader=new Shader({gpuProgram:Gr,resources:{localUniforms:ze}})}execute(ze,Gr){const Yr=Gr.context,Kr=Yr.customShader||this.shader,Zr=ze.renderer,Qr=Zr.graphicsContext,{batcher:Jr,instructions:ei}=Qr.getContextRenderData(Yr),ti=Zr.encoder;ti.setGeometry(Jr.geometry,Kr.gpuProgram);const ri=Zr.globalUniforms.bindGroup;ti.setBindGroup(0,ri,Kr.gpuProgram);const ii=Zr.renderPipes.uniformBatch.getUniformBindGroup(Kr.resources.localUniforms,!0);ti.setBindGroup(2,ii,Kr.gpuProgram);const si=ei.instructions;let ni=null;for(let oi=0;oi<ei.instructionSize;oi++){const li=si[oi];if(li.topology!==ni&&(ni=li.topology,ti.setPipelineFromGeometryProgramAndState(Jr.geometry,Kr.gpuProgram,ze.state,li.topology)),Kr.groups[1]=li.bindGroup,!li.gpuBindGroup){const ai=li.textures;li.bindGroup=getTextureBatchBindGroup(ai.textures,ai.count),li.gpuBindGroup=Zr.bindGroup.getBindGroup(li.bindGroup,Kr.gpuProgram,1)}ti.setBindGroup(1,li.bindGroup,Kr.gpuProgram),ti.renderPassEncoder.drawIndexed(li.size,1,li.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}GpuGraphicsAdaptor.extension={type:[ExtensionType.WebGPUPipesAdaptor],name:"graphics"};class GpuMeshAdapter{init(){const ze=compileHighShaderGpuProgram({name:"mesh",bits:[localUniformBit,textureBit,roundPixelsBit]});this._shader=new Shader({gpuProgram:ze,resources:{uTexture:Texture.EMPTY._source,uSampler:Texture.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new Matrix}}}})}execute(ze,Gr){const Yr=ze.renderer;let Kr=Gr._shader;if(!Kr)Kr=this._shader,Kr.groups[2]=Yr.texture.getTextureBindGroup(Gr.texture);else if(!Kr.gpuProgram){warn("Mesh shader has no gpuProgram",Gr.shader);return}const Zr=Kr.gpuProgram;if(Zr.autoAssignGlobalUniforms&&(Kr.groups[0]=Yr.globalUniforms.bindGroup),Zr.autoAssignLocalUniforms){const Qr=ze.localUniforms;Kr.groups[1]=Yr.renderPipes.uniformBatch.getUniformBindGroup(Qr,!0)}Yr.encoder.draw({geometry:Gr._geometry,shader:Kr,state:Gr.state})}destroy(){this._shader.destroy(!0),this._shader=null}}GpuMeshAdapter.extension={type:[ExtensionType.WebGPUPipesAdaptor],name:"mesh"};const DefaultWebGPUSystems=[...SharedSystems,GpuUboSystem,GpuEncoderSystem,GpuDeviceSystem,GpuBufferSystem,GpuTextureSystem,GpuRenderTargetSystem,GpuShaderSystem,GpuStateSystem,PipelineSystem,GpuColorMaskSystem,GpuStencilSystem,BindGroupSystem],DefaultWebGPUPipes=[...SharedRenderPipes,GpuUniformBatchPipe],DefaultWebGPUAdapters=[GpuBatchAdaptor,GpuMeshAdapter,GpuGraphicsAdaptor],systems=[],renderPipes=[],renderPipeAdaptors=[];extensions.handleByNamedList(ExtensionType.WebGPUSystem,systems);extensions.handleByNamedList(ExtensionType.WebGPUPipes,renderPipes);extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor,renderPipeAdaptors);extensions.add(...DefaultWebGPUSystems,...DefaultWebGPUPipes,...DefaultWebGPUAdapters);class WebGPURenderer extends AbstractRenderer{constructor(){const ze={name:"webgpu",type:RendererType.WEBGPU,systems,renderPipes,renderPipeAdaptors};super(ze)}}const WebGPURenderer$1=Object.freeze(Object.defineProperty({__proto__:null,WebGPURenderer},Symbol.toStringTag,{value:"Module"}));class GraphicsPipe{constructor(ze,Gr){this.state=State.for2d(),this._graphicsBatchesHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=ze,this._adaptor=Gr,this._adaptor.init(),this.renderer.renderableGC.addManagedHash(this,"_graphicsBatchesHash")}validateRenderable(ze){const Gr=ze.context,Yr=!!this._graphicsBatchesHash[ze.uid],Kr=this.renderer.graphicsContext.updateGpuContext(Gr);return!!(Kr.isBatchable||Yr!==Kr.isBatchable)}addRenderable(ze,Gr){const Yr=this.renderer.graphicsContext.updateGpuContext(ze.context);ze.didViewUpdate&&this._rebuild(ze),Yr.isBatchable?this._addToBatcher(ze,Gr):(this.renderer.renderPipes.batch.break(Gr),Gr.add(ze))}updateRenderable(ze){const Gr=this._graphicsBatchesHash[ze.uid];if(Gr)for(let Yr=0;Yr<Gr.length;Yr++){const Kr=Gr[Yr];Kr._batcher.updateElement(Kr)}}destroyRenderable(ze){this._graphicsBatchesHash[ze.uid]&&this._removeBatchForRenderable(ze.uid),ze.off("destroyed",this._destroyRenderableBound)}execute(ze){if(!ze.isRenderable)return;const Gr=this.renderer,Yr=ze.context;if(!Gr.graphicsContext.getGpuContext(Yr).batches.length)return;const Zr=Yr.customShader||this._adaptor.shader;this.state.blendMode=ze.groupBlendMode;const Qr=Zr.resources.localUniforms.uniforms;Qr.uTransformMatrix=ze.groupTransform,Qr.uRound=Gr._roundPixels|ze._roundPixels,color32BitToUniform(ze.groupColorAlpha,Qr.uColor,0),this._adaptor.execute(this,ze)}_rebuild(ze){const Gr=!!this._graphicsBatchesHash[ze.uid],Yr=this.renderer.graphicsContext.updateGpuContext(ze.context);Gr&&this._removeBatchForRenderable(ze.uid),Yr.isBatchable&&this._initBatchesForRenderable(ze),ze.batched=Yr.isBatchable}_addToBatcher(ze,Gr){const Yr=this.renderer.renderPipes.batch,Kr=this._getBatchesForRenderable(ze);for(let Zr=0;Zr<Kr.length;Zr++){const Qr=Kr[Zr];Yr.addToBatch(Qr,Gr)}}_getBatchesForRenderable(ze){return this._graphicsBatchesHash[ze.uid]||this._initBatchesForRenderable(ze)}_initBatchesForRenderable(ze){const Gr=ze.context,Yr=this.renderer.graphicsContext.getGpuContext(Gr),Kr=this.renderer._roundPixels|ze._roundPixels,Zr=Yr.batches.map(Qr=>{const Jr=BigPool.get(BatchableGraphics);return Qr.copyTo(Jr),Jr.renderable=ze,Jr.roundPixels=Kr,Jr});return this._graphicsBatchesHash[ze.uid]===void 0&&ze.on("destroyed",this._destroyRenderableBound),this._graphicsBatchesHash[ze.uid]=Zr,Zr}_removeBatchForRenderable(ze){this._graphicsBatchesHash[ze].forEach(Gr=>{BigPool.return(Gr)}),this._graphicsBatchesHash[ze]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const ze in this._graphicsBatchesHash)this._removeBatchForRenderable(ze);this._graphicsBatchesHash=null}}GraphicsPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"graphics"};const _PlaneGeometry=class Ns extends MeshGeometry{constructor(...ze){super({});let Gr=ze[0]??{};typeof Gr=="number"&&(deprecation(v8_0_0,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),Gr={width:Gr,height:ze[1],verticesX:ze[2],verticesY:ze[3]}),this.build(Gr)}build(ze){ze={...Ns.defaultOptions,...ze},this.verticesX=this.verticesX??ze.verticesX,this.verticesY=this.verticesY??ze.verticesY,this.width=this.width??ze.width,this.height=this.height??ze.height;const Gr=this.verticesX*this.verticesY,Yr=[],Kr=[],Zr=[],Qr=this.verticesX-1,Jr=this.verticesY-1,ei=this.width/Qr,ti=this.height/Jr;for(let ii=0;ii<Gr;ii++){const si=ii%this.verticesX,ni=ii/this.verticesX|0;Yr.push(si*ei,ni*ti),Kr.push(si/Qr,ni/Jr)}const ri=Qr*Jr;for(let ii=0;ii<ri;ii++){const si=ii%Qr,ni=ii/Qr|0,oi=ni*this.verticesX+si,li=ni*this.verticesX+si+1,ai=(ni+1)*this.verticesX+si,ui=(ni+1)*this.verticesX+si+1;Zr.push(oi,li,ai,li,ui,ai)}this.buffers[0].data=new Float32Array(Yr),this.buffers[1].data=new Float32Array(Kr),this.indexBuffer.data=new Uint32Array(Zr),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};_PlaneGeometry.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let PlaneGeometry=_PlaneGeometry;class BatchableMesh{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(ze){this._topology=ze}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(ze){this.texture!==ze&&(this.texture=ze,this._textureMatrixUpdateId=-1)}get uvs(){const Gr=this.geometry.getBuffer("aUV"),Yr=Gr.data;let Kr=Yr;const Zr=this.texture.textureMatrix;return Zr.isSimple||(Kr=this._transformedUvs,(this._textureMatrixUpdateId!==Zr._updateID||this._uvUpdateId!==Gr._updateID)&&((!Kr||Kr.length<Yr.length)&&(Kr=this._transformedUvs=new Float32Array(Yr.length)),this._textureMatrixUpdateId=Zr._updateID,this._uvUpdateId=Gr._updateID,Zr.multiplyUvs(Yr,Kr))),Kr}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}class MeshPipe{constructor(ze,Gr){this.localUniforms=new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new BindGroup({0:this.localUniforms}),this._meshDataHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.renderer=ze,this._adaptor=Gr,this._adaptor.init(),ze.renderableGC.addManagedHash(this,"_gpuBatchableMeshHash"),ze.renderableGC.addManagedHash(this,"_meshDataHash")}validateRenderable(ze){const Gr=this._getMeshData(ze),Yr=Gr.batched,Kr=ze.batched;if(Gr.batched=Kr,Yr!==Kr)return!0;if(Kr){const Zr=ze._geometry;if(Zr.indices.length!==Gr.indexSize||Zr.positions.length!==Gr.vertexSize)return Gr.indexSize=Zr.indices.length,Gr.vertexSize=Zr.positions.length,!0;const Qr=this._getBatchableMesh(ze);return Qr.texture.uid!==ze._texture.uid&&(Qr._textureMatrixUpdateId=-1),!Qr._batcher.checkAndUpdateTexture(Qr,ze._texture)}return!1}addRenderable(ze,Gr){const Yr=this.renderer.renderPipes.batch,{batched:Kr}=this._getMeshData(ze);if(Kr){const Zr=this._getBatchableMesh(ze);Zr.setTexture(ze._texture),Zr.geometry=ze._geometry,Yr.addToBatch(Zr,Gr)}else Yr.break(Gr),Gr.add(ze)}updateRenderable(ze){if(ze.batched){const Gr=this._gpuBatchableMeshHash[ze.uid];Gr.setTexture(ze._texture),Gr.geometry=ze._geometry,Gr._batcher.updateElement(Gr)}}destroyRenderable(ze){this._meshDataHash[ze.uid]=null;const Gr=this._gpuBatchableMeshHash[ze.uid];Gr&&(BigPool.return(Gr),this._gpuBatchableMeshHash[ze.uid]=null),ze.off("destroyed",this._destroyRenderableBound)}execute(ze){if(!ze.isRenderable)return;ze.state.blendMode=getAdjustedBlendModeBlend(ze.groupBlendMode,ze.texture._source);const Gr=this.localUniforms;Gr.uniforms.uTransformMatrix=ze.groupTransform,Gr.uniforms.uRound=this.renderer._roundPixels|ze._roundPixels,Gr.update(),color32BitToUniform(ze.groupColorAlpha,Gr.uniforms.uColor,0),this._adaptor.execute(this,ze)}_getMeshData(ze){return this._meshDataHash[ze.uid]||this._initMeshData(ze)}_initMeshData(ze){var Gr,Yr;return this._meshDataHash[ze.uid]={batched:ze.batched,indexSize:(Gr=ze._geometry.indices)==null?void 0:Gr.length,vertexSize:(Yr=ze._geometry.positions)==null?void 0:Yr.length},ze.on("destroyed",this._destroyRenderableBound),this._meshDataHash[ze.uid]}_getBatchableMesh(ze){return this._gpuBatchableMeshHash[ze.uid]||this._initBatchableMesh(ze)}_initBatchableMesh(ze){const Gr=BigPool.get(BatchableMesh);return Gr.renderable=ze,Gr.setTexture(ze._texture),Gr.transform=ze.groupTransform,Gr.roundPixels=this.renderer._roundPixels|ze._roundPixels,this._gpuBatchableMeshHash[ze.uid]=Gr,Gr}destroy(){for(const ze in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[ze]&&BigPool.return(this._gpuBatchableMeshHash[ze]);this._gpuBatchableMeshHash=null,this._meshDataHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}MeshPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"mesh"};class GlParticleContainerAdaptor{execute(ze,Gr){const Yr=ze.state,Kr=ze.renderer,Zr=Gr.shader||ze.defaultShader;Zr.resources.uTexture=Gr.texture._source,Zr.resources.uniforms=ze.localUniforms;const Qr=Kr.gl,Jr=ze.getBuffers(Gr);Kr.shader.bind(Zr),Kr.state.set(Yr),Kr.geometry.bind(Jr.geometry,Zr.glProgram);const ti=Jr.geometry.indexBuffer.data.BYTES_PER_ELEMENT===2?Qr.UNSIGNED_SHORT:Qr.UNSIGNED_INT;Qr.drawElements(Qr.TRIANGLES,Gr.particleChildren.length*6,ti,0)}}class GpuParticleContainerAdaptor{execute(ze,Gr){const Yr=ze.renderer,Kr=Gr.shader||ze.defaultShader;Kr.groups[0]=Yr.renderPipes.uniformBatch.getUniformBindGroup(ze.localUniforms,!0),Kr.groups[1]=Yr.texture.getTextureBindGroup(Gr.texture);const Zr=ze.state,Qr=ze.getBuffers(Gr);Yr.encoder.draw({geometry:Qr.geometry,shader:Gr.shader||ze.defaultShader,state:Zr,size:Gr.particleChildren.length*6})}}function createIndicesForQuads(Wr,ze=null){const Gr=Wr*6;if(Gr>65535?ze||(ze=new Uint32Array(Gr)):ze||(ze=new Uint16Array(Gr)),ze.length!==Gr)throw new Error(`Out buffer length is incorrect, got ${ze.length} and expected ${Gr}`);for(let Yr=0,Kr=0;Yr<Gr;Yr+=6,Kr+=4)ze[Yr+0]=Kr+0,ze[Yr+1]=Kr+1,ze[Yr+2]=Kr+2,ze[Yr+3]=Kr+0,ze[Yr+4]=Kr+2,ze[Yr+5]=Kr+3;return ze}function generateParticleUpdateFunction(Wr){return{dynamicUpdate:generateUpdateFunction(Wr,!0),staticUpdate:generateUpdateFunction(Wr,!1)}}function generateUpdateFunction(Wr,ze){const Gr=[];Gr.push(`
      
        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);let Yr=0;for(const Zr in Wr){const Qr=Wr[Zr];if(ze!==Qr.dynamic)continue;Gr.push(`offset = index + ${Yr}`),Gr.push(Qr.code);const Jr=getAttributeInfoFromFormat(Qr.format);Yr+=Jr.stride/4}Gr.push(`
            index += stride * 4;
        }
    `),Gr.unshift(`
        var stride = ${Yr};
    `);const Kr=Gr.join(`
`);return new Function("ps","f32v","u32v",Kr)}class ParticleBuffer{constructor(ze){this._size=0,this._generateParticleUpdateCache={};const Gr=this._size=ze.size??1e3,Yr=ze.properties;let Kr=0,Zr=0;for(const ri in Yr){const ii=Yr[ri],si=getAttributeInfoFromFormat(ii.format);ii.dynamic?Zr+=si.stride:Kr+=si.stride}this._dynamicStride=Zr/4,this._staticStride=Kr/4,this.staticAttributeBuffer=new ViewableBuffer(Gr*4*Kr),this.dynamicAttributeBuffer=new ViewableBuffer(Gr*4*Zr),this.indexBuffer=createIndicesForQuads(Gr);const Qr=new Geometry;let Jr=0,ei=0;this._staticBuffer=new Buffer({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST}),this._dynamicBuffer=new Buffer({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:BufferUsage.VERTEX|BufferUsage.COPY_DST});for(const ri in Yr){const ii=Yr[ri],si=getAttributeInfoFromFormat(ii.format);ii.dynamic?(Qr.addAttribute(ii.attributeName,{buffer:this._dynamicBuffer,stride:this._dynamicStride*4,offset:Jr*4,format:ii.format}),Jr+=si.size):(Qr.addAttribute(ii.attributeName,{buffer:this._staticBuffer,stride:this._staticStride*4,offset:ei*4,format:ii.format}),ei+=si.size)}Qr.addIndex(this.indexBuffer);const ti=this.getParticleUpdate(Yr);this._dynamicUpload=ti.dynamicUpdate,this._staticUpload=ti.staticUpdate,this.geometry=Qr}getParticleUpdate(ze){const Gr=getParticleSyncKey(ze);return this._generateParticleUpdateCache[Gr]?this._generateParticleUpdateCache[Gr]:(this._generateParticleUpdateCache[Gr]=this.generateParticleUpdate(ze),this._generateParticleUpdateCache[Gr])}generateParticleUpdate(ze){return generateParticleUpdateFunction(ze)}update(ze,Gr){ze.length>this._size&&(Gr=!0,this._size=Math.max(ze.length,this._size*1.5|0),this.staticAttributeBuffer=new ViewableBuffer(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new ViewableBuffer(this._size*this._dynamicStride*4*4),this.indexBuffer=createIndicesForQuads(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const Yr=this.dynamicAttributeBuffer;if(this._dynamicUpload(ze,Yr.float32View,Yr.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,ze.length*this._dynamicStride*4,!0),Gr){const Kr=this.staticAttributeBuffer;this._staticUpload(ze,Kr.float32View,Kr.uint32View),this._staticBuffer.setDataWithSize(Kr.float32View,ze.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}function getParticleSyncKey(Wr){const ze=[];for(const Gr in Wr){const Yr=Wr[Gr];ze.push(Gr,Yr.code,Yr.dynamic?"d":"s")}return ze.join("_")}var fragment=`varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,vertex=`attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,wgsl=`
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;class ParticleShader extends Shader{constructor(){const ze=GlProgram.from({vertex,fragment}),Gr=GpuProgram.from({fragment:{source:wgsl,entryPoint:"mainFragment"},vertex:{source:wgsl,entryPoint:"mainVertex"}});super({glProgram:ze,gpuProgram:Gr,resources:{uTexture:Texture.WHITE.source,uSampler:new TextureStyle({}),uniforms:{uTranslationMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Color(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class ParticleContainerPipe{constructor(ze,Gr){this.state=State.for2d(),this._gpuBufferHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this.localUniforms=new UniformGroup({uTranslationMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=ze,this.adaptor=Gr,this.defaultShader=new ParticleShader,this.state=State.for2d()}validateRenderable(ze){return!1}addRenderable(ze,Gr){this.renderer.renderPipes.batch.break(Gr),Gr.add(ze)}getBuffers(ze){return this._gpuBufferHash[ze.uid]||this._initBuffer(ze)}_initBuffer(ze){return this._gpuBufferHash[ze.uid]=new ParticleBuffer({size:ze.particleChildren.length,properties:ze._properties}),ze.on("destroyed",this._destroyRenderableBound),this._gpuBufferHash[ze.uid]}updateRenderable(ze){}destroyRenderable(ze){this._gpuBufferHash[ze.uid].destroy(),this._gpuBufferHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}execute(ze){const Gr=ze.particleChildren;if(Gr.length===0)return;const Yr=this.renderer,Kr=this.getBuffers(ze);ze.texture||(ze.texture=Gr[0].texture);const Zr=this.state;Kr.update(Gr,ze._childrenDirty),ze._childrenDirty=!1,Zr.blendMode=getAdjustedBlendModeBlend(ze.blendMode,ze.texture._source);const Qr=this.localUniforms.uniforms,Jr=Qr.uTranslationMatrix;ze.worldTransform.copyTo(Jr),Jr.prepend(Yr.globalUniforms.globalUniformData.projectionMatrix),Qr.uResolution=Yr.globalUniforms.globalUniformData.resolution,Qr.uRound=Yr._roundPixels|ze._roundPixels,color32BitToUniform(ze.groupColorAlpha,Qr.uColor,0),this.adaptor.execute(this,ze)}destroy(){this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class GlParticleContainerPipe extends ParticleContainerPipe{constructor(ze){super(ze,new GlParticleContainerAdaptor)}}GlParticleContainerPipe.extension={type:[ExtensionType.WebGLPipes],name:"particle"};class GpuParticleContainerPipe extends ParticleContainerPipe{constructor(ze){super(ze,new GpuParticleContainerAdaptor)}}GpuParticleContainerPipe.extension={type:[ExtensionType.WebGPUPipes],name:"particle"};const _NineSliceGeometry=class Hs extends PlaneGeometry{constructor(ze={}){ze={...Hs.defaultOptions,...ze},super({width:ze.width,height:ze.height,verticesX:4,verticesY:4}),this.update(ze)}update(ze){var Gr,Yr;this.width=ze.width??this.width,this.height=ze.height??this.height,this._originalWidth=ze.originalWidth??this._originalWidth,this._originalHeight=ze.originalHeight??this._originalHeight,this._leftWidth=ze.leftWidth??this._leftWidth,this._rightWidth=ze.rightWidth??this._rightWidth,this._topHeight=ze.topHeight??this._topHeight,this._bottomHeight=ze.bottomHeight??this._bottomHeight,this._anchorX=(Gr=ze.anchor)==null?void 0:Gr.x,this._anchorY=(Yr=ze.anchor)==null?void 0:Yr.y,this.updateUvs(),this.updatePositions()}updatePositions(){const ze=this.positions,{width:Gr,height:Yr,_leftWidth:Kr,_rightWidth:Zr,_topHeight:Qr,_bottomHeight:Jr,_anchorX:ei,_anchorY:ti}=this,ri=Kr+Zr,ii=Gr>ri?1:Gr/ri,si=Qr+Jr,ni=Yr>si?1:Yr/si,oi=Math.min(ii,ni),li=ei*Gr,ai=ti*Yr;ze[0]=ze[8]=ze[16]=ze[24]=-li,ze[2]=ze[10]=ze[18]=ze[26]=Kr*oi-li,ze[4]=ze[12]=ze[20]=ze[28]=Gr-Zr*oi-li,ze[6]=ze[14]=ze[22]=ze[30]=Gr-li,ze[1]=ze[3]=ze[5]=ze[7]=-ai,ze[9]=ze[11]=ze[13]=ze[15]=Qr*oi-ai,ze[17]=ze[19]=ze[21]=ze[23]=Yr-Jr*oi-ai,ze[25]=ze[27]=ze[29]=ze[31]=Yr-ai,this.getBuffer("aPosition").update()}updateUvs(){const ze=this.uvs;ze[0]=ze[8]=ze[16]=ze[24]=0,ze[1]=ze[3]=ze[5]=ze[7]=0,ze[6]=ze[14]=ze[22]=ze[30]=1,ze[25]=ze[27]=ze[29]=ze[31]=1;const Gr=1/this._originalWidth,Yr=1/this._originalHeight;ze[2]=ze[10]=ze[18]=ze[26]=Gr*this._leftWidth,ze[9]=ze[11]=ze[13]=ze[15]=Yr*this._topHeight,ze[4]=ze[12]=ze[20]=ze[28]=1-Gr*this._rightWidth,ze[17]=ze[19]=ze[21]=ze[23]=1-Yr*this._bottomHeight,this.getBuffer("aUV").update()}};_NineSliceGeometry.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let NineSliceGeometry=_NineSliceGeometry;class NineSliceSpritePipe{constructor(ze){this._gpuSpriteHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuSpriteHash")}addRenderable(ze,Gr){const Yr=this._getGpuSprite(ze);ze.didViewUpdate&&this._updateBatchableSprite(ze,Yr),this._renderer.renderPipes.batch.addToBatch(Yr,Gr)}updateRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];ze.didViewUpdate&&this._updateBatchableSprite(ze,Gr),Gr._batcher.updateElement(Gr)}validateRenderable(ze){const Gr=this._getGpuSprite(ze);return!Gr._batcher.checkAndUpdateTexture(Gr,ze._texture)}destroyRenderable(ze){const Gr=this._gpuSpriteHash[ze.uid];BigPool.return(Gr.geometry),BigPool.return(Gr),this._gpuSpriteHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}_updateBatchableSprite(ze,Gr){Gr.geometry.update(ze),Gr.setTexture(ze._texture)}_getGpuSprite(ze){return this._gpuSpriteHash[ze.uid]||this._initGPUSprite(ze)}_initGPUSprite(ze){const Gr=BigPool.get(BatchableMesh);return Gr.geometry=BigPool.get(NineSliceGeometry),Gr.renderable=ze,Gr.transform=ze.groupTransform,Gr.texture=ze._texture,Gr.roundPixels=this._renderer._roundPixels|ze._roundPixels,this._gpuSpriteHash[ze.uid]=Gr,ze.didViewUpdate||this._updateBatchableSprite(ze,Gr),ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuSpriteHash)this._gpuSpriteHash[ze].geometry.destroy();this._gpuSpriteHash=null,this._renderer=null}}NineSliceSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"nineSliceSprite"};const tilingBit={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},tilingBitGl={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `}};let gpuProgram$1,glProgram$1;class TilingSpriteShader extends Shader{constructor(){gpuProgram$1??(gpuProgram$1=compileHighShaderGpuProgram({name:"tiling-sprite-shader",bits:[localUniformBit,tilingBit,roundPixelsBit]})),glProgram$1??(glProgram$1=compileHighShaderGlProgram({name:"tiling-sprite-shader",bits:[localUniformBitGl,tilingBitGl,roundPixelsBitGl]}));const ze=new UniformGroup({uMapCoord:{value:new Matrix,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new Matrix,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:glProgram$1,gpuProgram:gpuProgram$1,resources:{localUniforms:new UniformGroup({uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:ze,uTexture:Texture.EMPTY.source,uSampler:Texture.EMPTY.source.style}})}updateUniforms(ze,Gr,Yr,Kr,Zr,Qr){const Jr=this.resources.tilingUniforms,ei=Qr.width,ti=Qr.height,ri=Qr.textureMatrix,ii=Jr.uniforms.uTextureTransform;ii.set(Yr.a*ei/ze,Yr.b*ei/Gr,Yr.c*ti/ze,Yr.d*ti/Gr,Yr.tx/ze,Yr.ty/Gr),ii.invert(),Jr.uniforms.uMapCoord=ri.mapCoord,Jr.uniforms.uClampFrame=ri.uClampFrame,Jr.uniforms.uClampOffset=ri.uClampOffset,Jr.uniforms.uTextureTransform=ii,Jr.uniforms.uSizeAnchor[0]=ze,Jr.uniforms.uSizeAnchor[1]=Gr,Jr.uniforms.uSizeAnchor[2]=Kr,Jr.uniforms.uSizeAnchor[3]=Zr,Qr&&(this.resources.uTexture=Qr.source,this.resources.uSampler=Qr.source.style)}}class QuadGeometry extends MeshGeometry{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}function setPositions(Wr,ze){const Gr=Wr.anchor.x,Yr=Wr.anchor.y;ze[0]=-Gr*Wr.width,ze[1]=-Yr*Wr.height,ze[2]=(1-Gr)*Wr.width,ze[3]=-Yr*Wr.height,ze[4]=(1-Gr)*Wr.width,ze[5]=(1-Yr)*Wr.height,ze[6]=-Gr*Wr.width,ze[7]=(1-Yr)*Wr.height}function applyMatrix(Wr,ze,Gr,Yr){let Kr=0;const Zr=Wr.length/ze,Qr=Yr.a,Jr=Yr.b,ei=Yr.c,ti=Yr.d,ri=Yr.tx,ii=Yr.ty;for(Gr*=ze;Kr<Zr;){const si=Wr[Gr],ni=Wr[Gr+1];Wr[Gr]=Qr*si+ei*ni+ri,Wr[Gr+1]=Jr*si+ti*ni+ii,Gr+=ze,Kr++}}function setUvs(Wr,ze){const Gr=Wr.texture,Yr=Gr.frame.width,Kr=Gr.frame.height;let Zr=0,Qr=0;Wr.applyAnchorToTexture&&(Zr=Wr.anchor.x,Qr=Wr.anchor.y),ze[0]=ze[6]=-Zr,ze[2]=ze[4]=1-Zr,ze[1]=ze[3]=-Qr,ze[5]=ze[7]=1-Qr;const Jr=Matrix.shared;Jr.copyFrom(Wr._tileTransform.matrix),Jr.tx/=Wr.width,Jr.ty/=Wr.height,Jr.invert(),Jr.scale(Wr.width/Yr,Wr.height/Kr),applyMatrix(ze,2,0,Jr)}const sharedQuad=new QuadGeometry;class TilingSpritePipe{constructor(ze){this._state=State.default2d,this._tilingSpriteDataHash=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_tilingSpriteDataHash")}validateRenderable(ze){const Gr=this._getTilingSpriteData(ze),Yr=Gr.canBatch;this._updateCanBatch(ze);const Kr=Gr.canBatch;if(Kr&&Kr===Yr){const{batchableMesh:Zr}=Gr;return!Zr._batcher.checkAndUpdateTexture(Zr,ze.texture)}return Yr!==Kr}addRenderable(ze,Gr){const Yr=this._renderer.renderPipes.batch;this._updateCanBatch(ze);const Kr=this._getTilingSpriteData(ze),{geometry:Zr,canBatch:Qr}=Kr;if(Qr){Kr.batchableMesh||(Kr.batchableMesh=new BatchableMesh);const Jr=Kr.batchableMesh;ze.didViewUpdate&&(this._updateBatchableMesh(ze),Jr.geometry=Zr,Jr.renderable=ze,Jr.transform=ze.groupTransform,Jr.setTexture(ze._texture)),Jr.roundPixels=this._renderer._roundPixels|ze._roundPixels,Yr.addToBatch(Jr,Gr)}else Yr.break(Gr),Kr.shader||(Kr.shader=new TilingSpriteShader),this.updateRenderable(ze),Gr.add(ze)}execute(ze){const{shader:Gr}=this._tilingSpriteDataHash[ze.uid];Gr.groups[0]=this._renderer.globalUniforms.bindGroup;const Yr=Gr.resources.localUniforms.uniforms;Yr.uTransformMatrix=ze.groupTransform,Yr.uRound=this._renderer._roundPixels|ze._roundPixels,color32BitToUniform(ze.groupColorAlpha,Yr.uColor,0),this._state.blendMode=getAdjustedBlendModeBlend(ze.groupBlendMode,ze.texture._source),this._renderer.encoder.draw({geometry:sharedQuad,shader:Gr,state:this._state})}updateRenderable(ze){const Gr=this._getTilingSpriteData(ze),{canBatch:Yr}=Gr;if(Yr){const{batchableMesh:Kr}=Gr;ze.didViewUpdate&&this._updateBatchableMesh(ze),Kr._batcher.updateElement(Kr)}else if(ze.didViewUpdate){const{shader:Kr}=Gr;Kr.updateUniforms(ze.width,ze.height,ze._tileTransform.matrix,ze.anchor.x,ze.anchor.y,ze.texture)}}destroyRenderable(ze){var Yr;const Gr=this._getTilingSpriteData(ze);Gr.batchableMesh=null,(Yr=Gr.shader)==null||Yr.destroy(),this._tilingSpriteDataHash[ze.uid]=null,ze.off("destroyed",this._destroyRenderableBound)}_getTilingSpriteData(ze){return this._tilingSpriteDataHash[ze.uid]||this._initTilingSpriteData(ze)}_initTilingSpriteData(ze){const Gr=new MeshGeometry({indices:sharedQuad.indices,positions:sharedQuad.positions.slice(),uvs:sharedQuad.uvs.slice()});return this._tilingSpriteDataHash[ze.uid]={canBatch:!0,renderable:ze,geometry:Gr},ze.on("destroyed",this._destroyRenderableBound),this._tilingSpriteDataHash[ze.uid]}_updateBatchableMesh(ze){const Gr=this._getTilingSpriteData(ze),{geometry:Yr}=Gr,Kr=ze.texture.source.style;Kr.addressMode!=="repeat"&&(Kr.addressMode="repeat",Kr.update()),setUvs(ze,Yr.uvs),setPositions(ze,Yr.positions)}destroy(){for(const ze in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[ze].renderable);this._tilingSpriteDataHash=null,this._renderer=null}_updateCanBatch(ze){const Gr=this._getTilingSpriteData(ze),Yr=ze.texture;let Kr=!0;return this._renderer.type===RendererType.WEBGL&&(Kr=this._renderer.context.supports.nonPowOf2wrapping),Gr.canBatch=Yr.textureMatrix.isSimple&&(Kr||Yr.source.isPowerOfTwo),Gr.canBatch}}TilingSpritePipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"tilingSprite"};const localUniformMSDFBit={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `}},localUniformMSDFBitGl={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `}},mSDFBit={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `}},mSDFBitGl={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `}};let gpuProgram,glProgram;class SdfShader extends Shader{constructor(){const ze=new UniformGroup({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new Matrix,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),Gr=getMaxTexturesPerBatch();gpuProgram??(gpuProgram=compileHighShaderGpuProgram({name:"sdf-shader",bits:[colorBit,generateTextureBatchBit(Gr),localUniformMSDFBit,mSDFBit,roundPixelsBit]})),glProgram??(glProgram=compileHighShaderGlProgram({name:"sdf-shader",bits:[colorBitGl,generateTextureBatchBitGl(Gr),localUniformMSDFBitGl,mSDFBitGl,roundPixelsBitGl]})),super({glProgram,gpuProgram,resources:{localUniforms:ze,batchSamplers:getBatchSamplersUniformGroup(Gr)}})}}class BitmapTextPipe{constructor(ze){this._gpuBitmapText={},this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.renderableGC.addManagedHash(this,"_gpuBitmapText")}validateRenderable(ze){const Gr=this._getGpuBitmapText(ze);return ze._didTextUpdate&&(ze._didTextUpdate=!1,this._updateContext(ze,Gr)),this._renderer.renderPipes.graphics.validateRenderable(Gr)}addRenderable(ze,Gr){const Yr=this._getGpuBitmapText(ze);syncWithProxy(ze,Yr),ze._didTextUpdate&&(ze._didTextUpdate=!1,this._updateContext(ze,Yr)),this._renderer.renderPipes.graphics.addRenderable(Yr,Gr),Yr.context.customShader&&this._updateDistanceField(ze)}destroyRenderable(ze){ze.off("destroyed",this._destroyRenderableBound),this._destroyRenderableByUid(ze.uid)}_destroyRenderableByUid(ze){const Gr=this._gpuBitmapText[ze].context;Gr.customShader&&(BigPool.return(Gr.customShader),Gr.customShader=null),BigPool.return(this._gpuBitmapText[ze]),this._gpuBitmapText[ze]=null}updateRenderable(ze){const Gr=this._getGpuBitmapText(ze);syncWithProxy(ze,Gr),this._renderer.renderPipes.graphics.updateRenderable(Gr),Gr.context.customShader&&this._updateDistanceField(ze)}_updateContext(ze,Gr){const{context:Yr}=Gr,Kr=BitmapFontManager.getFont(ze.text,ze._style);Yr.clear(),Kr.distanceField.type!=="none"&&(Yr.customShader||(Yr.customShader=BigPool.get(SdfShader)));const Zr=Array.from(ze.text),Qr=ze._style;let Jr=Kr.baseLineOffset;const ei=getBitmapTextLayout(Zr,Qr,Kr,!0);let ti=0;const ri=Qr.padding,ii=ei.scale;let si=ei.width,ni=ei.height+ei.offsetY;Qr._stroke&&(si+=Qr._stroke.width/ii,ni+=Qr._stroke.width/ii),Yr.translate(-ze._anchor._x*si-ri,-ze._anchor._y*ni-ri).scale(ii,ii);const oi=Kr.applyFillAsTint?Qr._fill.color:16777215;for(let li=0;li<ei.lines.length;li++){const ai=ei.lines[li];for(let ui=0;ui<ai.charPositions.length;ui++){const fi=Zr[ti++],pi=Kr.chars[fi];pi!=null&&pi.texture&&Yr.texture(pi.texture,oi||"black",Math.round(ai.charPositions[ui]+pi.xOffset),Math.round(Jr+pi.yOffset))}Jr+=Kr.lineHeight}}_getGpuBitmapText(ze){return this._gpuBitmapText[ze.uid]||this.initGpuText(ze)}initGpuText(ze){const Gr=BigPool.get(Graphics);return this._gpuBitmapText[ze.uid]=Gr,this._updateContext(ze,Gr),ze.on("destroyed",this._destroyRenderableBound),this._gpuBitmapText[ze.uid]}_updateDistanceField(ze){const Gr=this._getGpuBitmapText(ze).context,Yr=ze._style.fontFamily,Kr=Cache.get(`${Yr}-bitmap`),{a:Zr,b:Qr,c:Jr,d:ei}=ze.groupTransform,ti=Math.sqrt(Zr*Zr+Qr*Qr),ri=Math.sqrt(Jr*Jr+ei*ei),ii=(Math.abs(ti)+Math.abs(ri))/2,si=Kr.baseRenderedFontSize/ze._style.fontSize,ni=ii*Kr.distanceField.range*(1/si);Gr.customShader.resources.localUniforms.uniforms.uDistance=ni}destroy(){for(const ze in this._gpuBitmapText)this._destroyRenderableByUid(ze);this._gpuBitmapText=null,this._renderer=null}}BitmapTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"bitmapText"};function syncWithProxy(Wr,ze){ze.groupTransform=Wr.groupTransform,ze.groupColorAlpha=Wr.groupColorAlpha,ze.groupColor=Wr.groupColor,ze.groupBlendMode=Wr.groupBlendMode,ze.globalDisplayStatus=Wr.globalDisplayStatus,ze.groupTransform=Wr.groupTransform,ze.localDisplayStatus=Wr.localDisplayStatus,ze.groupAlpha=Wr.groupAlpha,ze._roundPixels=Wr._roundPixels}function updateTextBounds(Wr,ze){const{texture:Gr,bounds:Yr}=Wr;updateQuadBounds(Yr,ze._anchor,Gr);const Kr=ze._style.padding;Yr.minX-=Kr,Yr.minY-=Kr,Yr.maxX-=Kr,Yr.maxY-=Kr}class HTMLTextPipe{constructor(ze){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.runners.resolutionChange.add(this),this._renderer.renderableGC.addManagedHash(this,"_gpuText")}resolutionChange(){for(const ze in this._gpuText){const Gr=this._gpuText[ze];if(!Gr)continue;const Yr=Gr.batchableSprite.renderable;Yr._autoResolution&&(Yr._resolution=this._renderer.resolution,Yr.onViewUpdate())}}validateRenderable(ze){const Gr=this._getGpuText(ze),Yr=ze._getKey();return Gr.textureNeedsUploading?(Gr.textureNeedsUploading=!1,!0):Gr.currentKey!==Yr}addRenderable(ze,Gr){const Kr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),this._renderer.renderPipes.batch.addToBatch(Kr,Gr)}updateRenderable(ze){const Yr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),Yr._batcher.updateElement(Yr)}destroyRenderable(ze){ze.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(ze.uid)}_destroyRenderableById(ze){const Gr=this._gpuText[ze];this._renderer.htmlText.decreaseReferenceCount(Gr.currentKey),BigPool.return(Gr.batchableSprite),this._gpuText[ze]=null}_updateText(ze){const Gr=ze._getKey(),Yr=this._getGpuText(ze),Kr=Yr.batchableSprite;Yr.currentKey!==Gr&&this._updateGpuText(ze).catch(Zr=>{console.error(Zr)}),ze._didTextUpdate=!1,updateTextBounds(Kr,ze)}async _updateGpuText(ze){ze._didTextUpdate=!1;const Gr=this._getGpuText(ze);if(Gr.generatingTexture)return;const Yr=ze._getKey();this._renderer.htmlText.decreaseReferenceCount(Gr.currentKey),Gr.generatingTexture=!0,Gr.currentKey=Yr;const Kr=ze.resolution??this._renderer.resolution,Zr=await this._renderer.htmlText.getManagedTexture(ze.text,Kr,ze._style,ze._getKey()),Qr=Gr.batchableSprite;Qr.texture=Gr.texture=Zr,Gr.generatingTexture=!1,Gr.textureNeedsUploading=!0,ze.onViewUpdate(),updateTextBounds(Qr,ze)}_getGpuText(ze){return this._gpuText[ze.uid]||this.initGpuText(ze)}initGpuText(ze){const Gr={texture:Texture.EMPTY,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite),textureNeedsUploading:!1,generatingTexture:!1},Yr=Gr.batchableSprite;return Yr.renderable=ze,Yr.transform=ze.groupTransform,Yr.texture=Texture.EMPTY,Yr.bounds={minX:0,maxX:1,minY:0,maxY:0},Yr.roundPixels=this._renderer._roundPixels|ze._roundPixels,ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution,this._gpuText[ze.uid]=Gr,ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuText)this._destroyRenderableById(ze);this._gpuText=null,this._renderer=null}}HTMLTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"htmlText"};function isSafari(){const{userAgent:Wr}=DOMAdapter.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(Wr)}const tempBounds=new Bounds;function getPo2TextureFromSource(Wr,ze,Gr,Yr){const Kr=tempBounds;Kr.minX=0,Kr.minY=0,Kr.maxX=Wr.width/Yr|0,Kr.maxY=Wr.height/Yr|0;const Zr=TexturePool.getOptimalTexture(Kr.width,Kr.height,Yr,!1);return Zr.source.uploadMethodId="image",Zr.source.resource=Wr,Zr.source.alphaMode="premultiply-alpha-on-upload",Zr.frame.width=ze/Yr,Zr.frame.height=Gr/Yr,Zr.source.emit("update",Zr.source),Zr.updateUvs(),Zr}function extractFontFamilies(Wr,ze){const Gr=ze.fontFamily,Yr=[],Kr={},Zr=/font-family:([^;"\s]+)/g,Qr=Wr.match(Zr);function Jr(ei){Kr[ei]||(Yr.push(ei),Kr[ei]=!0)}if(Array.isArray(Gr))for(let ei=0;ei<Gr.length;ei++)Jr(Gr[ei]);else Jr(Gr);Qr&&Qr.forEach(ei=>{const ti=ei.split(":")[1].trim();Jr(ti)});for(const ei in ze.tagStyles){const ti=ze.tagStyles[ei].fontFamily;Jr(ti)}return Yr}async function loadFontAsBase64(Wr){const Gr=await(await DOMAdapter.get().fetch(Wr)).blob(),Yr=new FileReader;return await new Promise((Zr,Qr)=>{Yr.onloadend=()=>Zr(Yr.result),Yr.onerror=Qr,Yr.readAsDataURL(Gr)})}async function loadFontCSS(Wr,ze){const Gr=await loadFontAsBase64(ze);return`@font-face {
        font-family: "${Wr.fontFamily}";
        src: url('${Gr}');
        font-weight: ${Wr.fontWeight};
        font-style: ${Wr.fontStyle};
    }`}const FontStylePromiseCache=new Map;async function getFontCss(Wr,ze,Gr){const Yr=Wr.filter(Kr=>Cache.has(`${Kr}-and-url`)).map((Kr,Zr)=>{if(!FontStylePromiseCache.has(Kr)){const{url:Qr}=Cache.get(`${Kr}-and-url`);Zr===0?FontStylePromiseCache.set(Kr,loadFontCSS({fontWeight:ze.fontWeight,fontStyle:ze.fontStyle,fontFamily:Kr},Qr)):FontStylePromiseCache.set(Kr,loadFontCSS({fontWeight:Gr.fontWeight,fontStyle:Gr.fontStyle,fontFamily:Kr},Qr))}return FontStylePromiseCache.get(Kr)});return(await Promise.all(Yr)).join(`
`)}function getSVGUrl(Wr,ze,Gr,Yr,Kr){const{domElement:Zr,styleElement:Qr,svgRoot:Jr}=Kr;Zr.innerHTML=`<style>${ze.cssStyle}</style><div style='padding:0;'>${Wr}</div>`,Zr.setAttribute("style",`transform: scale(${Gr});transform-origin: top left; display: inline-block`),Qr.textContent=Yr;const{width:ei,height:ti}=Kr.image;return Jr.setAttribute("width",ei.toString()),Jr.setAttribute("height",ti.toString()),new XMLSerializer().serializeToString(Jr)}function getTemporaryCanvasFromImage(Wr,ze){const Gr=CanvasPool.getOptimalCanvasAndContext(Wr.width,Wr.height,ze),{context:Yr}=Gr;return Yr.clearRect(0,0,Wr.width,Wr.height),Yr.drawImage(Wr,0,0),Gr}function loadSVGImage(Wr,ze,Gr){return new Promise(async Yr=>{Gr&&await new Promise(Kr=>setTimeout(Kr,100)),Wr.onload=()=>{Yr()},Wr.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(ze)}`,Wr.crossOrigin="anonymous"})}class HTMLTextSystem{constructor(ze){this._activeTextures={},this._renderer=ze,this._createCanvas=ze.type===RendererType.WEBGPU}getTexture(ze){return this._buildTexturePromise(ze.text,ze.resolution,ze.style)}getManagedTexture(ze,Gr,Yr,Kr){if(this._activeTextures[Kr])return this._increaseReferenceCount(Kr),this._activeTextures[Kr].promise;const Zr=this._buildTexturePromise(ze,Gr,Yr).then(Qr=>(this._activeTextures[Kr].texture=Qr,Qr));return this._activeTextures[Kr]={texture:null,promise:Zr,usageCount:1},Zr}async _buildTexturePromise(ze,Gr,Yr){const Kr=BigPool.get(HTMLTextRenderData),Zr=extractFontFamilies(ze,Yr),Qr=await getFontCss(Zr,Yr,HTMLTextStyle.defaultTextStyle),Jr=measureHtmlText(ze,Yr,Qr,Kr),ei=Math.ceil(Math.ceil(Math.max(1,Jr.width)+Yr.padding*2)*Gr),ti=Math.ceil(Math.ceil(Math.max(1,Jr.height)+Yr.padding*2)*Gr),ri=Kr.image,ii=2;ri.width=(ei|0)+ii,ri.height=(ti|0)+ii;const si=getSVGUrl(ze,Yr,Gr,Qr,Kr);await loadSVGImage(ri,si,isSafari()&&Zr.length>0);const ni=ri;let oi;this._createCanvas&&(oi=getTemporaryCanvasFromImage(ri,Gr));const li=getPo2TextureFromSource(oi?oi.canvas:ni,ri.width-ii,ri.height-ii,Gr);return this._createCanvas&&(this._renderer.texture.initSource(li.source),CanvasPool.returnCanvasAndContext(oi)),BigPool.return(Kr),li}_increaseReferenceCount(ze){this._activeTextures[ze].usageCount++}decreaseReferenceCount(ze){const Gr=this._activeTextures[ze];Gr&&(Gr.usageCount--,Gr.usageCount===0&&(Gr.texture?this._cleanUp(Gr):Gr.promise.then(Yr=>{Gr.texture=Yr,this._cleanUp(Gr)}).catch(()=>{warn("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[ze]=null))}_cleanUp(ze){TexturePool.returnTexture(ze.texture),ze.texture.source.resource=null,ze.texture.source.uploadMethodId="unknown"}getReferenceCount(ze){return this._activeTextures[ze].usageCount}destroy(){this._activeTextures=null}}HTMLTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"htmlText"};HTMLTextSystem.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"};class CanvasTextPipe{constructor(ze){this._gpuText=Object.create(null),this._destroyRenderableBound=this.destroyRenderable.bind(this),this._renderer=ze,this._renderer.runners.resolutionChange.add(this),this._renderer.renderableGC.addManagedHash(this,"_gpuText")}resolutionChange(){for(const ze in this._gpuText){const Gr=this._gpuText[ze];if(!Gr)continue;const Yr=Gr.batchableSprite.renderable;Yr._autoResolution&&(Yr._resolution=this._renderer.resolution,Yr.onViewUpdate())}}validateRenderable(ze){const Gr=this._getGpuText(ze),Yr=ze._getKey();return Gr.currentKey!==Yr}addRenderable(ze,Gr){const Kr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),this._renderer.renderPipes.batch.addToBatch(Kr,Gr)}updateRenderable(ze){const Yr=this._getGpuText(ze).batchableSprite;ze._didTextUpdate&&this._updateText(ze),Yr._batcher.updateElement(Yr)}destroyRenderable(ze){ze.off("destroyed",this._destroyRenderableBound),this._destroyRenderableById(ze.uid)}_destroyRenderableById(ze){const Gr=this._gpuText[ze];this._renderer.canvasText.decreaseReferenceCount(Gr.currentKey),BigPool.return(Gr.batchableSprite),this._gpuText[ze]=null}_updateText(ze){const Gr=ze._getKey(),Yr=this._getGpuText(ze),Kr=Yr.batchableSprite;Yr.currentKey!==Gr&&this._updateGpuText(ze),ze._didTextUpdate=!1,updateTextBounds(Kr,ze)}_updateGpuText(ze){const Gr=this._getGpuText(ze),Yr=Gr.batchableSprite;Gr.texture&&this._renderer.canvasText.decreaseReferenceCount(Gr.currentKey),Gr.texture=Yr.texture=this._renderer.canvasText.getManagedTexture(ze),Gr.currentKey=ze._getKey(),Yr.texture=Gr.texture}_getGpuText(ze){return this._gpuText[ze.uid]||this.initGpuText(ze)}initGpuText(ze){const Gr={texture:null,currentKey:"--",batchableSprite:BigPool.get(BatchableSprite)};return Gr.batchableSprite.renderable=ze,Gr.batchableSprite.transform=ze.groupTransform,Gr.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},Gr.batchableSprite.roundPixels=this._renderer._roundPixels|ze._roundPixels,this._gpuText[ze.uid]=Gr,ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution,this._updateText(ze),ze.on("destroyed",this._destroyRenderableBound),Gr}destroy(){for(const ze in this._gpuText)this._destroyRenderableById(ze);this._gpuText=null,this._renderer=null}}CanvasTextPipe.extension={type:[ExtensionType.WebGLPipes,ExtensionType.WebGPUPipes,ExtensionType.CanvasPipes],name:"text"};function checkRow(Wr,ze,Gr){for(let Yr=0,Kr=4*Gr*ze;Yr<ze;++Yr,Kr+=4)if(Wr[Kr+3]!==0)return!1;return!0}function checkColumn(Wr,ze,Gr,Yr,Kr){const Zr=4*ze;for(let Qr=Yr,Jr=Yr*Zr+4*Gr;Qr<=Kr;++Qr,Jr+=Zr)if(Wr[Jr+3]!==0)return!1;return!0}function getCanvasBoundingBox(Wr,ze=1){const{width:Gr,height:Yr}=Wr,Kr=Wr.getContext("2d",{willReadFrequently:!0});if(Kr===null)throw new TypeError("Failed to get canvas 2D context");const Qr=Kr.getImageData(0,0,Gr,Yr).data;let Jr=0,ei=0,ti=Gr-1,ri=Yr-1;for(;ei<Yr&&checkRow(Qr,Gr,ei);)++ei;if(ei===Yr)return Rectangle.EMPTY;for(;checkRow(Qr,Gr,ri);)--ri;for(;checkColumn(Qr,Gr,Jr,ei,ri);)++Jr;for(;checkColumn(Qr,Gr,ti,ei,ri);)--ti;return++ti,++ri,new Rectangle(Jr/ze,ei/ze,(ti-Jr)/ze,(ri-ei)/ze)}class CanvasTextSystem{constructor(ze){this._activeTextures={},this._renderer=ze}getTextureSize(ze,Gr,Yr){const Kr=CanvasTextMetrics.measureText(ze||" ",Yr);let Zr=Math.ceil(Math.ceil(Math.max(1,Kr.width)+Yr.padding*2)*Gr),Qr=Math.ceil(Math.ceil(Math.max(1,Kr.height)+Yr.padding*2)*Gr);return Zr=Math.ceil(Zr-1e-6),Qr=Math.ceil(Qr-1e-6),Zr=nextPow2(Zr),Qr=nextPow2(Qr),{width:Zr,height:Qr}}getTexture(ze,Gr,Yr,Kr){typeof ze=="string"&&(deprecation("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),ze={text:ze,style:Yr,resolution:Gr}),ze.style instanceof TextStyle||(ze.style=new TextStyle(ze.style));const{texture:Zr,canvasAndContext:Qr}=this.createTextureAndCanvas(ze);return this._renderer.texture.initSource(Zr._source),CanvasPool.returnCanvasAndContext(Qr),Zr}createTextureAndCanvas(ze){const{text:Gr,style:Yr}=ze,Kr=ze.resolution??this._renderer.resolution,Zr=CanvasTextMetrics.measureText(Gr||" ",Yr),Qr=Math.ceil(Math.ceil(Math.max(1,Zr.width)+Yr.padding*2)*Kr),Jr=Math.ceil(Math.ceil(Math.max(1,Zr.height)+Yr.padding*2)*Kr),ei=CanvasPool.getOptimalCanvasAndContext(Qr,Jr),{canvas:ti}=ei;this.renderTextToCanvas(Gr,Yr,Kr,ei);const ri=getPo2TextureFromSource(ti,Qr,Jr,Kr);if(Yr.trim){const ii=getCanvasBoundingBox(ti,Kr);ri.frame.copyFrom(ii),ri.updateUvs()}return{texture:ri,canvasAndContext:ei}}getManagedTexture(ze){ze._resolution=ze._autoResolution?this._renderer.resolution:ze.resolution;const Gr=ze._getKey();if(this._activeTextures[Gr])return this._increaseReferenceCount(Gr),this._activeTextures[Gr].texture;const{texture:Yr,canvasAndContext:Kr}=this.createTextureAndCanvas(ze);return this._activeTextures[Gr]={canvasAndContext:Kr,texture:Yr,usageCount:1},Yr}_increaseReferenceCount(ze){this._activeTextures[ze].usageCount++}returnTexture(ze){const Gr=ze.source;Gr.resource=null,Gr.uploadMethodId="unknown",Gr.alphaMode="no-premultiply-alpha",TexturePool.returnTexture(ze)}decreaseReferenceCount(ze){const Gr=this._activeTextures[ze];Gr.usageCount--,Gr.usageCount===0&&(CanvasPool.returnCanvasAndContext(Gr.canvasAndContext),this.returnTexture(Gr.texture),this._activeTextures[ze]=null)}getReferenceCount(ze){return this._activeTextures[ze].usageCount}renderTextToCanvas(ze,Gr,Yr,Kr){var fi,pi,mi,Ti;const{canvas:Zr,context:Qr}=Kr,Jr=fontStringFromTextStyle(Gr),ei=CanvasTextMetrics.measureText(ze||" ",Gr),ti=ei.lines,ri=ei.lineHeight,ii=ei.lineWidths,si=ei.maxLineWidth,ni=ei.fontProperties,oi=Zr.height;if(Qr.resetTransform(),Qr.scale(Yr,Yr),Qr.textBaseline=Gr.textBaseline,(fi=Gr._stroke)!=null&&fi.width){const yi=Gr._stroke;Qr.lineWidth=yi.width,Qr.miterLimit=yi.miterLimit,Qr.lineJoin=yi.join,Qr.lineCap=yi.cap}Qr.font=Jr;let li,ai;const ui=Gr.dropShadow?2:1;for(let yi=0;yi<ui;++yi){const _i=Gr.dropShadow&&yi===0,Ci=_i?Math.ceil(Math.max(1,oi)+Gr.padding*2):0,Bi=Ci*Yr;if(_i){Qr.fillStyle="black",Qr.strokeStyle="black";const Mi=Gr.dropShadow,ki=Mi.color,Wi=Mi.alpha;Qr.shadowColor=Color.shared.setValue(ki).setAlpha(Wi).toRgbaString();const Li=Mi.blur*Yr,ci=Mi.distance*Yr;Qr.shadowBlur=Li,Qr.shadowOffsetX=Math.cos(Mi.angle)*ci,Qr.shadowOffsetY=Math.sin(Mi.angle)*ci+Bi}else{if(Qr.fillStyle=Gr._fill?getCanvasFillStyle(Gr._fill,Qr,ei):null,(pi=Gr._stroke)!=null&&pi.width){const Mi=Gr._stroke.width*Gr._stroke.alignment;Qr.strokeStyle=getCanvasFillStyle(Gr._stroke,Qr,ei,Mi)}Qr.shadowColor="black"}let Pi=(ri-ni.fontSize)/2;ri-ni.fontSize<0&&(Pi=0);const Si=((mi=Gr._stroke)==null?void 0:mi.width)??0;for(let Mi=0;Mi<ti.length;Mi++)li=Si/2,ai=Si/2+Mi*ri+ni.ascent+Pi,Gr.align==="right"?li+=si-ii[Mi]:Gr.align==="center"&&(li+=(si-ii[Mi])/2),(Ti=Gr._stroke)!=null&&Ti.width&&this._drawLetterSpacing(ti[Mi],Gr,Kr,li+Gr.padding,ai+Gr.padding-Ci,!0),Gr._fill!==void 0&&this._drawLetterSpacing(ti[Mi],Gr,Kr,li+Gr.padding,ai+Gr.padding-Ci)}}_drawLetterSpacing(ze,Gr,Yr,Kr,Zr,Qr=!1){const{context:Jr}=Yr,ei=Gr.letterSpacing;let ti=!1;if(CanvasTextMetrics.experimentalLetterSpacingSupported&&(CanvasTextMetrics.experimentalLetterSpacing?(Jr.letterSpacing=`${ei}px`,Jr.textLetterSpacing=`${ei}px`,ti=!0):(Jr.letterSpacing="0px",Jr.textLetterSpacing="0px")),ei===0||ti){Qr?Jr.strokeText(ze,Kr,Zr):Jr.fillText(ze,Kr,Zr);return}let ri=Kr;const ii=CanvasTextMetrics.graphemeSegmenter(ze);let si=Jr.measureText(ze).width,ni=0;for(let oi=0;oi<ii.length;++oi){const li=ii[oi];Qr?Jr.strokeText(li,ri,Zr):Jr.fillText(li,ri,Zr);let ai="";for(let ui=oi+1;ui<ii.length;++ui)ai+=ii[ui];ni=Jr.measureText(ai).width,ri+=si-ni+ei,si=ni}}destroy(){this._activeTextures=null}}CanvasTextSystem.extension={type:[ExtensionType.WebGLSystem,ExtensionType.WebGPUSystem,ExtensionType.CanvasSystem],name:"canvasText"};extensions.add(browserExt,webworkerExt);const CGA_CYAN="#01FFFF",CGA_PINK="#FF55FE",CGA_BLACK="#000000",CGA_WHITE="#ffffff",TILESIZE=32,PLAYERSPEED=.1,TILEMAP=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,5,4,3,3,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,5,4,3,3,3,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],GRIDWIDTH=TILEMAP[0].length,GRIDHEIGHT=TILEMAP.length;class Point{constructor(ze,Gr){Gi(this,"asCartesian");Gi(this,"asIsometric");this.asCartesian={x:ze,y:Gr},this.asIsometric={x:ze*TILESIZE-Gr*TILESIZE,y:ze*TILESIZE/2+Gr*TILESIZE/2}}update(ze){this.asCartesian=ze,this.asIsometric={x:ze.x*TILESIZE-ze.y*TILESIZE,y:ze.x*TILESIZE/2+ze.y*TILESIZE/2}}add(ze){this.asIsometric={x:this.asIsometric.x+ze.x,y:this.asIsometric.y+ze.y}}}class Player{constructor(ze,Gr,Yr,Kr,Zr){Gi(this,"id");Gi(this,"position");Gi(this,"username");Gi(this,"avatar");Gi(this,"context");this.id=ze,this.position=new Point(Kr.x,Kr.y),this.username=Gr,this.avatar=Yr,this.context=new Sprite(Zr),this.context.anchor.set(.75,0),this.context.x=this.position.asIsometric.x,this.context.y=this.position.asIsometric.y}updatePosition(ze){this.position.update(ze),this.context.x=this.position.asIsometric.x,this.context.y=this.position.asIsometric.y}getId(){return this.id}getAvatar(){return this.avatar}getUsername(){return this.username}getPoint(){return this.position}getPosition(){return this.position.asCartesian}getIsometricPosition(){return this.position.asIsometric}getContext(){return this.context}}var CameraMode=(Wr=>(Wr[Wr.Locked=0]="Locked",Wr[Wr.Free=1]="Free",Wr))(CameraMode||{}),PongState=(Wr=>(Wr[Wr.Waiting=0]="Waiting",Wr[Wr.PlayerNearby=1]="PlayerNearby",Wr[Wr.PlayerReady=2]="PlayerReady",Wr[Wr.InProgress=3]="InProgress",Wr))(PongState||{});let mouse={x:0,y:0},keyIsPressed={},keyWasPressed={};window.addEventListener("keydown",Wr=>{keyIsPressed[Wr.code]||(keyWasPressed[Wr.code]=!0),keyIsPressed[Wr.code]=!0});window.addEventListener("keyup",Wr=>{keyIsPressed[Wr.code]=!1});function resetKeyStates(Wr){for(const ze in Wr)Wr[ze]=!1}function dynamicIndexing(Wr,ze){let Gr=Math.ceil(ze.y+1),Yr=Math.ceil(ze.x+1);TILEMAP[Gr-1][Yr]>0||TILEMAP[Gr][Yr]>0||TILEMAP[Gr][Yr-1]>0?Wr.getContext().zIndex=-1:Wr.getContext().zIndex=5}function movePlayer(Wr,ze){let Gr={x:Wr.position.asCartesian.x,y:Wr.position.asCartesian.y};keyIsPressed.KeyW?Gr.y-=PLAYERSPEED*ze:keyIsPressed.KeyS?Gr.y+=PLAYERSPEED*ze:keyIsPressed.KeyA?Gr.x-=PLAYERSPEED*ze:keyIsPressed.KeyD&&(Gr.x+=PLAYERSPEED*ze);let Yr=Math.ceil(Gr.x),Kr=Math.ceil(Gr.y);return Yr>=0&&Yr<GRIDWIDTH&&Kr>=0&&Kr<GRIDHEIGHT&&TILEMAP[Kr][Yr]===0&&(Wr.updatePosition(Gr),dynamicIndexing(Wr,Gr)),Wr.position}function switchCameraMode(Wr){return Wr===CameraMode.Locked?CameraMode.Free:CameraMode.Locked}__vitePreload(()=>Promise.resolve().then(()=>htmx_min$1),void 0);const playerInfoBox=document.getElementById("pixi-player-info");var ts;const Qi=class Qi{constructor(){Gi(this,"players",new Map);Gi(this,"localPlayer",null);Gi(this,"pongTable",null)}static get instance(){return is(Qi,ts)||cs(Qi,ts,new Qi),is(Qi,ts)}isLocalPlayerInitialized(){return!!this.localPlayer}initLocalPlayer(ze,Gr,Yr,Kr,Zr){return this.localPlayer=new Player(ze,Gr,Yr,Kr,Zr),this.localPlayer}initPongTable(ze){this.pongTable=ze}addPlayer(ze,Gr,Yr,Kr,Zr){const Qr=new Player(ze,Gr,Yr,Kr,Zr),Jr=Qr.getContext(),ei=new ColorMatrixFilter;return Jr.interactive=!0,Jr.on("pointerover",()=>{console.log(`Player: ${ze}`),Jr.blendMode="color-dodge";const{matrix:ti}=ei;ti[1]=1,ti[2]=1,ti[3]=1,Jr.filters=[ei]}),Jr.on("pointerleave",()=>{Jr.filters=[]}),Jr.on("pointerdown",async()=>{if(playerInfoBox){playerInfoBox.style.display="block",playerInfoBox.style.top=`${mouse.y+10}px`,playerInfoBox.style.left=`${mouse.x+10}px`;try{const ti=document.getElementById("infoUsername"),ri=document.getElementById("infoAvatar");ti&&(ti.textContent=`${Gr}`),ri&&(ri.outerHTML=`<img src="/images/avatars/${Yr}" class="w-12 h-12 rounded-full" />`);const ii=document.getElementById("friendRequestBtn");ii&&(ii.setAttribute("hx-post",`sendReq/${ze}/${window.__INITIAL_STATE__.id}`),ii.setAttribute("hx-target","#friendRequestBtn"),ii.setAttribute("hx-swap","outerHTML"),ii.setAttribute("hx-target-error","#friendRequestBtn"),window.htmx.process(document.body))}catch(ti){console.error("Failed to fetch player info",ti)}}}),this.players.set(ze,Qr),this.players.get(ze)}getLocalPlayer(){if(this.localPlayer)return this.localPlayer}getPlayer(ze){return this.players.get(ze)}getPlayers(){return this.players}updatePlayer(ze,Gr){const Yr=this.players.get(ze);Yr&&Yr.updatePosition(Gr)}removePlayer(ze){this.players.delete(ze)}};ts=new WeakMap,ls(Qi,ts);let PlayerManager=Qi,playerManager=PlayerManager.instance;const textureMap=new Map([[0,"block_empty_black"],[1,"block_empty_white"],[3,"block_opaque_coloured"],[2,"block_opaque_white"],[4,"block_half_opaque_coloured"]]);function loadTextures(){let Wr=new Array;for(const[ze,Gr]of textureMap){console.log("TextureId: "+ze+", path: "+Gr);try{let Yr=Texture.from(Gr);Wr.push(Yr)}catch(Yr){console.log("Hmvve",Yr)}}return Wr}var rs;const Ji=class Ji{constructor(ze,Gr,Yr){Gi(this,"container");Gi(this,"graphicsContext");Gi(this,"tilingSprites",[]);Gi(this,"rows");Gi(this,"cols");Gi(this,"tileSize");this.container=new Container,this.graphicsContext=new Graphics,this.container.addChild(this.graphicsContext),this.rows=ze,this.cols=Gr,this.tileSize=Yr}static get instance(){return is(Ji,rs)||cs(Ji,rs,new Ji(GRIDHEIGHT,GRIDWIDTH,TILESIZE)),is(Ji,rs)}initTilingSprites(ze){const Gr=ze.length,Yr=ze[0].length;try{const Kr=loadTextures();if(!Kr){console.error("Failed to load texture.");return}this.tilingSprites=ze.map(Zr=>Zr.map(Qr=>new TilingSprite({texture:Kr[Qr],width:64,height:64})));for(let Zr=0;Zr<Gr;Zr++)for(let Qr=0;Qr<Yr;Qr++)this.container.addChild(this.tilingSprites[Zr][Qr])}catch(Kr){console.error("Error initializing sprite tiles:",Kr)}}drawIsometricTile(ze,Gr,Yr,Kr,Zr){ze.poly([Gr.x,Gr.y,Gr.x+Yr,Gr.y+Kr/2,Gr.x,Gr.y+Kr,Gr.x-Yr,Gr.y+Kr/2,Gr.x,Gr.y]),Zr?(ze.fill(CGA_BLACK),ze.stroke({color:CGA_CYAN})):ze.stroke({color:CGA_PINK})}async createSpriteGrid(ze){this.initTilingSprites(TILEMAP);for(let Gr=0;Gr<this.rows;Gr++)for(let Yr=0;Yr<this.cols;Yr++){let Kr=new Point(Yr,Gr);Kr.asIsometric.y-=ze[Gr][Yr]*this.tileSize,this.tilingSprites[Gr][Yr].x=Kr.asIsometric.x,this.tilingSprites[Gr][Yr].y=Kr.asIsometric.y}}async createGraphicsGrid(ze){for(let Gr=0;Gr<this.rows;Gr++)for(let Yr=0;Yr<this.cols;Yr++){let Kr=new Point(Yr,Gr);const Zr=this.getHeightOffset(Yr,Gr,ze);Kr.asIsometric.y-=Zr;{const Qr=new Point(Yr,Gr+1),Jr=new Point(Yr,Gr+1),ei=new Point(Yr+1,Gr+1),ti=new Point(Yr+1,Gr+1);Qr.asIsometric.y-=Zr,ti.asIsometric.y-=Zr,this.graphicsContext.poly([Qr.asIsometric.x,Qr.asIsometric.y,Jr.asIsometric.x,Jr.asIsometric.y,ei.asIsometric.x,ei.asIsometric.y,ti.asIsometric.x,ti.asIsometric.y]).stroke(CGA_BLACK).fill(CGA_PINK)}{const Qr=new Point(Yr+1,Gr+1),Jr=new Point(Yr+1,Gr+1),ei=new Point(Yr+1,Gr),ti=new Point(Yr+1,Gr);Qr.asIsometric.y-=Zr,ti.asIsometric.y-=Zr,this.graphicsContext.poly([Qr.asIsometric.x,Qr.asIsometric.y,Jr.asIsometric.x,Jr.asIsometric.y,ei.asIsometric.x,ei.asIsometric.y,ti.asIsometric.x,ti.asIsometric.y]).stroke(CGA_BLACK).fill(CGA_CYAN)}ze[Gr][Yr]!=0?this.drawIsometricTile(this.graphicsContext,Kr.asIsometric,this.tileSize,this.tileSize,!0):this.drawIsometricTile(this.graphicsContext,Kr.asIsometric,this.tileSize,this.tileSize,!1)}}addPlayer(ze){this.container.addChild(ze.getContext())}getHeightOffset(ze,Gr,Yr){return Yr[Gr][ze]*this.tileSize/4}moveMap(ze){this.container.x+=ze.x,this.container.y+=ze.y}getContainer(){return this.container}addToContainer(ze){this.container.addChild(ze)}};rs=new WeakMap,ls(Ji,rs);let GameMap=Ji;function addGameMap(Wr){let ze=GameMap.instance;const Gr=ze.getContainer();return ze.createGraphicsGrid(TILEMAP),Wr.stage.addChild(Gr),ze}function moveMapWithMouse(Wr,ze,Gr){if(!Gr)return;let Yr=window.innerWidth*.1,Kr=window.innerHeight*.1,Zr={x:0,y:0},Qr=5;if(Wr.x>=window.innerWidth-Yr){let Jr=(Wr.x-(window.innerWidth-Yr))/Yr;Zr.x-=Jr*Qr}if(Wr.x<=Yr){let Jr=(Yr-Wr.x)/Yr;Zr.x+=Jr*Qr}if(Wr.y<=Kr){let Jr=(Kr-Wr.y)/Kr;Zr.y+=Jr*Qr}if(Wr.y>=window.innerHeight-Kr){let Jr=(Wr.y-(window.innerHeight-Kr))/Kr;Zr.y-=Jr*Qr}ze.moveMap(Zr)}function setupMapZoom(){window.addEventListener("wheel",Wr=>{let ze=.05,Gr=.5,Yr=2,Kr=Wr.deltaY/Math.abs(Wr.deltaY),Zr;(ti=>{ti[ti.Up=-1]="Up",ti[ti.Down=1]="Down"})(Zr||(Zr={}));let Qr=pixiApp.stage,Jr=localPlayerPos.asCartesian.x+pixiApp.screen.width/2,ei=localPlayerPos.asCartesian.y+pixiApp.screen.height/2;if(Kr==-1&&Qr.scale.x<Yr){const ti=1-Qr.scale.x/(Qr.scale.x+ze);Qr.scale.x+=ze,Qr.scale.y+=ze,Qr.x-=(Jr-Qr.x)*ti,Qr.y-=(ei-Qr.y)*ti}else if(Kr==1&&Qr.scale.x>Gr){const ti=1-Qr.scale.x/(Qr.scale.x+ze);Qr.scale.x-=ze,Qr.scale.y-=ze,Qr.x+=(Jr-Qr.x)*ti,Qr.y+=(ei-Qr.y)*ti}})}let localUser=window.__INITIAL_STATE__;const gameserverUrl=window.__GAMESERVER_URL__;let socket;window.__GAMESERVER_URL__?socket=new WebSocket(`ws://${gameserverUrl}:8003/ws-gameserver`):socket=new WebSocket("ws://localhost:8003/ws-gameserver");function sendToServer(Wr){socket.readyState==WebSocket.OPEN&&socket.send(JSON.stringify(Wr))}function initializeLocalPlayer(Wr,ze,Gr){let Yr;Wr.x===0&&Wr.y===0?Yr={x:36,y:20}:Yr={x:Wr.x,y:Wr.y};let Kr,Zr;window.__INITIAL_STATE__?(Kr=localUser.username,Zr=localUser.avatar):(Kr="testUser",Zr="test.png");const Qr=playerManager.initLocalPlayer(Wr.id,Kr,Zr,Yr,Gr);if(Qr)return ze.addPlayer(Qr),Qr}function initializePlayers(Wr,ze,Gr){for(const[Yr,Kr]of Wr)if(console.log(`Player ${Yr} is at (${Kr.x}, ${Kr.y})`),!isLocalPlayer(Yr)){const Zr=playerManager.addPlayer(Yr,Kr.username,Kr.avatar,{x:Kr.x,y:Kr.y},Gr);Zr&&ze.addPlayer(Zr)}}function isLocalPlayer(Wr){return Wr===localUser.id}async function runConnectionManager(Wr){const ze=Texture.from("player_bunny"),Gr=initializeLocalPlayer(localUser.player,Wr,ze);Gr&&sendToServer({type:"new_connection",id:localUser.id,username:localUser.username,avatar:localUser.avatar,position:Gr.getPosition()}),socket.onmessage=Yr=>{const Kr=JSON.parse(Yr.data);if(Kr.type==="new_player"&&!isLocalPlayer(Kr.id)){const Zr=playerManager.addPlayer(Kr.id,Kr.username,Kr.avatar,Kr.position,ze);Zr&&Wr.addPlayer(Zr)}if(Kr.type=="initialize_players"&&initializePlayers(Kr.players,Wr,ze),Kr.type=="disconnect_player"&&!isLocalPlayer(Kr.id)){const Zr=Wr.getContainer(),Qr=playerManager.getPlayer(Kr.id);Qr&&Zr.removeChild(Qr.getContext()),playerManager.removePlayer(Kr.id)}if(Kr.type=="player_move"&&!isLocalPlayer(Kr.id)){const Zr=playerManager.getPlayer(Kr.id);Zr==null||Zr.updatePosition(Kr.position)}if(Kr.type=="confirm_pong_player"&&isLocalPlayer(Kr.pongPlayer.id)){const Zr=playerManager.getLocalPlayer(),Qr=playerManager.pongTable;Qr&&Zr&&(console.log(Kr.pongPlayer.side),Qr.setPlayerReady(Zr,Kr.pongPlayer.side))}if(Kr.type=="player_joined_pong"&&!isLocalPlayer(Kr.pongPlayer.id)){const Zr=playerManager.getPlayer(Kr.pongPlayer.id),Qr=playerManager.pongTable;Qr&&Zr&&(console.log(Kr.pongPlayer.side),Qr.setPlayerReady(Zr,Kr.pongPlayer.side))}if(Kr.type=="leave_pong"){const Zr=playerManager.pongTable;Zr&&Zr.removePlayer(Kr.pongPlayer.side)}if(Kr.type=="countdown_pong"){const Zr=playerManager.pongTable;Zr&&Zr.setCountdownTimer(Number(Kr.timer))}if(Kr.type=="start_pong_game"){const Zr=playerManager.pongTable;Zr&&Zr.startGame()}if(Kr.type=="pong_update"){const Zr=playerManager.pongTable;Zr&&(Zr.updatePaddle("left",Kr.pongState.paddles.left),Zr.updatePaddle("right",Kr.pongState.paddles.right))}if(Kr.type=="score_update"){const Zr=playerManager.pongTable;Zr&&(console.log("Data: ",Kr),Kr.side=="left"&&Zr.updateScore("right",Kr.score),Kr.side=="right"&&Zr.updateScore("left",Kr.score))}if(Kr.type=="ball_move"){const Zr=playerManager.pongTable;if(Zr){let Qr={x:Kr.ball.x,y:Kr.ball.y};Zr.updateBall(Qr)}}},window.addEventListener("beforeunload",()=>{if(socket.readyState==WebSocket.OPEN){const Yr=playerManager.getLocalPlayer();let Kr={x:0,y:0};Yr?(Kr=Yr.position.asCartesian,socket.send(JSON.stringify({type:"disconnection",info:"Client disconnected!",id:localUser.id,position:Kr})),sendToServer({type:"disconnection",id:localUser.id,position:Kr})):socket.send(JSON.stringify({type:"disconnection",info:"Client disconnected!",id:localUser.id,position:{x:-4.2,y:-4.2}}))}}),socket.onerror=Yr=>{console.log("Websocket error: ",Yr)}}class Ball{constructor(ze){Gi(this,"position");Gi(this,"graphics");Gi(this,"direction");Gi(this,"speed");this.graphics=new Graphics,this.position=new Point(ze.x,ze.y),this.speed=.05,this.direction={x:Math.random()*2-1,y:Math.random()*2-1},this.graphics.circle(0,0,3.5).fill(16777215),this.graphics.zIndex=100,this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}move(ze){let Gr=this.position.asCartesian,Yr={x:Gr.x+this.direction.x*this.speed*ze,y:Gr.y+this.direction.y*this.speed*ze};this.position.update(Yr),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}update(ze){this.position.update({x:ze.x,y:ze.y}),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}bounceX(){this.direction.x=-this.direction.x}bounceY(){this.direction.y=-this.direction.y}getContext(){return this.graphics}getPoint(){return this.position}}class Paddle{constructor(ze,Gr,Yr){Gi(this,"position");Gi(this,"graphics");Gi(this,"paddleHeight");Gi(this,"paddleSpeed");this.position=new Point(ze.x,ze.y),this.paddleHeight=Gr,this.paddleSpeed=Yr;let Kr=new Point(0,ze.y-Gr/2),Zr=new Point(0,ze.y+Gr/2);this.graphics=new Graphics().moveTo(Kr.asIsometric.x,Kr.asIsometric.y).lineTo(Zr.asIsometric.x,Zr.asIsometric.y).stroke(16777215),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}move(ze,Gr){let Yr={x:this.position.asCartesian.x,y:this.position.asCartesian.y};Yr.y+=this.paddleSpeed*ze*Gr,this.position.update(Yr),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}update(ze){this.position.update({x:this.position.asCartesian.x,y:ze}),this.graphics.x=this.position.asIsometric.x,this.graphics.y=this.position.asIsometric.y}getPaddleHeight(){return this.paddleHeight}getPoint(){return this.position}getGraphics(){return this.graphics}}class InfoBox{constructor(ze,Gr,Yr,Kr){Gi(this,"container");Gi(this,"graphics");Gi(this,"position");Gi(this,"text");Gi(this,"textSize");Gi(this,"height");Gi(this,"width");this.container=new Container,this.textSize=Gr;const Zr=new TextStyle({fill:CGA_PINK,fontSize:this.textSize});this.text=new Text({text:ze,style:Zr}),this.height=this.textSize*2,this.width=this.text.width+this.textSize,this.position={x:Yr,y:Kr},this.text.x=Yr+this.textSize/2,this.text.y=Kr+this.textSize/2,this.graphics=new Graphics().roundRect(Yr,Kr,this.width,this.height,5).fill(CGA_BLACK).stroke(CGA_PINK),this.container.addChild(this.graphics),this.container.addChild(this.text)}setPosition(ze,Gr){this.container.x=ze,this.container.y=Gr}setColor(ze){this.width=this.text.width+this.textSize,this.graphics.clear(),this.graphics.roundRect(this.position.x,this.position.y,this.width,this.height,5).fill(ze).stroke(CGA_PINK)}setText(ze,Gr){this.text.style.fill=Gr,this.text.text=ze,this.setColor(CGA_BLACK)}getContainer(){return this.container}getGraphics(){return this.graphics}}class PongInfo{constructor(ze,Gr,Yr){Gi(this,"box");this.box=new InfoBox("",ze,Gr,Yr)}displayPongState(ze,Gr,Yr){switch(ze){case PongState.Waiting:this.box.setText("Waiting for player",CGA_PINK);break;case PongState.PlayerNearby:this.box.setText("Press 'E'",CGA_CYAN);break;case PongState.PlayerReady:Gr&&this.box.setText(`${Gr} is ready!`,CGA_CYAN);break;case PongState.InProgress:Gr!==null&&Yr!==null&&this.box.setText(`${Gr} Score: ${Yr}`,CGA_PINK);break}}getContainer(){return this.box.getContainer()}}function slice2DArray(Wr,ze,Gr,Yr,Kr){return Wr.slice(Yr,Kr).map(Qr=>Qr.slice(ze,Gr))}function isWithinRange(Wr,ze,Gr){return Math.abs(Wr-ze)<=Gr}class PongTable{constructor(ze,Gr){Gi(this,"container",new Container);Gi(this,"worldPosition");Gi(this,"tableGrid",[]);Gi(this,"ball");Gi(this,"paddles",{left:new Paddle({x:0,y:0},.5,.05),right:new Paddle({x:4,y:0},.5,.05)});Gi(this,"players",{left:null,right:null});Gi(this,"indicators",{left:new PongInfo(12,0,0),right:new PongInfo(12,TILESIZE*4,TILESIZE*2)});Gi(this,"countdownTimer",new InfoBox("3",24,TILESIZE*2,0));Gi(this,"inProgress",!1);this.worldPosition=ze;let Yr=Math.round(ze.x),Kr=Math.round(ze.y);this.tableGrid=slice2DArray(Gr,Yr,Yr+2,Kr,Kr+2),this.ball=new Ball({x:2,y:1}),this.container.addChild(this.ball.getContext());let Zr=new Point(this.worldPosition.x,this.worldPosition.y);this.container.x+=Zr.asIsometric.x,this.container.y+=Zr.asIsometric.y,this.countdownTimer.container.renderable=!1,this.container.addChild(this.indicators.left.getContainer()),this.container.addChild(this.indicators.right.getContainer()),this.container.addChild(this.countdownTimer.getContainer()),this.container.addChild(this.paddles.left.getGraphics()),this.container.addChild(this.paddles.right.getGraphics()),this.container.y-=this.tableGrid[0][0]*TILESIZE/2,this.container.zIndex=10}setCountdownTimer(ze){ze===-1?this.countdownTimer.container.renderable=!1:(this.countdownTimer.container.renderable=!0,this.countdownTimer.setText(`Starting in: ${ze}`,CGA_WHITE),this.countdownTimer.setColor(CGA_BLACK))}isPlayerAtLeft(ze){let Gr={x:Math.round(ze.x),y:Math.round(ze.y)};return Gr.x===Math.round(this.worldPosition.x-1)&&Gr.y===Math.round(this.worldPosition.y)||Gr.x===Math.round(this.worldPosition.x-1)&&Gr.y===Math.round(this.worldPosition.y+1)}isPlayerAtRight(ze){let Gr={x:Math.round(ze.x),y:Math.round(ze.y)};return Gr.x===Math.round(this.worldPosition.x+3)&&Gr.y===Math.round(this.worldPosition.y)||Gr.x===Math.round(this.worldPosition.x+3)&&Gr.y===Math.round(this.worldPosition.y+1)}setPlayerReady(ze,Gr){this.players[Gr]||(this.players[Gr]={id:ze.getId(),username:ze.getUsername(),paddleY:32,ready:!0,score:0,side:Gr},this.indicators[Gr].displayPongState(PongState.PlayerReady,ze.getUsername(),0))}setIndicator(ze,Gr,Yr,Kr){this.indicators[ze].displayPongState(Gr,Yr,Kr)}startGame(){this.inProgress||(this.indicators.left.displayPongState(PongState.InProgress,this.players.left.username,0),this.indicators.right.displayPongState(PongState.InProgress,this.players.right.username,0)),this.inProgress=!0}isInProgress(){return this.inProgress}updateScore(ze,Gr){this.players[ze]&&(this.players[ze].score=Gr,this.indicators[ze].displayPongState(PongState.InProgress,this.players[ze].username,this.players[ze].score))}removePlayer(ze){this.players[ze]&&(this.players[ze]=null,this.indicators[ze].displayPongState(PongState.Waiting,null,null))}isSideReady(ze){if(this.players[ze])return this.players[ze].ready}isPlayerReady(ze){return this.players.left&&this.players.left.id===ze?this.players.left.ready:this.players.right&&this.players.right.id===ze?this.players.right.ready:!1}getPongPlayer(ze){return this.players[ze]?this.players[ze]:null}getPlayerSide(ze){let Gr=ze.getPosition();return this.isPlayerAtLeft(Gr)?"left":this.isPlayerAtRight(Gr)?"right":null}collidesWithPaddle(ze){let Gr=this.getLocalBallPosition(this.ball),Yr=this.getLocalPaddlePosition(this.paddles[ze]),Kr=this.paddles[ze].getPaddleHeight()/2*TILESIZE,Zr=Yr.y-Kr,Qr=Yr.y+Kr,Jr=0;return ze==="right"&&(Jr=TILESIZE*4),!!(Gr.y>Zr&&Gr.y<Qr&&isWithinRange(Jr,Gr.x,2))}updateBall(ze){this.ball.update(ze)}updatePaddle(ze,Gr){ze!==null&&this.paddles[ze].update(Gr)}getLocalBallPosition(ze){let Gr=ze.getPoint().asCartesian;return{x:Gr.x*TILESIZE,y:Gr.y*TILESIZE}}getLocalPaddlePosition(ze){let Gr=ze.getPoint().asCartesian;return{x:Gr.x*TILESIZE,y:Gr.y*TILESIZE}}getContainer(){return this.container}}const pixiApp=new Application;let prevPos={x:0,y:0},localPlayerPos=new Point(0,0),isGameFocused=!0,screenShake=!1,cameraMode=CameraMode.Locked;async function preload(){const Wr=[{alias:"player_bunny",src:"/assets/bunny.png"},{alias:"block_empty_black",src:"/assets/block_empty_black.png"},{alias:"block_empty_white",src:"/assets/block_empty_white.png"},{alias:"block_opaque_coloured",src:"/assets/block_opaque_coloured.png"},{alias:"block_opaque_white",src:"/assets/block_opaque_white.png"},{alias:"block_half_opaque_coloured",src:"/assets/block_half_opaque_coloured.png"}];await Assets.load(Wr)}async function setup(){const Wr=document.getElementById("pixi-container");Wr&&(await pixiApp.init({background:CGA_BLACK,resizeTo:Wr}),Wr.appendChild(pixiApp.canvas)),pixiApp.stage.eventMode="static",pixiApp.stage.hitArea=pixiApp.screen,window.addEventListener("pointermove",ze=>{mouse.x=ze.clientX,mouse.y=ze.clientY}),window.addEventListener("blur",()=>{isGameFocused=!1}),window.addEventListener("focus",()=>{isGameFocused=!0}),setupMapZoom(),console.log("Pixi app initialized:",pixiApp)}function indicateIfJoinable(Wr,ze){const Gr=ze.getPlayerSide(Wr);if(Gr===null){ze.isSideReady("left")||ze.setIndicator("left",PongState.Waiting,null,null),ze.isSideReady("right")||ze.setIndicator("right",PongState.Waiting,null,null);return}ze.isSideReady(Gr)||ze.setIndicator(Gr,PongState.PlayerNearby,null,null)}function joinOrLeavePongTable(Wr,ze){const Gr=ze.getPlayerSide(Wr);if(Gr!==null){const Yr={id:Wr.getId(),username:Wr.getUsername(),paddleY:1,ready:!1,score:0,side:Gr};if(!ze.isSideReady(Gr))sendToServer({type:"join_pong",pongPlayer:Yr});else{const Kr=ze.getPongPlayer(Gr);Kr&&Kr.id!==Wr.id?alert("There's already another player at the table!"):Kr&&sendToServer({type:"leave_pong",pongPlayer:Kr})}}}function handleCamera(Wr,ze,Gr){if(ze===CameraMode.Locked){let Yr=Wr.getPoint();localPlayerPos.update({x:Yr.asCartesian.x,y:Yr.asCartesian.y}),Gr.container.x=-Yr.asIsometric.x+pixiApp.screen.width/2,Gr.container.y=-Yr.asIsometric.y+pixiApp.screen.height/2}else moveMapWithMouse(mouse,Gr,isGameFocused)}(async()=>{await setup(),await preload();let Wr=addGameMap(pixiApp);window.__INITIAL_STATE__?runConnectionManager(Wr):initializeLocalPlayer({id:-1,x:0,y:0},Wr,Texture.from("player_bunny"));let ze=new PongTable({x:37,y:15},TILEMAP);Wr.container.addChild(ze.getContainer()),playerManager.initPongTable(ze);let Gr=0;pixiApp.ticker.add(Yr=>{const Kr=playerManager.getLocalPlayer();if(Kr){if(handleCamera(Kr,cameraMode,Wr),indicateIfJoinable(Kr,ze),keyWasPressed.KeyC&&(cameraMode=switchCameraMode(cameraMode)),keyWasPressed.KeyE&&joinOrLeavePongTable(Kr,ze),!ze.isPlayerReady(Kr.id))movePlayer(Kr,Yr.deltaTime);else{const Zr=ze.getPlayerSide(Kr);Zr!==null&&(keyIsPressed.ArrowUp&&sendToServer({type:"paddle_move",side:Zr,direction:"up"}),keyIsPressed.ArrowDown&&sendToServer({type:"paddle_move",side:Zr,direction:"down"}),ze.collidesWithPaddle(Zr)&&(screenShake=!0,setTimeout(()=>{screenShake=!1},250)))}screenShake&&(pixiApp.stage.x+=Math.sin(Gr)),(prevPos.x!=Kr.position.asCartesian.x||prevPos.y!=Kr.position.asCartesian.y)&&sendToServer({type:"player_move",id:Kr.getId(),position:Kr.getPosition()}),prevPos=Kr.getPosition()}Gr+=Yr.deltaTime,resetKeyStates(keyWasPressed)})})();extensions.add(AccessibilitySystem);extensions.mixin(Container,accessibilityTarget);extensions.add(ResizePlugin);extensions.add(TickerPlugin);extensions.add(EventSystem);extensions.mixin(Container,FederatedContainer);extensions.add(DOMPipe);extensions.add(GraphicsPipe);extensions.add(GraphicsContextSystem);extensions.add(MeshPipe);extensions.add(GlParticleContainerPipe);extensions.add(GpuParticleContainerPipe);extensions.add(CanvasTextSystem);extensions.add(CanvasTextPipe);extensions.add(BitmapTextPipe);extensions.add(HTMLTextSystem);extensions.add(HTMLTextPipe);extensions.add(TilingSpritePipe);extensions.add(NineSliceSpritePipe);extensions.add(FilterSystem);extensions.add(FilterPipe);const browserAll=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"})),webworkerAll=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));var htmx_min$3={exports:{}},htmx_min$2=htmx_min$3.exports,hasRequiredHtmx_min;function requireHtmx_min(){return hasRequiredHtmx_min||(hasRequiredHtmx_min=1,function(module){(function(Wr,ze){module.exports?module.exports=ze():Wr.htmx=Wr.htmx||ze()})(typeof self<"u"?self:htmx_min$2,function(){return function(){var Q={onLoad:F,process:zt,on:de,off:ge,trigger:ce,ajax:Nr,find:C,findAll:f,closest:v,values:function(Wr,ze){var Gr=dr(Wr,ze||"post");return Gr.values},remove:_,addClass:z,removeClass:n,toggleClass:$,takeClass:W,defineExtension:Ur,removeExtension:Br,logAll:V,logNone:j,logger:null,config:{historyEnabled:!0,historyCacheSize:10,refreshOnHistoryMiss:!1,defaultSwapStyle:"innerHTML",defaultSwapDelay:0,defaultSettleDelay:20,includeIndicatorStyles:!0,indicatorClass:"htmx-indicator",requestClass:"htmx-request",addedClass:"htmx-added",settlingClass:"htmx-settling",swappingClass:"htmx-swapping",allowEval:!0,allowScriptTags:!0,inlineScriptNonce:"",attributesToSettle:["class","style","width","height"],withCredentials:!1,timeout:0,wsReconnectDelay:"full-jitter",wsBinaryType:"blob",disableSelector:"[hx-disable], [data-hx-disable]",useTemplateFragments:!1,scrollBehavior:"smooth",defaultFocusScroll:!1,getCacheBusterParam:!1,globalViewTransitions:!1,methodsThatUseUrlParams:["get"],selfRequestsOnly:!1,ignoreTitle:!1,scrollIntoViewOnBoost:!0,triggerSpecsCache:null},parseInterval:d,_:t,createEventSource:function(Wr){return new EventSource(Wr,{withCredentials:!0})},createWebSocket:function(Wr){var ze=new WebSocket(Wr,[]);return ze.binaryType=Q.config.wsBinaryType,ze},version:"1.9.12"},r={addTriggerHandler:Lt,bodyContains:se,canAccessLocalStorage:U,findThisElement:xe,filterValues:yr,hasAttribute:o,getAttributeValue:te,getClosestAttributeValue:ne,getClosestMatch:c,getExpressionVars:Hr,getHeaders:xr,getInputValues:dr,getInternalData:ae,getSwapSpecification:wr,getTriggerSpecs:it,getTarget:ye,makeFragment:l,mergeObjects:le,makeSettleInfo:T,oobSwap:Ee,querySelectorExt:ue,selectAndSwap:je,settleImmediately:nr,shouldCancel:ut,triggerEvent:ce,triggerErrorEvent:fe,withExtensions:R},w=["get","post","put","delete","patch"],i=w.map(function(Wr){return"[hx-"+Wr+"], [data-hx-"+Wr+"]"}).join(", "),S=e("head"),q=e("title"),H=e("svg",!0);function e(Wr,ze){return new RegExp("<"+Wr+"(\\s[^>]*>|>)([\\s\\S]*?)<\\/"+Wr+">",ze?"gim":"im")}function d(Wr){if(Wr==null)return;let ze=NaN;return Wr.slice(-2)=="ms"?ze=parseFloat(Wr.slice(0,-2)):Wr.slice(-1)=="s"?ze=parseFloat(Wr.slice(0,-1))*1e3:Wr.slice(-1)=="m"?ze=parseFloat(Wr.slice(0,-1))*1e3*60:ze=parseFloat(Wr),isNaN(ze)?void 0:ze}function ee(Wr,ze){return Wr.getAttribute&&Wr.getAttribute(ze)}function o(Wr,ze){return Wr.hasAttribute&&(Wr.hasAttribute(ze)||Wr.hasAttribute("data-"+ze))}function te(Wr,ze){return ee(Wr,ze)||ee(Wr,"data-"+ze)}function u(Wr){return Wr.parentElement}function re(){return document}function c(Wr,ze){for(;Wr&&!ze(Wr);)Wr=u(Wr);return Wr||null}function L(Wr,ze,Gr){var Yr=te(ze,Gr),Kr=te(ze,"hx-disinherit");return Wr!==ze&&Kr&&(Kr==="*"||Kr.split(" ").indexOf(Gr)>=0)?"unset":Yr}function ne(Wr,ze){var Gr=null;if(c(Wr,function(Yr){return Gr=L(Wr,Yr,ze)}),Gr!=="unset")return Gr}function h(Wr,ze){var Gr=Wr.matches||Wr.matchesSelector||Wr.msMatchesSelector||Wr.mozMatchesSelector||Wr.webkitMatchesSelector||Wr.oMatchesSelector;return Gr&&Gr.call(Wr,ze)}function A(Wr){var ze=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,Gr=ze.exec(Wr);return Gr?Gr[1].toLowerCase():""}function s(Wr,ze){for(var Gr=new DOMParser,Yr=Gr.parseFromString(Wr,"text/html"),Kr=Yr.body;ze>0;)ze--,Kr=Kr.firstChild;return Kr==null&&(Kr=re().createDocumentFragment()),Kr}function N(Wr){return/<body/.test(Wr)}function l(Wr){var ze=!N(Wr),Gr=A(Wr),Yr=Wr;if(Gr==="head"&&(Yr=Yr.replace(S,"")),Q.config.useTemplateFragments&&ze){var Kr=s("<body><template>"+Yr+"</template></body>",0),Zr=Kr.querySelector("template").content;return Q.config.allowScriptTags?oe(Zr.querySelectorAll("script"),function(Qr){Q.config.inlineScriptNonce&&(Qr.nonce=Q.config.inlineScriptNonce),Qr.htmxExecuted=navigator.userAgent.indexOf("Firefox")===-1}):oe(Zr.querySelectorAll("script"),function(Qr){_(Qr)}),Zr}switch(Gr){case"thead":case"tbody":case"tfoot":case"colgroup":case"caption":return s("<table>"+Yr+"</table>",1);case"col":return s("<table><colgroup>"+Yr+"</colgroup></table>",2);case"tr":return s("<table><tbody>"+Yr+"</tbody></table>",2);case"td":case"th":return s("<table><tbody><tr>"+Yr+"</tr></tbody></table>",3);case"script":case"style":return s("<div>"+Yr+"</div>",1);default:return s(Yr,0)}}function ie(Wr){Wr&&Wr()}function I(Wr,ze){return Object.prototype.toString.call(Wr)==="[object "+ze+"]"}function k(Wr){return I(Wr,"Function")}function P(Wr){return I(Wr,"Object")}function ae(Wr){var ze="htmx-internal-data",Gr=Wr[ze];return Gr||(Gr=Wr[ze]={}),Gr}function M(Wr){var ze=[];if(Wr)for(var Gr=0;Gr<Wr.length;Gr++)ze.push(Wr[Gr]);return ze}function oe(Wr,ze){if(Wr)for(var Gr=0;Gr<Wr.length;Gr++)ze(Wr[Gr])}function X(Wr){var ze=Wr.getBoundingClientRect(),Gr=ze.top,Yr=ze.bottom;return Gr<window.innerHeight&&Yr>=0}function se(Wr){return Wr.getRootNode&&Wr.getRootNode()instanceof window.ShadowRoot?re().body.contains(Wr.getRootNode().host):re().body.contains(Wr)}function D(Wr){return Wr.trim().split(/\s+/)}function le(Wr,ze){for(var Gr in ze)ze.hasOwnProperty(Gr)&&(Wr[Gr]=ze[Gr]);return Wr}function E(Wr){try{return JSON.parse(Wr)}catch(ze){return b(ze),null}}function U(){var Wr="htmx:localStorageTest";try{return localStorage.setItem(Wr,Wr),localStorage.removeItem(Wr),!0}catch{return!1}}function B(Wr){try{var ze=new URL(Wr);return ze&&(Wr=ze.pathname+ze.search),/^\/$/.test(Wr)||(Wr=Wr.replace(/\/+$/,"")),Wr}catch{return Wr}}function t(e){return Tr(re().body,function(){return eval(e)})}function F(Wr){var ze=Q.on("htmx:load",function(Gr){Wr(Gr.detail.elt)});return ze}function V(){Q.logger=function(Wr,ze,Gr){console&&console.log(ze,Wr,Gr)}}function j(){Q.logger=null}function C(Wr,ze){return ze?Wr.querySelector(ze):C(re(),Wr)}function f(Wr,ze){return ze?Wr.querySelectorAll(ze):f(re(),Wr)}function _(Wr,ze){Wr=p(Wr),ze?setTimeout(function(){_(Wr),Wr=null},ze):Wr.parentElement.removeChild(Wr)}function z(Wr,ze,Gr){Wr=p(Wr),Gr?setTimeout(function(){z(Wr,ze),Wr=null},Gr):Wr.classList&&Wr.classList.add(ze)}function n(Wr,ze,Gr){Wr=p(Wr),Gr?setTimeout(function(){n(Wr,ze),Wr=null},Gr):Wr.classList&&(Wr.classList.remove(ze),Wr.classList.length===0&&Wr.removeAttribute("class"))}function $(Wr,ze){Wr=p(Wr),Wr.classList.toggle(ze)}function W(Wr,ze){Wr=p(Wr),oe(Wr.parentElement.children,function(Gr){n(Gr,ze)}),z(Wr,ze)}function v(Wr,ze){if(Wr=p(Wr),Wr.closest)return Wr.closest(ze);do if(Wr==null||h(Wr,ze))return Wr;while(Wr=Wr&&u(Wr));return null}function g(Wr,ze){return Wr.substring(0,ze.length)===ze}function G(Wr,ze){return Wr.substring(Wr.length-ze.length)===ze}function J(Wr){var ze=Wr.trim();return g(ze,"<")&&G(ze,"/>")?ze.substring(1,ze.length-2):ze}function Z(Wr,ze){return ze.indexOf("closest ")===0?[v(Wr,J(ze.substr(8)))]:ze.indexOf("find ")===0?[C(Wr,J(ze.substr(5)))]:ze==="next"?[Wr.nextElementSibling]:ze.indexOf("next ")===0?[K(Wr,J(ze.substr(5)))]:ze==="previous"?[Wr.previousElementSibling]:ze.indexOf("previous ")===0?[Y(Wr,J(ze.substr(9)))]:ze==="document"?[document]:ze==="window"?[window]:ze==="body"?[document.body]:re().querySelectorAll(J(ze))}var K=function(Wr,ze){for(var Gr=re().querySelectorAll(ze),Yr=0;Yr<Gr.length;Yr++){var Kr=Gr[Yr];if(Kr.compareDocumentPosition(Wr)===Node.DOCUMENT_POSITION_PRECEDING)return Kr}},Y=function(Wr,ze){for(var Gr=re().querySelectorAll(ze),Yr=Gr.length-1;Yr>=0;Yr--){var Kr=Gr[Yr];if(Kr.compareDocumentPosition(Wr)===Node.DOCUMENT_POSITION_FOLLOWING)return Kr}};function ue(Wr,ze){return ze?Z(Wr,ze)[0]:Z(re().body,Wr)[0]}function p(Wr){return I(Wr,"String")?C(Wr):Wr}function ve(Wr,ze,Gr){return k(ze)?{target:re().body,event:Wr,listener:ze}:{target:p(Wr),event:ze,listener:Gr}}function de(Wr,ze,Gr){jr(function(){var Kr=ve(Wr,ze,Gr);Kr.target.addEventListener(Kr.event,Kr.listener)});var Yr=k(ze);return Yr?ze:Gr}function ge(Wr,ze,Gr){return jr(function(){var Yr=ve(Wr,ze,Gr);Yr.target.removeEventListener(Yr.event,Yr.listener)}),k(ze)?ze:Gr}var pe=re().createElement("output");function me(Wr,ze){var Gr=ne(Wr,ze);if(Gr){if(Gr==="this")return[xe(Wr,ze)];var Yr=Z(Wr,Gr);return Yr.length===0?(b('The selector "'+Gr+'" on '+ze+" returned no matches!"),[pe]):Yr}}function xe(Wr,ze){return c(Wr,function(Gr){return te(Gr,ze)!=null})}function ye(Wr){var ze=ne(Wr,"hx-target");if(ze)return ze==="this"?xe(Wr,"hx-target"):ue(Wr,ze);var Gr=ae(Wr);return Gr.boosted?re().body:Wr}function be(Wr){for(var ze=Q.config.attributesToSettle,Gr=0;Gr<ze.length;Gr++)if(Wr===ze[Gr])return!0;return!1}function we(Wr,ze){oe(Wr.attributes,function(Gr){!ze.hasAttribute(Gr.name)&&be(Gr.name)&&Wr.removeAttribute(Gr.name)}),oe(ze.attributes,function(Gr){be(Gr.name)&&Wr.setAttribute(Gr.name,Gr.value)})}function Se(Wr,ze){for(var Gr=Fr(ze),Yr=0;Yr<Gr.length;Yr++){var Kr=Gr[Yr];try{if(Kr.isInlineSwap(Wr))return!0}catch(Zr){b(Zr)}}return Wr==="outerHTML"}function Ee(Wr,ze,Gr){var Yr="#"+ee(ze,"id"),Kr="outerHTML";Wr==="true"||(Wr.indexOf(":")>0?(Kr=Wr.substr(0,Wr.indexOf(":")),Yr=Wr.substr(Wr.indexOf(":")+1,Wr.length)):Kr=Wr);var Zr=re().querySelectorAll(Yr);return Zr?(oe(Zr,function(Qr){var Jr,ei=ze.cloneNode(!0);Jr=re().createDocumentFragment(),Jr.appendChild(ei),Se(Kr,Qr)||(Jr=ei);var ti={shouldSwap:!0,target:Qr,fragment:Jr};ce(Qr,"htmx:oobBeforeSwap",ti)&&(Qr=ti.target,ti.shouldSwap&&Fe(Kr,Qr,Qr,Jr,Gr),oe(Gr.elts,function(ri){ce(ri,"htmx:oobAfterSwap",ti)}))}),ze.parentNode.removeChild(ze)):(ze.parentNode.removeChild(ze),fe(re().body,"htmx:oobErrorNoTarget",{content:ze})),Wr}function Ce(Wr,ze,Gr){var Yr=ne(Wr,"hx-select-oob");if(Yr)for(var Kr=Yr.split(","),Zr=0;Zr<Kr.length;Zr++){var Qr=Kr[Zr].split(":",2),Jr=Qr[0].trim();Jr.indexOf("#")===0&&(Jr=Jr.substring(1));var ei=Qr[1]||"true",ti=ze.querySelector("#"+Jr);ti&&Ee(ei,ti,Gr)}oe(f(ze,"[hx-swap-oob], [data-hx-swap-oob]"),function(ri){var ii=te(ri,"hx-swap-oob");ii!=null&&Ee(ii,ri,Gr)})}function Re(Wr){oe(f(Wr,"[hx-preserve], [data-hx-preserve]"),function(ze){var Gr=te(ze,"id"),Yr=re().getElementById(Gr);Yr!=null&&ze.parentNode.replaceChild(Yr,ze)})}function Te(Wr,ze,Gr){oe(ze.querySelectorAll("[id]"),function(Yr){var Kr=ee(Yr,"id");if(Kr&&Kr.length>0){var Zr=Kr.replace("'","\\'"),Qr=Yr.tagName.replace(":","\\:"),Jr=Wr.querySelector(Qr+"[id='"+Zr+"']");if(Jr&&Jr!==Wr){var ei=Yr.cloneNode();we(Yr,Jr),Gr.tasks.push(function(){we(Yr,ei)})}}})}function Oe(Wr){return function(){n(Wr,Q.config.addedClass),zt(Wr),Nt(Wr),qe(Wr),ce(Wr,"htmx:load")}}function qe(Wr){var ze="[autofocus]",Gr=h(Wr,ze)?Wr:Wr.querySelector(ze);Gr!=null&&Gr.focus()}function a(Wr,ze,Gr,Yr){for(Te(Wr,Gr,Yr);Gr.childNodes.length>0;){var Kr=Gr.firstChild;z(Kr,Q.config.addedClass),Wr.insertBefore(Kr,ze),Kr.nodeType!==Node.TEXT_NODE&&Kr.nodeType!==Node.COMMENT_NODE&&Yr.tasks.push(Oe(Kr))}}function He(Wr,ze){for(var Gr=0;Gr<Wr.length;)ze=(ze<<5)-ze+Wr.charCodeAt(Gr++)|0;return ze}function Le(Wr){var ze=0;if(Wr.attributes)for(var Gr=0;Gr<Wr.attributes.length;Gr++){var Yr=Wr.attributes[Gr];Yr.value&&(ze=He(Yr.name,ze),ze=He(Yr.value,ze))}return ze}function Ae(Wr){var ze=ae(Wr);if(ze.onHandlers){for(var Gr=0;Gr<ze.onHandlers.length;Gr++){const Yr=ze.onHandlers[Gr];Wr.removeEventListener(Yr.event,Yr.listener)}delete ze.onHandlers}}function Ne(Wr){var ze=ae(Wr);ze.timeout&&clearTimeout(ze.timeout),ze.webSocket&&ze.webSocket.close(),ze.sseEventSource&&ze.sseEventSource.close(),ze.listenerInfos&&oe(ze.listenerInfos,function(Gr){Gr.on&&Gr.on.removeEventListener(Gr.trigger,Gr.listener)}),Ae(Wr),oe(Object.keys(ze),function(Gr){delete ze[Gr]})}function m(Wr){ce(Wr,"htmx:beforeCleanupElement"),Ne(Wr),Wr.children&&oe(Wr.children,function(ze){m(ze)})}function Ie(Wr,ze,Gr){if(Wr.tagName==="BODY")return Ue(Wr,ze,Gr);var Yr,Kr=Wr.previousSibling;for(a(u(Wr),Wr,ze,Gr),Kr==null?Yr=u(Wr).firstChild:Yr=Kr.nextSibling,Gr.elts=Gr.elts.filter(function(Zr){return Zr!=Wr});Yr&&Yr!==Wr;)Yr.nodeType===Node.ELEMENT_NODE&&Gr.elts.push(Yr),Yr=Yr.nextElementSibling;m(Wr),u(Wr).removeChild(Wr)}function ke(Wr,ze,Gr){return a(Wr,Wr.firstChild,ze,Gr)}function Pe(Wr,ze,Gr){return a(u(Wr),Wr,ze,Gr)}function Me(Wr,ze,Gr){return a(Wr,null,ze,Gr)}function Xe(Wr,ze,Gr){return a(u(Wr),Wr.nextSibling,ze,Gr)}function De(Wr,ze,Gr){return m(Wr),u(Wr).removeChild(Wr)}function Ue(Wr,ze,Gr){var Yr=Wr.firstChild;if(a(Wr,Yr,ze,Gr),Yr){for(;Yr.nextSibling;)m(Yr.nextSibling),Wr.removeChild(Yr.nextSibling);m(Yr),Wr.removeChild(Yr)}}function Be(Wr,ze,Gr){var Yr=Gr||ne(Wr,"hx-select");if(Yr){var Kr=re().createDocumentFragment();oe(ze.querySelectorAll(Yr),function(Zr){Kr.appendChild(Zr)}),ze=Kr}return ze}function Fe(Wr,ze,Gr,Yr,Kr){switch(Wr){case"none":return;case"outerHTML":Ie(Gr,Yr,Kr);return;case"afterbegin":ke(Gr,Yr,Kr);return;case"beforebegin":Pe(Gr,Yr,Kr);return;case"beforeend":Me(Gr,Yr,Kr);return;case"afterend":Xe(Gr,Yr,Kr);return;case"delete":De(Gr);return;default:for(var Zr=Fr(ze),Qr=0;Qr<Zr.length;Qr++){var Jr=Zr[Qr];try{var ei=Jr.handleSwap(Wr,Gr,Yr,Kr);if(ei){if(typeof ei.length<"u")for(var ti=0;ti<ei.length;ti++){var ri=ei[ti];ri.nodeType!==Node.TEXT_NODE&&ri.nodeType!==Node.COMMENT_NODE&&Kr.tasks.push(Oe(ri))}return}}catch(ii){b(ii)}}Wr==="innerHTML"?Ue(Gr,Yr,Kr):Fe(Q.config.defaultSwapStyle,ze,Gr,Yr,Kr)}}function Ve(Wr){if(Wr.indexOf("<title")>-1){var ze=Wr.replace(H,""),Gr=ze.match(q);if(Gr)return Gr[2]}}function je(Wr,ze,Gr,Yr,Kr,Zr){Kr.title=Ve(Yr);var Qr=l(Yr);if(Qr)return Ce(Gr,Qr,Kr),Qr=Be(Gr,Qr,Zr),Re(Qr),Fe(Wr,Gr,ze,Qr,Kr)}function _e(Wr,ze,Gr){var Yr=Wr.getResponseHeader(ze);if(Yr.indexOf("{")===0){var Kr=E(Yr);for(var Zr in Kr)if(Kr.hasOwnProperty(Zr)){var Qr=Kr[Zr];P(Qr)||(Qr={value:Qr}),ce(Gr,Zr,Qr)}}else for(var Jr=Yr.split(","),ei=0;ei<Jr.length;ei++)ce(Gr,Jr[ei].trim(),[])}var x=/[\s,]/,$e=/[_$a-zA-Z]/,We=/[_$a-zA-Z0-9]/,Ge=['"',"'","/"],Je=/[^\s]/,Ze=/[{(]/,Ke=/[})]/;function Ye(Wr){for(var ze=[],Gr=0;Gr<Wr.length;){if($e.exec(Wr.charAt(Gr))){for(var Yr=Gr;We.exec(Wr.charAt(Gr+1));)Gr++;ze.push(Wr.substr(Yr,Gr-Yr+1))}else if(Ge.indexOf(Wr.charAt(Gr))!==-1){var Kr=Wr.charAt(Gr),Yr=Gr;for(Gr++;Gr<Wr.length&&Wr.charAt(Gr)!==Kr;)Wr.charAt(Gr)==="\\"&&Gr++,Gr++;ze.push(Wr.substr(Yr,Gr-Yr+1))}else{var Zr=Wr.charAt(Gr);ze.push(Zr)}Gr++}return ze}function Qe(Wr,ze,Gr){return $e.exec(Wr.charAt(0))&&Wr!=="true"&&Wr!=="false"&&Wr!=="this"&&Wr!==Gr&&ze!=="."}function et(Wr,ze,Gr){if(ze[0]==="["){ze.shift();for(var Yr=1,Kr=" return (function("+Gr+"){ return (",Zr=null;ze.length>0;){var Qr=ze[0];if(Qr==="]"){if(Yr--,Yr===0){Zr===null&&(Kr=Kr+"true"),ze.shift(),Kr+=")})";try{var Jr=Tr(Wr,function(){return Function(Kr)()},function(){return!0});return Jr.source=Kr,Jr}catch(ei){return fe(re().body,"htmx:syntax:error",{error:ei,source:Kr}),null}}}else Qr==="["&&Yr++;Qe(Qr,Zr,Gr)?Kr+="(("+Gr+"."+Qr+") ? ("+Gr+"."+Qr+") : (window."+Qr+"))":Kr=Kr+Qr,Zr=ze.shift()}}}function y(Wr,ze){for(var Gr="";Wr.length>0&&!ze.test(Wr[0]);)Gr+=Wr.shift();return Gr}function tt(Wr){var ze;return Wr.length>0&&Ze.test(Wr[0])?(Wr.shift(),ze=y(Wr,Ke).trim(),Wr.shift()):ze=y(Wr,x),ze}var rt="input, textarea, select";function nt(Wr,ze,Gr){var Yr=[],Kr=Ye(ze);do{y(Kr,Je);var Zr=Kr.length,Qr=y(Kr,/[,\[\s]/);if(Qr!=="")if(Qr==="every"){var Jr={trigger:"every"};y(Kr,Je),Jr.pollInterval=d(y(Kr,/[,\[\s]/)),y(Kr,Je);var ei=et(Wr,Kr,"event");ei&&(Jr.eventFilter=ei),Yr.push(Jr)}else if(Qr.indexOf("sse:")===0)Yr.push({trigger:"sse",sseEvent:Qr.substr(4)});else{var ti={trigger:Qr},ei=et(Wr,Kr,"event");for(ei&&(ti.eventFilter=ei);Kr.length>0&&Kr[0]!==",";){y(Kr,Je);var ri=Kr.shift();if(ri==="changed")ti.changed=!0;else if(ri==="once")ti.once=!0;else if(ri==="consume")ti.consume=!0;else if(ri==="delay"&&Kr[0]===":")Kr.shift(),ti.delay=d(y(Kr,x));else if(ri==="from"&&Kr[0]===":"){if(Kr.shift(),Ze.test(Kr[0]))var ii=tt(Kr);else{var ii=y(Kr,x);if(ii==="closest"||ii==="find"||ii==="next"||ii==="previous"){Kr.shift();var si=tt(Kr);si.length>0&&(ii+=" "+si)}}ti.from=ii}else ri==="target"&&Kr[0]===":"?(Kr.shift(),ti.target=tt(Kr)):ri==="throttle"&&Kr[0]===":"?(Kr.shift(),ti.throttle=d(y(Kr,x))):ri==="queue"&&Kr[0]===":"?(Kr.shift(),ti.queue=y(Kr,x)):ri==="root"&&Kr[0]===":"?(Kr.shift(),ti[ri]=tt(Kr)):ri==="threshold"&&Kr[0]===":"?(Kr.shift(),ti[ri]=y(Kr,x)):fe(Wr,"htmx:syntax:error",{token:Kr.shift()})}Yr.push(ti)}Kr.length===Zr&&fe(Wr,"htmx:syntax:error",{token:Kr.shift()}),y(Kr,Je)}while(Kr[0]===","&&Kr.shift());return Gr&&(Gr[ze]=Yr),Yr}function it(Wr){var ze=te(Wr,"hx-trigger"),Gr=[];if(ze){var Yr=Q.config.triggerSpecsCache;Gr=Yr&&Yr[ze]||nt(Wr,ze,Yr)}return Gr.length>0?Gr:h(Wr,"form")?[{trigger:"submit"}]:h(Wr,'input[type="button"], input[type="submit"]')?[{trigger:"click"}]:h(Wr,rt)?[{trigger:"change"}]:[{trigger:"click"}]}function at(Wr){ae(Wr).cancelled=!0}function ot(Wr,ze,Gr){var Yr=ae(Wr);Yr.timeout=setTimeout(function(){se(Wr)&&Yr.cancelled!==!0&&(ct(Gr,Wr,Wt("hx:poll:trigger",{triggerSpec:Gr,target:Wr}))||ze(Wr),ot(Wr,ze,Gr))},Gr.pollInterval)}function st(Wr){return location.hostname===Wr.hostname&&ee(Wr,"href")&&ee(Wr,"href").indexOf("#")!==0}function lt(Wr,ze,Gr){if(Wr.tagName==="A"&&st(Wr)&&(Wr.target===""||Wr.target==="_self")||Wr.tagName==="FORM"){ze.boosted=!0;var Yr,Kr;if(Wr.tagName==="A")Yr="get",Kr=ee(Wr,"href");else{var Zr=ee(Wr,"method");Yr=Zr?Zr.toLowerCase():"get",Kr=ee(Wr,"action")}Gr.forEach(function(Qr){ht(Wr,function(Jr,ei){if(v(Jr,Q.config.disableSelector)){m(Jr);return}he(Yr,Kr,Jr,ei)},ze,Qr,!0)})}}function ut(Wr,ze){return!!((Wr.type==="submit"||Wr.type==="click")&&(ze.tagName==="FORM"||h(ze,'input[type="submit"], button')&&v(ze,"form")!==null||ze.tagName==="A"&&ze.href&&(ze.getAttribute("href")==="#"||ze.getAttribute("href").indexOf("#")!==0)))}function ft(Wr,ze){return ae(Wr).boosted&&Wr.tagName==="A"&&ze.type==="click"&&(ze.ctrlKey||ze.metaKey)}function ct(Wr,ze,Gr){var Yr=Wr.eventFilter;if(Yr)try{return Yr.call(ze,Gr)!==!0}catch(Kr){return fe(re().body,"htmx:eventFilter:error",{error:Kr,source:Yr.source}),!0}return!1}function ht(Wr,ze,Gr,Yr,Kr){var Zr=ae(Wr),Qr;Yr.from?Qr=Z(Wr,Yr.from):Qr=[Wr],Yr.changed&&Qr.forEach(function(Jr){var ei=ae(Jr);ei.lastValue=Jr.value}),oe(Qr,function(Jr){var ei=function(ti){if(!se(Wr)){Jr.removeEventListener(Yr.trigger,ei);return}if(!ft(Wr,ti)&&((Kr||ut(ti,Wr))&&ti.preventDefault(),!ct(Yr,Wr,ti))){var ri=ae(ti);if(ri.triggerSpec=Yr,ri.handledFor==null&&(ri.handledFor=[]),ri.handledFor.indexOf(Wr)<0){if(ri.handledFor.push(Wr),Yr.consume&&ti.stopPropagation(),Yr.target&&ti.target&&!h(ti.target,Yr.target))return;if(Yr.once){if(Zr.triggeredOnce)return;Zr.triggeredOnce=!0}if(Yr.changed){var ii=ae(Jr);if(ii.lastValue===Jr.value)return;ii.lastValue=Jr.value}if(Zr.delayed&&clearTimeout(Zr.delayed),Zr.throttle)return;Yr.throttle>0?Zr.throttle||(ze(Wr,ti),Zr.throttle=setTimeout(function(){Zr.throttle=null},Yr.throttle)):Yr.delay>0?Zr.delayed=setTimeout(function(){ze(Wr,ti)},Yr.delay):(ce(Wr,"htmx:trigger"),ze(Wr,ti))}}};Gr.listenerInfos==null&&(Gr.listenerInfos=[]),Gr.listenerInfos.push({trigger:Yr.trigger,listener:ei,on:Jr}),Jr.addEventListener(Yr.trigger,ei)})}var vt=!1,dt=null;function gt(){dt||(dt=function(){vt=!0},window.addEventListener("scroll",dt),setInterval(function(){vt&&(vt=!1,oe(re().querySelectorAll("[hx-trigger='revealed'],[data-hx-trigger='revealed']"),function(Wr){pt(Wr)}))},200))}function pt(Wr){if(!o(Wr,"data-hx-revealed")&&X(Wr)){Wr.setAttribute("data-hx-revealed","true");var ze=ae(Wr);ze.initHash?ce(Wr,"revealed"):Wr.addEventListener("htmx:afterProcessNode",function(Gr){ce(Wr,"revealed")},{once:!0})}}function mt(Wr,ze,Gr){for(var Yr=D(Gr),Kr=0;Kr<Yr.length;Kr++){var Zr=Yr[Kr].split(/:(.+)/);Zr[0]==="connect"&&xt(Wr,Zr[1],0),Zr[0]==="send"&&bt(Wr)}}function xt(Wr,ze,Gr){if(se(Wr)){if(ze.indexOf("/")==0){var Yr=location.hostname+(location.port?":"+location.port:"");location.protocol=="https:"?ze="wss://"+Yr+ze:location.protocol=="http:"&&(ze="ws://"+Yr+ze)}var Kr=Q.createWebSocket(ze);Kr.onerror=function(Zr){fe(Wr,"htmx:wsError",{error:Zr,socket:Kr}),yt(Wr)},Kr.onclose=function(Zr){if([1006,1012,1013].indexOf(Zr.code)>=0){var Qr=wt(Gr);setTimeout(function(){xt(Wr,ze,Gr+1)},Qr)}},Kr.onopen=function(Zr){Gr=0},ae(Wr).webSocket=Kr,Kr.addEventListener("message",function(Zr){if(!yt(Wr)){var Qr=Zr.data;R(Wr,function(si){Qr=si.transformResponse(Qr,null,Wr)});for(var Jr=T(Wr),ei=l(Qr),ti=M(ei.children),ri=0;ri<ti.length;ri++){var ii=ti[ri];Ee(te(ii,"hx-swap-oob")||"true",ii,Jr)}nr(Jr.tasks)}})}}function yt(Wr){if(!se(Wr))return ae(Wr).webSocket.close(),!0}function bt(Wr){var ze=c(Wr,function(Gr){return ae(Gr).webSocket!=null});ze?Wr.addEventListener(it(Wr)[0].trigger,function(Gr){var Yr=ae(ze).webSocket,Kr=xr(Wr,ze),Zr=dr(Wr,"post"),Qr=Zr.errors,Jr=Zr.values,ei=Hr(Wr),ti=le(Jr,ei),ri=yr(ti,Wr);if(ri.HEADERS=Kr,Qr&&Qr.length>0){ce(Wr,"htmx:validation:halted",Qr);return}Yr.send(JSON.stringify(ri)),ut(Gr,Wr)&&Gr.preventDefault()}):fe(Wr,"htmx:noWebSocketSourceError")}function wt(Wr){var ze=Q.config.wsReconnectDelay;if(typeof ze=="function")return ze(Wr);if(ze==="full-jitter"){var Gr=Math.min(Wr,6),Yr=1e3*Math.pow(2,Gr);return Yr*Math.random()}b('htmx.config.wsReconnectDelay must either be a function or the string "full-jitter"')}function St(Wr,ze,Gr){for(var Yr=D(Gr),Kr=0;Kr<Yr.length;Kr++){var Zr=Yr[Kr].split(/:(.+)/);Zr[0]==="connect"&&Et(Wr,Zr[1]),Zr[0]==="swap"&&Ct(Wr,Zr[1])}}function Et(Wr,ze){var Gr=Q.createEventSource(ze);Gr.onerror=function(Yr){fe(Wr,"htmx:sseError",{error:Yr,source:Gr}),Tt(Wr)},ae(Wr).sseEventSource=Gr}function Ct(Wr,ze){var Gr=c(Wr,Ot);if(Gr){var Yr=ae(Gr).sseEventSource,Kr=function(Zr){if(!Tt(Gr)){if(!se(Wr)){Yr.removeEventListener(ze,Kr);return}var Qr=Zr.data;R(Wr,function(ri){Qr=ri.transformResponse(Qr,null,Wr)});var Jr=wr(Wr),ei=ye(Wr),ti=T(Wr);je(Jr.swapStyle,ei,Wr,Qr,ti),nr(ti.tasks),ce(Wr,"htmx:sseMessage",Zr)}};ae(Wr).sseListener=Kr,Yr.addEventListener(ze,Kr)}else fe(Wr,"htmx:noSSESourceError")}function Rt(Wr,ze,Gr){var Yr=c(Wr,Ot);if(Yr){var Kr=ae(Yr).sseEventSource,Zr=function(){Tt(Yr)||(se(Wr)?ze(Wr):Kr.removeEventListener(Gr,Zr))};ae(Wr).sseListener=Zr,Kr.addEventListener(Gr,Zr)}else fe(Wr,"htmx:noSSESourceError")}function Tt(Wr){if(!se(Wr))return ae(Wr).sseEventSource.close(),!0}function Ot(Wr){return ae(Wr).sseEventSource!=null}function qt(Wr,ze,Gr,Yr){var Kr=function(){Gr.loaded||(Gr.loaded=!0,ze(Wr))};Yr>0?setTimeout(Kr,Yr):Kr()}function Ht(Wr,ze,Gr){var Yr=!1;return oe(w,function(Kr){if(o(Wr,"hx-"+Kr)){var Zr=te(Wr,"hx-"+Kr);Yr=!0,ze.path=Zr,ze.verb=Kr,Gr.forEach(function(Qr){Lt(Wr,Qr,ze,function(Jr,ei){if(v(Jr,Q.config.disableSelector)){m(Jr);return}he(Kr,Zr,Jr,ei)})})}}),Yr}function Lt(Wr,ze,Gr,Yr){if(ze.sseEvent)Rt(Wr,Yr,ze.sseEvent);else if(ze.trigger==="revealed")gt(),ht(Wr,Yr,Gr,ze),pt(Wr);else if(ze.trigger==="intersect"){var Kr={};ze.root&&(Kr.root=ue(Wr,ze.root)),ze.threshold&&(Kr.threshold=parseFloat(ze.threshold));var Zr=new IntersectionObserver(function(Qr){for(var Jr=0;Jr<Qr.length;Jr++){var ei=Qr[Jr];if(ei.isIntersecting){ce(Wr,"intersect");break}}},Kr);Zr.observe(Wr),ht(Wr,Yr,Gr,ze)}else ze.trigger==="load"?ct(ze,Wr,Wt("load",{elt:Wr}))||qt(Wr,Yr,Gr,ze.delay):ze.pollInterval>0?(Gr.polling=!0,ot(Wr,Yr,ze)):ht(Wr,Yr,Gr,ze)}function At(Wr){if(!Wr.htmxExecuted&&Q.config.allowScriptTags&&(Wr.type==="text/javascript"||Wr.type==="module"||Wr.type==="")){var ze=re().createElement("script");oe(Wr.attributes,function(Yr){ze.setAttribute(Yr.name,Yr.value)}),ze.textContent=Wr.textContent,ze.async=!1,Q.config.inlineScriptNonce&&(ze.nonce=Q.config.inlineScriptNonce);var Gr=Wr.parentElement;try{Gr.insertBefore(ze,Wr)}catch(Yr){b(Yr)}finally{Wr.parentElement&&Wr.parentElement.removeChild(Wr)}}}function Nt(Wr){h(Wr,"script")&&At(Wr),oe(f(Wr,"script"),function(ze){At(ze)})}function It(Wr){var ze=Wr.attributes;if(!ze)return!1;for(var Gr=0;Gr<ze.length;Gr++){var Yr=ze[Gr].name;if(g(Yr,"hx-on:")||g(Yr,"data-hx-on:")||g(Yr,"hx-on-")||g(Yr,"data-hx-on-"))return!0}return!1}function kt(Wr){var ze=null,Gr=[];if(It(Wr)&&Gr.push(Wr),document.evaluate)for(var Yr=document.evaluate('.//*[@*[ starts-with(name(), "hx-on:") or starts-with(name(), "data-hx-on:") or starts-with(name(), "hx-on-") or starts-with(name(), "data-hx-on-") ]]',Wr);ze=Yr.iterateNext();)Gr.push(ze);else if(typeof Wr.getElementsByTagName=="function")for(var Kr=Wr.getElementsByTagName("*"),Zr=0;Zr<Kr.length;Zr++)It(Kr[Zr])&&Gr.push(Kr[Zr]);return Gr}function Pt(Wr){if(Wr.querySelectorAll){var ze=", [hx-boost] a, [data-hx-boost] a, a[hx-boost], a[data-hx-boost]",Gr=Wr.querySelectorAll(i+ze+", form, [type='submit'], [hx-sse], [data-hx-sse], [hx-ws], [data-hx-ws], [hx-ext], [data-hx-ext], [hx-trigger], [data-hx-trigger], [hx-on], [data-hx-on]");return Gr}else return[]}function Mt(Wr){var ze=v(Wr.target,"button, input[type='submit']"),Gr=Dt(Wr);Gr&&(Gr.lastButtonClicked=ze)}function Xt(Wr){var ze=Dt(Wr);ze&&(ze.lastButtonClicked=null)}function Dt(Wr){var ze=v(Wr.target,"button, input[type='submit']");if(ze){var Gr=p("#"+ee(ze,"form"))||v(ze,"form");if(Gr)return ae(Gr)}}function Ut(Wr){Wr.addEventListener("click",Mt),Wr.addEventListener("focusin",Mt),Wr.addEventListener("focusout",Xt)}function Bt(Wr){for(var ze=Ye(Wr),Gr=0,Yr=0;Yr<ze.length;Yr++){const Kr=ze[Yr];Kr==="{"?Gr++:Kr==="}"&&Gr--}return Gr}function Ft(Wr,ze,Gr){var Yr=ae(Wr);Array.isArray(Yr.onHandlers)||(Yr.onHandlers=[]);var Kr,Zr=function(Qr){return Tr(Wr,function(){Kr||(Kr=new Function("event",Gr)),Kr.call(Wr,Qr)})};Wr.addEventListener(ze,Zr),Yr.onHandlers.push({event:ze,listener:Zr})}function Vt(Wr){var ze=te(Wr,"hx-on");if(ze){for(var Gr={},Yr=ze.split(`
`),Kr=null,Zr=0;Yr.length>0;){var Qr=Yr.shift(),Jr=Qr.match(/^\s*([a-zA-Z:\-\.]+:)(.*)/);Zr===0&&Jr?(Qr.split(":"),Kr=Jr[1].slice(0,-1),Gr[Kr]=Jr[2]):Gr[Kr]+=Qr,Zr+=Bt(Qr)}for(var ei in Gr)Ft(Wr,ei,Gr[ei])}}function jt(Wr){Ae(Wr);for(var ze=0;ze<Wr.attributes.length;ze++){var Gr=Wr.attributes[ze].name,Yr=Wr.attributes[ze].value;if(g(Gr,"hx-on")||g(Gr,"data-hx-on")){var Kr=Gr.indexOf("-on")+3,Zr=Gr.slice(Kr,Kr+1);if(Zr==="-"||Zr===":"){var Qr=Gr.slice(Kr+1);g(Qr,":")?Qr="htmx"+Qr:g(Qr,"-")?Qr="htmx:"+Qr.slice(1):g(Qr,"htmx-")&&(Qr="htmx:"+Qr.slice(5)),Ft(Wr,Qr,Yr)}}}}function _t(Wr){if(v(Wr,Q.config.disableSelector)){m(Wr);return}var ze=ae(Wr);if(ze.initHash!==Le(Wr)){Ne(Wr),ze.initHash=Le(Wr),Vt(Wr),ce(Wr,"htmx:beforeProcessNode"),Wr.value&&(ze.lastValue=Wr.value);var Gr=it(Wr),Yr=Ht(Wr,ze,Gr);Yr||(ne(Wr,"hx-boost")==="true"?lt(Wr,ze,Gr):o(Wr,"hx-trigger")&&Gr.forEach(function(Qr){Lt(Wr,Qr,ze,function(){})})),(Wr.tagName==="FORM"||ee(Wr,"type")==="submit"&&o(Wr,"form"))&&Ut(Wr);var Kr=te(Wr,"hx-sse");Kr&&St(Wr,ze,Kr);var Zr=te(Wr,"hx-ws");Zr&&mt(Wr,ze,Zr),ce(Wr,"htmx:afterProcessNode")}}function zt(Wr){if(Wr=p(Wr),v(Wr,Q.config.disableSelector)){m(Wr);return}_t(Wr),oe(Pt(Wr),function(ze){_t(ze)}),oe(kt(Wr),jt)}function $t(Wr){return Wr.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase()}function Wt(Wr,ze){var Gr;return window.CustomEvent&&typeof window.CustomEvent=="function"?Gr=new CustomEvent(Wr,{bubbles:!0,cancelable:!0,detail:ze}):(Gr=re().createEvent("CustomEvent"),Gr.initCustomEvent(Wr,!0,!0,ze)),Gr}function fe(Wr,ze,Gr){ce(Wr,ze,le({error:ze},Gr))}function Gt(Wr){return Wr==="htmx:afterProcessNode"}function R(Wr,ze){oe(Fr(Wr),function(Gr){try{ze(Gr)}catch(Yr){b(Yr)}})}function b(Wr){console.error?console.error(Wr):console.log&&console.log("ERROR: ",Wr)}function ce(Wr,ze,Gr){Wr=p(Wr),Gr==null&&(Gr={}),Gr.elt=Wr;var Yr=Wt(ze,Gr);Q.logger&&!Gt(ze)&&Q.logger(Wr,ze,Gr),Gr.error&&(b(Gr.error),ce(Wr,"htmx:error",{errorInfo:Gr}));var Kr=Wr.dispatchEvent(Yr),Zr=$t(ze);if(Kr&&Zr!==ze){var Qr=Wt(Zr,Yr.detail);Kr=Kr&&Wr.dispatchEvent(Qr)}return R(Wr,function(Jr){Kr=Kr&&Jr.onEvent(ze,Yr)!==!1&&!Yr.defaultPrevented}),Kr}var Jt=location.pathname+location.search;function Zt(){var Wr=re().querySelector("[hx-history-elt],[data-hx-history-elt]");return Wr||re().body}function Kt(Wr,ze,Gr,Yr){if(U()){if(Q.config.historyCacheSize<=0){localStorage.removeItem("htmx-history-cache");return}Wr=B(Wr);for(var Kr=E(localStorage.getItem("htmx-history-cache"))||[],Zr=0;Zr<Kr.length;Zr++)if(Kr[Zr].url===Wr){Kr.splice(Zr,1);break}var Qr={url:Wr,content:ze,title:Gr,scroll:Yr};for(ce(re().body,"htmx:historyItemCreated",{item:Qr,cache:Kr}),Kr.push(Qr);Kr.length>Q.config.historyCacheSize;)Kr.shift();for(;Kr.length>0;)try{localStorage.setItem("htmx-history-cache",JSON.stringify(Kr));break}catch(Jr){fe(re().body,"htmx:historyCacheError",{cause:Jr,cache:Kr}),Kr.shift()}}}function Yt(Wr){if(!U())return null;Wr=B(Wr);for(var ze=E(localStorage.getItem("htmx-history-cache"))||[],Gr=0;Gr<ze.length;Gr++)if(ze[Gr].url===Wr)return ze[Gr];return null}function Qt(Wr){var ze=Q.config.requestClass,Gr=Wr.cloneNode(!0);return oe(f(Gr,"."+ze),function(Yr){n(Yr,ze)}),Gr.innerHTML}function er(){var Wr=Zt(),ze=Jt||location.pathname+location.search,Gr;try{Gr=re().querySelector('[hx-history="false" i],[data-hx-history="false" i]')}catch{Gr=re().querySelector('[hx-history="false"],[data-hx-history="false"]')}Gr||(ce(re().body,"htmx:beforeHistorySave",{path:ze,historyElt:Wr}),Kt(ze,Qt(Wr),re().title,window.scrollY)),Q.config.historyEnabled&&history.replaceState({htmx:!0},re().title,window.location.href)}function tr(Wr){Q.config.getCacheBusterParam&&(Wr=Wr.replace(/org\.htmx\.cache-buster=[^&]*&?/,""),(G(Wr,"&")||G(Wr,"?"))&&(Wr=Wr.slice(0,-1))),Q.config.historyEnabled&&history.pushState({htmx:!0},"",Wr),Jt=Wr}function rr(Wr){Q.config.historyEnabled&&history.replaceState({htmx:!0},"",Wr),Jt=Wr}function nr(Wr){oe(Wr,function(ze){ze.call()})}function ir(Wr){var ze=new XMLHttpRequest,Gr={path:Wr,xhr:ze};ce(re().body,"htmx:historyCacheMiss",Gr),ze.open("GET",Wr,!0),ze.setRequestHeader("HX-Request","true"),ze.setRequestHeader("HX-History-Restore-Request","true"),ze.setRequestHeader("HX-Current-URL",re().location.href),ze.onload=function(){if(this.status>=200&&this.status<400){ce(re().body,"htmx:historyCacheMissLoad",Gr);var Yr=l(this.response);Yr=Yr.querySelector("[hx-history-elt],[data-hx-history-elt]")||Yr;var Kr=Zt(),Zr=T(Kr),Qr=Ve(this.response);if(Qr){var Jr=C("title");Jr?Jr.innerHTML=Qr:window.document.title=Qr}Ue(Kr,Yr,Zr),nr(Zr.tasks),Jt=Wr,ce(re().body,"htmx:historyRestore",{path:Wr,cacheMiss:!0,serverResponse:this.response})}else fe(re().body,"htmx:historyCacheMissLoadError",Gr)},ze.send()}function ar(Wr){er(),Wr=Wr||location.pathname+location.search;var ze=Yt(Wr);if(ze){var Gr=l(ze.content),Yr=Zt(),Kr=T(Yr);Ue(Yr,Gr,Kr),nr(Kr.tasks),document.title=ze.title,setTimeout(function(){window.scrollTo(0,ze.scroll)},0),Jt=Wr,ce(re().body,"htmx:historyRestore",{path:Wr,item:ze})}else Q.config.refreshOnHistoryMiss?window.location.reload(!0):ir(Wr)}function or(Wr){var ze=me(Wr,"hx-indicator");return ze==null&&(ze=[Wr]),oe(ze,function(Gr){var Yr=ae(Gr);Yr.requestCount=(Yr.requestCount||0)+1,Gr.classList.add.call(Gr.classList,Q.config.requestClass)}),ze}function sr(Wr){var ze=me(Wr,"hx-disabled-elt");return ze==null&&(ze=[]),oe(ze,function(Gr){var Yr=ae(Gr);Yr.requestCount=(Yr.requestCount||0)+1,Gr.setAttribute("disabled","")}),ze}function lr(Wr,ze){oe(Wr,function(Gr){var Yr=ae(Gr);Yr.requestCount=(Yr.requestCount||0)-1,Yr.requestCount===0&&Gr.classList.remove.call(Gr.classList,Q.config.requestClass)}),oe(ze,function(Gr){var Yr=ae(Gr);Yr.requestCount=(Yr.requestCount||0)-1,Yr.requestCount===0&&Gr.removeAttribute("disabled")})}function ur(Wr,ze){for(var Gr=0;Gr<Wr.length;Gr++){var Yr=Wr[Gr];if(Yr.isSameNode(ze))return!0}return!1}function fr(Wr){return Wr.name===""||Wr.name==null||Wr.disabled||v(Wr,"fieldset[disabled]")||Wr.type==="button"||Wr.type==="submit"||Wr.tagName==="image"||Wr.tagName==="reset"||Wr.tagName==="file"?!1:Wr.type==="checkbox"||Wr.type==="radio"?Wr.checked:!0}function cr(Wr,ze,Gr){if(Wr!=null&&ze!=null){var Yr=Gr[Wr];Yr===void 0?Gr[Wr]=ze:Array.isArray(Yr)?Array.isArray(ze)?Gr[Wr]=Yr.concat(ze):Yr.push(ze):Array.isArray(ze)?Gr[Wr]=[Yr].concat(ze):Gr[Wr]=[Yr,ze]}}function hr(Wr,ze,Gr,Yr,Kr){if(!(Yr==null||ur(Wr,Yr))){if(Wr.push(Yr),fr(Yr)){var Zr=ee(Yr,"name"),Qr=Yr.value;Yr.multiple&&Yr.tagName==="SELECT"&&(Qr=M(Yr.querySelectorAll("option:checked")).map(function(ei){return ei.value})),Yr.files&&(Qr=M(Yr.files)),cr(Zr,Qr,ze),Kr&&vr(Yr,Gr)}if(h(Yr,"form")){var Jr=Yr.elements;oe(Jr,function(ei){hr(Wr,ze,Gr,ei,Kr)})}}}function vr(Wr,ze){Wr.willValidate&&(ce(Wr,"htmx:validation:validate"),Wr.checkValidity()||(ze.push({elt:Wr,message:Wr.validationMessage,validity:Wr.validity}),ce(Wr,"htmx:validation:failed",{message:Wr.validationMessage,validity:Wr.validity})))}function dr(Wr,ze){var Gr=[],Yr={},Kr={},Zr=[],Qr=ae(Wr);Qr.lastButtonClicked&&!se(Qr.lastButtonClicked)&&(Qr.lastButtonClicked=null);var Jr=h(Wr,"form")&&Wr.noValidate!==!0||te(Wr,"hx-validate")==="true";if(Qr.lastButtonClicked&&(Jr=Jr&&Qr.lastButtonClicked.formNoValidate!==!0),ze!=="get"&&hr(Gr,Kr,Zr,v(Wr,"form"),Jr),hr(Gr,Yr,Zr,Wr,Jr),Qr.lastButtonClicked||Wr.tagName==="BUTTON"||Wr.tagName==="INPUT"&&ee(Wr,"type")==="submit"){var ei=Qr.lastButtonClicked||Wr,ti=ee(ei,"name");cr(ti,ei.value,Kr)}var ri=me(Wr,"hx-include");return oe(ri,function(ii){hr(Gr,Yr,Zr,ii,Jr),h(ii,"form")||oe(ii.querySelectorAll(rt),function(si){hr(Gr,Yr,Zr,si,Jr)})}),Yr=le(Yr,Kr),{errors:Zr,values:Yr}}function gr(Wr,ze,Gr){Wr!==""&&(Wr+="&"),String(Gr)==="[object Object]"&&(Gr=JSON.stringify(Gr));var Yr=encodeURIComponent(Gr);return Wr+=encodeURIComponent(ze)+"="+Yr,Wr}function pr(Wr){var ze="";for(var Gr in Wr)if(Wr.hasOwnProperty(Gr)){var Yr=Wr[Gr];Array.isArray(Yr)?oe(Yr,function(Kr){ze=gr(ze,Gr,Kr)}):ze=gr(ze,Gr,Yr)}return ze}function mr(Wr){var ze=new FormData;for(var Gr in Wr)if(Wr.hasOwnProperty(Gr)){var Yr=Wr[Gr];Array.isArray(Yr)?oe(Yr,function(Kr){ze.append(Gr,Kr)}):ze.append(Gr,Yr)}return ze}function xr(Wr,ze,Gr){var Yr={"HX-Request":"true","HX-Trigger":ee(Wr,"id"),"HX-Trigger-Name":ee(Wr,"name"),"HX-Target":te(ze,"id"),"HX-Current-URL":re().location.href};return Rr(Wr,"hx-headers",!1,Yr),Gr!==void 0&&(Yr["HX-Prompt"]=Gr),ae(Wr).boosted&&(Yr["HX-Boosted"]="true"),Yr}function yr(Wr,ze){var Gr=ne(ze,"hx-params");if(Gr){if(Gr==="none")return{};if(Gr==="*")return Wr;if(Gr.indexOf("not ")===0)return oe(Gr.substr(4).split(","),function(Kr){Kr=Kr.trim(),delete Wr[Kr]}),Wr;var Yr={};return oe(Gr.split(","),function(Kr){Kr=Kr.trim(),Yr[Kr]=Wr[Kr]}),Yr}else return Wr}function br(Wr){return ee(Wr,"href")&&ee(Wr,"href").indexOf("#")>=0}function wr(Wr,ze){var Gr=ze||ne(Wr,"hx-swap"),Yr={swapStyle:ae(Wr).boosted?"innerHTML":Q.config.defaultSwapStyle,swapDelay:Q.config.defaultSwapDelay,settleDelay:Q.config.defaultSettleDelay};if(Q.config.scrollIntoViewOnBoost&&ae(Wr).boosted&&!br(Wr)&&(Yr.show="top"),Gr){var Kr=D(Gr);if(Kr.length>0)for(var Zr=0;Zr<Kr.length;Zr++){var Qr=Kr[Zr];if(Qr.indexOf("swap:")===0)Yr.swapDelay=d(Qr.substr(5));else if(Qr.indexOf("settle:")===0)Yr.settleDelay=d(Qr.substr(7));else if(Qr.indexOf("transition:")===0)Yr.transition=Qr.substr(11)==="true";else if(Qr.indexOf("ignoreTitle:")===0)Yr.ignoreTitle=Qr.substr(12)==="true";else if(Qr.indexOf("scroll:")===0){var Jr=Qr.substr(7),ei=Jr.split(":"),ti=ei.pop(),ri=ei.length>0?ei.join(":"):null;Yr.scroll=ti,Yr.scrollTarget=ri}else if(Qr.indexOf("show:")===0){var ii=Qr.substr(5),ei=ii.split(":"),si=ei.pop(),ri=ei.length>0?ei.join(":"):null;Yr.show=si,Yr.showTarget=ri}else if(Qr.indexOf("focus-scroll:")===0){var ni=Qr.substr(13);Yr.focusScroll=ni=="true"}else Zr==0?Yr.swapStyle=Qr:b("Unknown modifier in hx-swap: "+Qr)}}return Yr}function Sr(Wr){return ne(Wr,"hx-encoding")==="multipart/form-data"||h(Wr,"form")&&ee(Wr,"enctype")==="multipart/form-data"}function Er(Wr,ze,Gr){var Yr=null;return R(ze,function(Kr){Yr==null&&(Yr=Kr.encodeParameters(Wr,Gr,ze))}),Yr??(Sr(ze)?mr(Gr):pr(Gr))}function T(Wr){return{tasks:[],elts:[Wr]}}function Cr(Wr,ze){var Gr=Wr[0],Yr=Wr[Wr.length-1];if(ze.scroll){var Kr=null;ze.scrollTarget&&(Kr=ue(Gr,ze.scrollTarget)),ze.scroll==="top"&&(Gr||Kr)&&(Kr=Kr||Gr,Kr.scrollTop=0),ze.scroll==="bottom"&&(Yr||Kr)&&(Kr=Kr||Yr,Kr.scrollTop=Kr.scrollHeight)}if(ze.show){var Kr=null;if(ze.showTarget){var Zr=ze.showTarget;ze.showTarget==="window"&&(Zr="body"),Kr=ue(Gr,Zr)}ze.show==="top"&&(Gr||Kr)&&(Kr=Kr||Gr,Kr.scrollIntoView({block:"start",behavior:Q.config.scrollBehavior})),ze.show==="bottom"&&(Yr||Kr)&&(Kr=Kr||Yr,Kr.scrollIntoView({block:"end",behavior:Q.config.scrollBehavior}))}}function Rr(Wr,ze,Gr,Yr){if(Yr==null&&(Yr={}),Wr==null)return Yr;var Kr=te(Wr,ze);if(Kr){var Zr=Kr.trim(),Qr=Gr;if(Zr==="unset")return null;Zr.indexOf("javascript:")===0?(Zr=Zr.substr(11),Qr=!0):Zr.indexOf("js:")===0&&(Zr=Zr.substr(3),Qr=!0),Zr.indexOf("{")!==0&&(Zr="{"+Zr+"}");var Jr;Qr?Jr=Tr(Wr,function(){return Function("return ("+Zr+")")()},{}):Jr=E(Zr);for(var ei in Jr)Jr.hasOwnProperty(ei)&&Yr[ei]==null&&(Yr[ei]=Jr[ei])}return Rr(u(Wr),ze,Gr,Yr)}function Tr(Wr,ze,Gr){return Q.config.allowEval?ze():(fe(Wr,"htmx:evalDisallowedError"),Gr)}function Or(Wr,ze){return Rr(Wr,"hx-vars",!0,ze)}function qr(Wr,ze){return Rr(Wr,"hx-vals",!1,ze)}function Hr(Wr){return le(Or(Wr),qr(Wr))}function Lr(Wr,ze,Gr){if(Gr!==null)try{Wr.setRequestHeader(ze,Gr)}catch{Wr.setRequestHeader(ze,encodeURIComponent(Gr)),Wr.setRequestHeader(ze+"-URI-AutoEncoded","true")}}function Ar(Wr){if(Wr.responseURL&&typeof URL<"u")try{var ze=new URL(Wr.responseURL);return ze.pathname+ze.search}catch{fe(re().body,"htmx:badResponseUrl",{url:Wr.responseURL})}}function O(Wr,ze){return ze.test(Wr.getAllResponseHeaders())}function Nr(Wr,ze,Gr){return Wr=Wr.toLowerCase(),Gr?Gr instanceof Element||I(Gr,"String")?he(Wr,ze,null,null,{targetOverride:p(Gr),returnPromise:!0}):he(Wr,ze,p(Gr.source),Gr.event,{handler:Gr.handler,headers:Gr.headers,values:Gr.values,targetOverride:p(Gr.target),swapOverride:Gr.swap,select:Gr.select,returnPromise:!0}):he(Wr,ze,null,null,{returnPromise:!0})}function Ir(Wr){for(var ze=[];Wr;)ze.push(Wr),Wr=Wr.parentElement;return ze}function kr(Wr,ze,Gr){var Yr,Kr;if(typeof URL=="function"){Kr=new URL(ze,document.location.href);var Zr=document.location.origin;Yr=Zr===Kr.origin}else Kr=ze,Yr=g(ze,document.location.origin);return Q.config.selfRequestsOnly&&!Yr?!1:ce(Wr,"htmx:validateUrl",le({url:Kr,sameHost:Yr},Gr))}function he(Wr,ze,Gr,Yr,Kr,Zr){var Qr=null,Jr=null;if(Kr=Kr??{},Kr.returnPromise&&typeof Promise<"u")var ei=new Promise(function(Xi,qi){Qr=Xi,Jr=qi});Gr==null&&(Gr=re().body);var ti=Kr.handler||Mr,ri=Kr.select||null;if(!se(Gr))return ie(Qr),ei;var ii=Kr.targetOverride||ye(Gr);if(ii==null||ii==pe)return fe(Gr,"htmx:targetError",{target:te(Gr,"hx-target")}),ie(Jr),ei;var si=ae(Gr),ni=si.lastButtonClicked;if(ni){var oi=ee(ni,"formaction");oi!=null&&(ze=oi);var li=ee(ni,"formmethod");li!=null&&li.toLowerCase()!=="dialog"&&(Wr=li)}var ai=ne(Gr,"hx-confirm");if(Zr===void 0){var ui=function(Xi){return he(Wr,ze,Gr,Yr,Kr,!!Xi)},fi={target:ii,elt:Gr,path:ze,verb:Wr,triggeringEvent:Yr,etc:Kr,issueRequest:ui,question:ai};if(ce(Gr,"htmx:confirm",fi)===!1)return ie(Qr),ei}var pi=Gr,mi=ne(Gr,"hx-sync"),Ti=null,yi=!1;if(mi){var _i=mi.split(":"),Ci=_i[0].trim();if(Ci==="this"?pi=xe(Gr,"hx-sync"):pi=ue(Gr,Ci),mi=(_i[1]||"drop").trim(),si=ae(pi),mi==="drop"&&si.xhr&&si.abortable!==!0)return ie(Qr),ei;if(mi==="abort"){if(si.xhr)return ie(Qr),ei;yi=!0}else if(mi==="replace")ce(pi,"htmx:abort");else if(mi.indexOf("queue")===0){var Bi=mi.split(" ");Ti=(Bi[1]||"last").trim()}}if(si.xhr)if(si.abortable)ce(pi,"htmx:abort");else{if(Ti==null){if(Yr){var Pi=ae(Yr);Pi&&Pi.triggerSpec&&Pi.triggerSpec.queue&&(Ti=Pi.triggerSpec.queue)}Ti==null&&(Ti="last")}return si.queuedRequests==null&&(si.queuedRequests=[]),Ti==="first"&&si.queuedRequests.length===0?si.queuedRequests.push(function(){he(Wr,ze,Gr,Yr,Kr)}):Ti==="all"?si.queuedRequests.push(function(){he(Wr,ze,Gr,Yr,Kr)}):Ti==="last"&&(si.queuedRequests=[],si.queuedRequests.push(function(){he(Wr,ze,Gr,Yr,Kr)})),ie(Qr),ei}var Si=new XMLHttpRequest;si.xhr=Si,si.abortable=yi;var Mi=function(){if(si.xhr=null,si.abortable=!1,si.queuedRequests!=null&&si.queuedRequests.length>0){var Xi=si.queuedRequests.shift();Xi()}},ki=ne(Gr,"hx-prompt");if(ki){var Wi=prompt(ki);if(Wi===null||!ce(Gr,"htmx:prompt",{prompt:Wi,target:ii}))return ie(Qr),Mi(),ei}if(ai&&!Zr&&!confirm(ai))return ie(Qr),Mi(),ei;var Li=xr(Gr,ii,Wi);Wr!=="get"&&!Sr(Gr)&&(Li["Content-Type"]="application/x-www-form-urlencoded"),Kr.headers&&(Li=le(Li,Kr.headers));var ci=dr(Gr,Wr),hi=ci.errors,di=ci.values;Kr.values&&(di=le(di,Kr.values));var gi=Hr(Gr),xi=le(di,gi),bi=yr(xi,Gr);Q.config.getCacheBusterParam&&Wr==="get"&&(bi["org.htmx.cache-buster"]=ee(ii,"id")||"true"),(ze==null||ze==="")&&(ze=re().location.href);var vi=Rr(Gr,"hx-request"),Ei=ae(Gr).boosted,Ri=Q.config.methodsThatUseUrlParams.indexOf(Wr)>=0,wi={boosted:Ei,useUrlParams:Ri,parameters:bi,unfilteredParameters:xi,headers:Li,target:ii,verb:Wr,errors:hi,withCredentials:Kr.credentials||vi.credentials||Q.config.withCredentials,timeout:Kr.timeout||vi.timeout||Q.config.timeout,path:ze,triggeringEvent:Yr};if(!ce(Gr,"htmx:configRequest",wi))return ie(Qr),Mi(),ei;if(ze=wi.path,Wr=wi.verb,Li=wi.headers,bi=wi.parameters,hi=wi.errors,Ri=wi.useUrlParams,hi&&hi.length>0)return ce(Gr,"htmx:validation:halted",wi),ie(Qr),Mi(),ei;var Di=ze.split("#"),Ni=Di[0],Fi=Di[1],Hi=ze;if(Ri){Hi=Ni;var Oi=Object.keys(bi).length!==0;Oi&&(Hi.indexOf("?")<0?Hi+="?":Hi+="&",Hi+=pr(bi),Fi&&(Hi+="#"+Fi))}if(!kr(Gr,Hi,wi))return fe(Gr,"htmx:invalidPath",wi),ie(Jr),ei;if(Si.open(Wr.toUpperCase(),Hi,!0),Si.overrideMimeType("text/html"),Si.withCredentials=wi.withCredentials,Si.timeout=wi.timeout,!vi.noHeaders){for(var ji in Li)if(Li.hasOwnProperty(ji)){var zi=Li[ji];Lr(Si,ji,zi)}}var Vi={xhr:Si,target:ii,requestConfig:wi,etc:Kr,boosted:Ei,select:ri,pathInfo:{requestPath:ze,finalRequestPath:Hi,anchor:Fi}};if(Si.onload=function(){try{var Xi=Ir(Gr);if(Vi.pathInfo.responsePath=Ar(Si),ti(Gr,Vi),lr($i,Ii),ce(Gr,"htmx:afterRequest",Vi),ce(Gr,"htmx:afterOnLoad",Vi),!se(Gr)){for(var qi=null;Xi.length>0&&qi==null;){var Zi=Xi.shift();se(Zi)&&(qi=Zi)}qi&&(ce(qi,"htmx:afterRequest",Vi),ce(qi,"htmx:afterOnLoad",Vi))}ie(Qr),Mi()}catch(_s){throw fe(Gr,"htmx:onLoadError",le({error:_s},Vi)),_s}},Si.onerror=function(){lr($i,Ii),fe(Gr,"htmx:afterRequest",Vi),fe(Gr,"htmx:sendError",Vi),ie(Jr),Mi()},Si.onabort=function(){lr($i,Ii),fe(Gr,"htmx:afterRequest",Vi),fe(Gr,"htmx:sendAbort",Vi),ie(Jr),Mi()},Si.ontimeout=function(){lr($i,Ii),fe(Gr,"htmx:afterRequest",Vi),fe(Gr,"htmx:timeout",Vi),ie(Jr),Mi()},!ce(Gr,"htmx:beforeRequest",Vi))return ie(Qr),Mi(),ei;var $i=or(Gr),Ii=sr(Gr);oe(["loadstart","loadend","progress","abort"],function(Xi){oe([Si,Si.upload],function(qi){qi.addEventListener(Xi,function(Zi){ce(Gr,"htmx:xhr:"+Xi,{lengthComputable:Zi.lengthComputable,loaded:Zi.loaded,total:Zi.total})})})}),ce(Gr,"htmx:beforeSend",Vi);var Ui=Ri?null:Er(Si,Gr,bi);return Si.send(Ui),ei}function Pr(Wr,ze){var Gr=ze.xhr,Yr=null,Kr=null;if(O(Gr,/HX-Push:/i)?(Yr=Gr.getResponseHeader("HX-Push"),Kr="push"):O(Gr,/HX-Push-Url:/i)?(Yr=Gr.getResponseHeader("HX-Push-Url"),Kr="push"):O(Gr,/HX-Replace-Url:/i)&&(Yr=Gr.getResponseHeader("HX-Replace-Url"),Kr="replace"),Yr)return Yr==="false"?{}:{type:Kr,path:Yr};var Zr=ze.pathInfo.finalRequestPath,Qr=ze.pathInfo.responsePath,Jr=ne(Wr,"hx-push-url"),ei=ne(Wr,"hx-replace-url"),ti=ae(Wr).boosted,ri=null,ii=null;return Jr?(ri="push",ii=Jr):ei?(ri="replace",ii=ei):ti&&(ri="push",ii=Qr||Zr),ii?ii==="false"?{}:(ii==="true"&&(ii=Qr||Zr),ze.pathInfo.anchor&&ii.indexOf("#")===-1&&(ii=ii+"#"+ze.pathInfo.anchor),{type:ri,path:ii}):{}}function Mr(Wr,ze){var Gr=ze.xhr,Yr=ze.target,Kr=ze.etc;ze.requestConfig;var Zr=ze.select;if(ce(Wr,"htmx:beforeOnLoad",ze)){if(O(Gr,/HX-Trigger:/i)&&_e(Gr,"HX-Trigger",Wr),O(Gr,/HX-Location:/i)){er();var Qr=Gr.getResponseHeader("HX-Location"),Jr;Qr.indexOf("{")===0&&(Jr=E(Qr),Qr=Jr.path,delete Jr.path),Nr("GET",Qr,Jr).then(function(){tr(Qr)});return}var ei=O(Gr,/HX-Refresh:/i)&&Gr.getResponseHeader("HX-Refresh")==="true";if(O(Gr,/HX-Redirect:/i)){location.href=Gr.getResponseHeader("HX-Redirect"),ei&&location.reload();return}if(ei){location.reload();return}O(Gr,/HX-Retarget:/i)&&(Gr.getResponseHeader("HX-Retarget")==="this"?ze.target=Wr:ze.target=ue(Wr,Gr.getResponseHeader("HX-Retarget")));var ti=Pr(Wr,ze),ri=Gr.status>=200&&Gr.status<400&&Gr.status!==204,ii=Gr.response,si=Gr.status>=400,ni=Q.config.ignoreTitle,oi=le({shouldSwap:ri,serverResponse:ii,isError:si,ignoreTitle:ni},ze);if(ce(Yr,"htmx:beforeSwap",oi)){if(Yr=oi.target,ii=oi.serverResponse,si=oi.isError,ni=oi.ignoreTitle,ze.target=Yr,ze.failed=si,ze.successful=!si,oi.shouldSwap){Gr.status===286&&at(Wr),R(Wr,function(_i){ii=_i.transformResponse(ii,Gr,Wr)}),ti.type&&er();var li=Kr.swapOverride;O(Gr,/HX-Reswap:/i)&&(li=Gr.getResponseHeader("HX-Reswap"));var Jr=wr(Wr,li);Jr.hasOwnProperty("ignoreTitle")&&(ni=Jr.ignoreTitle),Yr.classList.add(Q.config.swappingClass);var ai=null,ui=null,fi=function(){try{var _i=document.activeElement,Ci={};try{Ci={elt:_i,start:_i?_i.selectionStart:null,end:_i?_i.selectionEnd:null}}catch{}var Bi;Zr&&(Bi=Zr),O(Gr,/HX-Reselect:/i)&&(Bi=Gr.getResponseHeader("HX-Reselect")),ti.type&&(ce(re().body,"htmx:beforeHistoryUpdate",le({history:ti},ze)),ti.type==="push"?(tr(ti.path),ce(re().body,"htmx:pushedIntoHistory",{path:ti.path})):(rr(ti.path),ce(re().body,"htmx:replacedInHistory",{path:ti.path})));var Pi=T(Yr);if(je(Jr.swapStyle,Yr,Wr,ii,Pi,Bi),Ci.elt&&!se(Ci.elt)&&ee(Ci.elt,"id")){var Si=document.getElementById(ee(Ci.elt,"id")),Mi={preventScroll:Jr.focusScroll!==void 0?!Jr.focusScroll:!Q.config.defaultFocusScroll};if(Si){if(Ci.start&&Si.setSelectionRange)try{Si.setSelectionRange(Ci.start,Ci.end)}catch{}Si.focus(Mi)}}if(Yr.classList.remove(Q.config.swappingClass),oe(Pi.elts,function(Li){Li.classList&&Li.classList.add(Q.config.settlingClass),ce(Li,"htmx:afterSwap",ze)}),O(Gr,/HX-Trigger-After-Swap:/i)){var ki=Wr;se(Wr)||(ki=re().body),_e(Gr,"HX-Trigger-After-Swap",ki)}var Wi=function(){if(oe(Pi.tasks,function(di){di.call()}),oe(Pi.elts,function(di){di.classList&&di.classList.remove(Q.config.settlingClass),ce(di,"htmx:afterSettle",ze)}),ze.pathInfo.anchor){var Li=re().getElementById(ze.pathInfo.anchor);Li&&Li.scrollIntoView({block:"start",behavior:"auto"})}if(Pi.title&&!ni){var ci=C("title");ci?ci.innerHTML=Pi.title:window.document.title=Pi.title}if(Cr(Pi.elts,Jr),O(Gr,/HX-Trigger-After-Settle:/i)){var hi=Wr;se(Wr)||(hi=re().body),_e(Gr,"HX-Trigger-After-Settle",hi)}ie(ai)};Jr.settleDelay>0?setTimeout(Wi,Jr.settleDelay):Wi()}catch(Li){throw fe(Wr,"htmx:swapError",ze),ie(ui),Li}},pi=Q.config.globalViewTransitions;if(Jr.hasOwnProperty("transition")&&(pi=Jr.transition),pi&&ce(Wr,"htmx:beforeTransition",ze)&&typeof Promise<"u"&&document.startViewTransition){var mi=new Promise(function(_i,Ci){ai=_i,ui=Ci}),Ti=fi;fi=function(){document.startViewTransition(function(){return Ti(),mi})}}Jr.swapDelay>0?setTimeout(fi,Jr.swapDelay):fi()}si&&fe(Wr,"htmx:responseError",le({error:"Response Status Error Code "+Gr.status+" from "+ze.pathInfo.requestPath},ze))}}}var Xr={};function Dr(){return{init:function(Wr){return null},onEvent:function(Wr,ze){return!0},transformResponse:function(Wr,ze,Gr){return Wr},isInlineSwap:function(Wr){return!1},handleSwap:function(Wr,ze,Gr,Yr){return!1},encodeParameters:function(Wr,ze,Gr){return null}}}function Ur(Wr,ze){ze.init&&ze.init(r),Xr[Wr]=le(Dr(),ze)}function Br(Wr){delete Xr[Wr]}function Fr(Wr,ze,Gr){if(Wr==null)return ze;ze==null&&(ze=[]),Gr==null&&(Gr=[]);var Yr=te(Wr,"hx-ext");return Yr&&oe(Yr.split(","),function(Kr){if(Kr=Kr.replace(/ /g,""),Kr.slice(0,7)=="ignore:"){Gr.push(Kr.slice(7));return}if(Gr.indexOf(Kr)<0){var Zr=Xr[Kr];Zr&&ze.indexOf(Zr)<0&&ze.push(Zr)}}),Fr(u(Wr),ze,Gr)}var Vr=!1;re().addEventListener("DOMContentLoaded",function(){Vr=!0});function jr(Wr){Vr||re().readyState==="complete"?Wr():re().addEventListener("DOMContentLoaded",Wr)}function _r(){Q.config.includeIndicatorStyles!==!1&&re().head.insertAdjacentHTML("beforeend","<style>                      ."+Q.config.indicatorClass+"{opacity:0}                      ."+Q.config.requestClass+" ."+Q.config.indicatorClass+"{opacity:1; transition: opacity 200ms ease-in;}                      ."+Q.config.requestClass+"."+Q.config.indicatorClass+"{opacity:1; transition: opacity 200ms ease-in;}                    </style>")}function zr(){var Wr=re().querySelector('meta[name="htmx-config"]');return Wr?E(Wr.content):null}function $r(){var Wr=zr();Wr&&(Q.config=le(Q.config,Wr))}return jr(function(){$r(),_r();var Wr=re().body;zt(Wr);var ze=re().querySelectorAll("[hx-trigger='restored'],[data-hx-trigger='restored']");Wr.addEventListener("htmx:abort",function(Yr){var Kr=Yr.target,Zr=ae(Kr);Zr&&Zr.xhr&&Zr.xhr.abort()});const Gr=window.onpopstate?window.onpopstate.bind(window):null;window.onpopstate=function(Yr){Yr.state&&Yr.state.htmx?(ar(),oe(ze,function(Kr){ce(Kr,"htmx:restored",{document:re(),triggerEvent:ce})})):Gr&&Gr(Yr)},setTimeout(function(){ce(Wr,"htmx:load",{}),Wr=null},0)}),Q}()})}(htmx_min$3)),htmx_min$3.exports}var htmx_minExports=requireHtmx_min();const htmx_min=getDefaultExportFromCjs(htmx_minExports),htmx_min$1=_mergeNamespaces({__proto__:null,default:htmx_min},[htmx_minExports]);
